var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error3) {
    if (error3 instanceof FetchBaseError) {
      throw error3;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error3.message}`, "system", error3);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error3) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error3.message}`, "system", error3);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = dataUriToBuffer$1(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error3 = new AbortError("The operation was aborted.");
      reject(error3);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error3);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error3);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location2 = headers.get("Location");
        const locationURL = location2 === null ? null : new URL(location2, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error3) {
                reject(error3);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
        reject(error3);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), (error3) => {
          reject(error3);
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
          reject(error3);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), (error3) => {
              reject(error3);
            });
          } else {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), (error3) => {
              reject(error3);
            });
          }
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), (error3) => {
          reject(error3);
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
var import_http, import_https, import_zlib, import_stream, import_util, import_crypto, import_url, src, dataUriToBuffer$1, Readable, wm, Blob2, fetchBlob, Blob$1, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_http = __toModule(require("http"));
    import_https = __toModule(require("https"));
    import_zlib = __toModule(require("zlib"));
    import_stream = __toModule(require("stream"));
    import_util = __toModule(require("util"));
    import_crypto = __toModule(require("crypto"));
    import_url = __toModule(require("url"));
    src = dataUriToBuffer;
    dataUriToBuffer$1 = src;
    ({ Readable } = import_stream.default);
    wm = new WeakMap();
    Blob2 = class {
      constructor(blobParts = [], options2 = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob2) {
            buffer = element;
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length || buffer.size || 0;
          return buffer;
        });
        const type = options2.type === void 0 ? "" : String(options2.type).toLowerCase();
        wm.set(this, {
          type: /[^\u0020-\u007E]/.test(type) ? "" : type,
          size,
          parts
        });
      }
      get size() {
        return wm.get(this).size;
      }
      get type() {
        return wm.get(this).type;
      }
      async text() {
        return Buffer.from(await this.arrayBuffer()).toString();
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of this.stream()) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        return Readable.from(read(wm.get(this).parts));
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = wm.get(this).parts.values();
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
            blobParts.push(chunk);
            added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
            relativeStart = 0;
            if (added >= span) {
              break;
            }
          }
        }
        const blob = new Blob2([], { type: String(type).toLowerCase() });
        Object.assign(wm.get(blob), { size: span, parts: blobParts });
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    fetchBlob = Blob2;
    Blob$1 = fetchBlob;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && object[NAME] === "AbortSignal";
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_stream.default)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = import_stream.default.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_stream.default) {
          body.on("error", (err) => {
            const error3 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
            this[INTERNALS$2].error = error3;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_stream.PassThrough({ highWaterMark });
        p2 = new import_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof import_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw err;
      }
    };
    validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const err = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
        throw err;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback) {
        for (const name of this.keys()) {
          callback(this.get(name), name);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status || 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal !== null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-netlify/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-netlify/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports2, module2) {
    init_shims();
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v) {
          return exports3[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b) {
        d2.__proto__ = b;
      } || function(d2, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d2[p] = b[p];
      };
      __extends = function(d2, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d2, b);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s2, i = 1, n = arguments.length; i < n; i++) {
          s2 = arguments[i];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t[p] = s2[p];
        }
        return t;
      };
      __rest = function(s2, e) {
        var t = {};
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
            t[p] = s2[p];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
              t[p[i]] = s2[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d2 = decorators[i])
              r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error3) {
          e = { error: error3 };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
          s2 += arguments[i].length;
        for (var r = Array(s2), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || from);
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n](v), settle(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve2, reject, d2, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@firebase/util/dist/index.node.cjs.js
var require_index_node_cjs = __commonJS({
  "node_modules/@firebase/util/dist/index.node.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib = require_tslib();
    var CONSTANTS = {
      NODE_CLIENT: false,
      NODE_ADMIN: false,
      SDK_VERSION: "${JSCORE_VERSION}"
    };
    var assert = function(assertion, message) {
      if (!assertion) {
        throw assertionError(message);
      }
    };
    var assertionError = function(message) {
      return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message);
    };
    var stringToByteArray$1 = function(str) {
      var out = [];
      var p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
          out[p++] = c;
        } else if (c < 2048) {
          out[p++] = c >> 6 | 192;
          out[p++] = c & 63 | 128;
        } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
          c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
          out[p++] = c >> 18 | 240;
          out[p++] = c >> 12 & 63 | 128;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        } else {
          out[p++] = c >> 12 | 224;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        }
      }
      return out;
    };
    var byteArrayToString = function(bytes) {
      var out = [];
      var pos = 0, c = 0;
      while (pos < bytes.length) {
        var c1 = bytes[pos++];
        if (c1 < 128) {
          out[c++] = String.fromCharCode(c1);
        } else if (c1 > 191 && c1 < 224) {
          var c2 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
        } else if (c1 > 239 && c1 < 365) {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          var c4 = bytes[pos++];
          var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
          out[c++] = String.fromCharCode(55296 + (u >> 10));
          out[c++] = String.fromCharCode(56320 + (u & 1023));
        } else {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        }
      }
      return out.join("");
    };
    var base64 = {
      byteToCharMap_: null,
      charToByteMap_: null,
      byteToCharMapWebSafe_: null,
      charToByteMapWebSafe_: null,
      ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/=";
      },
      get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_.";
      },
      HAS_NATIVE_SUPPORT: typeof atob === "function",
      encodeByteArray: function(input, webSafe) {
        if (!Array.isArray(input)) {
          throw Error("encodeByteArray takes an array as a parameter");
        }
        this.init_();
        var byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
          var byte1 = input[i];
          var haveByte2 = i + 1 < input.length;
          var byte2 = haveByte2 ? input[i + 1] : 0;
          var haveByte3 = i + 2 < input.length;
          var byte3 = haveByte3 ? input[i + 2] : 0;
          var outByte1 = byte1 >> 2;
          var outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
          var outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
          var outByte4 = byte3 & 63;
          if (!haveByte3) {
            outByte4 = 64;
            if (!haveByte2) {
              outByte3 = 64;
            }
          }
          output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join("");
      },
      encodeString: function(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
      },
      decodeString: function(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
      },
      decodeStringToByteArray: function(input, webSafe) {
        this.init_();
        var charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length; ) {
          var byte1 = charToByteMap[input.charAt(i++)];
          var haveByte2 = i < input.length;
          var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
          ++i;
          var haveByte3 = i < input.length;
          var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          var haveByte4 = i < input.length;
          var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
            throw Error();
          }
          var outByte1 = byte1 << 2 | byte2 >> 4;
          output.push(outByte1);
          if (byte3 !== 64) {
            var outByte2 = byte2 << 4 & 240 | byte3 >> 2;
            output.push(outByte2);
            if (byte4 !== 64) {
              var outByte3 = byte3 << 6 & 192 | byte4;
              output.push(outByte3);
            }
          }
        }
        return output;
      },
      init_: function() {
        if (!this.byteToCharMap_) {
          this.byteToCharMap_ = {};
          this.charToByteMap_ = {};
          this.byteToCharMapWebSafe_ = {};
          this.charToByteMapWebSafe_ = {};
          for (var i = 0; i < this.ENCODED_VALS.length; i++) {
            this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
            this.charToByteMap_[this.byteToCharMap_[i]] = i;
            this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
            this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
            if (i >= this.ENCODED_VALS_BASE.length) {
              this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
              this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
            }
          }
        }
      }
    };
    var base64Encode = function(str) {
      var utf8Bytes = stringToByteArray$1(str);
      return base64.encodeByteArray(utf8Bytes, true);
    };
    var base64Decode = function(str) {
      try {
        return base64.decodeString(str, true);
      } catch (e) {
        console.error("base64Decode failed: ", e);
      }
      return null;
    };
    function deepCopy(value) {
      return deepExtend(void 0, value);
    }
    function deepExtend(target, source) {
      if (!(source instanceof Object)) {
        return source;
      }
      switch (source.constructor) {
        case Date:
          var dateValue = source;
          return new Date(dateValue.getTime());
        case Object:
          if (target === void 0) {
            target = {};
          }
          break;
        case Array:
          target = [];
          break;
        default:
          return source;
      }
      for (var prop in source) {
        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
          continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
      }
      return target;
    }
    function isValidKey(key) {
      return key !== "__proto__";
    }
    var Deferred = function() {
      function Deferred2() {
        var _this = this;
        this.reject = function() {
        };
        this.resolve = function() {
        };
        this.promise = new Promise(function(resolve2, reject) {
          _this.resolve = resolve2;
          _this.reject = reject;
        });
      }
      Deferred2.prototype.wrapCallback = function(callback) {
        var _this = this;
        return function(error3, value) {
          if (error3) {
            _this.reject(error3);
          } else {
            _this.resolve(value);
          }
          if (typeof callback === "function") {
            _this.promise.catch(function() {
            });
            if (callback.length === 1) {
              callback(error3);
            } else {
              callback(error3, value);
            }
          }
        };
      };
      return Deferred2;
    }();
    function createMockUserToken(token, projectId) {
      if (token.uid) {
        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
      }
      var header = {
        alg: "none",
        type: "JWT"
      };
      var project = projectId || "demo-project";
      var iat = token.iat || 0;
      var sub = token.sub || token.user_id;
      if (!sub) {
        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
      }
      var payload = tslib.__assign({
        iss: "https://securetoken.google.com/" + project,
        aud: project,
        iat,
        exp: iat + 3600,
        auth_time: iat,
        sub,
        user_id: sub,
        firebase: {
          sign_in_provider: "custom",
          identities: {}
        }
      }, token);
      var signature = "";
      return [
        base64.encodeString(JSON.stringify(header), false),
        base64.encodeString(JSON.stringify(payload), false),
        signature
      ].join(".");
    }
    function getUA() {
      if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
        return navigator["userAgent"];
      } else {
        return "";
      }
    }
    function isMobileCordova() {
      return typeof window !== "undefined" && !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
    }
    function isNode() {
      try {
        return Object.prototype.toString.call(global.process) === "[object process]";
      } catch (e) {
        return false;
      }
    }
    function isBrowser() {
      return typeof self === "object" && self.self === self;
    }
    function isBrowserExtension() {
      var runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
      return typeof runtime === "object" && runtime.id !== void 0;
    }
    function isReactNative() {
      return typeof navigator === "object" && navigator["product"] === "ReactNative";
    }
    function isElectron() {
      return getUA().indexOf("Electron/") >= 0;
    }
    function isIE() {
      var ua = getUA();
      return ua.indexOf("MSIE ") >= 0 || ua.indexOf("Trident/") >= 0;
    }
    function isUWP() {
      return getUA().indexOf("MSAppHost/") >= 0;
    }
    function isNodeSdk() {
      return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
    }
    function isSafari() {
      return !isNode() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
    }
    function isIndexedDBAvailable() {
      return "indexedDB" in self && indexedDB != null;
    }
    function validateIndexedDBOpenable() {
      return new Promise(function(resolve2, reject) {
        try {
          var preExist_1 = true;
          var DB_CHECK_NAME_1 = "validate-browser-context-for-indexeddb-analytics-module";
          var request_1 = self.indexedDB.open(DB_CHECK_NAME_1);
          request_1.onsuccess = function() {
            request_1.result.close();
            if (!preExist_1) {
              self.indexedDB.deleteDatabase(DB_CHECK_NAME_1);
            }
            resolve2(true);
          };
          request_1.onupgradeneeded = function() {
            preExist_1 = false;
          };
          request_1.onerror = function() {
            var _a;
            reject(((_a = request_1.error) === null || _a === void 0 ? void 0 : _a.message) || "");
          };
        } catch (error3) {
          reject(error3);
        }
      });
    }
    function areCookiesEnabled() {
      if (!navigator || !navigator.cookieEnabled) {
        return false;
      }
      return true;
    }
    function getGlobal() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("Unable to locate global object.");
    }
    var ERROR_NAME = "FirebaseError";
    var FirebaseError = function(_super) {
      tslib.__extends(FirebaseError2, _super);
      function FirebaseError2(code, message, customData) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.customData = customData;
        _this.name = ERROR_NAME;
        Object.setPrototypeOf(_this, FirebaseError2.prototype);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_this, ErrorFactory.prototype.create);
        }
        return _this;
      }
      return FirebaseError2;
    }(Error);
    var ErrorFactory = function() {
      function ErrorFactory2(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
      }
      ErrorFactory2.prototype.create = function(code) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          data[_i - 1] = arguments[_i];
        }
        var customData = data[0] || {};
        var fullCode = this.service + "/" + code;
        var template2 = this.errors[code];
        var message = template2 ? replaceTemplate(template2, customData) : "Error";
        var fullMessage = this.serviceName + ": " + message + " (" + fullCode + ").";
        var error3 = new FirebaseError(fullCode, fullMessage, customData);
        return error3;
      };
      return ErrorFactory2;
    }();
    function replaceTemplate(template2, data) {
      return template2.replace(PATTERN, function(_, key) {
        var value = data[key];
        return value != null ? String(value) : "<" + key + "?>";
      });
    }
    var PATTERN = /\{\$([^}]+)}/g;
    function jsonEval(str) {
      return JSON.parse(str);
    }
    function stringify(data) {
      return JSON.stringify(data);
    }
    var decode = function(token) {
      var header = {}, claims = {}, data = {}, signature = "";
      try {
        var parts = token.split(".");
        header = jsonEval(base64Decode(parts[0]) || "");
        claims = jsonEval(base64Decode(parts[1]) || "");
        signature = parts[2];
        data = claims["d"] || {};
        delete claims["d"];
      } catch (e) {
      }
      return {
        header,
        claims,
        data,
        signature
      };
    };
    var isValidTimestamp = function(token) {
      var claims = decode(token).claims;
      var now = Math.floor(new Date().getTime() / 1e3);
      var validSince = 0, validUntil = 0;
      if (typeof claims === "object") {
        if (claims.hasOwnProperty("nbf")) {
          validSince = claims["nbf"];
        } else if (claims.hasOwnProperty("iat")) {
          validSince = claims["iat"];
        }
        if (claims.hasOwnProperty("exp")) {
          validUntil = claims["exp"];
        } else {
          validUntil = validSince + 86400;
        }
      }
      return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;
    };
    var issuedAtTime = function(token) {
      var claims = decode(token).claims;
      if (typeof claims === "object" && claims.hasOwnProperty("iat")) {
        return claims["iat"];
      }
      return null;
    };
    var isValidFormat = function(token) {
      var decoded = decode(token), claims = decoded.claims;
      return !!claims && typeof claims === "object" && claims.hasOwnProperty("iat");
    };
    var isAdmin = function(token) {
      var claims = decode(token).claims;
      return typeof claims === "object" && claims["admin"] === true;
    };
    function contains(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function safeGet(obj, key) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
      } else {
        return void 0;
      }
    }
    function isEmpty(obj) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          return false;
        }
      }
      return true;
    }
    function map(obj, fn, contextObj) {
      var res = {};
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          res[key] = fn.call(contextObj, obj[key], key, obj);
        }
      }
      return res;
    }
    function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      var aKeys = Object.keys(a);
      var bKeys = Object.keys(b);
      for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {
        var k = aKeys_1[_i];
        if (!bKeys.includes(k)) {
          return false;
        }
        var aProp = a[k];
        var bProp = b[k];
        if (isObject(aProp) && isObject(bProp)) {
          if (!deepEqual(aProp, bProp)) {
            return false;
          }
        } else if (aProp !== bProp) {
          return false;
        }
      }
      for (var _a = 0, bKeys_1 = bKeys; _a < bKeys_1.length; _a++) {
        var k = bKeys_1[_a];
        if (!aKeys.includes(k)) {
          return false;
        }
      }
      return true;
    }
    function isObject(thing) {
      return thing !== null && typeof thing === "object";
    }
    function querystring(querystringParams) {
      var params = [];
      var _loop_1 = function(key2, value2) {
        if (Array.isArray(value2)) {
          value2.forEach(function(arrayVal) {
            params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(arrayVal));
          });
        } else {
          params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(value2));
        }
      };
      for (var _i = 0, _a = Object.entries(querystringParams); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        _loop_1(key, value);
      }
      return params.length ? "&" + params.join("&") : "";
    }
    function querystringDecode(querystring2) {
      var obj = {};
      var tokens = querystring2.replace(/^\?/, "").split("&");
      tokens.forEach(function(token) {
        if (token) {
          var _a = token.split("="), key = _a[0], value = _a[1];
          obj[decodeURIComponent(key)] = decodeURIComponent(value);
        }
      });
      return obj;
    }
    function extractQuerystring(url) {
      var queryStart = url.indexOf("?");
      if (!queryStart) {
        return "";
      }
      var fragmentStart = url.indexOf("#", queryStart);
      return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : void 0);
    }
    var Sha1 = function() {
      function Sha12() {
        this.chain_ = [];
        this.buf_ = [];
        this.W_ = [];
        this.pad_ = [];
        this.inbuf_ = 0;
        this.total_ = 0;
        this.blockSize = 512 / 8;
        this.pad_[0] = 128;
        for (var i = 1; i < this.blockSize; ++i) {
          this.pad_[i] = 0;
        }
        this.reset();
      }
      Sha12.prototype.reset = function() {
        this.chain_[0] = 1732584193;
        this.chain_[1] = 4023233417;
        this.chain_[2] = 2562383102;
        this.chain_[3] = 271733878;
        this.chain_[4] = 3285377520;
        this.inbuf_ = 0;
        this.total_ = 0;
      };
      Sha12.prototype.compress_ = function(buf, offset) {
        if (!offset) {
          offset = 0;
        }
        var W = this.W_;
        if (typeof buf === "string") {
          for (var i = 0; i < 16; i++) {
            W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
            offset += 4;
          }
        } else {
          for (var i = 0; i < 16; i++) {
            W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
            offset += 4;
          }
        }
        for (var i = 16; i < 80; i++) {
          var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
          W[i] = (t << 1 | t >>> 31) & 4294967295;
        }
        var a = this.chain_[0];
        var b = this.chain_[1];
        var c = this.chain_[2];
        var d2 = this.chain_[3];
        var e = this.chain_[4];
        var f, k;
        for (var i = 0; i < 80; i++) {
          if (i < 40) {
            if (i < 20) {
              f = d2 ^ b & (c ^ d2);
              k = 1518500249;
            } else {
              f = b ^ c ^ d2;
              k = 1859775393;
            }
          } else {
            if (i < 60) {
              f = b & c | d2 & (b | c);
              k = 2400959708;
            } else {
              f = b ^ c ^ d2;
              k = 3395469782;
            }
          }
          var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 4294967295;
          e = d2;
          d2 = c;
          c = (b << 30 | b >>> 2) & 4294967295;
          b = a;
          a = t;
        }
        this.chain_[0] = this.chain_[0] + a & 4294967295;
        this.chain_[1] = this.chain_[1] + b & 4294967295;
        this.chain_[2] = this.chain_[2] + c & 4294967295;
        this.chain_[3] = this.chain_[3] + d2 & 4294967295;
        this.chain_[4] = this.chain_[4] + e & 4294967295;
      };
      Sha12.prototype.update = function(bytes, length) {
        if (bytes == null) {
          return;
        }
        if (length === void 0) {
          length = bytes.length;
        }
        var lengthMinusBlock = length - this.blockSize;
        var n = 0;
        var buf = this.buf_;
        var inbuf = this.inbuf_;
        while (n < length) {
          if (inbuf === 0) {
            while (n <= lengthMinusBlock) {
              this.compress_(bytes, n);
              n += this.blockSize;
            }
          }
          if (typeof bytes === "string") {
            while (n < length) {
              buf[inbuf] = bytes.charCodeAt(n);
              ++inbuf;
              ++n;
              if (inbuf === this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            }
          } else {
            while (n < length) {
              buf[inbuf] = bytes[n];
              ++inbuf;
              ++n;
              if (inbuf === this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            }
          }
        }
        this.inbuf_ = inbuf;
        this.total_ += length;
      };
      Sha12.prototype.digest = function() {
        var digest = [];
        var totalBits = this.total_ * 8;
        if (this.inbuf_ < 56) {
          this.update(this.pad_, 56 - this.inbuf_);
        } else {
          this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        for (var i = this.blockSize - 1; i >= 56; i--) {
          this.buf_[i] = totalBits & 255;
          totalBits /= 256;
        }
        this.compress_(this.buf_);
        var n = 0;
        for (var i = 0; i < 5; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            digest[n] = this.chain_[i] >> j & 255;
            ++n;
          }
        }
        return digest;
      };
      return Sha12;
    }();
    function createSubscribe(executor, onNoObservers) {
      var proxy = new ObserverProxy(executor, onNoObservers);
      return proxy.subscribe.bind(proxy);
    }
    var ObserverProxy = function() {
      function ObserverProxy2(executor, onNoObservers) {
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        this.task.then(function() {
          executor(_this);
        }).catch(function(e) {
          _this.error(e);
        });
      }
      ObserverProxy2.prototype.next = function(value) {
        this.forEachObserver(function(observer) {
          observer.next(value);
        });
      };
      ObserverProxy2.prototype.error = function(error3) {
        this.forEachObserver(function(observer) {
          observer.error(error3);
        });
        this.close(error3);
      };
      ObserverProxy2.prototype.complete = function() {
        this.forEachObserver(function(observer) {
          observer.complete();
        });
        this.close();
      };
      ObserverProxy2.prototype.subscribe = function(nextOrObserver, error3, complete) {
        var _this = this;
        var observer;
        if (nextOrObserver === void 0 && error3 === void 0 && complete === void 0) {
          throw new Error("Missing Observer.");
        }
        if (implementsAnyMethods(nextOrObserver, [
          "next",
          "error",
          "complete"
        ])) {
          observer = nextOrObserver;
        } else {
          observer = {
            next: nextOrObserver,
            error: error3,
            complete
          };
        }
        if (observer.next === void 0) {
          observer.next = noop3;
        }
        if (observer.error === void 0) {
          observer.error = noop3;
        }
        if (observer.complete === void 0) {
          observer.complete = noop3;
        }
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        if (this.finalized) {
          this.task.then(function() {
            try {
              if (_this.finalError) {
                observer.error(_this.finalError);
              } else {
                observer.complete();
              }
            } catch (e) {
            }
            return;
          });
        }
        this.observers.push(observer);
        return unsub;
      };
      ObserverProxy2.prototype.unsubscribeOne = function(i) {
        if (this.observers === void 0 || this.observers[i] === void 0) {
          return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== void 0) {
          this.onNoObservers(this);
        }
      };
      ObserverProxy2.prototype.forEachObserver = function(fn) {
        if (this.finalized) {
          return;
        }
        for (var i = 0; i < this.observers.length; i++) {
          this.sendOne(i, fn);
        }
      };
      ObserverProxy2.prototype.sendOne = function(i, fn) {
        var _this = this;
        this.task.then(function() {
          if (_this.observers !== void 0 && _this.observers[i] !== void 0) {
            try {
              fn(_this.observers[i]);
            } catch (e) {
              if (typeof console !== "undefined" && console.error) {
                console.error(e);
              }
            }
          }
        });
      };
      ObserverProxy2.prototype.close = function(err) {
        var _this = this;
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        if (err !== void 0) {
          this.finalError = err;
        }
        this.task.then(function() {
          _this.observers = void 0;
          _this.onNoObservers = void 0;
        });
      };
      return ObserverProxy2;
    }();
    function async(fn, onError) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        Promise.resolve(true).then(function() {
          fn.apply(void 0, args);
        }).catch(function(error3) {
          if (onError) {
            onError(error3);
          }
        });
      };
    }
    function implementsAnyMethods(obj, methods) {
      if (typeof obj !== "object" || obj === null) {
        return false;
      }
      for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in obj && typeof obj[method] === "function") {
          return true;
        }
      }
      return false;
    }
    function noop3() {
    }
    var validateArgCount = function(fnName, minCount, maxCount, argCount) {
      var argError;
      if (argCount < minCount) {
        argError = "at least " + minCount;
      } else if (argCount > maxCount) {
        argError = maxCount === 0 ? "none" : "no more than " + maxCount;
      }
      if (argError) {
        var error3 = fnName + " failed: Was called with " + argCount + (argCount === 1 ? " argument." : " arguments.") + " Expects " + argError + ".";
        throw new Error(error3);
      }
    };
    function errorPrefix(fnName, argName) {
      return fnName + " failed: " + argName + " argument ";
    }
    function validateNamespace(fnName, namespace, optional) {
      if (optional && !namespace) {
        return;
      }
      if (typeof namespace !== "string") {
        throw new Error(errorPrefix(fnName, "namespace") + "must be a valid firebase namespace.");
      }
    }
    function validateCallback(fnName, argumentName, callback, optional) {
      if (optional && !callback) {
        return;
      }
      if (typeof callback !== "function") {
        throw new Error(errorPrefix(fnName, argumentName) + "must be a valid function.");
      }
    }
    function validateContextObject(fnName, argumentName, context, optional) {
      if (optional && !context) {
        return;
      }
      if (typeof context !== "object" || context === null) {
        throw new Error(errorPrefix(fnName, argumentName) + "must be a valid context object.");
      }
    }
    var stringToByteArray = function(str) {
      var out = [];
      var p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c >= 55296 && c <= 56319) {
          var high = c - 55296;
          i++;
          assert(i < str.length, "Surrogate pair missing trail surrogate.");
          var low = str.charCodeAt(i) - 56320;
          c = 65536 + (high << 10) + low;
        }
        if (c < 128) {
          out[p++] = c;
        } else if (c < 2048) {
          out[p++] = c >> 6 | 192;
          out[p++] = c & 63 | 128;
        } else if (c < 65536) {
          out[p++] = c >> 12 | 224;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        } else {
          out[p++] = c >> 18 | 240;
          out[p++] = c >> 12 & 63 | 128;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        }
      }
      return out;
    };
    var stringLength = function(str) {
      var p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
          p++;
        } else if (c < 2048) {
          p += 2;
        } else if (c >= 55296 && c <= 56319) {
          p += 4;
          i++;
        } else {
          p += 3;
        }
      }
      return p;
    };
    var DEFAULT_INTERVAL_MILLIS = 1e3;
    var DEFAULT_BACKOFF_FACTOR = 2;
    var MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;
    var RANDOM_FACTOR = 0.5;
    function calculateBackoffMillis(backoffCount, intervalMillis, backoffFactor) {
      if (intervalMillis === void 0) {
        intervalMillis = DEFAULT_INTERVAL_MILLIS;
      }
      if (backoffFactor === void 0) {
        backoffFactor = DEFAULT_BACKOFF_FACTOR;
      }
      var currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
      var randomWait = Math.round(RANDOM_FACTOR * currBaseValue * (Math.random() - 0.5) * 2);
      return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
    }
    function ordinal(i) {
      if (!Number.isFinite(i)) {
        return "" + i;
      }
      return i + indicator(i);
    }
    function indicator(i) {
      i = Math.abs(i);
      var cent = i % 100;
      if (cent >= 10 && cent <= 20) {
        return "th";
      }
      var dec = i % 10;
      if (dec === 1) {
        return "st";
      }
      if (dec === 2) {
        return "nd";
      }
      if (dec === 3) {
        return "rd";
      }
      return "th";
    }
    function getModularInstance(service) {
      if (service && service._delegate) {
        return service._delegate;
      } else {
        return service;
      }
    }
    CONSTANTS.NODE_CLIENT = true;
    exports2.CONSTANTS = CONSTANTS;
    exports2.Deferred = Deferred;
    exports2.ErrorFactory = ErrorFactory;
    exports2.FirebaseError = FirebaseError;
    exports2.MAX_VALUE_MILLIS = MAX_VALUE_MILLIS;
    exports2.RANDOM_FACTOR = RANDOM_FACTOR;
    exports2.Sha1 = Sha1;
    exports2.areCookiesEnabled = areCookiesEnabled;
    exports2.assert = assert;
    exports2.assertionError = assertionError;
    exports2.async = async;
    exports2.base64 = base64;
    exports2.base64Decode = base64Decode;
    exports2.base64Encode = base64Encode;
    exports2.calculateBackoffMillis = calculateBackoffMillis;
    exports2.contains = contains;
    exports2.createMockUserToken = createMockUserToken;
    exports2.createSubscribe = createSubscribe;
    exports2.decode = decode;
    exports2.deepCopy = deepCopy;
    exports2.deepEqual = deepEqual;
    exports2.deepExtend = deepExtend;
    exports2.errorPrefix = errorPrefix;
    exports2.extractQuerystring = extractQuerystring;
    exports2.getGlobal = getGlobal;
    exports2.getModularInstance = getModularInstance;
    exports2.getUA = getUA;
    exports2.isAdmin = isAdmin;
    exports2.isBrowser = isBrowser;
    exports2.isBrowserExtension = isBrowserExtension;
    exports2.isElectron = isElectron;
    exports2.isEmpty = isEmpty;
    exports2.isIE = isIE;
    exports2.isIndexedDBAvailable = isIndexedDBAvailable;
    exports2.isMobileCordova = isMobileCordova;
    exports2.isNode = isNode;
    exports2.isNodeSdk = isNodeSdk;
    exports2.isReactNative = isReactNative;
    exports2.isSafari = isSafari;
    exports2.isUWP = isUWP;
    exports2.isValidFormat = isValidFormat;
    exports2.isValidTimestamp = isValidTimestamp;
    exports2.issuedAtTime = issuedAtTime;
    exports2.jsonEval = jsonEval;
    exports2.map = map;
    exports2.ordinal = ordinal;
    exports2.querystring = querystring;
    exports2.querystringDecode = querystringDecode;
    exports2.safeGet = safeGet;
    exports2.stringLength = stringLength;
    exports2.stringToByteArray = stringToByteArray;
    exports2.stringify = stringify;
    exports2.validateArgCount = validateArgCount;
    exports2.validateCallback = validateCallback;
    exports2.validateContextObject = validateContextObject;
    exports2.validateIndexedDBOpenable = validateIndexedDBOpenable;
    exports2.validateNamespace = validateNamespace;
  }
});

// node_modules/@firebase/component/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/@firebase/component/dist/index.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib = require_tslib();
    var util = require_index_node_cjs();
    var Component = function() {
      function Component2(name, instanceFactory, type) {
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        this.serviceProps = {};
        this.instantiationMode = "LAZY";
        this.onInstanceCreated = null;
      }
      Component2.prototype.setInstantiationMode = function(mode) {
        this.instantiationMode = mode;
        return this;
      };
      Component2.prototype.setMultipleInstances = function(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
      };
      Component2.prototype.setServiceProps = function(props) {
        this.serviceProps = props;
        return this;
      };
      Component2.prototype.setInstanceCreatedCallback = function(callback) {
        this.onInstanceCreated = callback;
        return this;
      };
      return Component2;
    }();
    var DEFAULT_ENTRY_NAME = "[DEFAULT]";
    var Provider = function() {
      function Provider2(name, container) {
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.onInitCallbacks = new Map();
      }
      Provider2.prototype.get = function(identifier) {
        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
          var deferred = new util.Deferred();
          this.instancesDeferred.set(normalizedIdentifier, deferred);
          if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
            try {
              var instance = this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier
              });
              if (instance) {
                deferred.resolve(instance);
              }
            } catch (e) {
            }
          }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
      };
      Provider2.prototype.getImmediate = function(options2) {
        var _a;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(options2 === null || options2 === void 0 ? void 0 : options2.identifier);
        var optional = (_a = options2 === null || options2 === void 0 ? void 0 : options2.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
          try {
            return this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
          } catch (e) {
            if (optional) {
              return null;
            } else {
              throw e;
            }
          }
        } else {
          if (optional) {
            return null;
          } else {
            throw Error("Service " + this.name + " is not available");
          }
        }
      };
      Provider2.prototype.getComponent = function() {
        return this.component;
      };
      Provider2.prototype.setComponent = function(component) {
        var e_1, _a;
        if (component.name !== this.name) {
          throw Error("Mismatching Component " + component.name + " for Provider " + this.name + ".");
        }
        if (this.component) {
          throw Error("Component for " + this.name + " has already been provided");
        }
        this.component = component;
        if (!this.shouldAutoInitialize()) {
          return;
        }
        if (isComponentEager(component)) {
          try {
            this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
          } catch (e) {
          }
        }
        try {
          for (var _b = tslib.__values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = tslib.__read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];
            var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try {
              var instance = this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier
              });
              instanceDeferred.resolve(instance);
            } catch (e) {
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      };
      Provider2.prototype.clearInstance = function(identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME;
        }
        this.instancesDeferred.delete(identifier);
        this.instances.delete(identifier);
      };
      Provider2.prototype.delete = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var services;
          return tslib.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                services = Array.from(this.instances.values());
                return [4, Promise.all(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(services.filter(function(service) {
                  return "INTERNAL" in service;
                }).map(function(service) {
                  return service.INTERNAL.delete();
                }))), tslib.__read(services.filter(function(service) {
                  return "_delete" in service;
                }).map(function(service) {
                  return service._delete();
                }))))];
              case 1:
                _a.sent();
                return [2];
            }
          });
        });
      };
      Provider2.prototype.isComponentSet = function() {
        return this.component != null;
      };
      Provider2.prototype.isInitialized = function(identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME;
        }
        return this.instances.has(identifier);
      };
      Provider2.prototype.initialize = function(opts) {
        var e_2, _a;
        if (opts === void 0) {
          opts = {};
        }
        var _b = opts.options, options2 = _b === void 0 ? {} : _b;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
          throw Error(this.name + "(" + normalizedIdentifier + ") has already been initialized");
        }
        if (!this.isComponentSet()) {
          throw Error("Component " + this.name + " has not been registered yet");
        }
        var instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier,
          options: options2
        });
        try {
          for (var _c = tslib.__values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = tslib.__read(_d.value, 2), instanceIdentifier = _e[0], instanceDeferred = _e[1];
            var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) {
              instanceDeferred.resolve(instance);
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return))
              _a.call(_c);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        return instance;
      };
      Provider2.prototype.onInit = function(callback, identifier) {
        var _a;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        var existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
          callback(existingInstance, normalizedIdentifier);
        }
        return function() {
          existingCallbacks.delete(callback);
        };
      };
      Provider2.prototype.invokeOnInitCallbacks = function(instance, identifier) {
        var e_3, _a;
        var callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
          return;
        }
        try {
          for (var callbacks_1 = tslib.__values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
            var callback = callbacks_1_1.value;
            try {
              callback(instance, identifier);
            } catch (_b) {
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return))
              _a.call(callbacks_1);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      };
      Provider2.prototype.getOrInitializeService = function(_a) {
        var instanceIdentifier = _a.instanceIdentifier, _b = _a.options, options2 = _b === void 0 ? {} : _b;
        var instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
          instance = this.component.instanceFactory(this.container, {
            instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
            options: options2
          });
          this.instances.set(instanceIdentifier, instance);
          this.invokeOnInitCallbacks(instance, instanceIdentifier);
          if (this.component.onInstanceCreated) {
            try {
              this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
            } catch (_c) {
            }
          }
        }
        return instance || null;
      };
      Provider2.prototype.normalizeInstanceIdentifier = function(identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME;
        }
        if (this.component) {
          return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
        } else {
          return identifier;
        }
      };
      Provider2.prototype.shouldAutoInitialize = function() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT";
      };
      return Provider2;
    }();
    function normalizeIdentifierForFactory(identifier) {
      return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;
    }
    function isComponentEager(component) {
      return component.instantiationMode === "EAGER";
    }
    var ComponentContainer = function() {
      function ComponentContainer2(name) {
        this.name = name;
        this.providers = new Map();
      }
      ComponentContainer2.prototype.addComponent = function(component) {
        var provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          throw new Error("Component " + component.name + " has already been registered with " + this.name);
        }
        provider.setComponent(component);
      };
      ComponentContainer2.prototype.addOrOverwriteComponent = function(component) {
        var provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          this.providers.delete(component.name);
        }
        this.addComponent(component);
      };
      ComponentContainer2.prototype.getProvider = function(name) {
        if (this.providers.has(name)) {
          return this.providers.get(name);
        }
        var provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
      };
      ComponentContainer2.prototype.getProviders = function() {
        return Array.from(this.providers.values());
      };
      return ComponentContainer2;
    }();
    exports2.Component = Component;
    exports2.ComponentContainer = ComponentContainer;
    exports2.Provider = Provider;
  }
});

// node_modules/@firebase/logger/dist/index.cjs.js
var require_index_cjs2 = __commonJS({
  "node_modules/@firebase/logger/dist/index.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function __spreadArrays() {
      for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
        s2 += arguments[i].length;
      for (var r = Array(s2), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    }
    var _a;
    var instances = [];
    (function(LogLevel) {
      LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
      LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
      LogLevel[LogLevel["INFO"] = 2] = "INFO";
      LogLevel[LogLevel["WARN"] = 3] = "WARN";
      LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
      LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
    })(exports2.LogLevel || (exports2.LogLevel = {}));
    var levelStringToEnum = {
      "debug": exports2.LogLevel.DEBUG,
      "verbose": exports2.LogLevel.VERBOSE,
      "info": exports2.LogLevel.INFO,
      "warn": exports2.LogLevel.WARN,
      "error": exports2.LogLevel.ERROR,
      "silent": exports2.LogLevel.SILENT
    };
    var defaultLogLevel = exports2.LogLevel.INFO;
    var ConsoleMethod = (_a = {}, _a[exports2.LogLevel.DEBUG] = "log", _a[exports2.LogLevel.VERBOSE] = "log", _a[exports2.LogLevel.INFO] = "info", _a[exports2.LogLevel.WARN] = "warn", _a[exports2.LogLevel.ERROR] = "error", _a);
    var defaultLogHandler = function(instance, logType) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (logType < instance.logLevel) {
        return;
      }
      var now = new Date().toISOString();
      var method = ConsoleMethod[logType];
      if (method) {
        console[method].apply(console, __spreadArrays(["[" + now + "]  " + instance.name + ":"], args));
      } else {
        throw new Error("Attempted to log a message with an invalid logType (value: " + logType + ")");
      }
    };
    var Logger = function() {
      function Logger2(name) {
        this.name = name;
        this._logLevel = defaultLogLevel;
        this._logHandler = defaultLogHandler;
        this._userLogHandler = null;
        instances.push(this);
      }
      Object.defineProperty(Logger2.prototype, "logLevel", {
        get: function() {
          return this._logLevel;
        },
        set: function(val) {
          if (!(val in exports2.LogLevel)) {
            throw new TypeError('Invalid value "' + val + '" assigned to `logLevel`');
          }
          this._logLevel = val;
        },
        enumerable: false,
        configurable: true
      });
      Logger2.prototype.setLogLevel = function(val) {
        this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
      };
      Object.defineProperty(Logger2.prototype, "logHandler", {
        get: function() {
          return this._logHandler;
        },
        set: function(val) {
          if (typeof val !== "function") {
            throw new TypeError("Value assigned to `logHandler` must be a function");
          }
          this._logHandler = val;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Logger2.prototype, "userLogHandler", {
        get: function() {
          return this._userLogHandler;
        },
        set: function(val) {
          this._userLogHandler = val;
        },
        enumerable: false,
        configurable: true
      });
      Logger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.DEBUG], args));
        this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.DEBUG], args));
      };
      Logger2.prototype.log = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.VERBOSE], args));
        this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.VERBOSE], args));
      };
      Logger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.INFO], args));
        this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.INFO], args));
      };
      Logger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.WARN], args));
        this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.WARN], args));
      };
      Logger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.ERROR], args));
        this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.ERROR], args));
      };
      return Logger2;
    }();
    function setLogLevel(level) {
      instances.forEach(function(inst) {
        inst.setLogLevel(level);
      });
    }
    function setUserLogHandler(logCallback, options2) {
      var _loop_1 = function(instance2) {
        var customLogLevel = null;
        if (options2 && options2.level) {
          customLogLevel = levelStringToEnum[options2.level];
        }
        if (logCallback === null) {
          instance2.userLogHandler = null;
        } else {
          instance2.userLogHandler = function(instance3, level) {
            var args = [];
            for (var _i2 = 2; _i2 < arguments.length; _i2++) {
              args[_i2 - 2] = arguments[_i2];
            }
            var message = args.map(function(arg) {
              if (arg == null) {
                return null;
              } else if (typeof arg === "string") {
                return arg;
              } else if (typeof arg === "number" || typeof arg === "boolean") {
                return arg.toString();
              } else if (arg instanceof Error) {
                return arg.message;
              } else {
                try {
                  return JSON.stringify(arg);
                } catch (ignored) {
                  return null;
                }
              }
            }).filter(function(arg) {
              return arg;
            }).join(" ");
            if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance3.logLevel)) {
              logCallback({
                level: exports2.LogLevel[level].toLowerCase(),
                message,
                args,
                type: instance3.name
              });
            }
          };
        }
      };
      for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
        var instance = instances_1[_i];
        _loop_1(instance);
      }
    }
    exports2.Logger = Logger;
    exports2.setLogLevel = setLogLevel;
    exports2.setUserLogHandler = setUserLogHandler;
  }
});

// node_modules/dom-storage/lib/index.js
var require_lib = __commonJS({
  "node_modules/dom-storage/lib/index.js"(exports2, module2) {
    init_shims();
    (function() {
      "use strict";
      var fs = require("fs");
      function Storage(path, opts) {
        opts = opts || {};
        var db2;
        Object.defineProperty(this, "___priv_bk___", {
          value: {
            path
          },
          writable: false,
          enumerable: false
        });
        Object.defineProperty(this, "___priv_strict___", {
          value: !!opts.strict,
          writable: false,
          enumerable: false
        });
        Object.defineProperty(this, "___priv_ws___", {
          value: opts.ws || "  ",
          writable: false,
          enumerable: false
        });
        try {
          db2 = JSON.parse(fs.readFileSync(path));
        } catch (e) {
          db2 = {};
        }
        Object.keys(db2).forEach(function(key) {
          this[key] = db2[key];
        }, this);
      }
      Storage.prototype.getItem = function(key) {
        if (this.hasOwnProperty(key)) {
          if (this.___priv_strict___) {
            return String(this[key]);
          } else {
            return this[key];
          }
        }
        return null;
      };
      Storage.prototype.setItem = function(key, val) {
        if (val === void 0) {
          this[key] = null;
        } else if (this.___priv_strict___) {
          this[key] = String(val);
        } else {
          this[key] = val;
        }
        this.___save___();
      };
      Storage.prototype.removeItem = function(key) {
        delete this[key];
        this.___save___();
      };
      Storage.prototype.clear = function() {
        var self2 = this;
        Object.keys(self2).forEach(function(key) {
          self2[key] = void 0;
          delete self2[key];
        });
      };
      Storage.prototype.key = function(i) {
        i = i || 0;
        return Object.keys(this)[i];
      };
      Object.defineProperty(Storage.prototype, "length", {
        get: function() {
          return Object.keys(this).length;
        }
      });
      Storage.prototype.___save___ = function() {
        var self2 = this;
        if (!this.___priv_bk___.path) {
          return;
        }
        if (this.___priv_bk___.lock) {
          this.___priv_bk___.wait = true;
          return;
        }
        this.___priv_bk___.lock = true;
        fs.writeFile(this.___priv_bk___.path, JSON.stringify(this, null, this.___priv_ws___), "utf8", function(e) {
          self2.___priv_bk___.lock = false;
          if (e) {
            console.error("Could not write to database", self2.___priv_bk___.path);
            console.error(e);
            return;
          }
          if (self2.___priv_bk___.wait) {
            self2.___priv_bk___.wait = false;
            self2.___save___();
          }
        });
      };
      Object.defineProperty(Storage, "create", {
        value: function(path, opts) {
          return new Storage(path, opts);
        },
        writable: false,
        enumerable: false
      });
      module2.exports = Storage;
    })();
  }
});

// node_modules/xmlhttprequest/lib/XMLHttpRequest.js
var require_XMLHttpRequest = __commonJS({
  "node_modules/xmlhttprequest/lib/XMLHttpRequest.js"(exports2) {
    init_shims();
    var Url = require("url");
    var spawn = require("child_process").spawn;
    var fs = require("fs");
    exports2.XMLHttpRequest = function() {
      "use strict";
      var self2 = this;
      var http2 = require("http");
      var https2 = require("https");
      var request;
      var response;
      var settings = {};
      var disableHeaderCheck = false;
      var defaultHeaders = {
        "User-Agent": "node-XMLHttpRequest",
        "Accept": "*/*"
      };
      var headers = {};
      var headersCase = {};
      var forbiddenRequestHeaders = [
        "accept-charset",
        "accept-encoding",
        "access-control-request-headers",
        "access-control-request-method",
        "connection",
        "content-length",
        "content-transfer-encoding",
        "cookie",
        "cookie2",
        "date",
        "expect",
        "host",
        "keep-alive",
        "origin",
        "referer",
        "te",
        "trailer",
        "transfer-encoding",
        "upgrade",
        "via"
      ];
      var forbiddenRequestMethods = [
        "TRACE",
        "TRACK",
        "CONNECT"
      ];
      var sendFlag = false;
      var errorFlag = false;
      var listeners = {};
      this.UNSENT = 0;
      this.OPENED = 1;
      this.HEADERS_RECEIVED = 2;
      this.LOADING = 3;
      this.DONE = 4;
      this.readyState = this.UNSENT;
      this.onreadystatechange = null;
      this.responseText = "";
      this.responseXML = "";
      this.status = null;
      this.statusText = null;
      this.withCredentials = false;
      var isAllowedHttpHeader = function(header) {
        return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;
      };
      var isAllowedHttpMethod = function(method) {
        return method && forbiddenRequestMethods.indexOf(method) === -1;
      };
      this.open = function(method, url, async, user, password) {
        this.abort();
        errorFlag = false;
        if (!isAllowedHttpMethod(method)) {
          throw new Error("SecurityError: Request method not allowed");
        }
        settings = {
          "method": method,
          "url": url.toString(),
          "async": typeof async !== "boolean" ? true : async,
          "user": user || null,
          "password": password || null
        };
        setState(this.OPENED);
      };
      this.setDisableHeaderCheck = function(state) {
        disableHeaderCheck = state;
      };
      this.setRequestHeader = function(header, value) {
        if (this.readyState !== this.OPENED) {
          throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
        }
        if (!isAllowedHttpHeader(header)) {
          console.warn('Refused to set unsafe header "' + header + '"');
          return;
        }
        if (sendFlag) {
          throw new Error("INVALID_STATE_ERR: send flag is true");
        }
        header = headersCase[header.toLowerCase()] || header;
        headersCase[header.toLowerCase()] = header;
        headers[header] = headers[header] ? headers[header] + ", " + value : value;
      };
      this.getResponseHeader = function(header) {
        if (typeof header === "string" && this.readyState > this.OPENED && response && response.headers && response.headers[header.toLowerCase()] && !errorFlag) {
          return response.headers[header.toLowerCase()];
        }
        return null;
      };
      this.getAllResponseHeaders = function() {
        if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
          return "";
        }
        var result = "";
        for (var i in response.headers) {
          if (i !== "set-cookie" && i !== "set-cookie2") {
            result += i + ": " + response.headers[i] + "\r\n";
          }
        }
        return result.substr(0, result.length - 2);
      };
      this.getRequestHeader = function(name) {
        if (typeof name === "string" && headersCase[name.toLowerCase()]) {
          return headers[headersCase[name.toLowerCase()]];
        }
        return "";
      };
      this.send = function(data) {
        if (this.readyState !== this.OPENED) {
          throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
        }
        if (sendFlag) {
          throw new Error("INVALID_STATE_ERR: send has already been called");
        }
        var ssl = false, local = false;
        var url = Url.parse(settings.url);
        var host;
        switch (url.protocol) {
          case "https:":
            ssl = true;
          case "http:":
            host = url.hostname;
            break;
          case "file:":
            local = true;
            break;
          case void 0:
          case null:
          case "":
            host = "localhost";
            break;
          default:
            throw new Error("Protocol not supported.");
        }
        if (local) {
          if (settings.method !== "GET") {
            throw new Error("XMLHttpRequest: Only GET method is supported");
          }
          if (settings.async) {
            fs.readFile(url.pathname, "utf8", function(error3, data2) {
              if (error3) {
                self2.handleError(error3);
              } else {
                self2.status = 200;
                self2.responseText = data2;
                setState(self2.DONE);
              }
            });
          } else {
            try {
              this.responseText = fs.readFileSync(url.pathname, "utf8");
              this.status = 200;
              setState(self2.DONE);
            } catch (e) {
              this.handleError(e);
            }
          }
          return;
        }
        var port = url.port || (ssl ? 443 : 80);
        var uri = url.pathname + (url.search ? url.search : "");
        for (var name in defaultHeaders) {
          if (!headersCase[name.toLowerCase()]) {
            headers[name] = defaultHeaders[name];
          }
        }
        headers.Host = host;
        if (!(ssl && port === 443 || port === 80)) {
          headers.Host += ":" + url.port;
        }
        if (settings.user) {
          if (typeof settings.password === "undefined") {
            settings.password = "";
          }
          var authBuf = new Buffer(settings.user + ":" + settings.password);
          headers.Authorization = "Basic " + authBuf.toString("base64");
        }
        if (settings.method === "GET" || settings.method === "HEAD") {
          data = null;
        } else if (data) {
          headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);
          if (!headers["Content-Type"]) {
            headers["Content-Type"] = "text/plain;charset=UTF-8";
          }
        } else if (settings.method === "POST") {
          headers["Content-Length"] = 0;
        }
        var options2 = {
          host,
          port,
          path: uri,
          method: settings.method,
          headers,
          agent: false,
          withCredentials: self2.withCredentials
        };
        errorFlag = false;
        if (settings.async) {
          var doRequest = ssl ? https2.request : http2.request;
          sendFlag = true;
          self2.dispatchEvent("readystatechange");
          var responseHandler = function responseHandler2(resp2) {
            response = resp2;
            if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
              settings.url = response.headers.location;
              var url2 = Url.parse(settings.url);
              host = url2.hostname;
              var newOptions = {
                hostname: url2.hostname,
                port: url2.port,
                path: url2.path,
                method: response.statusCode === 303 ? "GET" : settings.method,
                headers,
                withCredentials: self2.withCredentials
              };
              request = doRequest(newOptions, responseHandler2).on("error", errorHandler);
              request.end();
              return;
            }
            response.setEncoding("utf8");
            setState(self2.HEADERS_RECEIVED);
            self2.status = response.statusCode;
            response.on("data", function(chunk) {
              if (chunk) {
                self2.responseText += chunk;
              }
              if (sendFlag) {
                setState(self2.LOADING);
              }
            });
            response.on("end", function() {
              if (sendFlag) {
                setState(self2.DONE);
                sendFlag = false;
              }
            });
            response.on("error", function(error3) {
              self2.handleError(error3);
            });
          };
          var errorHandler = function errorHandler2(error3) {
            self2.handleError(error3);
          };
          request = doRequest(options2, responseHandler).on("error", errorHandler);
          if (data) {
            request.write(data);
          }
          request.end();
          self2.dispatchEvent("loadstart");
        } else {
          var contentFile = ".node-xmlhttprequest-content-" + process.pid;
          var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
          fs.writeFileSync(syncFile, "", "utf8");
          var execString = "var http = require('http'), https = require('https'), fs = require('fs');var doRequest = http" + (ssl ? "s" : "") + ".request;var options = " + JSON.stringify(options2) + ";var responseText = '';var req = doRequest(options, function(response) {response.setEncoding('utf8');response.on('data', function(chunk) {  responseText += chunk;});response.on('end', function() {fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');fs.unlinkSync('" + syncFile + "');});response.on('error', function(error) {fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');fs.unlinkSync('" + syncFile + "');});}).on('error', function(error) {fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');fs.unlinkSync('" + syncFile + "');});" + (data ? "req.write('" + JSON.stringify(data).slice(1, -1).replace(/'/g, "\\'") + "');" : "") + "req.end();";
          var syncProc = spawn(process.argv[0], ["-e", execString]);
          while (fs.existsSync(syncFile)) {
          }
          var resp = JSON.parse(fs.readFileSync(contentFile, "utf8"));
          syncProc.stdin.end();
          fs.unlinkSync(contentFile);
          if (resp.err) {
            self2.handleError(resp.err);
          } else {
            response = resp.data;
            self2.status = resp.data.statusCode;
            self2.responseText = resp.data.text;
            setState(self2.DONE);
          }
        }
      };
      this.handleError = function(error3) {
        this.status = 0;
        this.statusText = error3;
        this.responseText = error3.stack;
        errorFlag = true;
        setState(this.DONE);
        this.dispatchEvent("error");
      };
      this.abort = function() {
        if (request) {
          request.abort();
          request = null;
        }
        headers = defaultHeaders;
        this.status = 0;
        this.responseText = "";
        this.responseXML = "";
        errorFlag = true;
        if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {
          sendFlag = false;
          setState(this.DONE);
        }
        this.readyState = this.UNSENT;
        this.dispatchEvent("abort");
      };
      this.addEventListener = function(event, callback) {
        if (!(event in listeners)) {
          listeners[event] = [];
        }
        listeners[event].push(callback);
      };
      this.removeEventListener = function(event, callback) {
        if (event in listeners) {
          listeners[event] = listeners[event].filter(function(ev) {
            return ev !== callback;
          });
        }
      };
      this.dispatchEvent = function(event) {
        if (typeof self2["on" + event] === "function") {
          self2["on" + event]();
        }
        if (event in listeners) {
          for (var i = 0, len = listeners[event].length; i < len; i++) {
            listeners[event][i].call(self2);
          }
        }
      };
      var setState = function(state) {
        if (state == self2.LOADING || self2.readyState !== state) {
          self2.readyState = state;
          if (settings.async || self2.readyState < self2.OPENED || self2.readyState === self2.DONE) {
            self2.dispatchEvent("readystatechange");
          }
          if (self2.readyState === self2.DONE && !errorFlag) {
            self2.dispatchEvent("load");
            self2.dispatchEvent("loadend");
          }
        }
      };
    };
  }
});

// node_modules/@firebase/app/dist/index.node.cjs.js
var require_index_node_cjs2 = __commonJS({
  "node_modules/@firebase/app/dist/index.node.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib = require_tslib();
    var util = require_index_node_cjs();
    var component = require_index_cjs();
    var logger$1 = require_index_cjs2();
    var Storage = require_lib();
    var xmlhttprequest = require_XMLHttpRequest();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var Storage__default = /* @__PURE__ */ _interopDefaultLegacy(Storage);
    var _a$1;
    var ERRORS = (_a$1 = {}, _a$1["no-app"] = "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", _a$1["bad-app-name"] = "Illegal App name: '{$appName}", _a$1["duplicate-app"] = "Firebase App named '{$appName}' already exists", _a$1["app-deleted"] = "Firebase App named '{$appName}' already deleted", _a$1["invalid-app-argument"] = "firebase.{$appName}() takes either no argument or a Firebase App instance.", _a$1["invalid-log-argument"] = "First argument to `onLog` must be null or a function.", _a$1);
    var ERROR_FACTORY = new util.ErrorFactory("app", "Firebase", ERRORS);
    var name$c = "@firebase/app";
    var version$1 = "0.6.29";
    var name$b = "@firebase/analytics";
    var name$a = "@firebase/app-check";
    var name$9 = "@firebase/auth";
    var name$8 = "@firebase/database";
    var name$7 = "@firebase/functions";
    var name$6 = "@firebase/installations";
    var name$5 = "@firebase/messaging";
    var name$4 = "@firebase/performance";
    var name$3 = "@firebase/remote-config";
    var name$2 = "@firebase/storage";
    var name$1 = "@firebase/firestore";
    var name = "firebase-wrapper";
    var _a;
    var DEFAULT_ENTRY_NAME = "[DEFAULT]";
    var PLATFORM_LOG_STRING = (_a = {}, _a[name$c] = "fire-core", _a[name$b] = "fire-analytics", _a[name$a] = "fire-app-check", _a[name$9] = "fire-auth", _a[name$8] = "fire-rtdb", _a[name$7] = "fire-fn", _a[name$6] = "fire-iid", _a[name$5] = "fire-fcm", _a[name$4] = "fire-perf", _a[name$3] = "fire-rc", _a[name$2] = "fire-gcs", _a[name$1] = "fire-fst", _a["fire-js"] = "fire-js", _a[name] = "fire-js-all", _a);
    var logger = new logger$1.Logger("@firebase/app");
    var FirebaseAppImpl = function() {
      function FirebaseAppImpl2(options2, config, firebase_) {
        var _this = this;
        this.firebase_ = firebase_;
        this.isDeleted_ = false;
        this.name_ = config.name;
        this.automaticDataCollectionEnabled_ = config.automaticDataCollectionEnabled || false;
        this.options_ = util.deepCopy(options2);
        this.container = new component.ComponentContainer(config.name);
        this._addComponent(new component.Component("app", function() {
          return _this;
        }, "PUBLIC"));
        this.firebase_.INTERNAL.components.forEach(function(component2) {
          return _this._addComponent(component2);
        });
      }
      Object.defineProperty(FirebaseAppImpl2.prototype, "automaticDataCollectionEnabled", {
        get: function() {
          this.checkDestroyed_();
          return this.automaticDataCollectionEnabled_;
        },
        set: function(val) {
          this.checkDestroyed_();
          this.automaticDataCollectionEnabled_ = val;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FirebaseAppImpl2.prototype, "name", {
        get: function() {
          this.checkDestroyed_();
          return this.name_;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FirebaseAppImpl2.prototype, "options", {
        get: function() {
          this.checkDestroyed_();
          return this.options_;
        },
        enumerable: false,
        configurable: true
      });
      FirebaseAppImpl2.prototype.delete = function() {
        var _this = this;
        return new Promise(function(resolve2) {
          _this.checkDestroyed_();
          resolve2();
        }).then(function() {
          _this.firebase_.INTERNAL.removeApp(_this.name_);
          return Promise.all(_this.container.getProviders().map(function(provider) {
            return provider.delete();
          }));
        }).then(function() {
          _this.isDeleted_ = true;
        });
      };
      FirebaseAppImpl2.prototype._getService = function(name2, instanceIdentifier) {
        var _a2;
        if (instanceIdentifier === void 0) {
          instanceIdentifier = DEFAULT_ENTRY_NAME;
        }
        this.checkDestroyed_();
        var provider = this.container.getProvider(name2);
        if (!provider.isInitialized() && ((_a2 = provider.getComponent()) === null || _a2 === void 0 ? void 0 : _a2.instantiationMode) === "EXPLICIT") {
          provider.initialize();
        }
        return provider.getImmediate({
          identifier: instanceIdentifier
        });
      };
      FirebaseAppImpl2.prototype._removeServiceInstance = function(name2, instanceIdentifier) {
        if (instanceIdentifier === void 0) {
          instanceIdentifier = DEFAULT_ENTRY_NAME;
        }
        this.container.getProvider(name2).clearInstance(instanceIdentifier);
      };
      FirebaseAppImpl2.prototype._addComponent = function(component2) {
        try {
          this.container.addComponent(component2);
        } catch (e) {
          logger.debug("Component " + component2.name + " failed to register with FirebaseApp " + this.name, e);
        }
      };
      FirebaseAppImpl2.prototype._addOrOverwriteComponent = function(component2) {
        this.container.addOrOverwriteComponent(component2);
      };
      FirebaseAppImpl2.prototype.toJSON = function() {
        return {
          name: this.name,
          automaticDataCollectionEnabled: this.automaticDataCollectionEnabled,
          options: this.options
        };
      };
      FirebaseAppImpl2.prototype.checkDestroyed_ = function() {
        if (this.isDeleted_) {
          throw ERROR_FACTORY.create("app-deleted", { appName: this.name_ });
        }
      };
      return FirebaseAppImpl2;
    }();
    FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log("dc");
    var version = "8.8.1";
    function createFirebaseNamespaceCore(firebaseAppImpl) {
      var apps = {};
      var components = new Map();
      var namespace = {
        __esModule: true,
        initializeApp,
        app,
        registerVersion,
        setLogLevel: logger$1.setLogLevel,
        onLog,
        apps: null,
        SDK_VERSION: version,
        INTERNAL: {
          registerComponent,
          removeApp,
          components,
          useAsService
        }
      };
      namespace["default"] = namespace;
      Object.defineProperty(namespace, "apps", {
        get: getApps
      });
      function removeApp(name2) {
        delete apps[name2];
      }
      function app(name2) {
        name2 = name2 || DEFAULT_ENTRY_NAME;
        if (!util.contains(apps, name2)) {
          throw ERROR_FACTORY.create("no-app", { appName: name2 });
        }
        return apps[name2];
      }
      app["App"] = firebaseAppImpl;
      function initializeApp(options2, rawConfig) {
        if (rawConfig === void 0) {
          rawConfig = {};
        }
        if (typeof rawConfig !== "object" || rawConfig === null) {
          var name_1 = rawConfig;
          rawConfig = { name: name_1 };
        }
        var config = rawConfig;
        if (config.name === void 0) {
          config.name = DEFAULT_ENTRY_NAME;
        }
        var name2 = config.name;
        if (typeof name2 !== "string" || !name2) {
          throw ERROR_FACTORY.create("bad-app-name", {
            appName: String(name2)
          });
        }
        if (util.contains(apps, name2)) {
          throw ERROR_FACTORY.create("duplicate-app", { appName: name2 });
        }
        var app2 = new firebaseAppImpl(options2, config, namespace);
        apps[name2] = app2;
        return app2;
      }
      function getApps() {
        return Object.keys(apps).map(function(name2) {
          return apps[name2];
        });
      }
      function registerComponent(component2) {
        var componentName = component2.name;
        if (components.has(componentName)) {
          logger.debug("There were multiple attempts to register component " + componentName + ".");
          return component2.type === "PUBLIC" ? namespace[componentName] : null;
        }
        components.set(componentName, component2);
        if (component2.type === "PUBLIC") {
          var serviceNamespace = function(appArg) {
            if (appArg === void 0) {
              appArg = app();
            }
            if (typeof appArg[componentName] !== "function") {
              throw ERROR_FACTORY.create("invalid-app-argument", {
                appName: componentName
              });
            }
            return appArg[componentName]();
          };
          if (component2.serviceProps !== void 0) {
            util.deepExtend(serviceNamespace, component2.serviceProps);
          }
          namespace[componentName] = serviceNamespace;
          firebaseAppImpl.prototype[componentName] = function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            var serviceFxn = this._getService.bind(this, componentName);
            return serviceFxn.apply(this, component2.multipleInstances ? args : []);
          };
        }
        for (var _i = 0, _a2 = Object.keys(apps); _i < _a2.length; _i++) {
          var appName = _a2[_i];
          apps[appName]._addComponent(component2);
        }
        return component2.type === "PUBLIC" ? namespace[componentName] : null;
      }
      function registerVersion(libraryKeyOrName, version2, variant) {
        var _a2;
        var library = (_a2 = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a2 !== void 0 ? _a2 : libraryKeyOrName;
        if (variant) {
          library += "-" + variant;
        }
        var libraryMismatch = library.match(/\s|\//);
        var versionMismatch = version2.match(/\s|\//);
        if (libraryMismatch || versionMismatch) {
          var warning = [
            'Unable to register library "' + library + '" with version "' + version2 + '":'
          ];
          if (libraryMismatch) {
            warning.push('library name "' + library + '" contains illegal characters (whitespace or "/")');
          }
          if (libraryMismatch && versionMismatch) {
            warning.push("and");
          }
          if (versionMismatch) {
            warning.push('version name "' + version2 + '" contains illegal characters (whitespace or "/")');
          }
          logger.warn(warning.join(" "));
          return;
        }
        registerComponent(new component.Component(library + "-version", function() {
          return { library, version: version2 };
        }, "VERSION"));
      }
      function onLog(logCallback, options2) {
        if (logCallback !== null && typeof logCallback !== "function") {
          throw ERROR_FACTORY.create("invalid-log-argument");
        }
        logger$1.setUserLogHandler(logCallback, options2);
      }
      function useAsService(app2, name2) {
        if (name2 === "serverAuth") {
          return null;
        }
        var useService = name2;
        return useService;
      }
      return namespace;
    }
    function createFirebaseNamespace() {
      var namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
      namespace.INTERNAL = tslib.__assign(tslib.__assign({}, namespace.INTERNAL), {
        createFirebaseNamespace,
        extendNamespace,
        createSubscribe: util.createSubscribe,
        ErrorFactory: util.ErrorFactory,
        deepExtend: util.deepExtend
      });
      function extendNamespace(props) {
        util.deepExtend(namespace, props);
      }
      return namespace;
    }
    var firebase$1 = createFirebaseNamespace();
    var PlatformLoggerService = function() {
      function PlatformLoggerService2(container) {
        this.container = container;
      }
      PlatformLoggerService2.prototype.getPlatformInfoString = function() {
        var providers = this.container.getProviders();
        return providers.map(function(provider) {
          if (isVersionServiceProvider(provider)) {
            var service = provider.getImmediate();
            return service.library + "/" + service.version;
          } else {
            return null;
          }
        }).filter(function(logString) {
          return logString;
        }).join(" ");
      };
      return PlatformLoggerService2;
    }();
    function isVersionServiceProvider(provider) {
      var component2 = provider.getComponent();
      return (component2 === null || component2 === void 0 ? void 0 : component2.type) === "VERSION";
    }
    function registerCoreComponents(firebase3, variant) {
      firebase3.INTERNAL.registerComponent(new component.Component("platform-logger", function(container) {
        return new PlatformLoggerService(container);
      }, "PRIVATE"));
      firebase3.registerVersion(name$c, version$1, variant);
      firebase3.registerVersion("fire-js", "");
    }
    firebase$1.INTERNAL.extendNamespace({
      INTERNAL: {
        node: {
          localStorage: new Storage__default["default"](null, { strict: true }),
          sessionStorage: new Storage__default["default"](null, { strict: true }),
          XMLHttpRequest: xmlhttprequest.XMLHttpRequest
        }
      }
    });
    var firebase2 = firebase$1;
    registerCoreComponents(firebase2, "node");
    exports2.default = firebase2;
    exports2.firebase = firebase2;
  }
});

// node_modules/@firebase/auth/dist/auth.js
var require_auth = __commonJS({
  "node_modules/@firebase/auth/dist/auth.js"() {
    init_shims();
    (function() {
      var firebase2 = require_index_node_cjs2().default;
      var k, aa = typeof Object.defineProperties == "function" ? Object.defineProperty : function(a, b, c) {
        a != Array.prototype && a != Object.prototype && (a[b] = c.value);
      };
      function ba(a) {
        a = [typeof window == "object" && window, typeof self == "object" && self, typeof global == "object" && global, a];
        for (var b = 0; b < a.length; ++b) {
          var c = a[b];
          if (c && c.Math == Math)
            return c;
        }
        return globalThis;
      }
      var ca = ba(this);
      function da(a, b) {
        if (b) {
          var c = ca;
          a = a.split(".");
          for (var d2 = 0; d2 < a.length - 1; d2++) {
            var e = a[d2];
            e in c || (c[e] = {});
            c = c[e];
          }
          a = a[a.length - 1];
          d2 = c[a];
          b = b(d2);
          b != d2 && b != null && aa(c, a, { configurable: true, writable: true, value: b });
        }
      }
      function ea(a) {
        var b = 0;
        return function() {
          return b < a.length ? { done: false, value: a[b++] } : { done: true };
        };
      }
      function fa(a) {
        var b = typeof Symbol != "undefined" && Symbol.iterator && a[Symbol.iterator];
        return b ? b.call(a) : { next: ea(a) };
      }
      da("Promise", function(a) {
        function b(g) {
          this.b = 0;
          this.c = void 0;
          this.a = [];
          var h = this.f();
          try {
            g(h.resolve, h.reject);
          } catch (m) {
            h.reject(m);
          }
        }
        function c() {
          this.a = null;
        }
        function d2(g) {
          return g instanceof b ? g : new b(function(h) {
            h(g);
          });
        }
        if (a)
          return a;
        c.prototype.b = function(g) {
          if (this.a == null) {
            this.a = [];
            var h = this;
            this.c(function() {
              h.g();
            });
          }
          this.a.push(g);
        };
        var e = ca.setTimeout;
        c.prototype.c = function(g) {
          e(g, 0);
        };
        c.prototype.g = function() {
          for (; this.a && this.a.length; ) {
            var g = this.a;
            this.a = [];
            for (var h = 0; h < g.length; ++h) {
              var m = g[h];
              g[h] = null;
              try {
                m();
              } catch (p) {
                this.f(p);
              }
            }
          }
          this.a = null;
        };
        c.prototype.f = function(g) {
          this.c(function() {
            throw g;
          });
        };
        b.prototype.f = function() {
          function g(p) {
            return function(v) {
              m || (m = true, p.call(h, v));
            };
          }
          var h = this, m = false;
          return { resolve: g(this.m), reject: g(this.g) };
        };
        b.prototype.m = function(g) {
          if (g === this)
            this.g(new TypeError("A Promise cannot resolve to itself"));
          else if (g instanceof b)
            this.s(g);
          else {
            a:
              switch (typeof g) {
                case "object":
                  var h = g != null;
                  break a;
                case "function":
                  h = true;
                  break a;
                default:
                  h = false;
              }
            h ? this.v(g) : this.h(g);
          }
        };
        b.prototype.v = function(g) {
          var h = void 0;
          try {
            h = g.then;
          } catch (m) {
            this.g(m);
            return;
          }
          typeof h == "function" ? this.u(h, g) : this.h(g);
        };
        b.prototype.g = function(g) {
          this.i(2, g);
        };
        b.prototype.h = function(g) {
          this.i(1, g);
        };
        b.prototype.i = function(g, h) {
          if (this.b != 0)
            throw Error("Cannot settle(" + g + ", " + h + "): Promise already settled in state" + this.b);
          this.b = g;
          this.c = h;
          this.l();
        };
        b.prototype.l = function() {
          if (this.a != null) {
            for (var g = 0; g < this.a.length; ++g)
              f.b(this.a[g]);
            this.a = null;
          }
        };
        var f = new c();
        b.prototype.s = function(g) {
          var h = this.f();
          g.Ra(h.resolve, h.reject);
        };
        b.prototype.u = function(g, h) {
          var m = this.f();
          try {
            g.call(h, m.resolve, m.reject);
          } catch (p) {
            m.reject(p);
          }
        };
        b.prototype.then = function(g, h) {
          function m(A, Q) {
            return typeof A == "function" ? function(ya) {
              try {
                p(A(ya));
              } catch (Ad) {
                v(Ad);
              }
            } : Q;
          }
          var p, v, B = new b(function(A, Q) {
            p = A;
            v = Q;
          });
          this.Ra(m(g, p), m(h, v));
          return B;
        };
        b.prototype.catch = function(g) {
          return this.then(void 0, g);
        };
        b.prototype.Ra = function(g, h) {
          function m() {
            switch (p.b) {
              case 1:
                g(p.c);
                break;
              case 2:
                h(p.c);
                break;
              default:
                throw Error("Unexpected state: " + p.b);
            }
          }
          var p = this;
          this.a == null ? f.b(m) : this.a.push(m);
        };
        b.resolve = d2;
        b.reject = function(g) {
          return new b(function(h, m) {
            m(g);
          });
        };
        b.race = function(g) {
          return new b(function(h, m) {
            for (var p = fa(g), v = p.next(); !v.done; v = p.next())
              d2(v.value).Ra(h, m);
          });
        };
        b.all = function(g) {
          var h = fa(g), m = h.next();
          return m.done ? d2([]) : new b(function(p, v) {
            function B(ya) {
              return function(Ad) {
                A[ya] = Ad;
                Q--;
                Q == 0 && p(A);
              };
            }
            var A = [], Q = 0;
            do
              A.push(void 0), Q++, d2(m.value).Ra(B(A.length - 1), v), m = h.next();
            while (!m.done);
          });
        };
        return b;
      });
      var ha = ha || {}, l = this || self, ia = /^[\w+/_-]+[=]{0,2}$/, ja = null;
      function ka(a) {
        return (a = a.querySelector && a.querySelector("script[nonce]")) && (a = a.nonce || a.getAttribute("nonce")) && ia.test(a) ? a : "";
      }
      function la() {
      }
      function ma(a) {
        var b = typeof a;
        return b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
      }
      function na(a) {
        var b = ma(a);
        return b == "array" || b == "object" && typeof a.length == "number";
      }
      function oa(a) {
        return ma(a) == "function";
      }
      function n(a) {
        var b = typeof a;
        return b == "object" && a != null || b == "function";
      }
      function pa(a) {
        return Object.prototype.hasOwnProperty.call(a, qa) && a[qa] || (a[qa] = ++ra);
      }
      var qa = "closure_uid_" + (1e9 * Math.random() >>> 0), ra = 0;
      function sa(a, b, c) {
        return a.call.apply(a.bind, arguments);
      }
      function ta(a, b, c) {
        if (!a)
          throw Error();
        if (2 < arguments.length) {
          var d2 = Array.prototype.slice.call(arguments, 2);
          return function() {
            var e = Array.prototype.slice.call(arguments);
            Array.prototype.unshift.apply(e, d2);
            return a.apply(b, e);
          };
        }
        return function() {
          return a.apply(b, arguments);
        };
      }
      function q(a, b, c) {
        Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = sa : q = ta;
        return q.apply(null, arguments);
      }
      function ua(a, b) {
        var c = Array.prototype.slice.call(arguments, 1);
        return function() {
          var d2 = c.slice();
          d2.push.apply(d2, arguments);
          return a.apply(this, d2);
        };
      }
      var va = Date.now;
      function r(a, b) {
        function c() {
        }
        c.prototype = b.prototype;
        a.bb = b.prototype;
        a.prototype = new c();
        a.prototype.constructor = a;
      }
      function wa(a) {
        return a;
      }
      ;
      function t(a, b, c) {
        this.code = xa + a;
        this.message = b || za[a] || "";
        this.a = c || null;
      }
      r(t, Error);
      t.prototype.w = function() {
        var a = { code: this.code, message: this.message };
        this.a && (a.serverResponse = this.a);
        return a;
      };
      t.prototype.toJSON = function() {
        return this.w();
      };
      function Aa(a) {
        var b = a && a.code;
        return b ? new t(b.substring(xa.length), a.message, a.serverResponse) : null;
      }
      var xa = "auth/", za = {
        "admin-restricted-operation": "This operation is restricted to administrators only.",
        "argument-error": "",
        "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",
        "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
        "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
        "code-expired": "The SMS code has expired. Please re-send the verification code to try again.",
        "cordova-not-ready": "Cordova framework is not ready.",
        "cors-unsupported": "This browser is not supported.",
        "credential-already-in-use": "This credential is already associated with a different user account.",
        "custom-token-mismatch": "The custom token corresponds to a different audience.",
        "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
        "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.",
        "email-change-needs-verification": "Multi-factor users must always have a verified email.",
        "email-already-in-use": "The email address is already in use by another account.",
        "expired-action-code": "The action code has expired. ",
        "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.",
        "internal-error": "An internal error has occurred.",
        "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
        "invalid-app-id": "The mobile app identifier is not registed for the current project.",
        "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",
        "invalid-auth-event": "An internal error has occurred.",
        "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.",
        "invalid-continue-uri": "The continue URL provided in the request is invalid.",
        "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",
        "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.",
        "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.",
        "invalid-email": "The email address is badly formatted.",
        "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.",
        "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.",
        "invalid-credential": "The supplied auth credential is malformed or has expired.",
        "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.",
        "invalid-multi-factor-session": "The request does not contain a valid proof of first factor successful sign-in.",
        "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
        "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.",
        "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
        "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.",
        "wrong-password": "The password is invalid or the user does not have a password.",
        "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.",
        "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
        "invalid-provider-id": "The specified provider ID is invalid.",
        "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.",
        "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.",
        "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.",
        "invalid-tenant-id": "The Auth instance's tenant ID is invalid.",
        "multi-factor-info-not-found": "The user does not have a second factor matching the identifier provided.",
        "multi-factor-auth-required": "Proof of ownership of a second factor is required to complete sign-in.",
        "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.",
        "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.",
        "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.",
        "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.",
        "missing-continue-uri": "A continue URL must be provided in the request.",
        "missing-iframe-start": "An internal error has occurred.",
        "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.",
        "missing-multi-factor-info": "No second factor identifier is provided.",
        "missing-multi-factor-session": "The request is missing proof of first factor successful sign-in.",
        "missing-or-invalid-nonce": "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.",
        "missing-phone-number": "To send verification codes, provide a phone number for the recipient.",
        "missing-verification-id": "The phone auth credential was created with an empty verification ID.",
        "app-deleted": "This instance of FirebaseApp has been deleted.",
        "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
        "network-request-failed": "A network error (such as timeout, interrupted connection or unreachable host) has occurred.",
        "no-auth-event": "An internal error has occurred.",
        "no-such-provider": "User was not linked to an account with the given provider.",
        "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.",
        "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
        "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
        "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.",
        "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.",
        "provider-already-linked": "User can only be linked to one identity for the given provider.",
        "quota-exceeded": "The project's quota for this operation has been exceeded.",
        "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.",
        "redirect-operation-pending": "A redirect sign-in operation is already pending.",
        "rejected-credential": "The request contains malformed or mismatching credentials.",
        "second-factor-already-in-use": "The second factor is already enrolled on this account.",
        "maximum-second-factor-count-exceeded": "The maximum allowed number of second factors on a user has been exceeded.",
        "tenant-id-mismatch": "The provided tenant ID does not match the Auth instance's tenant ID",
        timeout: "The operation has timed out.",
        "user-token-expired": "The user's credential is no longer valid. The user must sign in again.",
        "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.",
        "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.",
        "unsupported-first-factor": "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.",
        "unsupported-persistence-type": "The current environment does not support the specified persistence type.",
        "unsupported-tenant-operation": "This operation is not supported in a multi-tenant context.",
        "unverified-email": "The operation requires a verified email.",
        "user-cancelled": "The user did not grant your application the permissions it requested.",
        "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.",
        "user-disabled": "The user account has been disabled by an administrator.",
        "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.",
        "user-signed-out": "",
        "weak-password": "The password must be 6 characters long or more.",
        "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled."
      };
      var Ba = { ld: { Ua: "https://staging-identitytoolkit.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/", $a: "https://staging-securetoken.sandbox.googleapis.com/v1/token", Xa: "https://staging-identitytoolkit.sandbox.googleapis.com/v2/", id: "b" }, sd: { Ua: "https://www.googleapis.com/identitytoolkit/v3/relyingparty/", $a: "https://securetoken.googleapis.com/v1/token", Xa: "https://identitytoolkit.googleapis.com/v2/", id: "p" }, ud: {
        Ua: "https://staging-www.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/",
        $a: "https://staging-securetoken.sandbox.googleapis.com/v1/token",
        Xa: "https://staging-identitytoolkit.sandbox.googleapis.com/v2/",
        id: "s"
      }, vd: { Ua: "https://www-googleapis-test.sandbox.google.com/identitytoolkit/v3/relyingparty/", $a: "https://test-securetoken.sandbox.googleapis.com/v1/token", Xa: "https://test-identitytoolkit.sandbox.googleapis.com/v2/", id: "t" } };
      function Ca(a) {
        for (var b in Ba)
          if (Ba[b].id === a)
            return a = Ba[b], { firebaseEndpoint: a.Ua, secureTokenEndpoint: a.$a, identityPlatformEndpoint: a.Xa };
        return null;
      }
      var Da;
      Da = Ca("__EID__") ? "__EID__" : void 0;
      function Ea(a) {
        if (!a)
          return false;
        try {
          return !!a.$goog_Thenable;
        } catch (b) {
          return false;
        }
      }
      ;
      function u(a) {
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, u);
        else {
          var b = Error().stack;
          b && (this.stack = b);
        }
        a && (this.message = String(a));
      }
      r(u, Error);
      u.prototype.name = "CustomError";
      function Fa(a, b) {
        a = a.split("%s");
        for (var c = "", d2 = a.length - 1, e = 0; e < d2; e++)
          c += a[e] + (e < b.length ? b[e] : "%s");
        u.call(this, c + a[d2]);
      }
      r(Fa, u);
      Fa.prototype.name = "AssertionError";
      function Ga(a, b) {
        throw new Fa("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
      }
      ;
      function Ha(a, b) {
        this.c = a;
        this.f = b;
        this.b = 0;
        this.a = null;
      }
      Ha.prototype.get = function() {
        if (0 < this.b) {
          this.b--;
          var a = this.a;
          this.a = a.next;
          a.next = null;
        } else
          a = this.c();
        return a;
      };
      function Ia(a, b) {
        a.f(b);
        100 > a.b && (a.b++, b.next = a.a, a.a = b);
      }
      ;
      function Ja() {
        this.b = this.a = null;
      }
      var La = new Ha(function() {
        return new Ka();
      }, function(a) {
        a.reset();
      });
      Ja.prototype.add = function(a, b) {
        var c = La.get();
        c.set(a, b);
        this.b ? this.b.next = c : this.a = c;
        this.b = c;
      };
      function Ma() {
        var a = Na, b = null;
        a.a && (b = a.a, a.a = a.a.next, a.a || (a.b = null), b.next = null);
        return b;
      }
      function Ka() {
        this.next = this.b = this.a = null;
      }
      Ka.prototype.set = function(a, b) {
        this.a = a;
        this.b = b;
        this.next = null;
      };
      Ka.prototype.reset = function() {
        this.next = this.b = this.a = null;
      };
      var Oa = Array.prototype.indexOf ? function(a, b) {
        return Array.prototype.indexOf.call(a, b, void 0);
      } : function(a, b) {
        if (typeof a === "string")
          return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
        for (var c = 0; c < a.length; c++)
          if (c in a && a[c] === b)
            return c;
        return -1;
      }, w = Array.prototype.forEach ? function(a, b, c) {
        Array.prototype.forEach.call(a, b, c);
      } : function(a, b, c) {
        for (var d2 = a.length, e = typeof a === "string" ? a.split("") : a, f = 0; f < d2; f++)
          f in e && b.call(c, e[f], f, a);
      };
      function Pa(a, b) {
        for (var c = typeof a === "string" ? a.split("") : a, d2 = a.length - 1; 0 <= d2; --d2)
          d2 in c && b.call(void 0, c[d2], d2, a);
      }
      var Qa = Array.prototype.filter ? function(a, b) {
        return Array.prototype.filter.call(a, b, void 0);
      } : function(a, b) {
        for (var c = a.length, d2 = [], e = 0, f = typeof a === "string" ? a.split("") : a, g = 0; g < c; g++)
          if (g in f) {
            var h = f[g];
            b.call(void 0, h, g, a) && (d2[e++] = h);
          }
        return d2;
      }, Ra = Array.prototype.map ? function(a, b) {
        return Array.prototype.map.call(a, b, void 0);
      } : function(a, b) {
        for (var c = a.length, d2 = Array(c), e = typeof a === "string" ? a.split("") : a, f = 0; f < c; f++)
          f in e && (d2[f] = b.call(void 0, e[f], f, a));
        return d2;
      }, Sa = Array.prototype.some ? function(a, b) {
        return Array.prototype.some.call(a, b, void 0);
      } : function(a, b) {
        for (var c = a.length, d2 = typeof a === "string" ? a.split("") : a, e = 0; e < c; e++)
          if (e in d2 && b.call(void 0, d2[e], e, a))
            return true;
        return false;
      };
      function Ta(a) {
        a: {
          var b = Ua;
          for (var c = a.length, d2 = typeof a === "string" ? a.split("") : a, e = 0; e < c; e++)
            if (e in d2 && b.call(void 0, d2[e], e, a)) {
              b = e;
              break a;
            }
          b = -1;
        }
        return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
      }
      function Va(a, b) {
        return 0 <= Oa(a, b);
      }
      function Wa(a, b) {
        b = Oa(a, b);
        var c;
        (c = 0 <= b) && Array.prototype.splice.call(a, b, 1);
        return c;
      }
      function Xa(a, b) {
        var c = 0;
        Pa(a, function(d2, e) {
          b.call(void 0, d2, e, a) && Array.prototype.splice.call(a, e, 1).length == 1 && c++;
        });
      }
      function Ya(a) {
        return Array.prototype.concat.apply([], arguments);
      }
      function Za(a) {
        var b = a.length;
        if (0 < b) {
          for (var c = Array(b), d2 = 0; d2 < b; d2++)
            c[d2] = a[d2];
          return c;
        }
        return [];
      }
      ;
      var $a = String.prototype.trim ? function(a) {
        return a.trim();
      } : function(a) {
        return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
      }, ab = /&/g, bb = /</g, cb = />/g, db2 = /"/g, eb = /'/g, fb = /\x00/g, gb = /[\x00&<>"']/;
      function x(a, b) {
        return a.indexOf(b) != -1;
      }
      function hb(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      ;
      var ib;
      a: {
        var jb = l.navigator;
        if (jb) {
          var kb = jb.userAgent;
          if (kb) {
            ib = kb;
            break a;
          }
        }
        ib = "";
      }
      function y(a) {
        return x(ib, a);
      }
      ;
      function lb(a, b) {
        for (var c in a)
          b.call(void 0, a[c], c, a);
      }
      function mb(a) {
        for (var b in a)
          return false;
        return true;
      }
      function nb(a) {
        var b = {}, c;
        for (c in a)
          b[c] = a[c];
        return b;
      }
      var ob = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
      function z(a, b) {
        for (var c, d2, e = 1; e < arguments.length; e++) {
          d2 = arguments[e];
          for (c in d2)
            a[c] = d2[c];
          for (var f = 0; f < ob.length; f++)
            c = ob[f], Object.prototype.hasOwnProperty.call(d2, c) && (a[c] = d2[c]);
        }
      }
      ;
      function pb(a, b) {
        a: {
          try {
            var c = a && a.ownerDocument, d2 = c && (c.defaultView || c.parentWindow);
            d2 = d2 || l;
            if (d2.Element && d2.Location) {
              var e = d2;
              break a;
            }
          } catch (g) {
          }
          e = null;
        }
        if (e && typeof e[b] != "undefined" && (!a || !(a instanceof e[b]) && (a instanceof e.Location || a instanceof e.Element))) {
          if (n(a))
            try {
              var f = a.constructor.displayName || a.constructor.name || Object.prototype.toString.call(a);
            } catch (g) {
              f = "<object could not be stringified>";
            }
          else
            f = a === void 0 ? "undefined" : a === null ? "null" : typeof a;
          Ga("Argument is not a %s (or a non-Element, non-Location mock); got: %s", b, f);
        }
      }
      ;
      function qb(a, b) {
        this.a = a === rb && b || "";
        this.b = sb;
      }
      qb.prototype.ta = true;
      qb.prototype.sa = function() {
        return this.a;
      };
      qb.prototype.toString = function() {
        return "Const{" + this.a + "}";
      };
      function tb(a) {
        if (a instanceof qb && a.constructor === qb && a.b === sb)
          return a.a;
        Ga("expected object of type Const, got '" + a + "'");
        return "type_error:Const";
      }
      var sb = {}, rb = {};
      var ub;
      function vb() {
        if (ub === void 0) {
          var a = null, b = l.trustedTypes;
          if (b && b.createPolicy) {
            try {
              a = b.createPolicy("goog#html", { createHTML: wa, createScript: wa, createScriptURL: wa });
            } catch (c) {
              l.console && l.console.error(c.message);
            }
            ub = a;
          } else
            ub = a;
        }
        return ub;
      }
      ;
      function wb(a, b) {
        this.a = b === xb ? a : "";
      }
      wb.prototype.ta = true;
      wb.prototype.sa = function() {
        return this.a.toString();
      };
      wb.prototype.toString = function() {
        return "TrustedResourceUrl{" + this.a + "}";
      };
      function yb(a) {
        if (a instanceof wb && a.constructor === wb)
          return a.a;
        Ga("expected object of type TrustedResourceUrl, got '" + a + "' of type " + ma(a));
        return "type_error:TrustedResourceUrl";
      }
      function zb(a, b) {
        var c = tb(a);
        if (!Ab.test(c))
          throw Error("Invalid TrustedResourceUrl format: " + c);
        a = c.replace(Bb, function(d2, e) {
          if (!Object.prototype.hasOwnProperty.call(b, e))
            throw Error('Found marker, "' + e + '", in format string, "' + c + '", but no valid label mapping found in args: ' + JSON.stringify(b));
          d2 = b[e];
          return d2 instanceof qb ? tb(d2) : encodeURIComponent(String(d2));
        });
        return Cb(a);
      }
      var Bb = /%{(\w+)}/g, Ab = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i, xb = {};
      function Cb(a) {
        var b = vb();
        a = b ? b.createScriptURL(a) : a;
        return new wb(a, xb);
      }
      ;
      function C(a, b) {
        this.a = b === Db ? a : "";
      }
      C.prototype.ta = true;
      C.prototype.sa = function() {
        return this.a.toString();
      };
      C.prototype.toString = function() {
        return "SafeUrl{" + this.a + "}";
      };
      function Eb(a) {
        if (a instanceof C && a.constructor === C)
          return a.a;
        Ga("expected object of type SafeUrl, got '" + a + "' of type " + ma(a));
        return "type_error:SafeUrl";
      }
      var Fb = /^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)|font\/\w+|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime|x-matroska))(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i, Gb = /^data:(.*);base64,[a-z0-9+\/]+=*$/i, Hb = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
      function Ib(a) {
        if (a instanceof C)
          return a;
        a = typeof a == "object" && a.ta ? a.sa() : String(a);
        if (Hb.test(a))
          a = new C(a, Db);
        else {
          a = String(a);
          a = a.replace(/(%0A|%0D)/g, "");
          var b = a.match(Gb);
          a = b && Fb.test(b[1]) ? new C(a, Db) : null;
        }
        return a;
      }
      function Jb(a) {
        if (a instanceof C)
          return a;
        a = typeof a == "object" && a.ta ? a.sa() : String(a);
        Hb.test(a) || (a = "about:invalid#zClosurez");
        return new C(a, Db);
      }
      var Db = {}, Kb = new C("about:invalid#zClosurez", Db);
      function Lb(a, b, c) {
        this.a = c === Mb ? a : "";
      }
      Lb.prototype.ta = true;
      Lb.prototype.sa = function() {
        return this.a.toString();
      };
      Lb.prototype.toString = function() {
        return "SafeHtml{" + this.a + "}";
      };
      function Nb(a) {
        if (a instanceof Lb && a.constructor === Lb)
          return a.a;
        Ga("expected object of type SafeHtml, got '" + a + "' of type " + ma(a));
        return "type_error:SafeHtml";
      }
      var Mb = {};
      function Ob(a, b) {
        pb(a, "HTMLScriptElement");
        a.src = yb(b);
        (b = a.ownerDocument && a.ownerDocument.defaultView) && b != l ? b = ka(b.document) : (ja === null && (ja = ka(l.document)), b = ja);
        b && a.setAttribute("nonce", b);
      }
      function Pb(a, b, c, d2) {
        a = a instanceof C ? a : Jb(a);
        b = b || l;
        c = c instanceof qb ? tb(c) : c || "";
        return b.open(Eb(a), c, d2, void 0);
      }
      ;
      function Qb(a, b) {
        for (var c = a.split("%s"), d2 = "", e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length; )
          d2 += c.shift() + e.shift();
        return d2 + c.join("%s");
      }
      function Rb(a) {
        gb.test(a) && (a.indexOf("&") != -1 && (a = a.replace(ab, "&amp;")), a.indexOf("<") != -1 && (a = a.replace(bb, "&lt;")), a.indexOf(">") != -1 && (a = a.replace(cb, "&gt;")), a.indexOf('"') != -1 && (a = a.replace(db2, "&quot;")), a.indexOf("'") != -1 && (a = a.replace(eb, "&#39;")), a.indexOf("\0") != -1 && (a = a.replace(fb, "&#0;")));
        return a;
      }
      ;
      function Sb(a) {
        Sb[" "](a);
        return a;
      }
      Sb[" "] = la;
      function Tb(a, b) {
        var c = Ub;
        return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b(a);
      }
      ;
      var Vb = y("Opera"), Wb = y("Trident") || y("MSIE"), Xb = y("Edge"), Yb = Xb || Wb, Zb = y("Gecko") && !(x(ib.toLowerCase(), "webkit") && !y("Edge")) && !(y("Trident") || y("MSIE")) && !y("Edge"), $b = x(ib.toLowerCase(), "webkit") && !y("Edge");
      function ac() {
        var a = l.document;
        return a ? a.documentMode : void 0;
      }
      var bc;
      a: {
        var cc = "", dc = function() {
          var a = ib;
          if (Zb)
            return /rv:([^\);]+)(\)|;)/.exec(a);
          if (Xb)
            return /Edge\/([\d\.]+)/.exec(a);
          if (Wb)
            return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
          if ($b)
            return /WebKit\/(\S+)/.exec(a);
          if (Vb)
            return /(?:Version)[ \/]?(\S+)/.exec(a);
        }();
        dc && (cc = dc ? dc[1] : "");
        if (Wb) {
          var ec = ac();
          if (ec != null && ec > parseFloat(cc)) {
            bc = String(ec);
            break a;
          }
        }
        bc = cc;
      }
      var Ub = {};
      function fc(a) {
        return Tb(a, function() {
          for (var b = 0, c = $a(String(bc)).split("."), d2 = $a(String(a)).split("."), e = Math.max(c.length, d2.length), f = 0; b == 0 && f < e; f++) {
            var g = c[f] || "", h = d2[f] || "";
            do {
              g = /(\d*)(\D*)(.*)/.exec(g) || ["", "", "", ""];
              h = /(\d*)(\D*)(.*)/.exec(h) || ["", "", "", ""];
              if (g[0].length == 0 && h[0].length == 0)
                break;
              b = hb(g[1].length == 0 ? 0 : parseInt(g[1], 10), h[1].length == 0 ? 0 : parseInt(h[1], 10)) || hb(g[2].length == 0, h[2].length == 0) || hb(g[2], h[2]);
              g = g[3];
              h = h[3];
            } while (b == 0);
          }
          return 0 <= b;
        });
      }
      var gc;
      if (l.document && Wb) {
        var hc = ac();
        gc = hc ? hc : parseInt(bc, 10) || void 0;
      } else
        gc = void 0;
      var ic = gc;
      try {
        new self.OffscreenCanvas(0, 0).getContext("2d");
      } catch (a) {
      }
      var jc = !Wb || 9 <= Number(ic);
      function kc(a) {
        var b = document;
        return typeof a === "string" ? b.getElementById(a) : a;
      }
      function lc(a, b) {
        lb(b, function(c, d2) {
          c && typeof c == "object" && c.ta && (c = c.sa());
          d2 == "style" ? a.style.cssText = c : d2 == "class" ? a.className = c : d2 == "for" ? a.htmlFor = c : mc.hasOwnProperty(d2) ? a.setAttribute(mc[d2], c) : d2.lastIndexOf("aria-", 0) == 0 || d2.lastIndexOf("data-", 0) == 0 ? a.setAttribute(d2, c) : a[d2] = c;
        });
      }
      var mc = { cellpadding: "cellPadding", cellspacing: "cellSpacing", colspan: "colSpan", frameborder: "frameBorder", height: "height", maxlength: "maxLength", nonce: "nonce", role: "role", rowspan: "rowSpan", type: "type", usemap: "useMap", valign: "vAlign", width: "width" };
      function nc(a, b, c) {
        var d2 = arguments, e = document, f = String(d2[0]), g = d2[1];
        if (!jc && g && (g.name || g.type)) {
          f = ["<", f];
          g.name && f.push(' name="', Rb(g.name), '"');
          if (g.type) {
            f.push(' type="', Rb(g.type), '"');
            var h = {};
            z(h, g);
            delete h.type;
            g = h;
          }
          f.push(">");
          f = f.join("");
        }
        f = oc(e, f);
        g && (typeof g === "string" ? f.className = g : Array.isArray(g) ? f.className = g.join(" ") : lc(f, g));
        2 < d2.length && pc(e, f, d2);
        return f;
      }
      function pc(a, b, c) {
        function d2(h) {
          h && b.appendChild(typeof h === "string" ? a.createTextNode(h) : h);
        }
        for (var e = 2; e < c.length; e++) {
          var f = c[e];
          if (!na(f) || n(f) && 0 < f.nodeType)
            d2(f);
          else {
            a: {
              if (f && typeof f.length == "number") {
                if (n(f)) {
                  var g = typeof f.item == "function" || typeof f.item == "string";
                  break a;
                }
                if (oa(f)) {
                  g = typeof f.item == "function";
                  break a;
                }
              }
              g = false;
            }
            w(g ? Za(f) : f, d2);
          }
        }
      }
      function oc(a, b) {
        b = String(b);
        a.contentType === "application/xhtml+xml" && (b = b.toLowerCase());
        return a.createElement(b);
      }
      ;
      function qc(a) {
        l.setTimeout(function() {
          throw a;
        }, 0);
      }
      var rc;
      function sc() {
        var a = l.MessageChannel;
        typeof a === "undefined" && typeof window !== "undefined" && window.postMessage && window.addEventListener && !y("Presto") && (a = function() {
          var e = oc(document, "IFRAME");
          e.style.display = "none";
          document.documentElement.appendChild(e);
          var f = e.contentWindow;
          e = f.document;
          e.open();
          e.close();
          var g = "callImmediate" + Math.random(), h = f.location.protocol == "file:" ? "*" : f.location.protocol + "//" + f.location.host;
          e = q(function(m) {
            if ((h == "*" || m.origin == h) && m.data == g)
              this.port1.onmessage();
          }, this);
          f.addEventListener("message", e, false);
          this.port1 = {};
          this.port2 = { postMessage: function() {
            f.postMessage(g, h);
          } };
        });
        if (typeof a !== "undefined" && !y("Trident") && !y("MSIE")) {
          var b = new a(), c = {}, d2 = c;
          b.port1.onmessage = function() {
            if (c.next !== void 0) {
              c = c.next;
              var e = c.Hb;
              c.Hb = null;
              e();
            }
          };
          return function(e) {
            d2.next = { Hb: e };
            d2 = d2.next;
            b.port2.postMessage(0);
          };
        }
        return function(e) {
          l.setTimeout(e, 0);
        };
      }
      ;
      function tc(a, b) {
        uc || vc();
        wc || (uc(), wc = true);
        Na.add(a, b);
      }
      var uc;
      function vc() {
        if (l.Promise && l.Promise.resolve) {
          var a = l.Promise.resolve(void 0);
          uc = function() {
            a.then(xc);
          };
        } else
          uc = function() {
            var b = xc;
            !oa(l.setImmediate) || l.Window && l.Window.prototype && !y("Edge") && l.Window.prototype.setImmediate == l.setImmediate ? (rc || (rc = sc()), rc(b)) : l.setImmediate(b);
          };
      }
      var wc = false, Na = new Ja();
      function xc() {
        for (var a; a = Ma(); ) {
          try {
            a.a.call(a.b);
          } catch (b) {
            qc(b);
          }
          Ia(La, a);
        }
        wc = false;
      }
      ;
      function D(a, b) {
        this.a = yc;
        this.i = void 0;
        this.f = this.b = this.c = null;
        this.g = this.h = false;
        if (a != la)
          try {
            var c = this;
            a.call(b, function(d2) {
              zc(c, Ac, d2);
            }, function(d2) {
              if (!(d2 instanceof Bc))
                try {
                  if (d2 instanceof Error)
                    throw d2;
                  throw Error("Promise rejected.");
                } catch (e) {
                }
              zc(c, Cc, d2);
            });
          } catch (d2) {
            zc(this, Cc, d2);
          }
      }
      var yc = 0, Ac = 2, Cc = 3;
      function Dc() {
        this.next = this.f = this.b = this.g = this.a = null;
        this.c = false;
      }
      Dc.prototype.reset = function() {
        this.f = this.b = this.g = this.a = null;
        this.c = false;
      };
      var Ec = new Ha(function() {
        return new Dc();
      }, function(a) {
        a.reset();
      });
      function Fc(a, b, c) {
        var d2 = Ec.get();
        d2.g = a;
        d2.b = b;
        d2.f = c;
        return d2;
      }
      function E(a) {
        if (a instanceof D)
          return a;
        var b = new D(la);
        zc(b, Ac, a);
        return b;
      }
      function F(a) {
        return new D(function(b, c) {
          c(a);
        });
      }
      function Gc(a, b, c) {
        Hc(a, b, c, null) || tc(ua(b, a));
      }
      function Ic(a) {
        return new D(function(b, c) {
          var d2 = a.length, e = [];
          if (d2)
            for (var f = function(p, v) {
              d2--;
              e[p] = v;
              d2 == 0 && b(e);
            }, g = function(p) {
              c(p);
            }, h = 0, m; h < a.length; h++)
              m = a[h], Gc(m, ua(f, h), g);
          else
            b(e);
        });
      }
      function Jc(a) {
        return new D(function(b) {
          var c = a.length, d2 = [];
          if (c)
            for (var e = function(h, m, p) {
              c--;
              d2[h] = m ? { Qb: true, value: p } : { Qb: false, reason: p };
              c == 0 && b(d2);
            }, f = 0, g; f < a.length; f++)
              g = a[f], Gc(g, ua(e, f, true), ua(e, f, false));
          else
            b(d2);
        });
      }
      D.prototype.then = function(a, b, c) {
        return Kc(this, oa(a) ? a : null, oa(b) ? b : null, c);
      };
      D.prototype.$goog_Thenable = true;
      k = D.prototype;
      k.oa = function(a, b) {
        a = Fc(a, a, b);
        a.c = true;
        Lc(this, a);
        return this;
      };
      k.o = function(a, b) {
        return Kc(this, null, a, b);
      };
      k.cancel = function(a) {
        if (this.a == yc) {
          var b = new Bc(a);
          tc(function() {
            Mc(this, b);
          }, this);
        }
      };
      function Mc(a, b) {
        if (a.a == yc)
          if (a.c) {
            var c = a.c;
            if (c.b) {
              for (var d2 = 0, e = null, f = null, g = c.b; g && (g.c || (d2++, g.a == a && (e = g), !(e && 1 < d2))); g = g.next)
                e || (f = g);
              e && (c.a == yc && d2 == 1 ? Mc(c, b) : (f ? (d2 = f, d2.next == c.f && (c.f = d2), d2.next = d2.next.next) : Nc(c), Oc(c, e, Cc, b)));
            }
            a.c = null;
          } else
            zc(a, Cc, b);
      }
      function Lc(a, b) {
        a.b || a.a != Ac && a.a != Cc || Pc(a);
        a.f ? a.f.next = b : a.b = b;
        a.f = b;
      }
      function Kc(a, b, c, d2) {
        var e = Fc(null, null, null);
        e.a = new D(function(f, g) {
          e.g = b ? function(h) {
            try {
              var m = b.call(d2, h);
              f(m);
            } catch (p) {
              g(p);
            }
          } : f;
          e.b = c ? function(h) {
            try {
              var m = c.call(d2, h);
              m === void 0 && h instanceof Bc ? g(h) : f(m);
            } catch (p) {
              g(p);
            }
          } : g;
        });
        e.a.c = a;
        Lc(a, e);
        return e.a;
      }
      k.$c = function(a) {
        this.a = yc;
        zc(this, Ac, a);
      };
      k.ad = function(a) {
        this.a = yc;
        zc(this, Cc, a);
      };
      function zc(a, b, c) {
        a.a == yc && (a === c && (b = Cc, c = new TypeError("Promise cannot resolve to itself")), a.a = 1, Hc(c, a.$c, a.ad, a) || (a.i = c, a.a = b, a.c = null, Pc(a), b != Cc || c instanceof Bc || Qc(a, c)));
      }
      function Hc(a, b, c, d2) {
        if (a instanceof D)
          return Lc(a, Fc(b || la, c || null, d2)), true;
        if (Ea(a))
          return a.then(b, c, d2), true;
        if (n(a))
          try {
            var e = a.then;
            if (oa(e))
              return Rc(a, e, b, c, d2), true;
          } catch (f) {
            return c.call(d2, f), true;
          }
        return false;
      }
      function Rc(a, b, c, d2, e) {
        function f(m) {
          h || (h = true, d2.call(e, m));
        }
        function g(m) {
          h || (h = true, c.call(e, m));
        }
        var h = false;
        try {
          b.call(a, g, f);
        } catch (m) {
          f(m);
        }
      }
      function Pc(a) {
        a.h || (a.h = true, tc(a.gc, a));
      }
      function Nc(a) {
        var b = null;
        a.b && (b = a.b, a.b = b.next, b.next = null);
        a.b || (a.f = null);
        return b;
      }
      k.gc = function() {
        for (var a; a = Nc(this); )
          Oc(this, a, this.a, this.i);
        this.h = false;
      };
      function Oc(a, b, c, d2) {
        if (c == Cc && b.b && !b.c)
          for (; a && a.g; a = a.c)
            a.g = false;
        if (b.a)
          b.a.c = null, Sc(b, c, d2);
        else
          try {
            b.c ? b.g.call(b.f) : Sc(b, c, d2);
          } catch (e) {
            Tc.call(null, e);
          }
        Ia(Ec, b);
      }
      function Sc(a, b, c) {
        b == Ac ? a.g.call(a.f, c) : a.b && a.b.call(a.f, c);
      }
      function Qc(a, b) {
        a.g = true;
        tc(function() {
          a.g && Tc.call(null, b);
        });
      }
      var Tc = qc;
      function Bc(a) {
        u.call(this, a);
      }
      r(Bc, u);
      Bc.prototype.name = "cancel";
      function Uc() {
        Vc != 0 && (Wc[pa(this)] = this);
        this.ya = this.ya;
        this.pa = this.pa;
      }
      var Vc = 0, Wc = {};
      Uc.prototype.ya = false;
      function Xc(a) {
        if (!a.ya && (a.ya = true, a.Da(), Vc != 0)) {
          var b = pa(a);
          if (Vc != 0 && a.pa && 0 < a.pa.length)
            throw Error(a + " did not empty its onDisposeCallbacks queue. This probably means it overrode dispose() or disposeInternal() without calling the superclass' method.");
          delete Wc[b];
        }
      }
      Uc.prototype.Da = function() {
        if (this.pa)
          for (; this.pa.length; )
            this.pa.shift()();
      };
      var Yc = Object.freeze || function(a) {
        return a;
      };
      var Zc = !Wb || 9 <= Number(ic), $c = Wb && !fc("9"), ad = function() {
        if (!l.addEventListener || !Object.defineProperty)
          return false;
        var a = false, b = Object.defineProperty({}, "passive", { get: function() {
          a = true;
        } });
        try {
          l.addEventListener("test", la, b), l.removeEventListener("test", la, b);
        } catch (c) {
        }
        return a;
      }();
      function G(a, b) {
        this.type = a;
        this.b = this.target = b;
        this.defaultPrevented = false;
      }
      G.prototype.preventDefault = function() {
        this.defaultPrevented = true;
      };
      function bd(a, b) {
        G.call(this, a ? a.type : "");
        this.relatedTarget = this.b = this.target = null;
        this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
        this.key = "";
        this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
        this.pointerId = 0;
        this.pointerType = "";
        this.a = null;
        if (a) {
          var c = this.type = a.type, d2 = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
          this.target = a.target || a.srcElement;
          this.b = b;
          if (b = a.relatedTarget) {
            if (Zb) {
              a: {
                try {
                  Sb(b.nodeName);
                  var e = true;
                  break a;
                } catch (f) {
                }
                e = false;
              }
              e || (b = null);
            }
          } else
            c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
          this.relatedTarget = b;
          d2 ? (this.clientX = d2.clientX !== void 0 ? d2.clientX : d2.pageX, this.clientY = d2.clientY !== void 0 ? d2.clientY : d2.pageY, this.screenX = d2.screenX || 0, this.screenY = d2.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
          this.button = a.button;
          this.key = a.key || "";
          this.ctrlKey = a.ctrlKey;
          this.altKey = a.altKey;
          this.shiftKey = a.shiftKey;
          this.metaKey = a.metaKey;
          this.pointerId = a.pointerId || 0;
          this.pointerType = typeof a.pointerType === "string" ? a.pointerType : cd[a.pointerType] || "";
          this.a = a;
          a.defaultPrevented && this.preventDefault();
        }
      }
      r(bd, G);
      var cd = Yc({ 2: "touch", 3: "pen", 4: "mouse" });
      bd.prototype.preventDefault = function() {
        bd.bb.preventDefault.call(this);
        var a = this.a;
        if (a.preventDefault)
          a.preventDefault();
        else if (a.returnValue = false, $c)
          try {
            if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode)
              a.keyCode = -1;
          } catch (b) {
          }
      };
      bd.prototype.g = function() {
        return this.a;
      };
      var dd = "closure_listenable_" + (1e6 * Math.random() | 0), ed = 0;
      function fd(a, b, c, d2, e) {
        this.listener = a;
        this.proxy = null;
        this.src = b;
        this.type = c;
        this.capture = !!d2;
        this.Wa = e;
        this.key = ++ed;
        this.wa = this.Qa = false;
      }
      function gd(a) {
        a.wa = true;
        a.listener = null;
        a.proxy = null;
        a.src = null;
        a.Wa = null;
      }
      ;
      function hd(a) {
        this.src = a;
        this.a = {};
        this.b = 0;
      }
      hd.prototype.add = function(a, b, c, d2, e) {
        var f = a.toString();
        a = this.a[f];
        a || (a = this.a[f] = [], this.b++);
        var g = id(a, b, d2, e);
        -1 < g ? (b = a[g], c || (b.Qa = false)) : (b = new fd(b, this.src, f, !!d2, e), b.Qa = c, a.push(b));
        return b;
      };
      function jd(a, b) {
        var c = b.type;
        c in a.a && Wa(a.a[c], b) && (gd(b), a.a[c].length == 0 && (delete a.a[c], a.b--));
      }
      function id(a, b, c, d2) {
        for (var e = 0; e < a.length; ++e) {
          var f = a[e];
          if (!f.wa && f.listener == b && f.capture == !!c && f.Wa == d2)
            return e;
        }
        return -1;
      }
      ;
      var kd = "closure_lm_" + (1e6 * Math.random() | 0), ld = {}, md = 0;
      function nd(a, b, c, d2, e) {
        if (d2 && d2.once)
          od(a, b, c, d2, e);
        else if (Array.isArray(b))
          for (var f = 0; f < b.length; f++)
            nd(a, b[f], c, d2, e);
        else
          c = pd(c), a && a[dd] ? qd(a, b, c, n(d2) ? !!d2.capture : !!d2, e) : rd(a, b, c, false, d2, e);
      }
      function rd(a, b, c, d2, e, f) {
        if (!b)
          throw Error("Invalid event type");
        var g = n(e) ? !!e.capture : !!e, h = sd(a);
        h || (a[kd] = h = new hd(a));
        c = h.add(b, c, d2, g, f);
        if (!c.proxy) {
          d2 = td();
          c.proxy = d2;
          d2.src = a;
          d2.listener = c;
          if (a.addEventListener)
            ad || (e = g), e === void 0 && (e = false), a.addEventListener(b.toString(), d2, e);
          else if (a.attachEvent)
            a.attachEvent(ud(b.toString()), d2);
          else if (a.addListener && a.removeListener)
            a.addListener(d2);
          else
            throw Error("addEventListener and attachEvent are unavailable.");
          md++;
        }
      }
      function td() {
        var a = vd, b = Zc ? function(c) {
          return a.call(b.src, b.listener, c);
        } : function(c) {
          c = a.call(b.src, b.listener, c);
          if (!c)
            return c;
        };
        return b;
      }
      function od(a, b, c, d2, e) {
        if (Array.isArray(b))
          for (var f = 0; f < b.length; f++)
            od(a, b[f], c, d2, e);
        else
          c = pd(c), a && a[dd] ? wd(a, b, c, n(d2) ? !!d2.capture : !!d2, e) : rd(a, b, c, true, d2, e);
      }
      function xd(a, b, c, d2, e) {
        if (Array.isArray(b))
          for (var f = 0; f < b.length; f++)
            xd(a, b[f], c, d2, e);
        else
          (d2 = n(d2) ? !!d2.capture : !!d2, c = pd(c), a && a[dd]) ? (a = a.v, b = String(b).toString(), b in a.a && (f = a.a[b], c = id(f, c, d2, e), -1 < c && (gd(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.a[b], a.b--)))) : a && (a = sd(a)) && (b = a.a[b.toString()], a = -1, b && (a = id(b, c, d2, e)), (c = -1 < a ? b[a] : null) && yd(c));
      }
      function yd(a) {
        if (typeof a !== "number" && a && !a.wa) {
          var b = a.src;
          if (b && b[dd])
            jd(b.v, a);
          else {
            var c = a.type, d2 = a.proxy;
            b.removeEventListener ? b.removeEventListener(c, d2, a.capture) : b.detachEvent ? b.detachEvent(ud(c), d2) : b.addListener && b.removeListener && b.removeListener(d2);
            md--;
            (c = sd(b)) ? (jd(c, a), c.b == 0 && (c.src = null, b[kd] = null)) : gd(a);
          }
        }
      }
      function ud(a) {
        return a in ld ? ld[a] : ld[a] = "on" + a;
      }
      function zd(a, b, c, d2) {
        var e = true;
        if (a = sd(a)) {
          if (b = a.a[b.toString()])
            for (b = b.concat(), a = 0; a < b.length; a++) {
              var f = b[a];
              f && f.capture == c && !f.wa && (f = Bd(f, d2), e = e && f !== false);
            }
        }
        return e;
      }
      function Bd(a, b) {
        var c = a.listener, d2 = a.Wa || a.src;
        a.Qa && yd(a);
        return c.call(d2, b);
      }
      function vd(a, b) {
        if (a.wa)
          return true;
        if (!Zc) {
          if (!b)
            a: {
              b = ["window", "event"];
              for (var c = l, d2 = 0; d2 < b.length; d2++)
                if (c = c[b[d2]], c == null) {
                  b = null;
                  break a;
                }
              b = c;
            }
          d2 = b;
          b = new bd(d2, this);
          c = true;
          if (!(0 > d2.keyCode || d2.returnValue != void 0)) {
            a: {
              var e = false;
              if (d2.keyCode == 0)
                try {
                  d2.keyCode = -1;
                  break a;
                } catch (g) {
                  e = true;
                }
              if (e || d2.returnValue == void 0)
                d2.returnValue = true;
            }
            d2 = [];
            for (e = b.b; e; e = e.parentNode)
              d2.push(e);
            a = a.type;
            for (e = d2.length - 1; 0 <= e; e--) {
              b.b = d2[e];
              var f = zd(d2[e], a, true, b);
              c = c && f;
            }
            for (e = 0; e < d2.length; e++)
              b.b = d2[e], f = zd(d2[e], a, false, b), c = c && f;
          }
          return c;
        }
        return Bd(a, new bd(b, this));
      }
      function sd(a) {
        a = a[kd];
        return a instanceof hd ? a : null;
      }
      var Cd = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
      function pd(a) {
        if (oa(a))
          return a;
        a[Cd] || (a[Cd] = function(b) {
          return a.handleEvent(b);
        });
        return a[Cd];
      }
      ;
      function H() {
        Uc.call(this);
        this.v = new hd(this);
        this.bc = this;
        this.hb = null;
      }
      r(H, Uc);
      H.prototype[dd] = true;
      H.prototype.addEventListener = function(a, b, c, d2) {
        nd(this, a, b, c, d2);
      };
      H.prototype.removeEventListener = function(a, b, c, d2) {
        xd(this, a, b, c, d2);
      };
      H.prototype.dispatchEvent = function(a) {
        var b, c = this.hb;
        if (c)
          for (b = []; c; c = c.hb)
            b.push(c);
        c = this.bc;
        var d2 = a.type || a;
        if (typeof a === "string")
          a = new G(a, c);
        else if (a instanceof G)
          a.target = a.target || c;
        else {
          var e = a;
          a = new G(d2, c);
          z(a, e);
        }
        e = true;
        if (b)
          for (var f = b.length - 1; 0 <= f; f--) {
            var g = a.b = b[f];
            e = Dd(g, d2, true, a) && e;
          }
        g = a.b = c;
        e = Dd(g, d2, true, a) && e;
        e = Dd(g, d2, false, a) && e;
        if (b)
          for (f = 0; f < b.length; f++)
            g = a.b = b[f], e = Dd(g, d2, false, a) && e;
        return e;
      };
      H.prototype.Da = function() {
        H.bb.Da.call(this);
        if (this.v) {
          var a = this.v, b = 0, c;
          for (c in a.a) {
            for (var d2 = a.a[c], e = 0; e < d2.length; e++)
              ++b, gd(d2[e]);
            delete a.a[c];
            a.b--;
          }
        }
        this.hb = null;
      };
      function qd(a, b, c, d2, e) {
        a.v.add(String(b), c, false, d2, e);
      }
      function wd(a, b, c, d2, e) {
        a.v.add(String(b), c, true, d2, e);
      }
      function Dd(a, b, c, d2) {
        b = a.v.a[String(b)];
        if (!b)
          return true;
        b = b.concat();
        for (var e = true, f = 0; f < b.length; ++f) {
          var g = b[f];
          if (g && !g.wa && g.capture == c) {
            var h = g.listener, m = g.Wa || g.src;
            g.Qa && jd(a.v, g);
            e = h.call(m, d2) !== false && e;
          }
        }
        return e && !d2.defaultPrevented;
      }
      ;
      function Ed(a, b, c) {
        if (oa(a))
          c && (a = q(a, c));
        else if (a && typeof a.handleEvent == "function")
          a = q(a.handleEvent, a);
        else
          throw Error("Invalid listener argument");
        return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
      }
      function Fd(a) {
        var b = null;
        return new D(function(c, d2) {
          b = Ed(function() {
            c(void 0);
          }, a);
          b == -1 && d2(Error("Failed to schedule timer."));
        }).o(function(c) {
          l.clearTimeout(b);
          throw c;
        });
      }
      ;
      function Gd(a) {
        if (a.X && typeof a.X == "function")
          return a.X();
        if (typeof a === "string")
          return a.split("");
        if (na(a)) {
          for (var b = [], c = a.length, d2 = 0; d2 < c; d2++)
            b.push(a[d2]);
          return b;
        }
        b = [];
        c = 0;
        for (d2 in a)
          b[c++] = a[d2];
        return b;
      }
      function Hd(a) {
        if (a.Y && typeof a.Y == "function")
          return a.Y();
        if (!a.X || typeof a.X != "function") {
          if (na(a) || typeof a === "string") {
            var b = [];
            a = a.length;
            for (var c = 0; c < a; c++)
              b.push(c);
            return b;
          }
          b = [];
          c = 0;
          for (var d2 in a)
            b[c++] = d2;
          return b;
        }
      }
      function Id(a, b) {
        if (a.forEach && typeof a.forEach == "function")
          a.forEach(b, void 0);
        else if (na(a) || typeof a === "string")
          w(a, b, void 0);
        else
          for (var c = Hd(a), d2 = Gd(a), e = d2.length, f = 0; f < e; f++)
            b.call(void 0, d2[f], c && c[f], a);
      }
      ;
      function Jd(a, b) {
        this.b = {};
        this.a = [];
        this.c = 0;
        var c = arguments.length;
        if (1 < c) {
          if (c % 2)
            throw Error("Uneven number of arguments");
          for (var d2 = 0; d2 < c; d2 += 2)
            this.set(arguments[d2], arguments[d2 + 1]);
        } else if (a)
          if (a instanceof Jd)
            for (c = a.Y(), d2 = 0; d2 < c.length; d2++)
              this.set(c[d2], a.get(c[d2]));
          else
            for (d2 in a)
              this.set(d2, a[d2]);
      }
      k = Jd.prototype;
      k.X = function() {
        Kd(this);
        for (var a = [], b = 0; b < this.a.length; b++)
          a.push(this.b[this.a[b]]);
        return a;
      };
      k.Y = function() {
        Kd(this);
        return this.a.concat();
      };
      k.clear = function() {
        this.b = {};
        this.c = this.a.length = 0;
      };
      function Kd(a) {
        if (a.c != a.a.length) {
          for (var b = 0, c = 0; b < a.a.length; ) {
            var d2 = a.a[b];
            Ld(a.b, d2) && (a.a[c++] = d2);
            b++;
          }
          a.a.length = c;
        }
        if (a.c != a.a.length) {
          var e = {};
          for (c = b = 0; b < a.a.length; )
            d2 = a.a[b], Ld(e, d2) || (a.a[c++] = d2, e[d2] = 1), b++;
          a.a.length = c;
        }
      }
      k.get = function(a, b) {
        return Ld(this.b, a) ? this.b[a] : b;
      };
      k.set = function(a, b) {
        Ld(this.b, a) || (this.c++, this.a.push(a));
        this.b[a] = b;
      };
      k.forEach = function(a, b) {
        for (var c = this.Y(), d2 = 0; d2 < c.length; d2++) {
          var e = c[d2], f = this.get(e);
          a.call(b, f, e, this);
        }
      };
      function Ld(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      ;
      var Md = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
      function Nd(a, b) {
        if (a) {
          a = a.split("&");
          for (var c = 0; c < a.length; c++) {
            var d2 = a[c].indexOf("="), e = null;
            if (0 <= d2) {
              var f = a[c].substring(0, d2);
              e = a[c].substring(d2 + 1);
            } else
              f = a[c];
            b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
          }
        }
      }
      ;
      function Od(a, b) {
        this.a = this.l = this.c = "";
        this.g = null;
        this.h = this.f = "";
        this.i = false;
        var c;
        a instanceof Od ? (this.i = b !== void 0 ? b : a.i, Pd(this, a.c), this.l = a.l, this.a = a.a, Qd(this, a.g), this.f = a.f, Rd(this, Sd(a.b)), this.h = a.h) : a && (c = String(a).match(Md)) ? (this.i = !!b, Pd(this, c[1] || "", true), this.l = Td(c[2] || ""), this.a = Td(c[3] || "", true), Qd(this, c[4]), this.f = Td(c[5] || "", true), Rd(this, c[6] || "", true), this.h = Td(c[7] || "")) : (this.i = !!b, this.b = new Ud(null, this.i));
      }
      Od.prototype.toString = function() {
        var a = [], b = this.c;
        b && a.push(Vd(b, Wd, true), ":");
        var c = this.a;
        if (c || b == "file")
          a.push("//"), (b = this.l) && a.push(Vd(b, Wd, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.g, c != null && a.push(":", String(c));
        if (c = this.f)
          this.a && c.charAt(0) != "/" && a.push("/"), a.push(Vd(c, c.charAt(0) == "/" ? Xd : Yd, true));
        (c = this.b.toString()) && a.push("?", c);
        (c = this.h) && a.push("#", Vd(c, Zd));
        return a.join("");
      };
      Od.prototype.resolve = function(a) {
        var b = new Od(this), c = !!a.c;
        c ? Pd(b, a.c) : c = !!a.l;
        c ? b.l = a.l : c = !!a.a;
        c ? b.a = a.a : c = a.g != null;
        var d2 = a.f;
        if (c)
          Qd(b, a.g);
        else if (c = !!a.f) {
          if (d2.charAt(0) != "/")
            if (this.a && !this.f)
              d2 = "/" + d2;
            else {
              var e = b.f.lastIndexOf("/");
              e != -1 && (d2 = b.f.substr(0, e + 1) + d2);
            }
          e = d2;
          if (e == ".." || e == ".")
            d2 = "";
          else if (x(e, "./") || x(e, "/.")) {
            d2 = e.lastIndexOf("/", 0) == 0;
            e = e.split("/");
            for (var f = [], g = 0; g < e.length; ) {
              var h = e[g++];
              h == "." ? d2 && g == e.length && f.push("") : h == ".." ? ((1 < f.length || f.length == 1 && f[0] != "") && f.pop(), d2 && g == e.length && f.push("")) : (f.push(h), d2 = true);
            }
            d2 = f.join("/");
          } else
            d2 = e;
        }
        c ? b.f = d2 : c = a.b.toString() !== "";
        c ? Rd(b, Sd(a.b)) : c = !!a.h;
        c && (b.h = a.h);
        return b;
      };
      function Pd(a, b, c) {
        a.c = c ? Td(b, true) : b;
        a.c && (a.c = a.c.replace(/:$/, ""));
      }
      function Qd(a, b) {
        if (b) {
          b = Number(b);
          if (isNaN(b) || 0 > b)
            throw Error("Bad port number " + b);
          a.g = b;
        } else
          a.g = null;
      }
      function Rd(a, b, c) {
        b instanceof Ud ? (a.b = b, $d(a.b, a.i)) : (c || (b = Vd(b, ae)), a.b = new Ud(b, a.i));
      }
      function I(a, b, c) {
        a.b.set(b, c);
      }
      function be(a, b) {
        return a.b.get(b);
      }
      function J(a) {
        return a instanceof Od ? new Od(a) : new Od(a, void 0);
      }
      function ce(a, b, c, d2) {
        var e = new Od(null, void 0);
        a && Pd(e, a);
        b && (e.a = b);
        c && Qd(e, c);
        d2 && (e.f = d2);
        return e;
      }
      function Td(a, b) {
        return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
      }
      function Vd(a, b, c) {
        return typeof a === "string" ? (a = encodeURI(a).replace(b, de), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
      }
      function de(a) {
        a = a.charCodeAt(0);
        return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
      }
      var Wd = /[#\/\?@]/g, Yd = /[#\?:]/g, Xd = /[#\?]/g, ae = /[#\?@]/g, Zd = /#/g;
      function Ud(a, b) {
        this.b = this.a = null;
        this.c = a || null;
        this.f = !!b;
      }
      function ee(a) {
        a.a || (a.a = new Jd(), a.b = 0, a.c && Nd(a.c, function(b, c) {
          a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
        }));
      }
      function fe(a) {
        var b = Hd(a);
        if (typeof b == "undefined")
          throw Error("Keys are undefined");
        var c = new Ud(null, void 0);
        a = Gd(a);
        for (var d2 = 0; d2 < b.length; d2++) {
          var e = b[d2], f = a[d2];
          Array.isArray(f) ? ge(c, e, f) : c.add(e, f);
        }
        return c;
      }
      k = Ud.prototype;
      k.add = function(a, b) {
        ee(this);
        this.c = null;
        a = he(this, a);
        var c = this.a.get(a);
        c || this.a.set(a, c = []);
        c.push(b);
        this.b += 1;
        return this;
      };
      function ie(a, b) {
        ee(a);
        b = he(a, b);
        Ld(a.a.b, b) && (a.c = null, a.b -= a.a.get(b).length, a = a.a, Ld(a.b, b) && (delete a.b[b], a.c--, a.a.length > 2 * a.c && Kd(a)));
      }
      k.clear = function() {
        this.a = this.c = null;
        this.b = 0;
      };
      function je(a, b) {
        ee(a);
        b = he(a, b);
        return Ld(a.a.b, b);
      }
      k.forEach = function(a, b) {
        ee(this);
        this.a.forEach(function(c, d2) {
          w(c, function(e) {
            a.call(b, e, d2, this);
          }, this);
        }, this);
      };
      k.Y = function() {
        ee(this);
        for (var a = this.a.X(), b = this.a.Y(), c = [], d2 = 0; d2 < b.length; d2++)
          for (var e = a[d2], f = 0; f < e.length; f++)
            c.push(b[d2]);
        return c;
      };
      k.X = function(a) {
        ee(this);
        var b = [];
        if (typeof a === "string")
          je(this, a) && (b = Ya(b, this.a.get(he(this, a))));
        else {
          a = this.a.X();
          for (var c = 0; c < a.length; c++)
            b = Ya(b, a[c]);
        }
        return b;
      };
      k.set = function(a, b) {
        ee(this);
        this.c = null;
        a = he(this, a);
        je(this, a) && (this.b -= this.a.get(a).length);
        this.a.set(a, [b]);
        this.b += 1;
        return this;
      };
      k.get = function(a, b) {
        if (!a)
          return b;
        a = this.X(a);
        return 0 < a.length ? String(a[0]) : b;
      };
      function ge(a, b, c) {
        ie(a, b);
        0 < c.length && (a.c = null, a.a.set(he(a, b), Za(c)), a.b += c.length);
      }
      k.toString = function() {
        if (this.c)
          return this.c;
        if (!this.a)
          return "";
        for (var a = [], b = this.a.Y(), c = 0; c < b.length; c++) {
          var d2 = b[c], e = encodeURIComponent(String(d2));
          d2 = this.X(d2);
          for (var f = 0; f < d2.length; f++) {
            var g = e;
            d2[f] !== "" && (g += "=" + encodeURIComponent(String(d2[f])));
            a.push(g);
          }
        }
        return this.c = a.join("&");
      };
      function Sd(a) {
        var b = new Ud();
        b.c = a.c;
        a.a && (b.a = new Jd(a.a), b.b = a.b);
        return b;
      }
      function he(a, b) {
        b = String(b);
        a.f && (b = b.toLowerCase());
        return b;
      }
      function $d(a, b) {
        b && !a.f && (ee(a), a.c = null, a.a.forEach(function(c, d2) {
          var e = d2.toLowerCase();
          d2 != e && (ie(this, d2), ge(this, e, c));
        }, a));
        a.f = b;
      }
      ;
      function ke(a) {
        var b = [];
        le(new me(), a, b);
        return b.join("");
      }
      function me() {
      }
      function le(a, b, c) {
        if (b == null)
          c.push("null");
        else {
          if (typeof b == "object") {
            if (Array.isArray(b)) {
              var d2 = b;
              b = d2.length;
              c.push("[");
              for (var e = "", f = 0; f < b; f++)
                c.push(e), le(a, d2[f], c), e = ",";
              c.push("]");
              return;
            }
            if (b instanceof String || b instanceof Number || b instanceof Boolean)
              b = b.valueOf();
            else {
              c.push("{");
              e = "";
              for (d2 in b)
                Object.prototype.hasOwnProperty.call(b, d2) && (f = b[d2], typeof f != "function" && (c.push(e), ne(d2, c), c.push(":"), le(a, f, c), e = ","));
              c.push("}");
              return;
            }
          }
          switch (typeof b) {
            case "string":
              ne(b, c);
              break;
            case "number":
              c.push(isFinite(b) && !isNaN(b) ? String(b) : "null");
              break;
            case "boolean":
              c.push(String(b));
              break;
            case "function":
              c.push("null");
              break;
            default:
              throw Error("Unknown type: " + typeof b);
          }
        }
      }
      var oe = { '"': '\\"', "\\": "\\\\", "/": "\\/", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\u000b" }, pe = /\uffff/.test("\uFFFF") ? /[\\"\x00-\x1f\x7f-\uffff]/g : /[\\"\x00-\x1f\x7f-\xff]/g;
      function ne(a, b) {
        b.push('"', a.replace(pe, function(c) {
          var d2 = oe[c];
          d2 || (d2 = "\\u" + (c.charCodeAt(0) | 65536).toString(16).substr(1), oe[c] = d2);
          return d2;
        }), '"');
      }
      ;
      function qe() {
        var a = K();
        return Wb && !!ic && ic == 11 || /Edge\/\d+/.test(a);
      }
      function re() {
        return l.window && l.window.location.href || self && self.location && self.location.href || "";
      }
      function se(a, b) {
        b = b || l.window;
        var c = "about:blank";
        a && (c = Eb(Ib(a) || Kb));
        b.location.href = c;
      }
      function te(a, b) {
        var c = [], d2;
        for (d2 in a)
          d2 in b ? typeof a[d2] != typeof b[d2] ? c.push(d2) : typeof a[d2] == "object" && a[d2] != null && b[d2] != null ? 0 < te(a[d2], b[d2]).length && c.push(d2) : a[d2] !== b[d2] && c.push(d2) : c.push(d2);
        for (d2 in b)
          d2 in a || c.push(d2);
        return c;
      }
      function ue() {
        var a = K();
        a = ve(a) != we ? null : (a = a.match(/\sChrome\/(\d+)/i)) && a.length == 2 ? parseInt(a[1], 10) : null;
        return a && 30 > a ? false : !Wb || !ic || 9 < ic;
      }
      function xe(a) {
        a = (a || K()).toLowerCase();
        return a.match(/android/) || a.match(/webos/) || a.match(/iphone|ipad|ipod/) || a.match(/blackberry/) || a.match(/windows phone/) || a.match(/iemobile/) ? true : false;
      }
      function ye(a) {
        a = a || l.window;
        try {
          a.close();
        } catch (b) {
        }
      }
      function ze(a, b, c) {
        var d2 = Math.floor(1e9 * Math.random()).toString();
        b = b || 500;
        c = c || 600;
        var e = (window.screen.availHeight - c) / 2, f = (window.screen.availWidth - b) / 2;
        b = { width: b, height: c, top: 0 < e ? e : 0, left: 0 < f ? f : 0, location: true, resizable: true, statusbar: true, toolbar: false };
        c = K().toLowerCase();
        d2 && (b.target = d2, x(c, "crios/") && (b.target = "_blank"));
        ve(K()) == Ae && (a = a || "http://localhost", b.scrollbars = true);
        c = a || "";
        (a = b) || (a = {});
        d2 = window;
        b = c instanceof C ? c : Ib(typeof c.href != "undefined" ? c.href : String(c)) || Kb;
        c = a.target || c.target;
        e = [];
        for (g in a)
          switch (g) {
            case "width":
            case "height":
            case "top":
            case "left":
              e.push(g + "=" + a[g]);
              break;
            case "target":
            case "noopener":
            case "noreferrer":
              break;
            default:
              e.push(g + "=" + (a[g] ? 1 : 0));
          }
        var g = e.join(",");
        if ((y("iPhone") && !y("iPod") && !y("iPad") || y("iPad") || y("iPod")) && d2.navigator && d2.navigator.standalone && c && c != "_self")
          g = oc(document, "A"), pb(g, "HTMLAnchorElement"), b = b instanceof C ? b : Jb(b), g.href = Eb(b), g.setAttribute("target", c), a.noreferrer && g.setAttribute("rel", "noreferrer"), a = document.createEvent("MouseEvent"), a.initMouseEvent("click", true, true, d2, 1), g.dispatchEvent(a), g = {};
        else if (a.noreferrer) {
          if (g = Pb("", d2, c, g), a = Eb(b), g && (Yb && x(a, ";") && (a = "'" + a.replace(/'/g, "%27") + "'"), g.opener = null, a = '<meta name="referrer" content="no-referrer"><meta http-equiv="refresh" content="0; url=' + Rb(a) + '">', a = (d2 = vb()) ? d2.createHTML(a) : a, a = new Lb(a, null, Mb), d2 = g.document))
            d2.write(Nb(a)), d2.close();
        } else
          (g = Pb(b, d2, c, g)) && a.noopener && (g.opener = null);
        if (g)
          try {
            g.focus();
          } catch (h) {
          }
        return g;
      }
      function Be(a) {
        return new D(function(b) {
          function c() {
            Fd(2e3).then(function() {
              if (!a || a.closed)
                b();
              else
                return c();
            });
          }
          return c();
        });
      }
      var Ce = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, De = /^[^@]+@[^@]+$/;
      function Ee() {
        var a = null;
        return new D(function(b) {
          l.document.readyState == "complete" ? b() : (a = function() {
            b();
          }, od(window, "load", a));
        }).o(function(b) {
          xd(window, "load", a);
          throw b;
        });
      }
      function Fe() {
        return Ge(void 0) ? Ee().then(function() {
          return new D(function(a, b) {
            var c = l.document, d2 = setTimeout(function() {
              b(Error("Cordova framework is not ready."));
            }, 1e3);
            c.addEventListener("deviceready", function() {
              clearTimeout(d2);
              a();
            }, false);
          });
        }) : F(Error("Cordova must run in an Android or iOS file scheme."));
      }
      function Ge(a) {
        a = a || K();
        return !(He() !== "file:" && He() !== "ionic:" || !a.toLowerCase().match(/iphone|ipad|ipod|android/));
      }
      function Ie() {
        var a = l.window;
        try {
          return !(!a || a == a.top);
        } catch (b) {
          return false;
        }
      }
      function Je() {
        return typeof l.WorkerGlobalScope !== "undefined" && typeof l.importScripts === "function";
      }
      function Ke() {
        return firebase2.INTERNAL.hasOwnProperty("reactNative") ? "ReactNative" : firebase2.INTERNAL.hasOwnProperty("node") ? "Node" : Je() ? "Worker" : "Browser";
      }
      function Le() {
        var a = Ke();
        return a === "ReactNative" || a === "Node";
      }
      function Me() {
        for (var a = 50, b = []; 0 < a; )
          b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), a--;
        return b.join("");
      }
      var Ae = "Firefox", we = "Chrome";
      function ve(a) {
        var b = a.toLowerCase();
        if (x(b, "opera/") || x(b, "opr/") || x(b, "opios/"))
          return "Opera";
        if (x(b, "iemobile"))
          return "IEMobile";
        if (x(b, "msie") || x(b, "trident/"))
          return "IE";
        if (x(b, "edge/"))
          return "Edge";
        if (x(b, "firefox/"))
          return Ae;
        if (x(b, "silk/"))
          return "Silk";
        if (x(b, "blackberry"))
          return "Blackberry";
        if (x(b, "webos"))
          return "Webos";
        if (!x(b, "safari/") || x(b, "chrome/") || x(b, "crios/") || x(b, "android"))
          if (!x(b, "chrome/") && !x(b, "crios/") || x(b, "edge/")) {
            if (x(b, "android"))
              return "Android";
            if ((a = a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/)) && a.length == 2)
              return a[1];
          } else
            return we;
        else
          return "Safari";
        return "Other";
      }
      var Ne = { md: "FirebaseCore-web", od: "FirebaseUI-web" };
      function Oe(a, b) {
        b = b || [];
        var c = [], d2 = {}, e;
        for (e in Ne)
          d2[Ne[e]] = true;
        for (e = 0; e < b.length; e++)
          typeof d2[b[e]] !== "undefined" && (delete d2[b[e]], c.push(b[e]));
        c.sort();
        b = c;
        b.length || (b = ["FirebaseCore-web"]);
        c = Ke();
        c === "Browser" ? (d2 = K(), c = ve(d2)) : c === "Worker" && (d2 = K(), c = ve(d2) + "-" + c);
        return c + "/JsCore/" + a + "/" + b.join(",");
      }
      function K() {
        return l.navigator && l.navigator.userAgent || "";
      }
      function L(a, b) {
        a = a.split(".");
        b = b || l;
        for (var c = 0; c < a.length && typeof b == "object" && b != null; c++)
          b = b[a[c]];
        c != a.length && (b = void 0);
        return b;
      }
      function Pe() {
        try {
          var a = l.localStorage, b = Qe();
          if (a)
            return a.setItem(b, "1"), a.removeItem(b), qe() ? !!l.indexedDB : true;
        } catch (c) {
          return Je() && !!l.indexedDB;
        }
        return false;
      }
      function Re() {
        return (Se() || He() === "chrome-extension:" || Ge()) && !Le() && Pe() && !Je();
      }
      function Se() {
        return He() === "http:" || He() === "https:";
      }
      function He() {
        return l.location && l.location.protocol || null;
      }
      function Te(a) {
        a = a || K();
        return xe(a) || ve(a) == Ae ? false : true;
      }
      function Ue(a) {
        return typeof a === "undefined" ? null : ke(a);
      }
      function Ve(a) {
        var b = {}, c;
        for (c in a)
          a.hasOwnProperty(c) && a[c] !== null && a[c] !== void 0 && (b[c] = a[c]);
        return b;
      }
      function We(a) {
        if (a !== null)
          return JSON.parse(a);
      }
      function Qe(a) {
        return a ? a : Math.floor(1e9 * Math.random()).toString();
      }
      function Xe(a) {
        a = a || K();
        return ve(a) == "Safari" || a.toLowerCase().match(/iphone|ipad|ipod/) ? false : true;
      }
      function Ye() {
        var a = l.___jsl;
        if (a && a.H) {
          for (var b in a.H)
            if (a.H[b].r = a.H[b].r || [], a.H[b].L = a.H[b].L || [], a.H[b].r = a.H[b].L.concat(), a.CP)
              for (var c = 0; c < a.CP.length; c++)
                a.CP[c] = null;
        }
      }
      function Ze(a, b) {
        if (a > b)
          throw Error("Short delay should be less than long delay!");
        this.a = a;
        this.c = b;
        a = K();
        b = Ke();
        this.b = xe(a) || b === "ReactNative";
      }
      Ze.prototype.get = function() {
        var a = l.navigator;
        return (a && typeof a.onLine === "boolean" && (Se() || He() === "chrome-extension:" || typeof a.connection !== "undefined") ? a.onLine : 1) ? this.b ? this.c : this.a : Math.min(5e3, this.a);
      };
      function $e() {
        var a = l.document;
        return a && typeof a.visibilityState !== "undefined" ? a.visibilityState == "visible" : true;
      }
      function af() {
        var a = l.document, b = null;
        return $e() || !a ? E() : new D(function(c) {
          b = function() {
            $e() && (a.removeEventListener("visibilitychange", b, false), c());
          };
          a.addEventListener("visibilitychange", b, false);
        }).o(function(c) {
          a.removeEventListener("visibilitychange", b, false);
          throw c;
        });
      }
      function bf(a) {
        try {
          var b = new Date(parseInt(a, 10));
          if (!isNaN(b.getTime()) && !/[^0-9]/.test(a))
            return b.toUTCString();
        } catch (c) {
        }
        return null;
      }
      function cf() {
        return !(!L("fireauth.oauthhelper", l) && !L("fireauth.iframe", l));
      }
      function df() {
        var a = l.navigator;
        return a && a.serviceWorker && a.serviceWorker.controller || null;
      }
      function ef() {
        var a = l.navigator;
        return a && a.serviceWorker ? E().then(function() {
          return a.serviceWorker.ready;
        }).then(function(b) {
          return b.active || null;
        }).o(function() {
          return null;
        }) : E(null);
      }
      ;
      var ff = {};
      function gf(a) {
        ff[a] || (ff[a] = true, typeof console !== "undefined" && typeof console.warn === "function" && console.warn(a));
      }
      ;
      var hf;
      try {
        var jf = {};
        Object.defineProperty(jf, "abcd", { configurable: true, enumerable: true, value: 1 });
        Object.defineProperty(jf, "abcd", { configurable: true, enumerable: true, value: 2 });
        hf = jf.abcd == 2;
      } catch (a) {
        hf = false;
      }
      function M(a, b, c) {
        hf ? Object.defineProperty(a, b, { configurable: true, enumerable: true, value: c }) : a[b] = c;
      }
      function N(a, b) {
        if (b)
          for (var c in b)
            b.hasOwnProperty(c) && M(a, c, b[c]);
      }
      function kf(a) {
        var b = {};
        N(b, a);
        return b;
      }
      function lf(a) {
        var b = {}, c;
        for (c in a)
          a.hasOwnProperty(c) && (b[c] = a[c]);
        return b;
      }
      function mf(a, b) {
        if (!b || !b.length)
          return true;
        if (!a)
          return false;
        for (var c = 0; c < b.length; c++) {
          var d2 = a[b[c]];
          if (d2 === void 0 || d2 === null || d2 === "")
            return false;
        }
        return true;
      }
      function nf(a) {
        var b = a;
        if (typeof a == "object" && a != null) {
          b = "length" in a ? [] : {};
          for (var c in a)
            M(b, c, nf(a[c]));
        }
        return b;
      }
      ;
      function of(a) {
        var b = a && (a[pf] ? "phone" : null);
        if (b && a && a[qf]) {
          M(this, "uid", a[qf]);
          M(this, "displayName", a[rf] || null);
          var c = null;
          a[sf] && (c = new Date(a[sf]).toUTCString());
          M(this, "enrollmentTime", c);
          M(this, "factorId", b);
        } else
          throw new t("internal-error", "Internal assert: invalid MultiFactorInfo object");
      }
      of.prototype.w = function() {
        return { uid: this.uid, displayName: this.displayName, factorId: this.factorId, enrollmentTime: this.enrollmentTime };
      };
      function tf(a) {
        try {
          var b = new uf(a);
        } catch (c) {
          b = null;
        }
        return b;
      }
      var rf = "displayName", sf = "enrolledAt", qf = "mfaEnrollmentId", pf = "phoneInfo";
      function uf(a) {
        of.call(this, a);
        M(this, "phoneNumber", a[pf]);
      }
      r(uf, of);
      uf.prototype.w = function() {
        var a = uf.bb.w.call(this);
        a.phoneNumber = this.phoneNumber;
        return a;
      };
      function vf(a) {
        var b = {}, c = a[wf], d2 = a[xf], e = a[yf];
        a = tf(a[zf]);
        if (!e || e != Af && e != Bf && !c || e == Bf && !d2 || e == Cf && !a)
          throw Error("Invalid checkActionCode response!");
        e == Bf ? (b[Df] = c || null, b[Ef] = c || null, b[Ff] = d2) : (b[Df] = d2 || null, b[Ef] = d2 || null, b[Ff] = c || null);
        b[Gf] = a || null;
        M(this, Hf, e);
        M(this, If, nf(b));
      }
      var Cf = "REVERT_SECOND_FACTOR_ADDITION", Af = "EMAIL_SIGNIN", Bf = "VERIFY_AND_CHANGE_EMAIL", wf = "email", zf = "mfaInfo", xf = "newEmail", yf = "requestType", Ff = "email", Df = "fromEmail", Gf = "multiFactorInfo", Ef = "previousEmail", If = "data", Hf = "operation";
      function Jf(a) {
        a = J(a);
        var b = be(a, Kf) || null, c = be(a, Lf) || null, d2 = be(a, Mf) || null;
        d2 = d2 ? Nf[d2] || null : null;
        if (!b || !c || !d2)
          throw new t("argument-error", Kf + ", " + Lf + "and " + Mf + " are required in a valid action code URL.");
        N(this, { apiKey: b, operation: d2, code: c, continueUrl: be(a, Of) || null, languageCode: be(a, Pf) || null, tenantId: be(a, Qf) || null });
      }
      var Kf = "apiKey", Lf = "oobCode", Of = "continueUrl", Pf = "languageCode", Mf = "mode", Qf = "tenantId", Nf = { recoverEmail: "RECOVER_EMAIL", resetPassword: "PASSWORD_RESET", revertSecondFactorAddition: Cf, signIn: Af, verifyAndChangeEmail: Bf, verifyEmail: "VERIFY_EMAIL" };
      function Rf(a) {
        try {
          return new Jf(a);
        } catch (b) {
          return null;
        }
      }
      ;
      function Sf(a) {
        var b = a[Tf];
        if (typeof b === "undefined")
          throw new t("missing-continue-uri");
        if (typeof b !== "string" || typeof b === "string" && !b.length)
          throw new t("invalid-continue-uri");
        this.h = b;
        this.b = this.a = null;
        this.g = false;
        var c = a[Uf];
        if (c && typeof c === "object") {
          b = c[Vf];
          var d2 = c[Wf];
          c = c[Xf];
          if (typeof b === "string" && b.length) {
            this.a = b;
            if (typeof d2 !== "undefined" && typeof d2 !== "boolean")
              throw new t("argument-error", Wf + " property must be a boolean when specified.");
            this.g = !!d2;
            if (typeof c !== "undefined" && (typeof c !== "string" || typeof c === "string" && !c.length))
              throw new t("argument-error", Xf + " property must be a non empty string when specified.");
            this.b = c || null;
          } else {
            if (typeof b !== "undefined")
              throw new t("argument-error", Vf + " property must be a non empty string when specified.");
            if (typeof d2 !== "undefined" || typeof c !== "undefined")
              throw new t("missing-android-pkg-name");
          }
        } else if (typeof c !== "undefined")
          throw new t("argument-error", Uf + " property must be a non null object when specified.");
        this.f = null;
        if ((b = a[Yf]) && typeof b === "object")
          if (b = b[Zf], typeof b === "string" && b.length)
            this.f = b;
          else {
            if (typeof b !== "undefined")
              throw new t("argument-error", Zf + " property must be a non empty string when specified.");
          }
        else if (typeof b !== "undefined")
          throw new t("argument-error", Yf + " property must be a non null object when specified.");
        b = a[$f];
        if (typeof b !== "undefined" && typeof b !== "boolean")
          throw new t("argument-error", $f + " property must be a boolean when specified.");
        this.c = !!b;
        a = a[ag];
        if (typeof a !== "undefined" && (typeof a !== "string" || typeof a === "string" && !a.length))
          throw new t("argument-error", ag + " property must be a non empty string when specified.");
        this.i = a || null;
      }
      var Uf = "android", ag = "dynamicLinkDomain", $f = "handleCodeInApp", Yf = "iOS", Tf = "url", Wf = "installApp", Xf = "minimumVersion", Vf = "packageName", Zf = "bundleId";
      function bg(a) {
        var b = {};
        b.continueUrl = a.h;
        b.canHandleCodeInApp = a.c;
        if (b.androidPackageName = a.a)
          b.androidMinimumVersion = a.b, b.androidInstallApp = a.g;
        b.iOSBundleId = a.f;
        b.dynamicLinkDomain = a.i;
        for (var c in b)
          b[c] === null && delete b[c];
        return b;
      }
      ;
      function cg(a) {
        return Ra(a, function(b) {
          b = b.toString(16);
          return 1 < b.length ? b : "0" + b;
        }).join("");
      }
      ;
      var dg = null;
      function eg(a) {
        var b = [];
        fg(a, function(c) {
          b.push(c);
        });
        return b;
      }
      function fg(a, b) {
        function c(m) {
          for (; d2 < a.length; ) {
            var p = a.charAt(d2++), v = dg[p];
            if (v != null)
              return v;
            if (!/^[\s\xa0]*$/.test(p))
              throw Error("Unknown base64 encoding at char: " + p);
          }
          return m;
        }
        gg();
        for (var d2 = 0; ; ) {
          var e = c(-1), f = c(0), g = c(64), h = c(64);
          if (h === 64 && e === -1)
            break;
          b(e << 2 | f >> 4);
          g != 64 && (b(f << 4 & 240 | g >> 2), h != 64 && b(g << 6 & 192 | h));
        }
      }
      function gg() {
        if (!dg) {
          dg = {};
          for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b = ["+/=", "+/", "-_=", "-_.", "-_"], c = 0; 5 > c; c++)
            for (var d2 = a.concat(b[c].split("")), e = 0; e < d2.length; e++) {
              var f = d2[e];
              dg[f] === void 0 && (dg[f] = e);
            }
        }
      }
      ;
      function hg(a) {
        var b = ig(a);
        if (!(b && b.sub && b.iss && b.aud && b.exp))
          throw Error("Invalid JWT");
        this.h = a;
        this.a = b.exp;
        this.i = b.sub;
        a = Date.now() / 1e3;
        this.g = b.iat || (a > this.a ? this.a : a);
        this.b = b.provider_id || b.firebase && b.firebase.sign_in_provider || null;
        this.f = b.firebase && b.firebase.tenant || null;
        this.c = !!b.is_anonymous || this.b == "anonymous";
      }
      hg.prototype.T = function() {
        return this.f;
      };
      hg.prototype.l = function() {
        return this.c;
      };
      hg.prototype.toString = function() {
        return this.h;
      };
      function jg(a) {
        try {
          return new hg(a);
        } catch (b) {
          return null;
        }
      }
      function ig(a) {
        if (!a)
          return null;
        a = a.split(".");
        if (a.length != 3)
          return null;
        a = a[1];
        for (var b = (4 - a.length % 4) % 4, c = 0; c < b; c++)
          a += ".";
        try {
          var d2 = eg(a);
          a = [];
          for (c = b = 0; b < d2.length; ) {
            var e = d2[b++];
            if (128 > e)
              a[c++] = String.fromCharCode(e);
            else if (191 < e && 224 > e) {
              var f = d2[b++];
              a[c++] = String.fromCharCode((e & 31) << 6 | f & 63);
            } else if (239 < e && 365 > e) {
              f = d2[b++];
              var g = d2[b++], h = d2[b++], m = ((e & 7) << 18 | (f & 63) << 12 | (g & 63) << 6 | h & 63) - 65536;
              a[c++] = String.fromCharCode(55296 + (m >> 10));
              a[c++] = String.fromCharCode(56320 + (m & 1023));
            } else
              f = d2[b++], g = d2[b++], a[c++] = String.fromCharCode((e & 15) << 12 | (f & 63) << 6 | g & 63);
          }
          return JSON.parse(a.join(""));
        } catch (p) {
        }
        return null;
      }
      ;
      var kg = "oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version".split(" "), lg = ["client_id", "response_type", "scope", "redirect_uri", "state"], mg = { nd: { Ja: "locale", va: 700, ua: 600, fa: "facebook.com", Ya: lg }, pd: { Ja: null, va: 500, ua: 750, fa: "github.com", Ya: lg }, qd: { Ja: "hl", va: 515, ua: 680, fa: "google.com", Ya: lg }, wd: { Ja: "lang", va: 485, ua: 705, fa: "twitter.com", Ya: kg }, kd: { Ja: "locale", va: 640, ua: 600, fa: "apple.com", Ya: [] } };
      function ng(a) {
        for (var b in mg)
          if (mg[b].fa == a)
            return mg[b];
        return null;
      }
      ;
      function og(a) {
        var b = {};
        b["facebook.com"] = pg;
        b["google.com"] = qg;
        b["github.com"] = rg;
        b["twitter.com"] = sg;
        var c = a && a[tg];
        try {
          if (c)
            return b[c] ? new b[c](a) : new ug(a);
          if (typeof a[vg] !== "undefined")
            return new wg(a);
        } catch (d2) {
        }
        return null;
      }
      var vg = "idToken", tg = "providerId";
      function wg(a) {
        var b = a[tg];
        if (!b && a[vg]) {
          var c = jg(a[vg]);
          c && c.b && (b = c.b);
        }
        if (!b)
          throw Error("Invalid additional user info!");
        if (b == "anonymous" || b == "custom")
          b = null;
        c = false;
        typeof a.isNewUser !== "undefined" ? c = !!a.isNewUser : a.kind === "identitytoolkit#SignupNewUserResponse" && (c = true);
        M(this, "providerId", b);
        M(this, "isNewUser", c);
      }
      function ug(a) {
        wg.call(this, a);
        a = We(a.rawUserInfo || "{}");
        M(this, "profile", nf(a || {}));
      }
      r(ug, wg);
      function pg(a) {
        ug.call(this, a);
        if (this.providerId != "facebook.com")
          throw Error("Invalid provider ID!");
      }
      r(pg, ug);
      function rg(a) {
        ug.call(this, a);
        if (this.providerId != "github.com")
          throw Error("Invalid provider ID!");
        M(this, "username", this.profile && this.profile.login || null);
      }
      r(rg, ug);
      function qg(a) {
        ug.call(this, a);
        if (this.providerId != "google.com")
          throw Error("Invalid provider ID!");
      }
      r(qg, ug);
      function sg(a) {
        ug.call(this, a);
        if (this.providerId != "twitter.com")
          throw Error("Invalid provider ID!");
        M(this, "username", a.screenName || null);
      }
      r(sg, ug);
      function xg(a) {
        var b = J(a), c = be(b, "link"), d2 = be(J(c), "link");
        b = be(b, "deep_link_id");
        return be(J(b), "link") || b || d2 || c || a;
      }
      ;
      function yg(a, b) {
        if (!a && !b)
          throw new t("internal-error", "Internal assert: no raw session string available");
        if (a && b)
          throw new t("internal-error", "Internal assert: unable to determine the session type");
        this.a = a || null;
        this.b = b || null;
        this.type = this.a ? zg : Ag;
      }
      var zg = "enroll", Ag = "signin";
      yg.prototype.Ha = function() {
        return this.a ? E(this.a) : E(this.b);
      };
      yg.prototype.w = function() {
        return this.type == zg ? { multiFactorSession: { idToken: this.a } } : { multiFactorSession: { pendingCredential: this.b } };
      };
      function Bg() {
      }
      Bg.prototype.ka = function() {
      };
      Bg.prototype.b = function() {
      };
      Bg.prototype.c = function() {
      };
      Bg.prototype.w = function() {
      };
      function Cg(a, b) {
        return a.then(function(c) {
          if (c[Dg]) {
            var d2 = jg(c[Dg]);
            if (!d2 || b != d2.i)
              throw new t("user-mismatch");
            return c;
          }
          throw new t("user-mismatch");
        }).o(function(c) {
          throw c && c.code && c.code == xa + "user-not-found" ? new t("user-mismatch") : c;
        });
      }
      function Eg(a, b) {
        if (b)
          this.a = b;
        else
          throw new t("internal-error", "failed to construct a credential");
        M(this, "providerId", a);
        M(this, "signInMethod", a);
      }
      Eg.prototype.ka = function(a) {
        return Fg(a, Gg(this));
      };
      Eg.prototype.b = function(a, b) {
        var c = Gg(this);
        c.idToken = b;
        return Hg(a, c);
      };
      Eg.prototype.c = function(a, b) {
        return Cg(Ig(a, Gg(this)), b);
      };
      function Gg(a) {
        return { pendingToken: a.a, requestUri: "http://localhost" };
      }
      Eg.prototype.w = function() {
        return { providerId: this.providerId, signInMethod: this.signInMethod, pendingToken: this.a };
      };
      function Jg(a) {
        if (a && a.providerId && a.signInMethod && a.providerId.indexOf("saml.") == 0 && a.pendingToken)
          try {
            return new Eg(a.providerId, a.pendingToken);
          } catch (b) {
          }
        return null;
      }
      function Kg(a, b, c) {
        this.a = null;
        if (b.idToken || b.accessToken)
          b.idToken && M(this, "idToken", b.idToken), b.accessToken && M(this, "accessToken", b.accessToken), b.nonce && !b.pendingToken && M(this, "nonce", b.nonce), b.pendingToken && (this.a = b.pendingToken);
        else if (b.oauthToken && b.oauthTokenSecret)
          M(this, "accessToken", b.oauthToken), M(this, "secret", b.oauthTokenSecret);
        else
          throw new t("internal-error", "failed to construct a credential");
        M(this, "providerId", a);
        M(this, "signInMethod", c);
      }
      Kg.prototype.ka = function(a) {
        return Fg(a, Lg(this));
      };
      Kg.prototype.b = function(a, b) {
        var c = Lg(this);
        c.idToken = b;
        return Hg(a, c);
      };
      Kg.prototype.c = function(a, b) {
        var c = Lg(this);
        return Cg(Ig(a, c), b);
      };
      function Lg(a) {
        var b = {};
        a.idToken && (b.id_token = a.idToken);
        a.accessToken && (b.access_token = a.accessToken);
        a.secret && (b.oauth_token_secret = a.secret);
        b.providerId = a.providerId;
        a.nonce && !a.a && (b.nonce = a.nonce);
        b = { postBody: fe(b).toString(), requestUri: "http://localhost" };
        a.a && (delete b.postBody, b.pendingToken = a.a);
        return b;
      }
      Kg.prototype.w = function() {
        var a = { providerId: this.providerId, signInMethod: this.signInMethod };
        this.idToken && (a.oauthIdToken = this.idToken);
        this.accessToken && (a.oauthAccessToken = this.accessToken);
        this.secret && (a.oauthTokenSecret = this.secret);
        this.nonce && (a.nonce = this.nonce);
        this.a && (a.pendingToken = this.a);
        return a;
      };
      function Mg(a) {
        if (a && a.providerId && a.signInMethod) {
          var b = { idToken: a.oauthIdToken, accessToken: a.oauthTokenSecret ? null : a.oauthAccessToken, oauthTokenSecret: a.oauthTokenSecret, oauthToken: a.oauthTokenSecret && a.oauthAccessToken, nonce: a.nonce, pendingToken: a.pendingToken };
          try {
            return new Kg(a.providerId, b, a.signInMethod);
          } catch (c) {
          }
        }
        return null;
      }
      function Ng(a, b) {
        this.Qc = b || [];
        N(this, { providerId: a, isOAuthProvider: true });
        this.Jb = {};
        this.qb = (ng(a) || {}).Ja || null;
        this.pb = null;
      }
      Ng.prototype.Ka = function(a) {
        this.Jb = nb(a);
        return this;
      };
      function Og(a) {
        if (typeof a !== "string" || a.indexOf("saml.") != 0)
          throw new t("argument-error", 'SAML provider IDs must be prefixed with "saml."');
        Ng.call(this, a, []);
      }
      r(Og, Ng);
      function Pg(a) {
        Ng.call(this, a, lg);
        this.a = [];
      }
      r(Pg, Ng);
      Pg.prototype.Ca = function(a) {
        Va(this.a, a) || this.a.push(a);
        return this;
      };
      Pg.prototype.Rb = function() {
        return Za(this.a);
      };
      Pg.prototype.credential = function(a, b) {
        var c;
        n(a) ? c = { idToken: a.idToken || null, accessToken: a.accessToken || null, nonce: a.rawNonce || null } : c = { idToken: a || null, accessToken: b || null };
        if (!c.idToken && !c.accessToken)
          throw new t("argument-error", "credential failed: must provide the ID token and/or the access token.");
        return new Kg(this.providerId, c, this.providerId);
      };
      function Qg() {
        Pg.call(this, "facebook.com");
      }
      r(Qg, Pg);
      M(Qg, "PROVIDER_ID", "facebook.com");
      M(Qg, "FACEBOOK_SIGN_IN_METHOD", "facebook.com");
      function Rg(a) {
        if (!a)
          throw new t("argument-error", "credential failed: expected 1 argument (the OAuth access token).");
        var b = a;
        n(a) && (b = a.accessToken);
        return new Qg().credential({ accessToken: b });
      }
      function Sg() {
        Pg.call(this, "github.com");
      }
      r(Sg, Pg);
      M(Sg, "PROVIDER_ID", "github.com");
      M(Sg, "GITHUB_SIGN_IN_METHOD", "github.com");
      function Tg(a) {
        if (!a)
          throw new t("argument-error", "credential failed: expected 1 argument (the OAuth access token).");
        var b = a;
        n(a) && (b = a.accessToken);
        return new Sg().credential({ accessToken: b });
      }
      function Ug() {
        Pg.call(this, "google.com");
        this.Ca("profile");
      }
      r(Ug, Pg);
      M(Ug, "PROVIDER_ID", "google.com");
      M(Ug, "GOOGLE_SIGN_IN_METHOD", "google.com");
      function Vg(a, b) {
        var c = a;
        n(a) && (c = a.idToken, b = a.accessToken);
        return new Ug().credential({ idToken: c, accessToken: b });
      }
      function Wg() {
        Ng.call(this, "twitter.com", kg);
      }
      r(Wg, Ng);
      M(Wg, "PROVIDER_ID", "twitter.com");
      M(Wg, "TWITTER_SIGN_IN_METHOD", "twitter.com");
      function Xg(a, b) {
        var c = a;
        n(c) || (c = { oauthToken: a, oauthTokenSecret: b });
        if (!c.oauthToken || !c.oauthTokenSecret)
          throw new t("argument-error", "credential failed: expected 2 arguments (the OAuth access token and secret).");
        return new Kg("twitter.com", c, "twitter.com");
      }
      function Yg(a, b, c) {
        this.a = a;
        this.f = b;
        M(this, "providerId", "password");
        M(this, "signInMethod", c === Zg.EMAIL_LINK_SIGN_IN_METHOD ? Zg.EMAIL_LINK_SIGN_IN_METHOD : Zg.EMAIL_PASSWORD_SIGN_IN_METHOD);
      }
      Yg.prototype.ka = function(a) {
        return this.signInMethod == Zg.EMAIL_LINK_SIGN_IN_METHOD ? O(a, $g, { email: this.a, oobCode: this.f }) : O(a, ah, { email: this.a, password: this.f });
      };
      Yg.prototype.b = function(a, b) {
        return this.signInMethod == Zg.EMAIL_LINK_SIGN_IN_METHOD ? O(a, bh, { idToken: b, email: this.a, oobCode: this.f }) : O(a, ch, { idToken: b, email: this.a, password: this.f });
      };
      Yg.prototype.c = function(a, b) {
        return Cg(this.ka(a), b);
      };
      Yg.prototype.w = function() {
        return { email: this.a, password: this.f, signInMethod: this.signInMethod };
      };
      function dh(a) {
        return a && a.email && a.password ? new Yg(a.email, a.password, a.signInMethod) : null;
      }
      function Zg() {
        N(this, { providerId: "password", isOAuthProvider: false });
      }
      function eh(a, b) {
        b = fh(b);
        if (!b)
          throw new t("argument-error", "Invalid email link!");
        return new Yg(a, b.code, Zg.EMAIL_LINK_SIGN_IN_METHOD);
      }
      function fh(a) {
        a = xg(a);
        return (a = Rf(a)) && a.operation === Af ? a : null;
      }
      N(Zg, { PROVIDER_ID: "password" });
      N(Zg, { EMAIL_LINK_SIGN_IN_METHOD: "emailLink" });
      N(Zg, { EMAIL_PASSWORD_SIGN_IN_METHOD: "password" });
      function gh(a) {
        if (!(a.fb && a.eb || a.La && a.ea))
          throw new t("internal-error");
        this.a = a;
        M(this, "providerId", "phone");
        this.fa = "phone";
        M(this, "signInMethod", "phone");
      }
      gh.prototype.ka = function(a) {
        return a.gb(hh(this));
      };
      gh.prototype.b = function(a, b) {
        var c = hh(this);
        c.idToken = b;
        return O(a, ih, c);
      };
      gh.prototype.c = function(a, b) {
        var c = hh(this);
        c.operation = "REAUTH";
        a = O(a, jh, c);
        return Cg(a, b);
      };
      gh.prototype.w = function() {
        var a = { providerId: "phone" };
        this.a.fb && (a.verificationId = this.a.fb);
        this.a.eb && (a.verificationCode = this.a.eb);
        this.a.La && (a.temporaryProof = this.a.La);
        this.a.ea && (a.phoneNumber = this.a.ea);
        return a;
      };
      function kh(a) {
        if (a && a.providerId === "phone" && (a.verificationId && a.verificationCode || a.temporaryProof && a.phoneNumber)) {
          var b = {};
          w(["verificationId", "verificationCode", "temporaryProof", "phoneNumber"], function(c) {
            a[c] && (b[c] = a[c]);
          });
          return new gh(b);
        }
        return null;
      }
      function hh(a) {
        return a.a.La && a.a.ea ? { temporaryProof: a.a.La, phoneNumber: a.a.ea } : { sessionInfo: a.a.fb, code: a.a.eb };
      }
      function lh(a) {
        try {
          this.a = a || firebase2.auth();
        } catch (b) {
          throw new t("argument-error", "Either an instance of firebase.auth.Auth must be passed as an argument to the firebase.auth.PhoneAuthProvider constructor, or the default firebase App instance must be initialized via firebase.initializeApp().");
        }
        N(this, { providerId: "phone", isOAuthProvider: false });
      }
      lh.prototype.gb = function(a, b) {
        var c = this.a.a;
        return E(b.verify()).then(function(d2) {
          if (typeof d2 !== "string")
            throw new t("argument-error", "An implementation of firebase.auth.ApplicationVerifier.prototype.verify() must return a firebase.Promise that resolves with a string.");
          switch (b.type) {
            case "recaptcha":
              var e = n(a) ? a.session : null, f = n(a) ? a.phoneNumber : a, g;
              e && e.type == zg ? g = e.Ha().then(function(h) {
                return mh(c, { idToken: h, phoneEnrollmentInfo: { phoneNumber: f, recaptchaToken: d2 } });
              }) : e && e.type == Ag ? g = e.Ha().then(function(h) {
                return nh(c, { mfaPendingCredential: h, mfaEnrollmentId: a.multiFactorHint && a.multiFactorHint.uid || a.multiFactorUid, phoneSignInInfo: { recaptchaToken: d2 } });
              }) : g = oh(c, { phoneNumber: f, recaptchaToken: d2 });
              return g.then(function(h) {
                typeof b.reset === "function" && b.reset();
                return h;
              }, function(h) {
                typeof b.reset === "function" && b.reset();
                throw h;
              });
            default:
              throw new t("argument-error", 'Only firebase.auth.ApplicationVerifiers with type="recaptcha" are currently supported.');
          }
        });
      };
      function ph(a, b) {
        if (!a)
          throw new t("missing-verification-id");
        if (!b)
          throw new t("missing-verification-code");
        return new gh({ fb: a, eb: b });
      }
      N(lh, { PROVIDER_ID: "phone" });
      N(lh, { PHONE_SIGN_IN_METHOD: "phone" });
      function qh(a) {
        if (a.temporaryProof && a.phoneNumber)
          return new gh({ La: a.temporaryProof, ea: a.phoneNumber });
        var b = a && a.providerId;
        if (!b || b === "password")
          return null;
        var c = a && a.oauthAccessToken, d2 = a && a.oauthTokenSecret, e = a && a.nonce, f = a && a.oauthIdToken, g = a && a.pendingToken;
        try {
          switch (b) {
            case "google.com":
              return Vg(f, c);
            case "facebook.com":
              return Rg(c);
            case "github.com":
              return Tg(c);
            case "twitter.com":
              return Xg(c, d2);
            default:
              return c || d2 || f || g ? g ? b.indexOf("saml.") == 0 ? new Eg(b, g) : new Kg(b, {
                pendingToken: g,
                idToken: a.oauthIdToken,
                accessToken: a.oauthAccessToken
              }, b) : new Pg(b).credential({ idToken: f, accessToken: c, rawNonce: e }) : null;
          }
        } catch (h) {
          return null;
        }
      }
      function rh(a) {
        if (!a.isOAuthProvider)
          throw new t("invalid-oauth-provider");
      }
      ;
      function sh(a, b, c, d2, e, f, g) {
        this.c = a;
        this.b = b || null;
        this.g = c || null;
        this.f = d2 || null;
        this.i = f || null;
        this.h = g || null;
        this.a = e || null;
        if (this.g || this.a) {
          if (this.g && this.a)
            throw new t("invalid-auth-event");
          if (this.g && !this.f)
            throw new t("invalid-auth-event");
        } else
          throw new t("invalid-auth-event");
      }
      sh.prototype.getUid = function() {
        var a = [];
        a.push(this.c);
        this.b && a.push(this.b);
        this.f && a.push(this.f);
        this.h && a.push(this.h);
        return a.join("-");
      };
      sh.prototype.T = function() {
        return this.h;
      };
      sh.prototype.w = function() {
        return { type: this.c, eventId: this.b, urlResponse: this.g, sessionId: this.f, postBody: this.i, tenantId: this.h, error: this.a && this.a.w() };
      };
      function th(a) {
        a = a || {};
        return a.type ? new sh(a.type, a.eventId, a.urlResponse, a.sessionId, a.error && Aa(a.error), a.postBody, a.tenantId) : null;
      }
      ;
      function uh() {
        this.b = null;
        this.a = [];
      }
      var vh = null;
      function wh(a) {
        var b = vh;
        b.a.push(a);
        b.b || (b.b = function(c) {
          for (var d2 = 0; d2 < b.a.length; d2++)
            b.a[d2](c);
        }, a = L("universalLinks.subscribe", l), typeof a === "function" && a(null, b.b));
      }
      ;
      function xh(a) {
        var b = "unauthorized-domain", c = void 0, d2 = J(a);
        a = d2.a;
        d2 = d2.c;
        d2 == "chrome-extension" ? c = Qb("This chrome extension ID (chrome-extension://%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : d2 == "http" || d2 == "https" ? c = Qb("This domain (%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : b = "operation-not-supported-in-this-environment";
        t.call(this, b, c);
      }
      r(xh, t);
      function yh(a, b, c) {
        t.call(this, a, c);
        a = b || {};
        a.Kb && M(this, "email", a.Kb);
        a.ea && M(this, "phoneNumber", a.ea);
        a.credential && M(this, "credential", a.credential);
        a.$b && M(this, "tenantId", a.$b);
      }
      r(yh, t);
      yh.prototype.w = function() {
        var a = { code: this.code, message: this.message };
        this.email && (a.email = this.email);
        this.phoneNumber && (a.phoneNumber = this.phoneNumber);
        this.tenantId && (a.tenantId = this.tenantId);
        var b = this.credential && this.credential.w();
        b && z(a, b);
        return a;
      };
      yh.prototype.toJSON = function() {
        return this.w();
      };
      function zh(a) {
        if (a.code) {
          var b = a.code || "";
          b.indexOf(xa) == 0 && (b = b.substring(xa.length));
          var c = { credential: qh(a), $b: a.tenantId };
          if (a.email)
            c.Kb = a.email;
          else if (a.phoneNumber)
            c.ea = a.phoneNumber;
          else if (!c.credential)
            return new t(b, a.message || void 0);
          return new yh(b, c, a.message);
        }
        return null;
      }
      ;
      function Ah() {
      }
      Ah.prototype.c = null;
      function Bh(a) {
        return a.c || (a.c = a.b());
      }
      ;
      var Ch;
      function Dh() {
      }
      r(Dh, Ah);
      Dh.prototype.a = function() {
        var a = Eh(this);
        return a ? new ActiveXObject(a) : new XMLHttpRequest();
      };
      Dh.prototype.b = function() {
        var a = {};
        Eh(this) && (a[0] = true, a[1] = true);
        return a;
      };
      function Eh(a) {
        if (!a.f && typeof XMLHttpRequest == "undefined" && typeof ActiveXObject != "undefined") {
          for (var b = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0; c < b.length; c++) {
            var d2 = b[c];
            try {
              return new ActiveXObject(d2), a.f = d2;
            } catch (e) {
            }
          }
          throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
        }
        return a.f;
      }
      Ch = new Dh();
      function Fh() {
      }
      r(Fh, Ah);
      Fh.prototype.a = function() {
        var a = new XMLHttpRequest();
        if ("withCredentials" in a)
          return a;
        if (typeof XDomainRequest != "undefined")
          return new Gh();
        throw Error("Unsupported browser");
      };
      Fh.prototype.b = function() {
        return {};
      };
      function Gh() {
        this.a = new XDomainRequest();
        this.readyState = 0;
        this.onreadystatechange = null;
        this.responseType = this.responseText = this.response = "";
        this.status = -1;
        this.statusText = "";
        this.a.onload = q(this.qc, this);
        this.a.onerror = q(this.Tb, this);
        this.a.onprogress = q(this.rc, this);
        this.a.ontimeout = q(this.vc, this);
      }
      k = Gh.prototype;
      k.open = function(a, b, c) {
        if (c != null && !c)
          throw Error("Only async requests are supported.");
        this.a.open(a, b);
      };
      k.send = function(a) {
        if (a)
          if (typeof a == "string")
            this.a.send(a);
          else
            throw Error("Only string data is supported");
        else
          this.a.send();
      };
      k.abort = function() {
        this.a.abort();
      };
      k.setRequestHeader = function() {
      };
      k.getResponseHeader = function(a) {
        return a.toLowerCase() == "content-type" ? this.a.contentType : "";
      };
      k.qc = function() {
        this.status = 200;
        this.response = this.responseText = this.a.responseText;
        Hh(this, 4);
      };
      k.Tb = function() {
        this.status = 500;
        this.response = this.responseText = "";
        Hh(this, 4);
      };
      k.vc = function() {
        this.Tb();
      };
      k.rc = function() {
        this.status = 200;
        Hh(this, 1);
      };
      function Hh(a, b) {
        a.readyState = b;
        if (a.onreadystatechange)
          a.onreadystatechange();
      }
      k.getAllResponseHeaders = function() {
        return "content-type: " + this.a.contentType;
      };
      function Ih(a, b, c) {
        this.reset(a, b, c, void 0, void 0);
      }
      Ih.prototype.a = null;
      var Jh = 0;
      Ih.prototype.reset = function(a, b, c, d2, e) {
        typeof e == "number" || Jh++;
        d2 || va();
        delete this.a;
      };
      function Kh(a) {
        this.f = a;
        this.b = this.c = this.a = null;
      }
      function Lh(a, b) {
        this.name = a;
        this.value = b;
      }
      Lh.prototype.toString = function() {
        return this.name;
      };
      var Mh = new Lh("SEVERE", 1e3), Nh = new Lh("WARNING", 900), Oh = new Lh("CONFIG", 700), Ph = new Lh("FINE", 500);
      function Qh(a) {
        if (a.c)
          return a.c;
        if (a.a)
          return Qh(a.a);
        Ga("Root logger has no level set.");
        return null;
      }
      Kh.prototype.log = function(a, b, c) {
        if (a.value >= Qh(this).value)
          for (oa(b) && (b = b()), a = new Ih(a, String(b), this.f), c && (a.a = c), c = this; c; )
            c = c.a;
      };
      var Rh = {}, Sh = null;
      function Th(a) {
        Sh || (Sh = new Kh(""), Rh[""] = Sh, Sh.c = Oh);
        var b;
        if (!(b = Rh[a])) {
          b = new Kh(a);
          var c = a.lastIndexOf("."), d2 = a.substr(c + 1);
          c = Th(a.substr(0, c));
          c.b || (c.b = {});
          c.b[d2] = b;
          b.a = c;
          Rh[a] = b;
        }
        return b;
      }
      ;
      function Uh(a, b) {
        a && a.log(Ph, b, void 0);
      }
      ;
      function Vh(a) {
        this.f = a;
      }
      r(Vh, Ah);
      Vh.prototype.a = function() {
        return new Wh(this.f);
      };
      Vh.prototype.b = function(a) {
        return function() {
          return a;
        };
      }({});
      function Wh(a) {
        H.call(this);
        this.u = a;
        this.h = void 0;
        this.readyState = Xh;
        this.status = 0;
        this.responseType = this.responseText = this.response = this.statusText = "";
        this.onreadystatechange = null;
        this.l = new Headers();
        this.b = null;
        this.s = "GET";
        this.f = "";
        this.a = false;
        this.i = Th("goog.net.FetchXmlHttp");
        this.m = this.c = this.g = null;
      }
      r(Wh, H);
      var Xh = 0;
      k = Wh.prototype;
      k.open = function(a, b) {
        if (this.readyState != Xh)
          throw this.abort(), Error("Error reopening a connection");
        this.s = a;
        this.f = b;
        this.readyState = 1;
        Yh(this);
      };
      k.send = function(a) {
        if (this.readyState != 1)
          throw this.abort(), Error("need to call open() first. ");
        this.a = true;
        var b = { headers: this.l, method: this.s, credentials: this.h, cache: void 0 };
        a && (b.body = a);
        this.u.fetch(new Request(this.f, b)).then(this.uc.bind(this), this.Va.bind(this));
      };
      k.abort = function() {
        this.response = this.responseText = "";
        this.l = new Headers();
        this.status = 0;
        this.c && this.c.cancel("Request was aborted.");
        1 <= this.readyState && this.a && this.readyState != 4 && (this.a = false, Zh(this));
        this.readyState = Xh;
      };
      k.uc = function(a) {
        this.a && (this.g = a, this.b || (this.status = this.g.status, this.statusText = this.g.statusText, this.b = a.headers, this.readyState = 2, Yh(this)), this.a && (this.readyState = 3, Yh(this), this.a && (this.responseType === "arraybuffer" ? a.arrayBuffer().then(this.sc.bind(this), this.Va.bind(this)) : typeof l.ReadableStream !== "undefined" && "body" in a ? (this.response = this.responseText = "", this.c = a.body.getReader(), this.m = new TextDecoder(), $h(this)) : a.text().then(this.tc.bind(this), this.Va.bind(this)))));
      };
      function $h(a) {
        a.c.read().then(a.pc.bind(a)).catch(a.Va.bind(a));
      }
      k.pc = function(a) {
        if (this.a) {
          var b = this.m.decode(a.value ? a.value : new Uint8Array(0), { stream: !a.done });
          b && (this.response = this.responseText += b);
          a.done ? Zh(this) : Yh(this);
          this.readyState == 3 && $h(this);
        }
      };
      k.tc = function(a) {
        this.a && (this.response = this.responseText = a, Zh(this));
      };
      k.sc = function(a) {
        this.a && (this.response = a, Zh(this));
      };
      k.Va = function(a) {
        var b = this.i;
        b && b.log(Nh, "Failed to fetch url " + this.f, a instanceof Error ? a : Error(a));
        this.a && Zh(this);
      };
      function Zh(a) {
        a.readyState = 4;
        a.g = null;
        a.c = null;
        a.m = null;
        Yh(a);
      }
      k.setRequestHeader = function(a, b) {
        this.l.append(a, b);
      };
      k.getResponseHeader = function(a) {
        return this.b ? this.b.get(a.toLowerCase()) || "" : ((a = this.i) && a.log(Nh, "Attempting to get response header but no headers have been received for url: " + this.f, void 0), "");
      };
      k.getAllResponseHeaders = function() {
        if (!this.b) {
          var a = this.i;
          a && a.log(Nh, "Attempting to get all response headers but no headers have been received for url: " + this.f, void 0);
          return "";
        }
        a = [];
        for (var b = this.b.entries(), c = b.next(); !c.done; )
          c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
        return a.join("\r\n");
      };
      function Yh(a) {
        a.onreadystatechange && a.onreadystatechange.call(a);
      }
      Object.defineProperty(Wh.prototype, "withCredentials", { get: function() {
        return this.h === "include";
      }, set: function(a) {
        this.h = a ? "include" : "same-origin";
      } });
      function ai(a) {
        H.call(this);
        this.headers = new Jd();
        this.D = a || null;
        this.c = false;
        this.C = this.a = null;
        this.h = this.P = this.l = "";
        this.f = this.N = this.i = this.J = false;
        this.g = 0;
        this.s = null;
        this.m = bi;
        this.u = this.S = false;
      }
      r(ai, H);
      var bi = "";
      ai.prototype.b = Th("goog.net.XhrIo");
      var ci = /^https?$/i, di = ["POST", "PUT"];
      function ei(a, b, c, d2, e) {
        if (a.a)
          throw Error("[goog.net.XhrIo] Object is active with another request=" + a.l + "; newUri=" + b);
        c = c ? c.toUpperCase() : "GET";
        a.l = b;
        a.h = "";
        a.P = c;
        a.J = false;
        a.c = true;
        a.a = a.D ? a.D.a() : Ch.a();
        a.C = a.D ? Bh(a.D) : Bh(Ch);
        a.a.onreadystatechange = q(a.Wb, a);
        try {
          Uh(a.b, fi(a, "Opening Xhr")), a.N = true, a.a.open(c, String(b), true), a.N = false;
        } catch (g) {
          Uh(a.b, fi(a, "Error opening Xhr: " + g.message));
          gi(a, g);
          return;
        }
        b = d2 || "";
        var f = new Jd(a.headers);
        e && Id(e, function(g, h) {
          f.set(h, g);
        });
        e = Ta(f.Y());
        d2 = l.FormData && b instanceof l.FormData;
        !Va(di, c) || e || d2 || f.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
        f.forEach(function(g, h) {
          this.a.setRequestHeader(h, g);
        }, a);
        a.m && (a.a.responseType = a.m);
        "withCredentials" in a.a && a.a.withCredentials !== a.S && (a.a.withCredentials = a.S);
        try {
          hi(a), 0 < a.g && (a.u = ii(a.a), Uh(a.b, fi(a, "Will abort after " + a.g + "ms if incomplete, xhr2 " + a.u)), a.u ? (a.a.timeout = a.g, a.a.ontimeout = q(a.Ma, a)) : a.s = Ed(a.Ma, a.g, a)), Uh(a.b, fi(a, "Sending request")), a.i = true, a.a.send(b), a.i = false;
        } catch (g) {
          Uh(a.b, fi(a, "Send error: " + g.message)), gi(a, g);
        }
      }
      function ii(a) {
        return Wb && fc(9) && typeof a.timeout === "number" && a.ontimeout !== void 0;
      }
      function Ua(a) {
        return a.toLowerCase() == "content-type";
      }
      k = ai.prototype;
      k.Ma = function() {
        typeof ha != "undefined" && this.a && (this.h = "Timed out after " + this.g + "ms, aborting", Uh(this.b, fi(this, this.h)), this.dispatchEvent("timeout"), this.abort(8));
      };
      function gi(a, b) {
        a.c = false;
        a.a && (a.f = true, a.a.abort(), a.f = false);
        a.h = b;
        ji(a);
        ki(a);
      }
      function ji(a) {
        a.J || (a.J = true, a.dispatchEvent("complete"), a.dispatchEvent("error"));
      }
      k.abort = function() {
        this.a && this.c && (Uh(this.b, fi(this, "Aborting")), this.c = false, this.f = true, this.a.abort(), this.f = false, this.dispatchEvent("complete"), this.dispatchEvent("abort"), ki(this));
      };
      k.Da = function() {
        this.a && (this.c && (this.c = false, this.f = true, this.a.abort(), this.f = false), ki(this, true));
        ai.bb.Da.call(this);
      };
      k.Wb = function() {
        this.ya || (this.N || this.i || this.f ? li(this) : this.Jc());
      };
      k.Jc = function() {
        li(this);
      };
      function li(a) {
        if (a.c && typeof ha != "undefined") {
          if (a.C[1] && mi(a) == 4 && ni(a) == 2)
            Uh(a.b, fi(a, "Local request error detected and ignored"));
          else if (a.i && mi(a) == 4)
            Ed(a.Wb, 0, a);
          else if (a.dispatchEvent("readystatechange"), mi(a) == 4) {
            Uh(a.b, fi(a, "Request complete"));
            a.c = false;
            try {
              var b = ni(a);
              a:
                switch (b) {
                  case 200:
                  case 201:
                  case 202:
                  case 204:
                  case 206:
                  case 304:
                  case 1223:
                    var c = true;
                    break a;
                  default:
                    c = false;
                }
              var d2;
              if (!(d2 = c)) {
                var e;
                if (e = b === 0) {
                  var f = String(a.l).match(Md)[1] || null;
                  if (!f && l.self && l.self.location) {
                    var g = l.self.location.protocol;
                    f = g.substr(0, g.length - 1);
                  }
                  e = !ci.test(f ? f.toLowerCase() : "");
                }
                d2 = e;
              }
              if (d2)
                a.dispatchEvent("complete"), a.dispatchEvent("success");
              else {
                try {
                  var h = 2 < mi(a) ? a.a.statusText : "";
                } catch (m) {
                  Uh(a.b, "Can not get status: " + m.message), h = "";
                }
                a.h = h + " [" + ni(a) + "]";
                ji(a);
              }
            } finally {
              ki(a);
            }
          }
        }
      }
      function ki(a, b) {
        if (a.a) {
          hi(a);
          var c = a.a, d2 = a.C[0] ? la : null;
          a.a = null;
          a.C = null;
          b || a.dispatchEvent("ready");
          try {
            c.onreadystatechange = d2;
          } catch (e) {
            (a = a.b) && a.log(Mh, "Problem encountered resetting onreadystatechange: " + e.message, void 0);
          }
        }
      }
      function hi(a) {
        a.a && a.u && (a.a.ontimeout = null);
        a.s && (l.clearTimeout(a.s), a.s = null);
      }
      function mi(a) {
        return a.a ? a.a.readyState : 0;
      }
      function ni(a) {
        try {
          return 2 < mi(a) ? a.a.status : -1;
        } catch (b) {
          return -1;
        }
      }
      function oi(a) {
        try {
          return a.a ? a.a.responseText : "";
        } catch (b) {
          return Uh(a.b, "Can not get responseText: " + b.message), "";
        }
      }
      k.getResponse = function() {
        try {
          if (!this.a)
            return null;
          if ("response" in this.a)
            return this.a.response;
          switch (this.m) {
            case bi:
            case "text":
              return this.a.responseText;
            case "arraybuffer":
              if ("mozResponseArrayBuffer" in this.a)
                return this.a.mozResponseArrayBuffer;
          }
          var a = this.b;
          a && a.log(Mh, "Response type " + this.m + " is not supported on this browser", void 0);
          return null;
        } catch (b) {
          return Uh(this.b, "Can not get response: " + b.message), null;
        }
      };
      function fi(a, b) {
        return b + " [" + a.P + " " + a.l + " " + ni(a) + "]";
      }
      ;
      function pi(a) {
        var b = qi;
        this.g = [];
        this.u = b;
        this.s = a || null;
        this.f = this.a = false;
        this.c = void 0;
        this.v = this.C = this.i = false;
        this.h = 0;
        this.b = null;
        this.l = 0;
      }
      pi.prototype.cancel = function(a) {
        if (this.a)
          this.c instanceof pi && this.c.cancel();
        else {
          if (this.b) {
            var b = this.b;
            delete this.b;
            a ? b.cancel(a) : (b.l--, 0 >= b.l && b.cancel());
          }
          this.u ? this.u.call(this.s, this) : this.v = true;
          this.a || (a = new ri(this), si(this), ti(this, false, a));
        }
      };
      pi.prototype.m = function(a, b) {
        this.i = false;
        ti(this, a, b);
      };
      function ti(a, b, c) {
        a.a = true;
        a.c = c;
        a.f = !b;
        ui(a);
      }
      function si(a) {
        if (a.a) {
          if (!a.v)
            throw new vi(a);
          a.v = false;
        }
      }
      function wi(a, b) {
        xi(a, null, b, void 0);
      }
      function xi(a, b, c, d2) {
        a.g.push([b, c, d2]);
        a.a && ui(a);
      }
      pi.prototype.then = function(a, b, c) {
        var d2, e, f = new D(function(g, h) {
          d2 = g;
          e = h;
        });
        xi(this, d2, function(g) {
          g instanceof ri ? f.cancel() : e(g);
        });
        return f.then(a, b, c);
      };
      pi.prototype.$goog_Thenable = true;
      function yi(a) {
        return Sa(a.g, function(b) {
          return oa(b[1]);
        });
      }
      function ui(a) {
        if (a.h && a.a && yi(a)) {
          var b = a.h, c = zi[b];
          c && (l.clearTimeout(c.a), delete zi[b]);
          a.h = 0;
        }
        a.b && (a.b.l--, delete a.b);
        b = a.c;
        for (var d2 = c = false; a.g.length && !a.i; ) {
          var e = a.g.shift(), f = e[0], g = e[1];
          e = e[2];
          if (f = a.f ? g : f)
            try {
              var h = f.call(e || a.s, b);
              h !== void 0 && (a.f = a.f && (h == b || h instanceof Error), a.c = b = h);
              if (Ea(b) || typeof l.Promise === "function" && b instanceof l.Promise)
                d2 = true, a.i = true;
            } catch (m) {
              b = m, a.f = true, yi(a) || (c = true);
            }
        }
        a.c = b;
        d2 && (h = q(a.m, a, true), d2 = q(a.m, a, false), b instanceof pi ? (xi(b, h, d2), b.C = true) : b.then(h, d2));
        c && (b = new Ai(b), zi[b.a] = b, a.h = b.a);
      }
      function vi() {
        u.call(this);
      }
      r(vi, u);
      vi.prototype.message = "Deferred has already fired";
      vi.prototype.name = "AlreadyCalledError";
      function ri() {
        u.call(this);
      }
      r(ri, u);
      ri.prototype.message = "Deferred was canceled";
      ri.prototype.name = "CanceledError";
      function Ai(a) {
        this.a = l.setTimeout(q(this.c, this), 0);
        this.b = a;
      }
      Ai.prototype.c = function() {
        delete zi[this.a];
        throw this.b;
      };
      var zi = {};
      function Bi(a) {
        var b = {}, c = b.document || document, d2 = yb(a).toString(), e = oc(document, "SCRIPT"), f = { Xb: e, Ma: void 0 }, g = new pi(f), h = null, m = b.timeout != null ? b.timeout : 5e3;
        0 < m && (h = window.setTimeout(function() {
          Ci(e, true);
          var p = new Di(Ei, "Timeout reached for loading script " + d2);
          si(g);
          ti(g, false, p);
        }, m), f.Ma = h);
        e.onload = e.onreadystatechange = function() {
          e.readyState && e.readyState != "loaded" && e.readyState != "complete" || (Ci(e, b.xd || false, h), si(g), ti(g, true, null));
        };
        e.onerror = function() {
          Ci(e, true, h);
          var p = new Di(Fi, "Error while loading script " + d2);
          si(g);
          ti(g, false, p);
        };
        f = b.attributes || {};
        z(f, { type: "text/javascript", charset: "UTF-8" });
        lc(e, f);
        Ob(e, a);
        Gi(c).appendChild(e);
        return g;
      }
      function Gi(a) {
        var b;
        return (b = (a || document).getElementsByTagName("HEAD")) && b.length != 0 ? b[0] : a.documentElement;
      }
      function qi() {
        if (this && this.Xb) {
          var a = this.Xb;
          a && a.tagName == "SCRIPT" && Ci(a, true, this.Ma);
        }
      }
      function Ci(a, b, c) {
        c != null && l.clearTimeout(c);
        a.onload = la;
        a.onerror = la;
        a.onreadystatechange = la;
        b && window.setTimeout(function() {
          a && a.parentNode && a.parentNode.removeChild(a);
        }, 0);
      }
      var Fi = 0, Ei = 1;
      function Di(a, b) {
        var c = "Jsloader error (code #" + a + ")";
        b && (c += ": " + b);
        u.call(this, c);
        this.code = a;
      }
      r(Di, u);
      function Hi(a) {
        this.f = a;
      }
      r(Hi, Ah);
      Hi.prototype.a = function() {
        return new this.f();
      };
      Hi.prototype.b = function() {
        return {};
      };
      function Ii(a, b, c) {
        this.c = a;
        a = b || {};
        this.l = a.secureTokenEndpoint || "https://securetoken.googleapis.com/v1/token";
        this.m = a.secureTokenTimeout || Ji;
        this.g = nb(a.secureTokenHeaders || Ki);
        this.h = a.firebaseEndpoint || "https://www.googleapis.com/identitytoolkit/v3/relyingparty/";
        this.i = a.identityPlatformEndpoint || "https://identitytoolkit.googleapis.com/v2/";
        this.v = a.firebaseTimeout || Li;
        this.a = nb(a.firebaseHeaders || Mi);
        c && (this.a["X-Client-Version"] = c, this.g["X-Client-Version"] = c);
        c = Ke() == "Node";
        c = l.XMLHttpRequest || c && firebase2.INTERNAL.node && firebase2.INTERNAL.node.XMLHttpRequest;
        if (!c && !Je())
          throw new t("internal-error", "The XMLHttpRequest compatibility library was not found.");
        this.f = void 0;
        Je() ? this.f = new Vh(self) : Le() ? this.f = new Hi(c) : this.f = new Fh();
        this.b = null;
      }
      var Ni, Dg = "idToken", Ji = new Ze(3e4, 6e4), Ki = { "Content-Type": "application/x-www-form-urlencoded" }, Li = new Ze(3e4, 6e4), Mi = { "Content-Type": "application/json" };
      function Oi(a, b) {
        b ? a.a["X-Firebase-Locale"] = b : delete a.a["X-Firebase-Locale"];
      }
      function Pi(a, b) {
        b && (a.l = Qi("https://securetoken.googleapis.com/v1/token", b), a.h = Qi("https://www.googleapis.com/identitytoolkit/v3/relyingparty/", b), a.i = Qi("https://identitytoolkit.googleapis.com/v2/", b));
      }
      function Qi(a, b) {
        a = J(a);
        b = J(b.url);
        a.f = a.a + a.f;
        Pd(a, b.c);
        a.a = b.a;
        Qd(a, b.g);
        return a.toString();
      }
      function Ri(a, b) {
        b ? (a.a["X-Client-Version"] = b, a.g["X-Client-Version"] = b) : (delete a.a["X-Client-Version"], delete a.g["X-Client-Version"]);
      }
      Ii.prototype.T = function() {
        return this.b;
      };
      function Si(a, b, c, d2, e, f, g) {
        ue() || Je() ? a = q(a.u, a) : (Ni || (Ni = new D(function(h, m) {
          Ti(h, m);
        })), a = q(a.s, a));
        a(b, c, d2, e, f, g);
      }
      Ii.prototype.u = function(a, b, c, d2, e, f) {
        if (Je() && (typeof l.fetch === "undefined" || typeof l.Headers === "undefined" || typeof l.Request === "undefined"))
          throw new t("operation-not-supported-in-this-environment", "fetch, Headers and Request native APIs or equivalent Polyfills must be available to support HTTP requests from a Worker environment.");
        var g = new ai(this.f);
        if (f) {
          g.g = Math.max(0, f);
          var h = setTimeout(function() {
            g.dispatchEvent("timeout");
          }, f);
        }
        qd(g, "complete", function() {
          h && clearTimeout(h);
          var m = null;
          try {
            m = JSON.parse(oi(this)) || null;
          } catch (p) {
            m = null;
          }
          b && b(m);
        });
        wd(g, "ready", function() {
          h && clearTimeout(h);
          Xc(this);
        });
        wd(g, "timeout", function() {
          h && clearTimeout(h);
          Xc(this);
          b && b(null);
        });
        ei(g, a, c, d2, e);
      };
      var Ui = new qb(rb, "https://apis.google.com/js/client.js?onload=%{onload}"), Vi = "__fcb" + Math.floor(1e6 * Math.random()).toString();
      function Ti(a, b) {
        if (((window.gapi || {}).client || {}).request)
          a();
        else {
          l[Vi] = function() {
            ((window.gapi || {}).client || {}).request ? a() : b(Error("CORS_UNSUPPORTED"));
          };
          var c = zb(Ui, { onload: Vi });
          wi(Bi(c), function() {
            b(Error("CORS_UNSUPPORTED"));
          });
        }
      }
      Ii.prototype.s = function(a, b, c, d2, e) {
        var f = this;
        Ni.then(function() {
          window.gapi.client.setApiKey(f.c);
          var g = window.gapi.auth.getToken();
          window.gapi.auth.setToken(null);
          window.gapi.client.request({ path: a, method: c, body: d2, headers: e, authType: "none", callback: function(h) {
            window.gapi.auth.setToken(g);
            b && b(h);
          } });
        }).o(function(g) {
          b && b({ error: { message: g && g.message || "CORS_UNSUPPORTED" } });
        });
      };
      function Wi(a, b) {
        return new D(function(c, d2) {
          b.grant_type == "refresh_token" && b.refresh_token || b.grant_type == "authorization_code" && b.code ? Si(a, a.l + "?key=" + encodeURIComponent(a.c), function(e) {
            e ? e.error ? d2(Xi(e)) : e.access_token && e.refresh_token ? c(e) : d2(new t("internal-error")) : d2(new t("network-request-failed"));
          }, "POST", fe(b).toString(), a.g, a.m.get()) : d2(new t("internal-error"));
        });
      }
      function Yi(a, b, c, d2, e, f, g) {
        var h = J(b + c);
        I(h, "key", a.c);
        g && I(h, "cb", Date.now().toString());
        var m = d2 == "GET";
        if (m)
          for (var p in e)
            e.hasOwnProperty(p) && I(h, p, e[p]);
        return new D(function(v, B) {
          Si(a, h.toString(), function(A) {
            A ? A.error ? B(Xi(A, f || {})) : v(A) : B(new t("network-request-failed"));
          }, d2, m ? void 0 : ke(Ve(e)), a.a, a.v.get());
        });
      }
      function Zi(a) {
        a = a.email;
        if (typeof a !== "string" || !De.test(a))
          throw new t("invalid-email");
      }
      function $i(a) {
        "email" in a && Zi(a);
      }
      function aj(a, b) {
        return O(a, bj, { identifier: b, continueUri: Se() ? re() : "http://localhost" }).then(function(c) {
          return c.signinMethods || [];
        });
      }
      function cj(a) {
        return O(a, dj, {}).then(function(b) {
          return b.authorizedDomains || [];
        });
      }
      function P(a) {
        if (!a[Dg]) {
          if (a.mfaPendingCredential)
            throw new t("multi-factor-auth-required", null, nb(a));
          throw new t("internal-error");
        }
      }
      function ej(a) {
        if (a.phoneNumber || a.temporaryProof) {
          if (!a.phoneNumber || !a.temporaryProof)
            throw new t("internal-error");
        } else {
          if (!a.sessionInfo)
            throw new t("missing-verification-id");
          if (!a.code)
            throw new t("missing-verification-code");
        }
      }
      Ii.prototype.Ab = function() {
        return O(this, fj, {});
      };
      Ii.prototype.Cb = function(a, b) {
        return O(this, gj, { idToken: a, email: b });
      };
      Ii.prototype.Db = function(a, b) {
        return O(this, ch, { idToken: a, password: b });
      };
      var hj = { displayName: "DISPLAY_NAME", photoUrl: "PHOTO_URL" };
      k = Ii.prototype;
      k.Eb = function(a, b) {
        var c = { idToken: a }, d2 = [];
        lb(hj, function(e, f) {
          var g = b[f];
          g === null ? d2.push(e) : f in b && (c[f] = g);
        });
        d2.length && (c.deleteAttribute = d2);
        return O(this, gj, c);
      };
      k.wb = function(a, b) {
        a = { requestType: "PASSWORD_RESET", email: a };
        z(a, b);
        return O(this, ij, a);
      };
      k.xb = function(a, b) {
        a = { requestType: "EMAIL_SIGNIN", email: a };
        z(a, b);
        return O(this, jj, a);
      };
      k.vb = function(a, b) {
        a = { requestType: "VERIFY_EMAIL", idToken: a };
        z(a, b);
        return O(this, kj, a);
      };
      k.Fb = function(a, b, c) {
        a = { requestType: "VERIFY_AND_CHANGE_EMAIL", idToken: a, newEmail: b };
        z(a, c);
        return O(this, lj, a);
      };
      function oh(a, b) {
        return O(a, mj, b);
      }
      k.gb = function(a) {
        return O(this, nj, a);
      };
      function mh(a, b) {
        return O(a, oj, b).then(function(c) {
          return c.phoneSessionInfo.sessionInfo;
        });
      }
      function pj(a) {
        if (!a.phoneVerificationInfo)
          throw new t("internal-error");
        if (!a.phoneVerificationInfo.sessionInfo)
          throw new t("missing-verification-id");
        if (!a.phoneVerificationInfo.code)
          throw new t("missing-verification-code");
      }
      function nh(a, b) {
        return O(a, qj, b).then(function(c) {
          return c.phoneResponseInfo.sessionInfo;
        });
      }
      function rj(a, b, c) {
        return O(a, sj, { idToken: b, deleteProvider: c });
      }
      function tj(a) {
        if (!a.requestUri || !a.sessionId && !a.postBody && !a.pendingToken)
          throw new t("internal-error");
      }
      function uj(a, b) {
        b.oauthIdToken && b.providerId && b.providerId.indexOf("oidc.") == 0 && !b.pendingToken && (a.sessionId ? b.nonce = a.sessionId : a.postBody && (a = new Ud(a.postBody), je(a, "nonce") && (b.nonce = a.get("nonce"))));
        return b;
      }
      function vj(a) {
        var b = null;
        a.needConfirmation ? (a.code = "account-exists-with-different-credential", b = zh(a)) : a.errorMessage == "FEDERATED_USER_ID_ALREADY_LINKED" ? (a.code = "credential-already-in-use", b = zh(a)) : a.errorMessage == "EMAIL_EXISTS" ? (a.code = "email-already-in-use", b = zh(a)) : a.errorMessage && (b = wj(a.errorMessage));
        if (b)
          throw b;
        P(a);
      }
      function Fg(a, b) {
        b.returnIdpCredential = true;
        return O(a, xj, b);
      }
      function Hg(a, b) {
        b.returnIdpCredential = true;
        return O(a, yj, b);
      }
      function Ig(a, b) {
        b.returnIdpCredential = true;
        b.autoCreate = false;
        return O(a, zj, b);
      }
      function Aj(a) {
        if (!a.oobCode)
          throw new t("invalid-action-code");
      }
      k.ob = function(a, b) {
        return O(this, Bj, { oobCode: a, newPassword: b });
      };
      k.Sa = function(a) {
        return O(this, Cj, { oobCode: a });
      };
      k.kb = function(a) {
        return O(this, Dj, { oobCode: a });
      };
      var Dj = { endpoint: "setAccountInfo", A: Aj, Z: "email", B: true }, Cj = { endpoint: "resetPassword", A: Aj, G: function(a) {
        var b = a.requestType;
        if (!b || !a.email && b != "EMAIL_SIGNIN" && b != "VERIFY_AND_CHANGE_EMAIL")
          throw new t("internal-error");
      }, B: true }, Ej = { endpoint: "signupNewUser", A: function(a) {
        Zi(a);
        if (!a.password)
          throw new t("weak-password");
      }, G: P, V: true, B: true }, bj = { endpoint: "createAuthUri", B: true }, Fj = { endpoint: "deleteAccount", O: ["idToken"] }, sj = { endpoint: "setAccountInfo", O: ["idToken", "deleteProvider"], A: function(a) {
        if (!Array.isArray(a.deleteProvider))
          throw new t("internal-error");
      } }, $g = { endpoint: "emailLinkSignin", O: ["email", "oobCode"], A: Zi, G: P, V: true, B: true }, bh = { endpoint: "emailLinkSignin", O: ["idToken", "email", "oobCode"], A: Zi, G: P, V: true }, Gj = { endpoint: "accounts/mfaEnrollment:finalize", O: ["idToken", "phoneVerificationInfo"], A: pj, G: P, B: true, Na: true }, Hj = { endpoint: "accounts/mfaSignIn:finalize", O: ["mfaPendingCredential", "phoneVerificationInfo"], A: pj, G: P, B: true, Na: true }, Ij = { endpoint: "getAccountInfo" }, jj = { endpoint: "getOobConfirmationCode", O: ["requestType"], A: function(a) {
        if (a.requestType != "EMAIL_SIGNIN")
          throw new t("internal-error");
        Zi(a);
      }, Z: "email", B: true }, kj = { endpoint: "getOobConfirmationCode", O: ["idToken", "requestType"], A: function(a) {
        if (a.requestType != "VERIFY_EMAIL")
          throw new t("internal-error");
      }, Z: "email", B: true }, lj = { endpoint: "getOobConfirmationCode", O: ["idToken", "newEmail", "requestType"], A: function(a) {
        if (a.requestType != "VERIFY_AND_CHANGE_EMAIL")
          throw new t("internal-error");
      }, Z: "email", B: true }, ij = { endpoint: "getOobConfirmationCode", O: ["requestType"], A: function(a) {
        if (a.requestType != "PASSWORD_RESET")
          throw new t("internal-error");
        Zi(a);
      }, Z: "email", B: true }, dj = { mb: true, endpoint: "getProjectConfig", Vb: "GET" }, Jj = { mb: true, endpoint: "getRecaptchaParam", Vb: "GET", G: function(a) {
        if (!a.recaptchaSiteKey)
          throw new t("internal-error");
      } }, Bj = { endpoint: "resetPassword", A: Aj, Z: "email", B: true }, mj = { endpoint: "sendVerificationCode", O: ["phoneNumber", "recaptchaToken"], Z: "sessionInfo", B: true }, gj = { endpoint: "setAccountInfo", O: ["idToken"], A: $i, V: true }, ch = {
        endpoint: "setAccountInfo",
        O: ["idToken"],
        A: function(a) {
          $i(a);
          if (!a.password)
            throw new t("weak-password");
        },
        G: P,
        V: true
      }, fj = { endpoint: "signupNewUser", G: P, V: true, B: true }, oj = { endpoint: "accounts/mfaEnrollment:start", O: ["idToken", "phoneEnrollmentInfo"], A: function(a) {
        if (!a.phoneEnrollmentInfo)
          throw new t("internal-error");
        if (!a.phoneEnrollmentInfo.phoneNumber)
          throw new t("missing-phone-number");
        if (!a.phoneEnrollmentInfo.recaptchaToken)
          throw new t("missing-app-credential");
      }, G: function(a) {
        if (!a.phoneSessionInfo || !a.phoneSessionInfo.sessionInfo)
          throw new t("internal-error");
      }, B: true, Na: true }, qj = {
        endpoint: "accounts/mfaSignIn:start",
        O: ["mfaPendingCredential", "mfaEnrollmentId", "phoneSignInInfo"],
        A: function(a) {
          if (!a.phoneSignInInfo || !a.phoneSignInInfo.recaptchaToken)
            throw new t("missing-app-credential");
        },
        G: function(a) {
          if (!a.phoneResponseInfo || !a.phoneResponseInfo.sessionInfo)
            throw new t("internal-error");
        },
        B: true,
        Na: true
      }, xj = { endpoint: "verifyAssertion", A: tj, Za: uj, G: vj, V: true, B: true }, zj = { endpoint: "verifyAssertion", A: tj, Za: uj, G: function(a) {
        if (a.errorMessage && a.errorMessage == "USER_NOT_FOUND")
          throw new t("user-not-found");
        if (a.errorMessage)
          throw wj(a.errorMessage);
        P(a);
      }, V: true, B: true }, yj = { endpoint: "verifyAssertion", A: function(a) {
        tj(a);
        if (!a.idToken)
          throw new t("internal-error");
      }, Za: uj, G: vj, V: true }, Kj = { endpoint: "verifyCustomToken", A: function(a) {
        if (!a.token)
          throw new t("invalid-custom-token");
      }, G: P, V: true, B: true }, ah = { endpoint: "verifyPassword", A: function(a) {
        Zi(a);
        if (!a.password)
          throw new t("wrong-password");
      }, G: P, V: true, B: true }, nj = { endpoint: "verifyPhoneNumber", A: ej, G: P, B: true }, ih = {
        endpoint: "verifyPhoneNumber",
        A: function(a) {
          if (!a.idToken)
            throw new t("internal-error");
          ej(a);
        },
        G: function(a) {
          if (a.temporaryProof)
            throw a.code = "credential-already-in-use", zh(a);
          P(a);
        }
      }, jh = { Ib: { USER_NOT_FOUND: "user-not-found" }, endpoint: "verifyPhoneNumber", A: ej, G: P, B: true }, Lj = { endpoint: "accounts/mfaEnrollment:withdraw", O: ["idToken", "mfaEnrollmentId"], G: function(a) {
        if (!!a[Dg] ^ !!a.refreshToken)
          throw new t("internal-error");
      }, B: true, Na: true };
      function O(a, b, c) {
        if (!mf(c, b.O))
          return F(new t("internal-error"));
        var d2 = !!b.Na, e = b.Vb || "POST", f;
        return E(c).then(b.A).then(function() {
          b.V && (c.returnSecureToken = true);
          b.B && a.b && typeof c.tenantId === "undefined" && (c.tenantId = a.b);
          return d2 ? Yi(a, a.i, b.endpoint, e, c, b.Ib, b.mb || false) : Yi(a, a.h, b.endpoint, e, c, b.Ib, b.mb || false);
        }).then(function(g) {
          f = g;
          return b.Za ? b.Za(c, f) : f;
        }).then(b.G).then(function() {
          if (!b.Z)
            return f;
          if (!(b.Z in f))
            throw new t("internal-error");
          return f[b.Z];
        });
      }
      function wj(a) {
        return Xi({ error: { errors: [{ message: a }], code: 400, message: a } });
      }
      function Xi(a, b) {
        var c = (a.error && a.error.errors && a.error.errors[0] || {}).reason || "";
        var d2 = { keyInvalid: "invalid-api-key", ipRefererBlocked: "app-not-authorized" };
        if (c = d2[c] ? new t(d2[c]) : null)
          return c;
        c = a.error && a.error.message || "";
        d2 = {
          INVALID_CUSTOM_TOKEN: "invalid-custom-token",
          CREDENTIAL_MISMATCH: "custom-token-mismatch",
          MISSING_CUSTOM_TOKEN: "internal-error",
          INVALID_IDENTIFIER: "invalid-email",
          MISSING_CONTINUE_URI: "internal-error",
          INVALID_EMAIL: "invalid-email",
          INVALID_PASSWORD: "wrong-password",
          USER_DISABLED: "user-disabled",
          MISSING_PASSWORD: "internal-error",
          EMAIL_EXISTS: "email-already-in-use",
          PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
          INVALID_IDP_RESPONSE: "invalid-credential",
          INVALID_PENDING_TOKEN: "invalid-credential",
          FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
          MISSING_OR_INVALID_NONCE: "missing-or-invalid-nonce",
          INVALID_MESSAGE_PAYLOAD: "invalid-message-payload",
          INVALID_RECIPIENT_EMAIL: "invalid-recipient-email",
          INVALID_SENDER: "invalid-sender",
          EMAIL_NOT_FOUND: "user-not-found",
          RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
          EXPIRED_OOB_CODE: "expired-action-code",
          INVALID_OOB_CODE: "invalid-action-code",
          MISSING_OOB_CODE: "internal-error",
          INVALID_PROVIDER_ID: "invalid-provider-id",
          CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
          INVALID_ID_TOKEN: "invalid-user-token",
          TOKEN_EXPIRED: "user-token-expired",
          USER_NOT_FOUND: "user-token-expired",
          CORS_UNSUPPORTED: "cors-unsupported",
          DYNAMIC_LINK_NOT_ACTIVATED: "dynamic-link-not-activated",
          INVALID_APP_ID: "invalid-app-id",
          TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
          WEAK_PASSWORD: "weak-password",
          OPERATION_NOT_ALLOWED: "operation-not-allowed",
          USER_CANCELLED: "user-cancelled",
          CAPTCHA_CHECK_FAILED: "captcha-check-failed",
          INVALID_APP_CREDENTIAL: "invalid-app-credential",
          INVALID_CODE: "invalid-verification-code",
          INVALID_PHONE_NUMBER: "invalid-phone-number",
          INVALID_SESSION_INFO: "invalid-verification-id",
          INVALID_TEMPORARY_PROOF: "invalid-credential",
          MISSING_APP_CREDENTIAL: "missing-app-credential",
          MISSING_CODE: "missing-verification-code",
          MISSING_PHONE_NUMBER: "missing-phone-number",
          MISSING_SESSION_INFO: "missing-verification-id",
          QUOTA_EXCEEDED: "quota-exceeded",
          SESSION_EXPIRED: "code-expired",
          REJECTED_CREDENTIAL: "rejected-credential",
          INVALID_CONTINUE_URI: "invalid-continue-uri",
          MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
          MISSING_IOS_BUNDLE_ID: "missing-ios-bundle-id",
          UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
          INVALID_DYNAMIC_LINK_DOMAIN: "invalid-dynamic-link-domain",
          INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
          INVALID_CERT_HASH: "invalid-cert-hash",
          UNSUPPORTED_TENANT_OPERATION: "unsupported-tenant-operation",
          INVALID_TENANT_ID: "invalid-tenant-id",
          TENANT_ID_MISMATCH: "tenant-id-mismatch",
          ADMIN_ONLY_OPERATION: "admin-restricted-operation",
          INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
          MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
          MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
          MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
          EMAIL_CHANGE_NEEDS_VERIFICATION: "email-change-needs-verification",
          SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
          SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
          UNSUPPORTED_FIRST_FACTOR: "unsupported-first-factor",
          UNVERIFIED_EMAIL: "unverified-email"
        };
        z(d2, b || {});
        b = (b = c.match(/^[^\s]+\s*:\s*([\s\S]*)$/)) && 1 < b.length ? b[1] : void 0;
        for (var e in d2)
          if (c.indexOf(e) === 0)
            return new t(d2[e], b);
        !b && a && (b = Ue(a));
        return new t("internal-error", b);
      }
      ;
      function Mj(a) {
        this.b = a;
        this.a = null;
        this.sb = Nj(this);
      }
      function Nj(a) {
        return Oj().then(function() {
          return new D(function(b, c) {
            L("gapi.iframes.getContext")().open({ where: document.body, url: a.b, messageHandlersFilter: L("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"), attributes: { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" } }, dontclear: true }, function(d2) {
              function e() {
                clearTimeout(f);
                b();
              }
              a.a = d2;
              a.a.restyle({ setHideOnLeave: false });
              var f = setTimeout(function() {
                c(Error("Network Error"));
              }, Pj.get());
              d2.ping(e).then(e, function() {
                c(Error("Network Error"));
              });
            });
          });
        });
      }
      function Qj(a, b) {
        return a.sb.then(function() {
          return new D(function(c) {
            a.a.send(b.type, b, c, L("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
          });
        });
      }
      function Rj(a, b) {
        a.sb.then(function() {
          a.a.register("authEvent", b, L("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
        });
      }
      var Sj = new qb(rb, "https://apis.google.com/js/api.js?onload=%{onload}"), Tj = new Ze(3e4, 6e4), Pj = new Ze(5e3, 15e3), Uj = null;
      function Oj() {
        return Uj ? Uj : Uj = new D(function(a, b) {
          function c() {
            Ye();
            L("gapi.load")("gapi.iframes", { callback: a, ontimeout: function() {
              Ye();
              b(Error("Network Error"));
            }, timeout: Tj.get() });
          }
          if (L("gapi.iframes.Iframe"))
            a();
          else if (L("gapi.load"))
            c();
          else {
            var d2 = "__iframefcb" + Math.floor(1e6 * Math.random()).toString();
            l[d2] = function() {
              L("gapi.load") ? c() : b(Error("Network Error"));
            };
            d2 = zb(Sj, { onload: d2 });
            E(Bi(d2)).o(function() {
              b(Error("Network Error"));
            });
          }
        }).o(function(a) {
          Uj = null;
          throw a;
        });
      }
      ;
      function Vj(a, b, c, d2) {
        this.l = a;
        this.h = b;
        this.i = c;
        this.g = d2;
        this.f = null;
        this.g ? (a = J(this.g.url), a = ce(a.c, a.a, a.g, "/emulator/auth/iframe")) : a = ce("https", this.l, null, "/__/auth/iframe");
        this.a = a;
        I(this.a, "apiKey", this.h);
        I(this.a, "appName", this.i);
        this.b = null;
        this.c = [];
      }
      Vj.prototype.toString = function() {
        this.f ? I(this.a, "v", this.f) : ie(this.a.b, "v");
        this.b ? I(this.a, "eid", this.b) : ie(this.a.b, "eid");
        this.c.length ? I(this.a, "fw", this.c.join(",")) : ie(this.a.b, "fw");
        return this.a.toString();
      };
      function Wj(a, b, c, d2, e, f) {
        this.u = a;
        this.s = b;
        this.c = c;
        this.m = d2;
        this.v = f;
        this.i = this.g = this.l = null;
        this.a = e;
        this.h = this.f = null;
      }
      Wj.prototype.zb = function(a) {
        this.h = a;
        return this;
      };
      Wj.prototype.toString = function() {
        if (this.v) {
          var a = J(this.v.url);
          a = ce(a.c, a.a, a.g, "/emulator/auth/handler");
        } else
          a = ce("https", this.u, null, "/__/auth/handler");
        I(a, "apiKey", this.s);
        I(a, "appName", this.c);
        I(a, "authType", this.m);
        if (this.a.isOAuthProvider) {
          var b = this.a;
          try {
            var c = firebase2.app(this.c).auth().la();
          } catch (h) {
            c = null;
          }
          b.pb = c;
          I(a, "providerId", this.a.providerId);
          c = this.a;
          b = Ve(c.Jb);
          for (var d2 in b)
            b[d2] = b[d2].toString();
          d2 = c.Qc;
          b = nb(b);
          for (var e = 0; e < d2.length; e++) {
            var f = d2[e];
            f in b && delete b[f];
          }
          c.qb && c.pb && !b[c.qb] && (b[c.qb] = c.pb);
          mb(b) || I(a, "customParameters", Ue(b));
        }
        typeof this.a.Rb === "function" && (c = this.a.Rb(), c.length && I(a, "scopes", c.join(",")));
        this.l ? I(a, "redirectUrl", this.l) : ie(a.b, "redirectUrl");
        this.g ? I(a, "eventId", this.g) : ie(a.b, "eventId");
        this.i ? I(a, "v", this.i) : ie(a.b, "v");
        if (this.b)
          for (var g in this.b)
            this.b.hasOwnProperty(g) && !be(a, g) && I(a, g, this.b[g]);
        this.h ? I(a, "tid", this.h) : ie(a.b, "tid");
        this.f ? I(a, "eid", this.f) : ie(a.b, "eid");
        g = Xj(this.c);
        g.length && I(a, "fw", g.join(","));
        return a.toString();
      };
      function Xj(a) {
        try {
          return firebase2.app(a).auth().Ga();
        } catch (b) {
          return [];
        }
      }
      function Yj(a, b, c, d2, e, f) {
        this.s = a;
        this.g = b;
        this.b = c;
        this.f = f;
        this.c = d2 || null;
        this.i = e || null;
        this.l = this.u = this.C = null;
        this.h = [];
        this.m = this.a = null;
      }
      function Zj(a) {
        var b = re();
        return cj(a).then(function(c) {
          a: {
            var d2 = J(b), e = d2.c;
            d2 = d2.a;
            for (var f = 0; f < c.length; f++) {
              var g = c[f];
              var h = d2;
              var m = e;
              g.indexOf("chrome-extension://") == 0 ? h = J(g).a == h && m == "chrome-extension" : m != "http" && m != "https" ? h = false : Ce.test(g) ? h = h == g : (g = g.split(".").join("\\."), h = new RegExp("^(.+\\." + g + "|" + g + ")$", "i").test(h));
              if (h) {
                c = true;
                break a;
              }
            }
            c = false;
          }
          if (!c)
            throw new xh(re());
        });
      }
      function ak(a) {
        if (a.m)
          return a.m;
        a.m = Ee().then(function() {
          if (!a.u) {
            var b = a.c, c = a.i, d2 = Xj(a.b), e = new Vj(a.s, a.g, a.b, a.f);
            e.f = b;
            e.b = c;
            e.c = Za(d2 || []);
            a.u = e.toString();
          }
          a.v = new Mj(a.u);
          bk(a);
        });
        return a.m;
      }
      k = Yj.prototype;
      k.Pb = function(a, b, c) {
        var d2 = new t("popup-closed-by-user"), e = new t("web-storage-unsupported"), f = this, g = false;
        return this.ma().then(function() {
          ck(f).then(function(h) {
            h || (a && ye(a), b(e), g = true);
          });
        }).o(function() {
        }).then(function() {
          if (!g)
            return Be(a);
        }).then(function() {
          if (!g)
            return Fd(c).then(function() {
              b(d2);
            });
        });
      };
      k.Yb = function() {
        var a = K();
        return !Te(a) && !Xe(a);
      };
      k.Ub = function() {
        return false;
      };
      k.Nb = function(a, b, c, d2, e, f, g, h) {
        if (!a)
          return F(new t("popup-blocked"));
        if (g && !Te())
          return this.ma().o(function(p) {
            ye(a);
            e(p);
          }), d2(), E();
        this.a || (this.a = Zj(dk(this)));
        var m = this;
        return this.a.then(function() {
          var p = m.ma().o(function(v) {
            ye(a);
            e(v);
            throw v;
          });
          d2();
          return p;
        }).then(function() {
          rh(c);
          if (!g) {
            var p = ek(m.s, m.g, m.b, b, c, null, f, m.c, void 0, m.i, h, m.f);
            se(p, a);
          }
        }).o(function(p) {
          p.code == "auth/network-request-failed" && (m.a = null);
          throw p;
        });
      };
      function dk(a) {
        a.l || (a.C = a.c ? Oe(a.c, Xj(a.b)) : null, a.l = new Ii(a.g, Ca(a.i), a.C), a.f && Pi(a.l, a.f));
        return a.l;
      }
      k.Ob = function(a, b, c, d2) {
        this.a || (this.a = Zj(dk(this)));
        var e = this;
        return this.a.then(function() {
          rh(b);
          var f = ek(e.s, e.g, e.b, a, b, re(), c, e.c, void 0, e.i, d2, e.f);
          se(f);
        }).o(function(f) {
          f.code == "auth/network-request-failed" && (e.a = null);
          throw f;
        });
      };
      k.ma = function() {
        var a = this;
        return ak(this).then(function() {
          return a.v.sb;
        }).o(function() {
          a.a = null;
          throw new t("network-request-failed");
        });
      };
      k.ac = function() {
        return true;
      };
      function ek(a, b, c, d2, e, f, g, h, m, p, v, B) {
        a = new Wj(a, b, c, d2, e, B);
        a.l = f;
        a.g = g;
        a.i = h;
        a.b = nb(m || null);
        a.f = p;
        return a.zb(v).toString();
      }
      function bk(a) {
        if (!a.v)
          throw Error("IfcHandler must be initialized!");
        Rj(a.v, function(b) {
          var c = {};
          if (b && b.authEvent) {
            var d2 = false;
            b = th(b.authEvent);
            for (c = 0; c < a.h.length; c++)
              d2 = a.h[c](b) || d2;
            c = {};
            c.status = d2 ? "ACK" : "ERROR";
            return E(c);
          }
          c.status = "ERROR";
          return E(c);
        });
      }
      function ck(a) {
        var b = { type: "webStorageSupport" };
        return ak(a).then(function() {
          return Qj(a.v, b);
        }).then(function(c) {
          if (c && c.length && typeof c[0].webStorageSupport !== "undefined")
            return c[0].webStorageSupport;
          throw Error();
        });
      }
      k.Ea = function(a) {
        this.h.push(a);
      };
      k.Ta = function(a) {
        Xa(this.h, function(b) {
          return b == a;
        });
      };
      function fk(a) {
        this.a = a || firebase2.INTERNAL.reactNative && firebase2.INTERNAL.reactNative.AsyncStorage;
        if (!this.a)
          throw new t("internal-error", "The React Native compatibility library was not found.");
        this.type = "asyncStorage";
      }
      k = fk.prototype;
      k.get = function(a) {
        return E(this.a.getItem(a)).then(function(b) {
          return b && We(b);
        });
      };
      k.set = function(a, b) {
        return E(this.a.setItem(a, Ue(b)));
      };
      k.U = function(a) {
        return E(this.a.removeItem(a));
      };
      k.ca = function() {
      };
      k.ia = function() {
      };
      function gk(a) {
        this.b = a;
        this.a = {};
        this.f = q(this.c, this);
      }
      var hk = [];
      function ik() {
        var a = Je() ? self : null;
        w(hk, function(c) {
          c.b == a && (b = c);
        });
        if (!b) {
          var b = new gk(a);
          hk.push(b);
        }
        return b;
      }
      gk.prototype.c = function(a) {
        var b = a.data.eventType, c = a.data.eventId, d2 = this.a[b];
        if (d2 && 0 < d2.length) {
          a.ports[0].postMessage({ status: "ack", eventId: c, eventType: b, response: null });
          var e = [];
          w(d2, function(f) {
            e.push(E().then(function() {
              return f(a.origin, a.data.data);
            }));
          });
          Jc(e).then(function(f) {
            var g = [];
            w(f, function(h) {
              g.push({ fulfilled: h.Qb, value: h.value, reason: h.reason ? h.reason.message : void 0 });
            });
            w(g, function(h) {
              for (var m in h)
                typeof h[m] === "undefined" && delete h[m];
            });
            a.ports[0].postMessage({
              status: "done",
              eventId: c,
              eventType: b,
              response: g
            });
          });
        }
      };
      function jk(a, b, c) {
        mb(a.a) && a.b.addEventListener("message", a.f);
        typeof a.a[b] === "undefined" && (a.a[b] = []);
        a.a[b].push(c);
      }
      ;
      function kk(a) {
        this.a = a;
      }
      kk.prototype.postMessage = function(a, b) {
        this.a.postMessage(a, b);
      };
      function lk(a) {
        this.c = a;
        this.b = false;
        this.a = [];
      }
      function mk(a, b, c, d2) {
        var e, f = c || {}, g, h, m, p = null;
        if (a.b)
          return F(Error("connection_unavailable"));
        var v = d2 ? 800 : 50, B = typeof MessageChannel !== "undefined" ? new MessageChannel() : null;
        return new D(function(A, Q) {
          B ? (e = Math.floor(Math.random() * Math.pow(10, 20)).toString(), B.port1.start(), h = setTimeout(function() {
            Q(Error("unsupported_event"));
          }, v), g = function(ya) {
            ya.data.eventId === e && (ya.data.status === "ack" ? (clearTimeout(h), m = setTimeout(function() {
              Q(Error("timeout"));
            }, 3e3)) : ya.data.status === "done" ? (clearTimeout(m), typeof ya.data.response !== "undefined" ? A(ya.data.response) : Q(Error("unknown_error"))) : (clearTimeout(h), clearTimeout(m), Q(Error("invalid_response"))));
          }, p = { messageChannel: B, onMessage: g }, a.a.push(p), B.port1.addEventListener("message", g), a.c.postMessage({ eventType: b, eventId: e, data: f }, [B.port2])) : Q(Error("connection_unavailable"));
        }).then(function(A) {
          nk(a, p);
          return A;
        }).o(function(A) {
          nk(a, p);
          throw A;
        });
      }
      function nk(a, b) {
        if (b) {
          var c = b.messageChannel, d2 = b.onMessage;
          c && (c.port1.removeEventListener("message", d2), c.port1.close());
          Xa(a.a, function(e) {
            return e == b;
          });
        }
      }
      lk.prototype.close = function() {
        for (; 0 < this.a.length; )
          nk(this, this.a[0]);
        this.b = true;
      };
      function ok() {
        if (!pk())
          throw new t("web-storage-unsupported");
        this.c = {};
        this.a = [];
        this.b = 0;
        this.m = l.indexedDB;
        this.type = "indexedDB";
        this.g = this.v = this.f = this.l = null;
        this.s = false;
        this.h = null;
        var a = this;
        Je() && self ? (this.v = ik(), jk(this.v, "keyChanged", function(b, c) {
          return qk(a).then(function(d2) {
            0 < d2.length && w(a.a, function(e) {
              e(d2);
            });
            return { keyProcessed: Va(d2, c.key) };
          });
        }), jk(this.v, "ping", function() {
          return E(["keyChanged"]);
        })) : ef().then(function(b) {
          if (a.h = b)
            a.g = new lk(new kk(b)), mk(a.g, "ping", null, true).then(function(c) {
              c[0].fulfilled && Va(c[0].value, "keyChanged") && (a.s = true);
            }).o(function() {
            });
        });
      }
      var rk;
      function sk(a) {
        return new D(function(b, c) {
          var d2 = a.m.deleteDatabase("firebaseLocalStorageDb");
          d2.onsuccess = function() {
            b();
          };
          d2.onerror = function(e) {
            c(Error(e.target.error));
          };
        });
      }
      function tk(a) {
        return new D(function(b, c) {
          var d2 = a.m.open("firebaseLocalStorageDb", 1);
          d2.onerror = function(e) {
            try {
              e.preventDefault();
            } catch (f) {
            }
            c(Error(e.target.error));
          };
          d2.onupgradeneeded = function(e) {
            e = e.target.result;
            try {
              e.createObjectStore("firebaseLocalStorage", { keyPath: "fbase_key" });
            } catch (f) {
              c(f);
            }
          };
          d2.onsuccess = function(e) {
            e = e.target.result;
            e.objectStoreNames.contains("firebaseLocalStorage") ? b(e) : sk(a).then(function() {
              return tk(a);
            }).then(function(f) {
              b(f);
            }).o(function(f) {
              c(f);
            });
          };
        });
      }
      function uk(a) {
        a.i || (a.i = tk(a));
        return a.i;
      }
      function vk(a, b) {
        function c(e, f) {
          uk(a).then(b).then(e).o(function(g) {
            if (3 < ++d2)
              f(g);
            else
              return uk(a).then(function(h) {
                h.close();
                a.i = void 0;
                return c(e, f);
              }).o(function(h) {
                f(h);
              });
          });
        }
        var d2 = 0;
        return new D(c);
      }
      function pk() {
        try {
          return !!l.indexedDB;
        } catch (a) {
          return false;
        }
      }
      function wk(a) {
        return a.objectStore("firebaseLocalStorage");
      }
      function xk(a, b) {
        return a.transaction(["firebaseLocalStorage"], b ? "readwrite" : "readonly");
      }
      function yk(a) {
        return new D(function(b, c) {
          a.onsuccess = function(d2) {
            d2 && d2.target ? b(d2.target.result) : b();
          };
          a.onerror = function(d2) {
            c(d2.target.error);
          };
        });
      }
      k = ok.prototype;
      k.set = function(a, b) {
        var c = this, d2 = false;
        return vk(this, function(e) {
          e = wk(xk(e, true));
          return yk(e.get(a));
        }).then(function(e) {
          return vk(c, function(f) {
            f = wk(xk(f, true));
            if (e)
              return e.value = b, yk(f.put(e));
            c.b++;
            d2 = true;
            var g = {};
            g.fbase_key = a;
            g.value = b;
            return yk(f.add(g));
          });
        }).then(function() {
          c.c[a] = b;
          return zk(c, a);
        }).oa(function() {
          d2 && c.b--;
        });
      };
      function zk(a, b) {
        return a.g && a.h && df() === a.h ? mk(a.g, "keyChanged", { key: b }, a.s).then(function() {
        }).o(function() {
        }) : E();
      }
      k.get = function(a) {
        return vk(this, function(b) {
          return yk(wk(xk(b, false)).get(a));
        }).then(function(b) {
          return b && b.value;
        });
      };
      k.U = function(a) {
        var b = this, c = false;
        return vk(this, function(d2) {
          c = true;
          b.b++;
          return yk(wk(xk(d2, true))["delete"](a));
        }).then(function() {
          delete b.c[a];
          return zk(b, a);
        }).oa(function() {
          c && b.b--;
        });
      };
      function qk(a) {
        return uk(a).then(function(b) {
          var c = wk(xk(b, false));
          return c.getAll ? yk(c.getAll()) : new D(function(d2, e) {
            var f = [], g = c.openCursor();
            g.onsuccess = function(h) {
              (h = h.target.result) ? (f.push(h.value), h["continue"]()) : d2(f);
            };
            g.onerror = function(h) {
              e(h.target.error);
            };
          });
        }).then(function(b) {
          var c = {}, d2 = [];
          if (a.b == 0) {
            for (d2 = 0; d2 < b.length; d2++)
              c[b[d2].fbase_key] = b[d2].value;
            d2 = te(a.c, c);
            a.c = c;
          }
          return d2;
        });
      }
      k.ca = function(a) {
        this.a.length == 0 && Ak(this);
        this.a.push(a);
      };
      k.ia = function(a) {
        Xa(this.a, function(b) {
          return b == a;
        });
        this.a.length == 0 && Bk(this);
      };
      function Ak(a) {
        function b() {
          a.f = setTimeout(function() {
            a.l = qk(a).then(function(c) {
              0 < c.length && w(a.a, function(d2) {
                d2(c);
              });
            }).then(function() {
              b();
            }).o(function(c) {
              c.message != "STOP_EVENT" && b();
            });
          }, 800);
        }
        Bk(a);
        b();
      }
      function Bk(a) {
        a.l && a.l.cancel("STOP_EVENT");
        a.f && (clearTimeout(a.f), a.f = null);
      }
      ;
      function Ck(a) {
        var b = this, c = null;
        this.a = [];
        this.type = "indexedDB";
        this.c = a;
        this.b = E().then(function() {
          if (pk()) {
            var d2 = Qe(), e = "__sak" + d2;
            rk || (rk = new ok());
            c = rk;
            return c.set(e, d2).then(function() {
              return c.get(e);
            }).then(function(f) {
              if (f !== d2)
                throw Error("indexedDB not supported!");
              return c.U(e);
            }).then(function() {
              return c;
            }).o(function() {
              return b.c;
            });
          }
          return b.c;
        }).then(function(d2) {
          b.type = d2.type;
          d2.ca(function(e) {
            w(b.a, function(f) {
              f(e);
            });
          });
          return d2;
        });
      }
      k = Ck.prototype;
      k.get = function(a) {
        return this.b.then(function(b) {
          return b.get(a);
        });
      };
      k.set = function(a, b) {
        return this.b.then(function(c) {
          return c.set(a, b);
        });
      };
      k.U = function(a) {
        return this.b.then(function(b) {
          return b.U(a);
        });
      };
      k.ca = function(a) {
        this.a.push(a);
      };
      k.ia = function(a) {
        Xa(this.a, function(b) {
          return b == a;
        });
      };
      function Dk() {
        this.a = {};
        this.type = "inMemory";
      }
      k = Dk.prototype;
      k.get = function(a) {
        return E(this.a[a]);
      };
      k.set = function(a, b) {
        this.a[a] = b;
        return E();
      };
      k.U = function(a) {
        delete this.a[a];
        return E();
      };
      k.ca = function() {
      };
      k.ia = function() {
      };
      function Ek() {
        if (!Fk()) {
          if (Ke() == "Node")
            throw new t("internal-error", "The LocalStorage compatibility library was not found.");
          throw new t("web-storage-unsupported");
        }
        this.a = Gk() || firebase2.INTERNAL.node.localStorage;
        this.type = "localStorage";
      }
      function Gk() {
        try {
          var a = l.localStorage, b = Qe();
          a && (a.setItem(b, "1"), a.removeItem(b));
          return a;
        } catch (c) {
          return null;
        }
      }
      function Fk() {
        var a = Ke() == "Node";
        a = Gk() || a && firebase2.INTERNAL.node && firebase2.INTERNAL.node.localStorage;
        if (!a)
          return false;
        try {
          return a.setItem("__sak", "1"), a.removeItem("__sak"), true;
        } catch (b) {
          return false;
        }
      }
      k = Ek.prototype;
      k.get = function(a) {
        var b = this;
        return E().then(function() {
          var c = b.a.getItem(a);
          return We(c);
        });
      };
      k.set = function(a, b) {
        var c = this;
        return E().then(function() {
          var d2 = Ue(b);
          d2 === null ? c.U(a) : c.a.setItem(a, d2);
        });
      };
      k.U = function(a) {
        var b = this;
        return E().then(function() {
          b.a.removeItem(a);
        });
      };
      k.ca = function(a) {
        l.window && nd(l.window, "storage", a);
      };
      k.ia = function(a) {
        l.window && xd(l.window, "storage", a);
      };
      function Hk() {
        this.type = "nullStorage";
      }
      k = Hk.prototype;
      k.get = function() {
        return E(null);
      };
      k.set = function() {
        return E();
      };
      k.U = function() {
        return E();
      };
      k.ca = function() {
      };
      k.ia = function() {
      };
      function Ik() {
        if (!Jk()) {
          if (Ke() == "Node")
            throw new t("internal-error", "The SessionStorage compatibility library was not found.");
          throw new t("web-storage-unsupported");
        }
        this.a = Kk() || firebase2.INTERNAL.node.sessionStorage;
        this.type = "sessionStorage";
      }
      function Kk() {
        try {
          var a = l.sessionStorage, b = Qe();
          a && (a.setItem(b, "1"), a.removeItem(b));
          return a;
        } catch (c) {
          return null;
        }
      }
      function Jk() {
        var a = Ke() == "Node";
        a = Kk() || a && firebase2.INTERNAL.node && firebase2.INTERNAL.node.sessionStorage;
        if (!a)
          return false;
        try {
          return a.setItem("__sak", "1"), a.removeItem("__sak"), true;
        } catch (b) {
          return false;
        }
      }
      k = Ik.prototype;
      k.get = function(a) {
        var b = this;
        return E().then(function() {
          var c = b.a.getItem(a);
          return We(c);
        });
      };
      k.set = function(a, b) {
        var c = this;
        return E().then(function() {
          var d2 = Ue(b);
          d2 === null ? c.U(a) : c.a.setItem(a, d2);
        });
      };
      k.U = function(a) {
        var b = this;
        return E().then(function() {
          b.a.removeItem(a);
        });
      };
      k.ca = function() {
      };
      k.ia = function() {
      };
      function Lk() {
        var a = {};
        a.Browser = Mk;
        a.Node = Nk;
        a.ReactNative = Ok;
        a.Worker = Pk;
        this.a = a[Ke()];
      }
      var Qk, Mk = { F: Ek, cb: Ik }, Nk = { F: Ek, cb: Ik }, Ok = { F: fk, cb: Hk }, Pk = { F: Ek, cb: Hk };
      var Rk = { rd: "local", NONE: "none", td: "session" };
      function Sk(a) {
        var b = new t("invalid-persistence-type"), c = new t("unsupported-persistence-type");
        a: {
          for (d2 in Rk)
            if (Rk[d2] == a) {
              var d2 = true;
              break a;
            }
          d2 = false;
        }
        if (!d2 || typeof a !== "string")
          throw b;
        switch (Ke()) {
          case "ReactNative":
            if (a === "session")
              throw c;
            break;
          case "Node":
            if (a !== "none")
              throw c;
            break;
          case "Worker":
            if (a === "session" || !pk() && a !== "none")
              throw c;
            break;
          default:
            if (!Pe() && a !== "none")
              throw c;
        }
      }
      function Tk() {
        var a = !Xe(K()) && Ie() ? true : false, b = Te(), c = Pe();
        this.m = a;
        this.h = b;
        this.l = c;
        this.a = {};
        Qk || (Qk = new Lk());
        a = Qk;
        try {
          this.g = !qe() && cf() || !l.indexedDB ? new a.a.F() : new Ck(Je() ? new Dk() : new a.a.F());
        } catch (d2) {
          this.g = new Dk(), this.h = true;
        }
        try {
          this.i = new a.a.cb();
        } catch (d2) {
          this.i = new Dk();
        }
        this.v = new Dk();
        this.f = q(this.Zb, this);
        this.b = {};
      }
      var Uk;
      function Vk() {
        Uk || (Uk = new Tk());
        return Uk;
      }
      function Wk(a, b) {
        switch (b) {
          case "session":
            return a.i;
          case "none":
            return a.v;
          default:
            return a.g;
        }
      }
      function Xk(a, b) {
        return "firebase:" + a.name + (b ? ":" + b : "");
      }
      function Yk(a, b, c) {
        var d2 = Xk(b, c), e = Wk(a, b.F);
        return a.get(b, c).then(function(f) {
          var g = null;
          try {
            g = We(l.localStorage.getItem(d2));
          } catch (h) {
          }
          if (g && !f)
            return l.localStorage.removeItem(d2), a.set(b, g, c);
          g && f && e.type != "localStorage" && l.localStorage.removeItem(d2);
        });
      }
      k = Tk.prototype;
      k.get = function(a, b) {
        return Wk(this, a.F).get(Xk(a, b));
      };
      function Zk(a, b, c) {
        c = Xk(b, c);
        b.F == "local" && (a.b[c] = null);
        return Wk(a, b.F).U(c);
      }
      k.set = function(a, b, c) {
        var d2 = Xk(a, c), e = this, f = Wk(this, a.F);
        return f.set(d2, b).then(function() {
          return f.get(d2);
        }).then(function(g) {
          a.F == "local" && (e.b[d2] = g);
        });
      };
      k.addListener = function(a, b, c) {
        a = Xk(a, b);
        this.l && (this.b[a] = l.localStorage.getItem(a));
        mb(this.a) && (Wk(this, "local").ca(this.f), this.h || (qe() || !cf()) && l.indexedDB || !this.l || $k(this));
        this.a[a] || (this.a[a] = []);
        this.a[a].push(c);
      };
      k.removeListener = function(a, b, c) {
        a = Xk(a, b);
        this.a[a] && (Xa(this.a[a], function(d2) {
          return d2 == c;
        }), this.a[a].length == 0 && delete this.a[a]);
        mb(this.a) && (Wk(this, "local").ia(this.f), al(this));
      };
      function $k(a) {
        al(a);
        a.c = setInterval(function() {
          for (var b in a.a) {
            var c = l.localStorage.getItem(b), d2 = a.b[b];
            c != d2 && (a.b[b] = c, c = new bd({ type: "storage", key: b, target: window, oldValue: d2, newValue: c, a: true }), a.Zb(c));
          }
        }, 1e3);
      }
      function al(a) {
        a.c && (clearInterval(a.c), a.c = null);
      }
      k.Zb = function(a) {
        if (a && a.g) {
          var b = a.a.key;
          if (b == null)
            for (var c in this.a) {
              var d2 = this.b[c];
              typeof d2 === "undefined" && (d2 = null);
              var e = l.localStorage.getItem(c);
              e !== d2 && (this.b[c] = e, this.nb(c));
            }
          else if (b.indexOf("firebase:") == 0 && this.a[b]) {
            typeof a.a.a !== "undefined" ? Wk(this, "local").ia(this.f) : al(this);
            if (this.m) {
              if (c = l.localStorage.getItem(b), d2 = a.a.newValue, d2 !== c)
                d2 !== null ? l.localStorage.setItem(b, d2) : l.localStorage.removeItem(b);
              else if (this.b[b] === d2 && typeof a.a.a === "undefined")
                return;
            }
            var f = this;
            c = function() {
              if (typeof a.a.a !== "undefined" || f.b[b] !== l.localStorage.getItem(b))
                f.b[b] = l.localStorage.getItem(b), f.nb(b);
            };
            Wb && ic && ic == 10 && l.localStorage.getItem(b) !== a.a.newValue && a.a.newValue !== a.a.oldValue ? setTimeout(c, 10) : c();
          }
        } else
          w(a, q(this.nb, this));
      };
      k.nb = function(a) {
        this.a[a] && w(this.a[a], function(b) {
          b();
        });
      };
      function bl(a) {
        this.a = a;
        this.b = Vk();
      }
      var cl = { name: "authEvent", F: "local" };
      function dl(a) {
        return a.b.get(cl, a.a).then(function(b) {
          return th(b);
        });
      }
      ;
      function el() {
        this.a = Vk();
      }
      ;
      function fl() {
        this.b = -1;
      }
      ;
      function gl(a, b) {
        this.b = hl;
        this.f = l.Uint8Array ? new Uint8Array(this.b) : Array(this.b);
        this.g = this.c = 0;
        this.a = [];
        this.i = a;
        this.h = b;
        this.l = l.Int32Array ? new Int32Array(64) : Array(64);
        il === void 0 && (l.Int32Array ? il = new Int32Array(jl) : il = jl);
        this.reset();
      }
      var il;
      r(gl, fl);
      for (var hl = 64, kl = hl - 1, ll = [], ml = 0; ml < kl; ml++)
        ll[ml] = 0;
      var nl = Ya(128, ll);
      gl.prototype.reset = function() {
        this.g = this.c = 0;
        this.a = l.Int32Array ? new Int32Array(this.h) : Za(this.h);
      };
      function ol(a) {
        for (var b = a.f, c = a.l, d2 = 0, e = 0; e < b.length; )
          c[d2++] = b[e] << 24 | b[e + 1] << 16 | b[e + 2] << 8 | b[e + 3], e = 4 * d2;
        for (b = 16; 64 > b; b++) {
          e = c[b - 15] | 0;
          d2 = c[b - 2] | 0;
          var f = (c[b - 16] | 0) + ((e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3) | 0, g = (c[b - 7] | 0) + ((d2 >>> 17 | d2 << 15) ^ (d2 >>> 19 | d2 << 13) ^ d2 >>> 10) | 0;
          c[b] = f + g | 0;
        }
        d2 = a.a[0] | 0;
        e = a.a[1] | 0;
        var h = a.a[2] | 0, m = a.a[3] | 0, p = a.a[4] | 0, v = a.a[5] | 0, B = a.a[6] | 0;
        f = a.a[7] | 0;
        for (b = 0; 64 > b; b++) {
          var A = ((d2 >>> 2 | d2 << 30) ^ (d2 >>> 13 | d2 << 19) ^ (d2 >>> 22 | d2 << 10)) + (d2 & e ^ d2 & h ^ e & h) | 0;
          g = p & v ^ ~p & B;
          f = f + ((p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7)) | 0;
          g = g + (il[b] | 0) | 0;
          g = f + (g + (c[b] | 0) | 0) | 0;
          f = B;
          B = v;
          v = p;
          p = m + g | 0;
          m = h;
          h = e;
          e = d2;
          d2 = g + A | 0;
        }
        a.a[0] = a.a[0] + d2 | 0;
        a.a[1] = a.a[1] + e | 0;
        a.a[2] = a.a[2] + h | 0;
        a.a[3] = a.a[3] + m | 0;
        a.a[4] = a.a[4] + p | 0;
        a.a[5] = a.a[5] + v | 0;
        a.a[6] = a.a[6] + B | 0;
        a.a[7] = a.a[7] + f | 0;
      }
      function pl(a, b, c) {
        c === void 0 && (c = b.length);
        var d2 = 0, e = a.c;
        if (typeof b === "string")
          for (; d2 < c; )
            a.f[e++] = b.charCodeAt(d2++), e == a.b && (ol(a), e = 0);
        else if (na(b))
          for (; d2 < c; ) {
            var f = b[d2++];
            if (!(typeof f == "number" && 0 <= f && 255 >= f && f == (f | 0)))
              throw Error("message must be a byte array");
            a.f[e++] = f;
            e == a.b && (ol(a), e = 0);
          }
        else
          throw Error("message must be string or array");
        a.c = e;
        a.g += c;
      }
      var jl = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function ql() {
        gl.call(this, 8, rl);
      }
      r(ql, gl);
      var rl = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
      function sl(a, b, c, d2, e, f) {
        this.v = a;
        this.i = b;
        this.l = c;
        this.m = d2 || null;
        this.u = e || null;
        this.s = f;
        this.h = b + ":" + c;
        this.C = new el();
        this.g = new bl(this.h);
        this.f = null;
        this.b = [];
        this.a = this.c = null;
      }
      function tl(a) {
        return new t("invalid-cordova-configuration", a);
      }
      k = sl.prototype;
      k.ma = function() {
        return this.Ia ? this.Ia : this.Ia = Fe().then(function() {
          if (typeof L("universalLinks.subscribe", l) !== "function")
            throw tl("cordova-universal-links-plugin-fix is not installed");
          if (typeof L("BuildInfo.packageName", l) === "undefined")
            throw tl("cordova-plugin-buildinfo is not installed");
          if (typeof L("cordova.plugins.browsertab.openUrl", l) !== "function")
            throw tl("cordova-plugin-browsertab is not installed");
          if (typeof L("cordova.InAppBrowser.open", l) !== "function")
            throw tl("cordova-plugin-inappbrowser is not installed");
        }, function() {
          throw new t("cordova-not-ready");
        });
      };
      function ul() {
        for (var a = 20, b = []; 0 < a; )
          b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), a--;
        return b.join("");
      }
      function vl(a) {
        var b = new ql();
        pl(b, a);
        a = [];
        var c = 8 * b.g;
        56 > b.c ? pl(b, nl, 56 - b.c) : pl(b, nl, b.b - (b.c - 56));
        for (var d2 = 63; 56 <= d2; d2--)
          b.f[d2] = c & 255, c /= 256;
        ol(b);
        for (d2 = c = 0; d2 < b.i; d2++)
          for (var e = 24; 0 <= e; e -= 8)
            a[c++] = b.a[d2] >> e & 255;
        return cg(a);
      }
      k.Pb = function(a, b) {
        b(new t("operation-not-supported-in-this-environment"));
        return E();
      };
      k.Nb = function() {
        return F(new t("operation-not-supported-in-this-environment"));
      };
      k.ac = function() {
        return false;
      };
      k.Yb = function() {
        return true;
      };
      k.Ub = function() {
        return true;
      };
      k.Ob = function(a, b, c, d2) {
        if (this.c)
          return F(new t("redirect-operation-pending"));
        var e = this, f = l.document, g = null, h = null, m = null, p = null;
        return this.c = E().then(function() {
          rh(b);
          return wl(e);
        }).then(function() {
          return xl(e, a, b, c, d2);
        }).then(function() {
          return new D(function(v, B) {
            h = function() {
              var A = L("cordova.plugins.browsertab.close", l);
              v();
              typeof A === "function" && A();
              e.a && typeof e.a.close === "function" && (e.a.close(), e.a = null);
              return false;
            };
            e.Ea(h);
            m = function() {
              g || (g = Fd(2e3).then(function() {
                B(new t("redirect-cancelled-by-user"));
              }));
            };
            p = function() {
              $e() && m();
            };
            f.addEventListener("resume", m, false);
            K().toLowerCase().match(/android/) || f.addEventListener("visibilitychange", p, false);
          }).o(function(v) {
            return yl(e).then(function() {
              throw v;
            });
          });
        }).oa(function() {
          m && f.removeEventListener("resume", m, false);
          p && f.removeEventListener("visibilitychange", p, false);
          g && g.cancel();
          h && e.Ta(h);
          e.c = null;
        });
      };
      function xl(a, b, c, d2, e) {
        var f = ul(), g = new sh(b, d2, null, f, new t("no-auth-event"), null, e), h = L("BuildInfo.packageName", l);
        if (typeof h !== "string")
          throw new t("invalid-cordova-configuration");
        var m = L("BuildInfo.displayName", l), p = {};
        if (K().toLowerCase().match(/iphone|ipad|ipod/))
          p.ibi = h;
        else if (K().toLowerCase().match(/android/))
          p.apn = h;
        else
          return F(new t("operation-not-supported-in-this-environment"));
        m && (p.appDisplayName = m);
        f = vl(f);
        p.sessionId = f;
        var v = ek(a.v, a.i, a.l, b, c, null, d2, a.m, p, a.u, e, a.s);
        return a.ma().then(function() {
          var B = a.h;
          return a.C.a.set(cl, g.w(), B);
        }).then(function() {
          var B = L("cordova.plugins.browsertab.isAvailable", l);
          if (typeof B !== "function")
            throw new t("invalid-cordova-configuration");
          var A = null;
          B(function(Q) {
            if (Q) {
              A = L("cordova.plugins.browsertab.openUrl", l);
              if (typeof A !== "function")
                throw new t("invalid-cordova-configuration");
              A(v);
            } else {
              A = L("cordova.InAppBrowser.open", l);
              if (typeof A !== "function")
                throw new t("invalid-cordova-configuration");
              Q = K();
              a.a = A(v, Q.match(/(iPad|iPhone|iPod).*OS 7_\d/i) || Q.match(/(iPad|iPhone|iPod).*OS 8_\d/i) ? "_blank" : "_system", "location=yes");
            }
          });
        });
      }
      function zl(a, b) {
        for (var c = 0; c < a.b.length; c++)
          try {
            a.b[c](b);
          } catch (d2) {
          }
      }
      function wl(a) {
        a.f || (a.f = a.ma().then(function() {
          return new D(function(b) {
            function c(d2) {
              b(d2);
              a.Ta(c);
              return false;
            }
            a.Ea(c);
            Al(a);
          });
        }));
        return a.f;
      }
      function yl(a) {
        var b = null;
        return dl(a.g).then(function(c) {
          b = c;
          c = a.g;
          return Zk(c.b, cl, c.a);
        }).then(function() {
          return b;
        });
      }
      function Al(a) {
        function b(g) {
          d2 = true;
          e && e.cancel();
          yl(a).then(function(h) {
            var m = c;
            if (h && g && g.url) {
              var p = null;
              m = xg(g.url);
              m.indexOf("/__/auth/callback") != -1 && (p = J(m), p = We(be(p, "firebaseError") || null), p = (p = typeof p === "object" ? Aa(p) : null) ? new sh(h.c, h.b, null, null, p, null, h.T()) : new sh(h.c, h.b, m, h.f, null, null, h.T()));
              m = p || c;
            }
            zl(a, m);
          });
        }
        var c = new sh("unknown", null, null, null, new t("no-auth-event")), d2 = false, e = Fd(500).then(function() {
          return yl(a).then(function() {
            d2 || zl(a, c);
          });
        }), f = l.handleOpenURL;
        l.handleOpenURL = function(g) {
          g.toLowerCase().indexOf(L("BuildInfo.packageName", l).toLowerCase() + "://") == 0 && b({ url: g });
          if (typeof f === "function")
            try {
              f(g);
            } catch (h) {
              console.error(h);
            }
        };
        vh || (vh = new uh());
        wh(b);
      }
      k.Ea = function(a) {
        this.b.push(a);
        wl(this).o(function(b) {
          b.code === "auth/invalid-cordova-configuration" && (b = new sh("unknown", null, null, null, new t("no-auth-event")), a(b));
        });
      };
      k.Ta = function(a) {
        Xa(this.b, function(b) {
          return b == a;
        });
      };
      function Bl(a) {
        this.a = a;
        this.b = Vk();
      }
      var Cl = { name: "pendingRedirect", F: "session" };
      function Dl(a) {
        return a.b.set(Cl, "pending", a.a);
      }
      function El(a) {
        return Zk(a.b, Cl, a.a);
      }
      function Fl(a) {
        return a.b.get(Cl, a.a).then(function(b) {
          return b == "pending";
        });
      }
      ;
      function Gl(a, b, c, d2) {
        this.i = {};
        this.u = 0;
        this.D = a;
        this.v = b;
        this.m = c;
        this.J = d2;
        this.h = [];
        this.f = false;
        this.l = q(this.s, this);
        this.b = new Hl();
        this.C = new Il();
        this.g = new Bl(Jl(this.v, this.m));
        this.c = {};
        this.c.unknown = this.b;
        this.c.signInViaRedirect = this.b;
        this.c.linkViaRedirect = this.b;
        this.c.reauthViaRedirect = this.b;
        this.c.signInViaPopup = this.C;
        this.c.linkViaPopup = this.C;
        this.c.reauthViaPopup = this.C;
        this.a = Kl(this.D, this.v, this.m, Da, this.J);
      }
      function Kl(a, b, c, d2, e) {
        var f = firebase2.SDK_VERSION || null;
        return Ge() ? new sl(a, b, c, f, d2, e) : new Yj(a, b, c, f, d2, e);
      }
      Gl.prototype.reset = function() {
        this.f = false;
        this.a.Ta(this.l);
        this.a = Kl(this.D, this.v, this.m, null, this.J);
        this.i = {};
      };
      function Ll(a) {
        a.f || (a.f = true, a.a.Ea(a.l));
        var b = a.a;
        return a.a.ma().o(function(c) {
          a.a == b && a.reset();
          throw c;
        });
      }
      function Ml(a) {
        a.a.Yb() && Ll(a).o(function(b) {
          var c = new sh("unknown", null, null, null, new t("operation-not-supported-in-this-environment"));
          Nl(b) && a.s(c);
        });
        a.a.Ub() || Ol(a.b);
      }
      function Pl(a, b) {
        Va(a.h, b) || a.h.push(b);
        a.f || Fl(a.g).then(function(c) {
          c ? El(a.g).then(function() {
            Ll(a).o(function(d2) {
              var e = new sh("unknown", null, null, null, new t("operation-not-supported-in-this-environment"));
              Nl(d2) && a.s(e);
            });
          }) : Ml(a);
        }).o(function() {
          Ml(a);
        });
      }
      function Ql(a, b) {
        Xa(a.h, function(c) {
          return c == b;
        });
      }
      Gl.prototype.s = function(a) {
        if (!a)
          throw new t("invalid-auth-event");
        6e5 <= Date.now() - this.u && (this.i = {}, this.u = 0);
        if (a && a.getUid() && this.i.hasOwnProperty(a.getUid()))
          return false;
        for (var b = false, c = 0; c < this.h.length; c++) {
          var d2 = this.h[c];
          if (d2.Gb(a.c, a.b)) {
            if (b = this.c[a.c])
              b.h(a, d2), a && (a.f || a.b) && (this.i[a.getUid()] = true, this.u = Date.now());
            b = true;
            break;
          }
        }
        Ol(this.b);
        return b;
      };
      var Rl = new Ze(2e3, 1e4), Sl = new Ze(3e4, 6e4);
      Gl.prototype.ra = function() {
        return this.b.ra();
      };
      function Tl(a, b, c, d2, e, f, g) {
        return a.a.Nb(b, c, d2, function() {
          a.f || (a.f = true, a.a.Ea(a.l));
        }, function() {
          a.reset();
        }, e, f, g);
      }
      function Nl(a) {
        return a && a.code == "auth/cordova-not-ready" ? true : false;
      }
      function Ul(a, b, c, d2, e) {
        var f;
        return Dl(a.g).then(function() {
          return a.a.Ob(b, c, d2, e).o(function(g) {
            if (Nl(g))
              throw new t("operation-not-supported-in-this-environment");
            f = g;
            return El(a.g).then(function() {
              throw f;
            });
          }).then(function() {
            return a.a.ac() ? new D(function() {
            }) : El(a.g).then(function() {
              return a.ra();
            }).then(function() {
            }).o(function() {
            });
          });
        });
      }
      function Vl(a, b, c, d2, e) {
        return a.a.Pb(d2, function(f) {
          b.na(c, null, f, e);
        }, Rl.get());
      }
      var Wl = {};
      function Jl(a, b, c) {
        a = a + ":" + b;
        c && (a = a + ":" + c.url);
        return a;
      }
      function Xl(a, b, c, d2) {
        var e = Jl(b, c, d2);
        Wl[e] || (Wl[e] = new Gl(a, b, c, d2));
        return Wl[e];
      }
      function Hl() {
        this.b = null;
        this.f = [];
        this.c = [];
        this.a = null;
        this.i = this.g = false;
      }
      Hl.prototype.reset = function() {
        this.b = null;
        this.a && (this.a.cancel(), this.a = null);
      };
      Hl.prototype.h = function(a, b) {
        if (a) {
          this.reset();
          this.g = true;
          var c = a.c, d2 = a.b, e = a.a && a.a.code == "auth/web-storage-unsupported", f = a.a && a.a.code == "auth/operation-not-supported-in-this-environment";
          this.i = !(!e && !f);
          c != "unknown" || e || f ? a.a ? (Yl(this, true, null, a.a), E()) : b.Fa(c, d2) ? Zl(this, a, b) : F(new t("invalid-auth-event")) : (Yl(this, false, null, null), E());
        } else
          F(new t("invalid-auth-event"));
      };
      function Ol(a) {
        a.g || (a.g = true, Yl(a, false, null, null));
      }
      function $l(a) {
        a.g && !a.i && Yl(a, false, null, null);
      }
      function Zl(a, b, c) {
        c = c.Fa(b.c, b.b);
        var d2 = b.g, e = b.f, f = b.i, g = b.T(), h = !!b.c.match(/Redirect$/);
        c(d2, e, g, f).then(function(m) {
          Yl(a, h, m, null);
        }).o(function(m) {
          Yl(a, h, null, m);
        });
      }
      function am(a, b) {
        a.b = function() {
          return F(b);
        };
        if (a.c.length)
          for (var c = 0; c < a.c.length; c++)
            a.c[c](b);
      }
      function bm(a, b) {
        a.b = function() {
          return E(b);
        };
        if (a.f.length)
          for (var c = 0; c < a.f.length; c++)
            a.f[c](b);
      }
      function Yl(a, b, c, d2) {
        b ? d2 ? am(a, d2) : bm(a, c) : bm(a, { user: null });
        a.f = [];
        a.c = [];
      }
      Hl.prototype.ra = function() {
        var a = this;
        return new D(function(b, c) {
          a.b ? a.b().then(b, c) : (a.f.push(b), a.c.push(c), cm(a));
        });
      };
      function cm(a) {
        var b = new t("timeout");
        a.a && a.a.cancel();
        a.a = Fd(Sl.get()).then(function() {
          a.b || (a.g = true, Yl(a, true, null, b));
        });
      }
      function Il() {
      }
      Il.prototype.h = function(a, b) {
        if (a) {
          var c = a.c, d2 = a.b;
          a.a ? (b.na(a.c, null, a.a, a.b), E()) : b.Fa(c, d2) ? dm(a, b) : F(new t("invalid-auth-event"));
        } else
          F(new t("invalid-auth-event"));
      };
      function dm(a, b) {
        var c = a.b, d2 = a.c;
        b.Fa(d2, c)(a.g, a.f, a.T(), a.i).then(function(e) {
          b.na(d2, e, null, c);
        }).o(function(e) {
          b.na(d2, null, e, c);
        });
      }
      ;
      function em() {
        this.jb = false;
        Object.defineProperty(this, "appVerificationDisabled", { get: function() {
          return this.jb;
        }, set: function(a) {
          this.jb = a;
        }, enumerable: false });
      }
      ;
      function fm(a, b) {
        this.a = b;
        M(this, "verificationId", a);
      }
      fm.prototype.confirm = function(a) {
        a = ph(this.verificationId, a);
        return this.a(a);
      };
      function gm(a, b, c, d2) {
        return new lh(a).gb(b, c).then(function(e) {
          return new fm(e, d2);
        });
      }
      ;
      function hm(a) {
        var b = ig(a);
        if (!(b && b.exp && b.auth_time && b.iat))
          throw new t("internal-error", "An internal error occurred. The token obtained by Firebase appears to be malformed. Please retry the operation.");
        N(this, { token: a, expirationTime: bf(1e3 * b.exp), authTime: bf(1e3 * b.auth_time), issuedAtTime: bf(1e3 * b.iat), signInProvider: b.firebase && b.firebase.sign_in_provider ? b.firebase.sign_in_provider : null, signInSecondFactor: b.firebase && b.firebase.sign_in_second_factor ? b.firebase.sign_in_second_factor : null, claims: b });
      }
      ;
      function im(a, b, c) {
        var d2 = b && b[jm];
        if (!d2)
          throw new t("argument-error", "Internal assert: Invalid MultiFactorResolver");
        this.a = a;
        this.f = nb(b);
        this.g = c;
        this.c = new yg(null, d2);
        this.b = [];
        var e = this;
        w(b[km] || [], function(f) {
          (f = tf(f)) && e.b.push(f);
        });
        M(this, "auth", this.a);
        M(this, "session", this.c);
        M(this, "hints", this.b);
      }
      var km = "mfaInfo", jm = "mfaPendingCredential";
      im.prototype.Rc = function(a) {
        var b = this;
        return a.tb(this.a.a, this.c).then(function(c) {
          var d2 = nb(b.f);
          delete d2[km];
          delete d2[jm];
          z(d2, c);
          return b.g(d2);
        });
      };
      function lm(a, b, c, d2) {
        t.call(this, "multi-factor-auth-required", d2, b);
        this.b = new im(a, b, c);
        M(this, "resolver", this.b);
      }
      r(lm, t);
      function mm(a, b, c) {
        if (a && n(a.serverResponse) && a.code === "auth/multi-factor-auth-required")
          try {
            return new lm(b, a.serverResponse, c, a.message);
          } catch (d2) {
          }
        return null;
      }
      ;
      function nm() {
      }
      nm.prototype.tb = function(a, b, c) {
        return b.type == zg ? om(this, a, b, c) : pm(this, a, b);
      };
      function om(a, b, c, d2) {
        return c.Ha().then(function(e) {
          e = { idToken: e };
          typeof d2 !== "undefined" && (e.displayName = d2);
          z(e, { phoneVerificationInfo: hh(a.a) });
          return O(b, Gj, e);
        });
      }
      function pm(a, b, c) {
        return c.Ha().then(function(d2) {
          d2 = { mfaPendingCredential: d2 };
          z(d2, { phoneVerificationInfo: hh(a.a) });
          return O(b, Hj, d2);
        });
      }
      function qm(a) {
        M(this, "factorId", a.fa);
        this.a = a;
      }
      r(qm, nm);
      function rm(a) {
        qm.call(this, a);
        if (this.a.fa != lh.PROVIDER_ID)
          throw new t("argument-error", "firebase.auth.PhoneMultiFactorAssertion requires a valid firebase.auth.PhoneAuthCredential");
      }
      r(rm, qm);
      function sm(a, b) {
        G.call(this, a);
        for (var c in b)
          this[c] = b[c];
      }
      r(sm, G);
      function tm(a, b) {
        this.a = a;
        this.b = [];
        this.c = q(this.yc, this);
        nd(this.a, "userReloaded", this.c);
        var c = [];
        b && b.multiFactor && b.multiFactor.enrolledFactors && w(b.multiFactor.enrolledFactors, function(d2) {
          var e = null, f = {};
          if (d2) {
            d2.uid && (f[qf] = d2.uid);
            d2.displayName && (f[rf] = d2.displayName);
            d2.enrollmentTime && (f[sf] = new Date(d2.enrollmentTime).toISOString());
            d2.phoneNumber && (f[pf] = d2.phoneNumber);
            try {
              e = new uf(f);
            } catch (g) {
            }
            d2 = e;
          } else
            d2 = null;
          d2 && c.push(d2);
        });
        um(this, c);
      }
      function vm(a) {
        var b = [];
        w(a.mfaInfo || [], function(c) {
          (c = tf(c)) && b.push(c);
        });
        return b;
      }
      k = tm.prototype;
      k.yc = function(a) {
        um(this, vm(a.hd));
      };
      function um(a, b) {
        a.b = b;
        M(a, "enrolledFactors", b);
      }
      k.Sb = function() {
        return this.a.I().then(function(a) {
          return new yg(a, null);
        });
      };
      k.fc = function(a, b) {
        var c = this, d2 = this.a.a;
        return this.Sb().then(function(e) {
          return a.tb(d2, e, b);
        }).then(function(e) {
          wm2(c.a, e);
          return c.a.reload();
        });
      };
      k.bd = function(a) {
        var b = this, c = typeof a === "string" ? a : a.uid, d2 = this.a.a;
        return this.a.I().then(function(e) {
          return O(d2, Lj, { idToken: e, mfaEnrollmentId: c });
        }).then(function(e) {
          var f = Qa(b.b, function(g) {
            return g.uid != c;
          });
          um(b, f);
          wm2(b.a, e);
          return b.a.reload().o(function(g) {
            if (g.code != "auth/user-token-expired")
              throw g;
          });
        });
      };
      k.w = function() {
        return { multiFactor: { enrolledFactors: Ra(this.b, function(a) {
          return a.w();
        }) } };
      };
      function xm(a, b, c) {
        this.h = a;
        this.i = b;
        this.g = c;
        this.c = 3e4;
        this.f = 96e4;
        this.b = null;
        this.a = this.c;
        if (this.f < this.c)
          throw Error("Proactive refresh lower bound greater than upper bound!");
      }
      xm.prototype.start = function() {
        this.a = this.c;
        ym(this, true);
      };
      function zm(a, b) {
        if (b)
          return a.a = a.c, a.g();
        b = a.a;
        a.a *= 2;
        a.a > a.f && (a.a = a.f);
        return b;
      }
      function ym(a, b) {
        a.stop();
        a.b = Fd(zm(a, b)).then(function() {
          return af();
        }).then(function() {
          return a.h();
        }).then(function() {
          ym(a, true);
        }).o(function(c) {
          a.i(c) && ym(a, false);
        });
      }
      xm.prototype.stop = function() {
        this.b && (this.b.cancel(), this.b = null);
      };
      function Am(a) {
        this.f = a;
        this.b = this.a = null;
        this.c = Date.now();
      }
      Am.prototype.w = function() {
        return { apiKey: this.f.c, refreshToken: this.a, accessToken: this.b && this.b.toString(), expirationTime: this.c };
      };
      function Bm(a, b) {
        typeof b === "undefined" && (a.b ? (b = a.b, b = b.a - b.g) : b = 0);
        a.c = Date.now() + 1e3 * b;
      }
      function Cm(a, b) {
        a.b = jg(b[Dg] || "");
        a.a = b.refreshToken;
        b = b.expiresIn;
        Bm(a, typeof b !== "undefined" ? Number(b) : void 0);
      }
      function Dm(a, b) {
        a.b = b.b;
        a.a = b.a;
        a.c = b.c;
      }
      function Em(a, b) {
        return Wi(a.f, b).then(function(c) {
          a.b = jg(c.access_token);
          a.a = c.refresh_token;
          Bm(a, c.expires_in);
          return { accessToken: a.b.toString(), refreshToken: a.a };
        }).o(function(c) {
          c.code == "auth/user-token-expired" && (a.a = null);
          throw c;
        });
      }
      Am.prototype.getToken = function(a) {
        a = !!a;
        return this.b && !this.a ? F(new t("user-token-expired")) : a || !this.b || Date.now() > this.c - 3e4 ? this.a ? Em(this, { grant_type: "refresh_token", refresh_token: this.a }) : E(null) : E({ accessToken: this.b.toString(), refreshToken: this.a });
      };
      function Fm(a, b) {
        this.a = a || null;
        this.b = b || null;
        N(this, { lastSignInTime: bf(b || null), creationTime: bf(a || null) });
      }
      function Gm(a) {
        return new Fm(a.a, a.b);
      }
      Fm.prototype.w = function() {
        return { lastLoginAt: this.b, createdAt: this.a };
      };
      function Hm(a, b, c, d2, e, f) {
        N(this, { uid: a, displayName: d2 || null, photoURL: e || null, email: c || null, phoneNumber: f || null, providerId: b });
      }
      function Im(a, b, c) {
        this.N = [];
        this.l = a.apiKey;
        this.m = a.appName;
        this.s = a.authDomain || null;
        var d2 = firebase2.SDK_VERSION ? Oe(firebase2.SDK_VERSION) : null;
        this.a = new Ii(this.l, Ca(Da), d2);
        (this.u = a.emulatorConfig || null) && Pi(this.a, this.u);
        this.h = new Am(this.a);
        Jm(this, b[Dg]);
        Cm(this.h, b);
        M(this, "refreshToken", this.h.a);
        Km(this, c || {});
        H.call(this);
        this.P = false;
        this.s && Re() && (this.b = Xl(this.s, this.l, this.m, this.u));
        this.W = [];
        this.i = null;
        this.D = Lm(this);
        this.ba = q(this.ib, this);
        var e = this;
        this.za = null;
        this.Pa = function(f) {
          e.xa(f.h);
        };
        this.qa = null;
        this.Ba = function(f) {
          Mm(e, f.c);
        };
        this.$ = null;
        this.aa = [];
        this.Oa = function(f) {
          Nm(e, f.f);
        };
        this.ja = null;
        this.S = new tm(this, c);
        M(this, "multiFactor", this.S);
      }
      r(Im, H);
      Im.prototype.xa = function(a) {
        this.za = a;
        Oi(this.a, a);
      };
      function Mm(a, b) {
        a.u = b;
        Pi(a.a, b);
        a.b && (b = a.b, a.b = Xl(a.s, a.l, a.m, a.u), a.P && (Ql(b, a), Pl(a.b, a)));
      }
      Im.prototype.la = function() {
        return this.za;
      };
      function Om(a, b) {
        a.qa && xd(a.qa, "languageCodeChanged", a.Pa);
        (a.qa = b) && nd(b, "languageCodeChanged", a.Pa);
      }
      function Pm(a, b) {
        a.$ && xd(a.$, "emulatorConfigChanged", a.Ba);
        (a.$ = b) && nd(b, "emulatorConfigChanged", a.Ba);
      }
      function Nm(a, b) {
        a.aa = b;
        Ri(a.a, firebase2.SDK_VERSION ? Oe(firebase2.SDK_VERSION, a.aa) : null);
      }
      Im.prototype.Ga = function() {
        return Za(this.aa);
      };
      function Qm(a, b) {
        a.ja && xd(a.ja, "frameworkChanged", a.Oa);
        (a.ja = b) && nd(b, "frameworkChanged", a.Oa);
      }
      Im.prototype.ib = function() {
        this.D.b && (this.D.stop(), this.D.start());
      };
      function Rm(a) {
        try {
          return firebase2.app(a.m).auth();
        } catch (b) {
          throw new t("internal-error", "No firebase.auth.Auth instance is available for the Firebase App '" + a.m + "'!");
        }
      }
      function Lm(a) {
        return new xm(function() {
          return a.I(true);
        }, function(b) {
          return b && b.code == "auth/network-request-failed" ? true : false;
        }, function() {
          var b = a.h.c - Date.now() - 3e5;
          return 0 < b ? b : 0;
        });
      }
      function Sm(a) {
        a.J || a.D.b || (a.D.start(), xd(a, "tokenChanged", a.ba), nd(a, "tokenChanged", a.ba));
      }
      function Tm(a) {
        xd(a, "tokenChanged", a.ba);
        a.D.stop();
      }
      function Jm(a, b) {
        a.Aa = b;
        M(a, "_lat", b);
      }
      function Um(a, b) {
        Xa(a.W, function(c) {
          return c == b;
        });
      }
      function Vm(a) {
        for (var b = [], c = 0; c < a.W.length; c++)
          b.push(a.W[c](a));
        return Jc(b).then(function() {
          return a;
        });
      }
      function Wm(a) {
        a.b && !a.P && (a.P = true, Pl(a.b, a));
      }
      function Km(a, b) {
        N(a, { uid: b.uid, displayName: b.displayName || null, photoURL: b.photoURL || null, email: b.email || null, emailVerified: b.emailVerified || false, phoneNumber: b.phoneNumber || null, isAnonymous: b.isAnonymous || false, tenantId: b.tenantId || null, metadata: new Fm(b.createdAt, b.lastLoginAt), providerData: [] });
        a.a.b = a.tenantId;
      }
      M(Im.prototype, "providerId", "firebase");
      function Xm() {
      }
      function Ym(a) {
        return E().then(function() {
          if (a.J)
            throw new t("app-deleted");
        });
      }
      function Zm(a) {
        return Ra(a.providerData, function(b) {
          return b.providerId;
        });
      }
      function $m(a, b) {
        b && (an(a, b.providerId), a.providerData.push(b));
      }
      function an(a, b) {
        Xa(a.providerData, function(c) {
          return c.providerId == b;
        });
      }
      function bn(a, b, c) {
        (b != "uid" || c) && a.hasOwnProperty(b) && M(a, b, c);
      }
      function cn(a, b) {
        a != b && (N(a, { uid: b.uid, displayName: b.displayName, photoURL: b.photoURL, email: b.email, emailVerified: b.emailVerified, phoneNumber: b.phoneNumber, isAnonymous: b.isAnonymous, tenantId: b.tenantId, providerData: [] }), b.metadata ? M(a, "metadata", Gm(b.metadata)) : M(a, "metadata", new Fm()), w(b.providerData, function(c) {
          $m(a, c);
        }), Dm(a.h, b.h), M(a, "refreshToken", a.h.a), um(a.S, b.S.b));
      }
      k = Im.prototype;
      k.reload = function() {
        var a = this;
        return R(this, Ym(this).then(function() {
          return dn(a).then(function() {
            return Vm(a);
          }).then(Xm);
        }));
      };
      function dn(a) {
        return a.I().then(function(b) {
          var c = a.isAnonymous;
          return en(a, b).then(function() {
            c || bn(a, "isAnonymous", false);
            return b;
          });
        });
      }
      k.oc = function(a) {
        return this.I(a).then(function(b) {
          return new hm(b);
        });
      };
      k.I = function(a) {
        var b = this;
        return R(this, Ym(this).then(function() {
          return b.h.getToken(a);
        }).then(function(c) {
          if (!c)
            throw new t("internal-error");
          c.accessToken != b.Aa && (Jm(b, c.accessToken), b.dispatchEvent(new sm("tokenChanged")));
          bn(b, "refreshToken", c.refreshToken);
          return c.accessToken;
        }));
      };
      function wm2(a, b) {
        b[Dg] && a.Aa != b[Dg] && (Cm(a.h, b), a.dispatchEvent(new sm("tokenChanged")), Jm(a, b[Dg]), bn(a, "refreshToken", a.h.a));
      }
      function en(a, b) {
        return O(a.a, Ij, { idToken: b }).then(q(a.Kc, a));
      }
      k.Kc = function(a) {
        a = a.users;
        if (!a || !a.length)
          throw new t("internal-error");
        a = a[0];
        Km(this, { uid: a.localId, displayName: a.displayName, photoURL: a.photoUrl, email: a.email, emailVerified: !!a.emailVerified, phoneNumber: a.phoneNumber, lastLoginAt: a.lastLoginAt, createdAt: a.createdAt, tenantId: a.tenantId });
        for (var b = fn(a), c = 0; c < b.length; c++)
          $m(this, b[c]);
        bn(this, "isAnonymous", !(this.email && a.passwordHash) && !(this.providerData && this.providerData.length));
        this.dispatchEvent(new sm("userReloaded", { hd: a }));
      };
      function fn(a) {
        return (a = a.providerUserInfo) && a.length ? Ra(a, function(b) {
          return new Hm(b.rawId, b.providerId, b.email, b.displayName, b.photoUrl, b.phoneNumber);
        }) : [];
      }
      k.Lc = function(a) {
        gf("firebase.User.prototype.reauthenticateAndRetrieveDataWithCredential is deprecated. Please use firebase.User.prototype.reauthenticateWithCredential instead.");
        return this.ub(a);
      };
      k.ub = function(a) {
        var b = this, c = null;
        return R(this, a.c(this.a, this.uid).then(function(d2) {
          wm2(b, d2);
          c = gn(b, d2, "reauthenticate");
          b.i = null;
          return b.reload();
        }).then(function() {
          return c;
        }), true);
      };
      function hn(a, b) {
        return dn(a).then(function() {
          if (Va(Zm(a), b))
            return Vm(a).then(function() {
              throw new t("provider-already-linked");
            });
        });
      }
      k.Cc = function(a) {
        gf("firebase.User.prototype.linkAndRetrieveDataWithCredential is deprecated. Please use firebase.User.prototype.linkWithCredential instead.");
        return this.rb(a);
      };
      k.rb = function(a) {
        var b = this, c = null;
        return R(this, hn(this, a.providerId).then(function() {
          return b.I();
        }).then(function(d2) {
          return a.b(b.a, d2);
        }).then(function(d2) {
          c = gn(b, d2, "link");
          return jn(b, d2);
        }).then(function() {
          return c;
        }));
      };
      k.Dc = function(a, b) {
        var c = this;
        return R(this, hn(this, "phone").then(function() {
          return gm(Rm(c), a, b, q(c.rb, c));
        }));
      };
      k.Mc = function(a, b) {
        var c = this;
        return R(this, E().then(function() {
          return gm(Rm(c), a, b, q(c.ub, c));
        }), true);
      };
      function gn(a, b, c) {
        var d2 = qh(b);
        b = og(b);
        return kf({ user: a, credential: d2, additionalUserInfo: b, operationType: c });
      }
      function jn(a, b) {
        wm2(a, b);
        return a.reload().then(function() {
          return a;
        });
      }
      k.Cb = function(a) {
        var b = this;
        return R(this, this.I().then(function(c) {
          return b.a.Cb(c, a);
        }).then(function(c) {
          wm2(b, c);
          return b.reload();
        }));
      };
      k.ed = function(a) {
        var b = this;
        return R(this, this.I().then(function(c) {
          return a.b(b.a, c);
        }).then(function(c) {
          wm2(b, c);
          return b.reload();
        }));
      };
      k.Db = function(a) {
        var b = this;
        return R(this, this.I().then(function(c) {
          return b.a.Db(c, a);
        }).then(function(c) {
          wm2(b, c);
          return b.reload();
        }));
      };
      k.Eb = function(a) {
        if (a.displayName === void 0 && a.photoURL === void 0)
          return Ym(this);
        var b = this;
        return R(this, this.I().then(function(c) {
          return b.a.Eb(c, { displayName: a.displayName, photoUrl: a.photoURL });
        }).then(function(c) {
          wm2(b, c);
          bn(b, "displayName", c.displayName || null);
          bn(b, "photoURL", c.photoUrl || null);
          w(b.providerData, function(d2) {
            d2.providerId === "password" && (M(d2, "displayName", b.displayName), M(d2, "photoURL", b.photoURL));
          });
          return Vm(b);
        }).then(Xm));
      };
      k.cd = function(a) {
        var b = this;
        return R(this, dn(this).then(function(c) {
          return Va(Zm(b), a) ? rj(b.a, c, [a]).then(function(d2) {
            var e = {};
            w(d2.providerUserInfo || [], function(f) {
              e[f.providerId] = true;
            });
            w(Zm(b), function(f) {
              e[f] || an(b, f);
            });
            e[lh.PROVIDER_ID] || M(b, "phoneNumber", null);
            return Vm(b);
          }) : Vm(b).then(function() {
            throw new t("no-such-provider");
          });
        }));
      };
      k.delete = function() {
        var a = this;
        return R(this, this.I().then(function(b) {
          return O(a.a, Fj, { idToken: b });
        }).then(function() {
          a.dispatchEvent(new sm("userDeleted"));
        })).then(function() {
          for (var b = 0; b < a.N.length; b++)
            a.N[b].cancel("app-deleted");
          Om(a, null);
          Pm(a, null);
          Qm(a, null);
          a.N = [];
          a.J = true;
          Tm(a);
          M(a, "refreshToken", null);
          a.b && Ql(a.b, a);
        });
      };
      k.Gb = function(a, b) {
        return a == "linkViaPopup" && (this.g || null) == b && this.f || a == "reauthViaPopup" && (this.g || null) == b && this.f || a == "linkViaRedirect" && (this.ga || null) == b || a == "reauthViaRedirect" && (this.ga || null) == b ? true : false;
      };
      k.na = function(a, b, c, d2) {
        a != "linkViaPopup" && a != "reauthViaPopup" || d2 != (this.g || null) || (c && this.C ? this.C(c) : b && !c && this.f && this.f(b), this.c && (this.c.cancel(), this.c = null), delete this.f, delete this.C);
      };
      k.Fa = function(a, b) {
        return a == "linkViaPopup" && b == (this.g || null) ? q(this.Lb, this) : a == "reauthViaPopup" && b == (this.g || null) ? q(this.Mb, this) : a == "linkViaRedirect" && (this.ga || null) == b ? q(this.Lb, this) : a == "reauthViaRedirect" && (this.ga || null) == b ? q(this.Mb, this) : null;
      };
      k.Ec = function(a) {
        var b = this;
        return kn(this, "linkViaPopup", a, function() {
          return hn(b, a.providerId).then(function() {
            return Vm(b);
          });
        }, false);
      };
      k.Nc = function(a) {
        return kn(this, "reauthViaPopup", a, function() {
          return E();
        }, true);
      };
      function kn(a, b, c, d2, e) {
        if (!Re())
          return F(new t("operation-not-supported-in-this-environment"));
        if (a.i && !e)
          return F(a.i);
        var f = ng(c.providerId), g = Qe(a.uid + ":::"), h = null;
        (!Te() || Ie()) && a.s && c.isOAuthProvider && (h = ek(a.s, a.l, a.m, b, c, null, g, firebase2.SDK_VERSION || null, null, null, a.tenantId, a.u));
        var m = ze(h, f && f.va, f && f.ua);
        d2 = d2().then(function() {
          ln(a);
          if (!e)
            return a.I().then(function() {
            });
        }).then(function() {
          return Tl(a.b, m, b, c, g, !!h, a.tenantId);
        }).then(function() {
          return new D(function(p, v) {
            a.na(b, null, new t("cancelled-popup-request"), a.g || null);
            a.f = p;
            a.C = v;
            a.g = g;
            a.c = Vl(a.b, a, b, m, g);
          });
        }).then(function(p) {
          m && ye(m);
          return p ? kf(p) : null;
        }).o(function(p) {
          m && ye(m);
          throw p;
        });
        return R(a, d2, e);
      }
      k.Fc = function(a) {
        var b = this;
        return mn(this, "linkViaRedirect", a, function() {
          return hn(b, a.providerId);
        }, false);
      };
      k.Oc = function(a) {
        return mn(this, "reauthViaRedirect", a, function() {
          return E();
        }, true);
      };
      function mn(a, b, c, d2, e) {
        if (!Re())
          return F(new t("operation-not-supported-in-this-environment"));
        if (a.i && !e)
          return F(a.i);
        var f = null, g = Qe(a.uid + ":::");
        d2 = d2().then(function() {
          ln(a);
          if (!e)
            return a.I().then(function() {
            });
        }).then(function() {
          a.ga = g;
          return Vm(a);
        }).then(function(h) {
          a.ha && (h = a.ha, h = h.b.set(nn, a.w(), h.a));
          return h;
        }).then(function() {
          return Ul(a.b, b, c, g, a.tenantId);
        }).o(function(h) {
          f = h;
          if (a.ha)
            return on(a.ha);
          throw f;
        }).then(function() {
          if (f)
            throw f;
        });
        return R(a, d2, e);
      }
      function ln(a) {
        if (!a.b || !a.P) {
          if (a.b && !a.P)
            throw new t("internal-error");
          throw new t("auth-domain-config-required");
        }
      }
      k.Lb = function(a, b, c, d2) {
        var e = this;
        this.c && (this.c.cancel(), this.c = null);
        var f = null;
        c = this.I().then(function(g) {
          return Hg(e.a, { requestUri: a, postBody: d2, sessionId: b, idToken: g });
        }).then(function(g) {
          f = gn(e, g, "link");
          return jn(e, g);
        }).then(function() {
          return f;
        });
        return R(this, c);
      };
      k.Mb = function(a, b, c, d2) {
        var e = this;
        this.c && (this.c.cancel(), this.c = null);
        var f = null, g = E().then(function() {
          return Cg(Ig(e.a, { requestUri: a, sessionId: b, postBody: d2, tenantId: c }), e.uid);
        }).then(function(h) {
          f = gn(e, h, "reauthenticate");
          wm2(e, h);
          e.i = null;
          return e.reload();
        }).then(function() {
          return f;
        });
        return R(this, g, true);
      };
      k.vb = function(a) {
        var b = this, c = null;
        return R(this, this.I().then(function(d2) {
          c = d2;
          return typeof a === "undefined" || mb(a) ? {} : bg(new Sf(a));
        }).then(function(d2) {
          return b.a.vb(c, d2);
        }).then(function(d2) {
          if (b.email != d2)
            return b.reload();
        }).then(function() {
        }));
      };
      k.Fb = function(a, b) {
        var c = this, d2 = null;
        return R(this, this.I().then(function(e) {
          d2 = e;
          return typeof b === "undefined" || mb(b) ? {} : bg(new Sf(b));
        }).then(function(e) {
          return c.a.Fb(d2, a, e);
        }).then(function(e) {
          if (c.email != e)
            return c.reload();
        }).then(function() {
        }));
      };
      function R(a, b, c) {
        var d2 = pn(a, b, c);
        a.N.push(d2);
        d2.oa(function() {
          Wa(a.N, d2);
        });
        return d2.o(function(e) {
          var f = null;
          e && e.code === "auth/multi-factor-auth-required" && (f = mm(e.w(), Rm(a), q(a.jc, a)));
          throw f || e;
        });
      }
      k.jc = function(a) {
        var b = null, c = this;
        a = Cg(E(a), c.uid).then(function(d2) {
          b = gn(c, d2, "reauthenticate");
          wm2(c, d2);
          c.i = null;
          return c.reload();
        }).then(function() {
          return b;
        });
        return R(this, a, true);
      };
      function pn(a, b, c) {
        return a.i && !c ? (b.cancel(), F(a.i)) : b.o(function(d2) {
          !d2 || d2.code != "auth/user-disabled" && d2.code != "auth/user-token-expired" || (a.i || a.dispatchEvent(new sm("userInvalidated")), a.i = d2);
          throw d2;
        });
      }
      k.toJSON = function() {
        return this.w();
      };
      k.w = function() {
        var a = { uid: this.uid, displayName: this.displayName, photoURL: this.photoURL, email: this.email, emailVerified: this.emailVerified, phoneNumber: this.phoneNumber, isAnonymous: this.isAnonymous, tenantId: this.tenantId, providerData: [], apiKey: this.l, appName: this.m, authDomain: this.s, stsTokenManager: this.h.w(), redirectEventId: this.ga || null };
        this.metadata && z(a, this.metadata.w());
        w(this.providerData, function(b) {
          a.providerData.push(lf(b));
        });
        z(a, this.S.w());
        return a;
      };
      function qn(a) {
        if (!a.apiKey)
          return null;
        var b = { apiKey: a.apiKey, authDomain: a.authDomain, appName: a.appName, emulatorConfig: a.emulatorConfig }, c = {};
        if (a.stsTokenManager && a.stsTokenManager.accessToken) {
          c[Dg] = a.stsTokenManager.accessToken;
          c.refreshToken = a.stsTokenManager.refreshToken || null;
          var d2 = a.stsTokenManager.expirationTime;
          d2 && (c.expiresIn = (d2 - Date.now()) / 1e3);
        } else
          return null;
        var e = new Im(b, c, a);
        a.providerData && w(a.providerData, function(f) {
          f && $m(e, kf(f));
        });
        a.redirectEventId && (e.ga = a.redirectEventId);
        return e;
      }
      function rn(a, b, c, d2) {
        var e = new Im(a, b);
        c && (e.ha = c);
        d2 && Nm(e, d2);
        return e.reload().then(function() {
          return e;
        });
      }
      function sn(a, b, c, d2) {
        var e = a.h, f = {};
        f[Dg] = e.b && e.b.toString();
        f.refreshToken = e.a;
        b = new Im(b || { apiKey: a.l, authDomain: a.s, appName: a.m }, f);
        c && (b.ha = c);
        d2 && Nm(b, d2);
        cn(b, a);
        return b;
      }
      ;
      function tn(a) {
        this.a = a;
        this.b = Vk();
      }
      var nn = { name: "redirectUser", F: "session" };
      function on(a) {
        return Zk(a.b, nn, a.a);
      }
      function un(a, b) {
        return a.b.get(nn, a.a).then(function(c) {
          c && b && (c.authDomain = b);
          return qn(c || {});
        });
      }
      ;
      function vn(a) {
        this.a = a;
        this.b = Vk();
        this.c = null;
        this.f = wn(this);
        this.b.addListener(xn("local"), this.a, q(this.g, this));
      }
      vn.prototype.g = function() {
        var a = this, b = xn("local");
        yn(this, function() {
          return E().then(function() {
            return a.c && a.c.F != "local" ? a.b.get(b, a.a) : null;
          }).then(function(c) {
            if (c)
              return zn(a, "local").then(function() {
                a.c = b;
              });
          });
        });
      };
      function zn(a, b) {
        var c = [], d2;
        for (d2 in Rk)
          Rk[d2] !== b && c.push(Zk(a.b, xn(Rk[d2]), a.a));
        c.push(Zk(a.b, An, a.a));
        return Ic(c);
      }
      function wn(a) {
        var b = xn("local"), c = xn("session"), d2 = xn("none");
        return Yk(a.b, b, a.a).then(function() {
          return a.b.get(c, a.a);
        }).then(function(e) {
          return e ? c : a.b.get(d2, a.a).then(function(f) {
            return f ? d2 : a.b.get(b, a.a).then(function(g) {
              return g ? b : a.b.get(An, a.a).then(function(h) {
                return h ? xn(h) : b;
              });
            });
          });
        }).then(function(e) {
          a.c = e;
          return zn(a, e.F);
        }).o(function() {
          a.c || (a.c = b);
        });
      }
      var An = { name: "persistence", F: "session" };
      function xn(a) {
        return { name: "authUser", F: a };
      }
      vn.prototype.yb = function(a) {
        var b = null, c = this;
        Sk(a);
        return yn(this, function() {
          return a != c.c.F ? c.b.get(c.c, c.a).then(function(d2) {
            b = d2;
            return zn(c, a);
          }).then(function() {
            c.c = xn(a);
            if (b)
              return c.b.set(c.c, b, c.a);
          }) : E();
        });
      };
      function Bn(a) {
        return yn(a, function() {
          return a.b.set(An, a.c.F, a.a);
        });
      }
      function Cn(a, b) {
        return yn(a, function() {
          return a.b.set(a.c, b.w(), a.a);
        });
      }
      function Dn(a) {
        return yn(a, function() {
          return Zk(a.b, a.c, a.a);
        });
      }
      function En(a, b, c) {
        return yn(a, function() {
          return a.b.get(a.c, a.a).then(function(d2) {
            d2 && b && (d2.authDomain = b);
            d2 && c && (d2.emulatorConfig = c);
            return qn(d2 || {});
          });
        });
      }
      function yn(a, b) {
        a.f = a.f.then(b, b);
        return a.f;
      }
      ;
      function Fn(a) {
        this.l = false;
        M(this, "settings", new em());
        M(this, "app", a);
        if (S(this).options && S(this).options.apiKey)
          a = firebase2.SDK_VERSION ? Oe(firebase2.SDK_VERSION) : null, this.a = new Ii(S(this).options && S(this).options.apiKey, Ca(Da), a);
        else
          throw new t("invalid-api-key");
        this.P = [];
        this.s = [];
        this.N = [];
        this.Pa = firebase2.INTERNAL.createSubscribe(q(this.zc, this));
        this.W = void 0;
        this.ib = firebase2.INTERNAL.createSubscribe(q(this.Ac, this));
        Gn(this, null);
        this.i = new vn(S(this).options.apiKey + ":" + S(this).name);
        this.D = new tn(S(this).options.apiKey + ":" + S(this).name);
        this.$ = T(this, Hn(this));
        this.h = T(this, In(this));
        this.ba = false;
        this.ja = q(this.Zc, this);
        this.Ba = q(this.da, this);
        this.qa = q(this.mc, this);
        this.za = q(this.wc, this);
        this.Aa = q(this.xc, this);
        this.b = null;
        Jn(this);
        this.INTERNAL = {};
        this.INTERNAL["delete"] = q(this.delete, this);
        this.INTERNAL.logFramework = q(this.Gc, this);
        this.u = 0;
        H.call(this);
        Kn(this);
        this.J = [];
        this.R = null;
      }
      r(Fn, H);
      function Ln(a) {
        G.call(this, "languageCodeChanged");
        this.h = a;
      }
      r(Ln, G);
      function Mn(a) {
        G.call(this, "emulatorConfigChanged");
        this.c = a;
      }
      r(Mn, G);
      function Nn(a) {
        G.call(this, "frameworkChanged");
        this.f = a;
      }
      r(Nn, G);
      k = Fn.prototype;
      k.yb = function(a) {
        a = this.i.yb(a);
        return T(this, a);
      };
      k.xa = function(a) {
        this.aa === a || this.l || (this.aa = a, Oi(this.a, this.aa), this.dispatchEvent(new Ln(this.la())));
      };
      k.la = function() {
        return this.aa;
      };
      k.fd = function() {
        var a = l.navigator;
        this.xa(a ? a.languages && a.languages[0] || a.language || a.userLanguage || null : null);
      };
      k.gd = function(a, b) {
        if (!this.R) {
          if (!/^https?:\/\//.test(a))
            throw new t("argument-error", "Emulator URL must start with a valid scheme (http:// or https://).");
          b = b ? !!b.disableWarnings : false;
          On(b);
          this.R = { url: a, ec: b };
          this.settings.jb = true;
          Pi(this.a, this.R);
          this.dispatchEvent(new Mn(this.R));
        }
      };
      function On(a) {
        typeof console !== "undefined" && typeof console.info === "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
        l.document && !a && Ee().then(function() {
          var b = l.document.createElement("div");
          b.innerText = "Running in emulator mode. Do not use with production credentials.";
          b.style.position = "fixed";
          b.style.width = "100%";
          b.style.backgroundColor = "#ffffff";
          b.style.border = ".1em solid #000000";
          b.style.color = "#b50000";
          b.style.bottom = "0px";
          b.style.left = "0px";
          b.style.margin = "0px";
          b.style.zIndex = 1e4;
          b.style.textAlign = "center";
          b.classList.add("firebase-emulator-warning");
          l.document.body.appendChild(b);
        });
      }
      k.Gc = function(a) {
        this.J.push(a);
        Ri(this.a, firebase2.SDK_VERSION ? Oe(firebase2.SDK_VERSION, this.J) : null);
        this.dispatchEvent(new Nn(this.J));
      };
      k.Ga = function() {
        return Za(this.J);
      };
      k.zb = function(a) {
        this.S === a || this.l || (this.S = a, this.a.b = this.S);
      };
      k.T = function() {
        return this.S;
      };
      function Kn(a) {
        Object.defineProperty(a, "lc", { get: function() {
          return this.la();
        }, set: function(b) {
          this.xa(b);
        }, enumerable: false });
        a.aa = null;
        Object.defineProperty(a, "ti", { get: function() {
          return this.T();
        }, set: function(b) {
          this.zb(b);
        }, enumerable: false });
        a.S = null;
        Object.defineProperty(a, "emulatorConfig", { get: function() {
          if (this.R) {
            var b = J(this.R.url);
            b = kf({ protocol: b.c, host: b.a, port: b.g, options: kf({ disableWarnings: this.R.ec }) });
          } else
            b = null;
          return b;
        }, enumerable: false });
      }
      k.toJSON = function() {
        return { apiKey: S(this).options.apiKey, authDomain: S(this).options.authDomain, appName: S(this).name, currentUser: U(this) && U(this).w() };
      };
      function Pn(a) {
        return a.Oa || F(new t("auth-domain-config-required"));
      }
      function Jn(a) {
        var b = S(a).options.authDomain, c = S(a).options.apiKey;
        b && Re() && (a.Oa = a.$.then(function() {
          if (!a.l) {
            a.b = Xl(b, c, S(a).name, a.R);
            Pl(a.b, a);
            U(a) && Wm(U(a));
            if (a.m) {
              Wm(a.m);
              var d2 = a.m;
              d2.xa(a.la());
              Om(d2, a);
              d2 = a.m;
              Nm(d2, a.J);
              Qm(d2, a);
              d2 = a.m;
              Mm(d2, a.R);
              Pm(d2, a);
              a.m = null;
            }
            return a.b;
          }
        }));
      }
      k.Gb = function(a, b) {
        switch (a) {
          case "unknown":
          case "signInViaRedirect":
            return true;
          case "signInViaPopup":
            return this.g == b && !!this.f;
          default:
            return false;
        }
      };
      k.na = function(a, b, c, d2) {
        a == "signInViaPopup" && this.g == d2 && (c && this.C ? this.C(c) : b && !c && this.f && this.f(b), this.c && (this.c.cancel(), this.c = null), delete this.f, delete this.C);
      };
      k.Fa = function(a, b) {
        return a == "signInViaRedirect" || a == "signInViaPopup" && this.g == b && this.f ? q(this.ic, this) : null;
      };
      k.ic = function(a, b, c, d2) {
        var e = this, f = { requestUri: a, postBody: d2, sessionId: b, tenantId: c };
        this.c && (this.c.cancel(), this.c = null);
        return e.$.then(function() {
          return Qn(e, Fg(e.a, f));
        });
      };
      k.Xc = function(a) {
        if (!Re())
          return F(new t("operation-not-supported-in-this-environment"));
        var b = this, c = ng(a.providerId), d2 = Qe(), e = null;
        (!Te() || Ie()) && S(this).options.authDomain && a.isOAuthProvider && (e = ek(S(this).options.authDomain, S(this).options.apiKey, S(this).name, "signInViaPopup", a, null, d2, firebase2.SDK_VERSION || null, null, null, this.T(), this.R));
        var f = ze(e, c && c.va, c && c.ua);
        c = Pn(this).then(function(g) {
          return Tl(g, f, "signInViaPopup", a, d2, !!e, b.T());
        }).then(function() {
          return new D(function(g, h) {
            b.na("signInViaPopup", null, new t("cancelled-popup-request"), b.g);
            b.f = g;
            b.C = h;
            b.g = d2;
            b.c = Vl(b.b, b, "signInViaPopup", f, d2);
          });
        }).then(function(g) {
          f && ye(f);
          return g ? kf(g) : null;
        }).o(function(g) {
          f && ye(f);
          throw g;
        });
        return T(this, c);
      };
      k.Yc = function(a) {
        if (!Re())
          return F(new t("operation-not-supported-in-this-environment"));
        var b = this, c = Pn(this).then(function() {
          return Bn(b.i);
        }).then(function() {
          return Ul(b.b, "signInViaRedirect", a, void 0, b.T());
        });
        return T(this, c);
      };
      function Rn(a) {
        if (!Re())
          return F(new t("operation-not-supported-in-this-environment"));
        var b = Pn(a).then(function() {
          return a.b.ra();
        }).then(function(c) {
          return c ? kf(c) : null;
        });
        return T(a, b);
      }
      k.ra = function() {
        var a = this;
        return Rn(this).then(function(b) {
          a.b && $l(a.b.b);
          return b;
        }).o(function(b) {
          a.b && $l(a.b.b);
          throw b;
        });
      };
      k.dd = function(a) {
        if (!a)
          return F(new t("null-user"));
        if (this.S != a.tenantId)
          return F(new t("tenant-id-mismatch"));
        var b = this, c = {};
        c.apiKey = S(this).options.apiKey;
        c.authDomain = S(this).options.authDomain;
        c.appName = S(this).name;
        var d2 = sn(a, c, b.D, b.Ga());
        return T(this, this.h.then(function() {
          if (S(b).options.apiKey != a.l)
            return d2.reload();
        }).then(function() {
          if (U(b) && a.uid == U(b).uid)
            return cn(U(b), a), b.da(a);
          Gn(b, d2);
          Wm(d2);
          return b.da(d2);
        }).then(function() {
          Sn(b);
        }));
      };
      function Tn(a, b) {
        var c = {};
        c.apiKey = S(a).options.apiKey;
        c.authDomain = S(a).options.authDomain;
        c.appName = S(a).name;
        a.R && (c.emulatorConfig = a.R);
        return a.$.then(function() {
          return rn(c, b, a.D, a.Ga());
        }).then(function(d2) {
          if (U(a) && d2.uid == U(a).uid)
            return cn(U(a), d2), a.da(d2);
          Gn(a, d2);
          Wm(d2);
          return a.da(d2);
        }).then(function() {
          Sn(a);
        });
      }
      function Gn(a, b) {
        U(a) && (Um(U(a), a.Ba), xd(U(a), "tokenChanged", a.qa), xd(U(a), "userDeleted", a.za), xd(U(a), "userInvalidated", a.Aa), Tm(U(a)));
        b && (b.W.push(a.Ba), nd(b, "tokenChanged", a.qa), nd(b, "userDeleted", a.za), nd(b, "userInvalidated", a.Aa), 0 < a.u && Sm(b));
        M(a, "currentUser", b);
        b && (b.xa(a.la()), Om(b, a), Nm(b, a.J), Qm(b, a), Mm(b, a.R), Pm(b, a));
      }
      k.Bb = function() {
        var a = this, b = this.h.then(function() {
          a.b && $l(a.b.b);
          if (!U(a))
            return E();
          Gn(a, null);
          return Dn(a.i).then(function() {
            Sn(a);
          });
        });
        return T(this, b);
      };
      function Un(a) {
        var b = un(a.D, S(a).options.authDomain).then(function(c) {
          if (a.m = c)
            c.ha = a.D;
          return on(a.D);
        });
        return T(a, b);
      }
      function Hn(a) {
        var b = S(a).options.authDomain, c = Un(a).then(function() {
          return En(a.i, b, a.R);
        }).then(function(d2) {
          return d2 ? (d2.ha = a.D, a.m && (a.m.ga || null) == (d2.ga || null) ? d2 : d2.reload().then(function() {
            return Cn(a.i, d2).then(function() {
              return d2;
            });
          }).o(function(e) {
            return e.code == "auth/network-request-failed" ? d2 : Dn(a.i);
          })) : null;
        }).then(function(d2) {
          Gn(a, d2 || null);
        });
        return T(a, c);
      }
      function In(a) {
        return a.$.then(function() {
          return Rn(a);
        }).o(function() {
        }).then(function() {
          if (!a.l)
            return a.ja();
        }).o(function() {
        }).then(function() {
          if (!a.l) {
            a.ba = true;
            var b = a.i;
            b.b.addListener(xn("local"), b.a, a.ja);
          }
        });
      }
      k.Zc = function() {
        var a = this;
        return En(this.i, S(this).options.authDomain).then(function(b) {
          if (!a.l) {
            var c;
            if (c = U(a) && b) {
              c = U(a).uid;
              var d2 = b.uid;
              c = c === void 0 || c === null || c === "" || d2 === void 0 || d2 === null || d2 === "" ? false : c == d2;
            }
            if (c)
              return cn(U(a), b), U(a).I();
            if (U(a) || b)
              Gn(a, b), b && (Wm(b), b.ha = a.D), a.b && Pl(a.b, a), Sn(a);
          }
        });
      };
      k.da = function(a) {
        return Cn(this.i, a);
      };
      k.mc = function() {
        Sn(this);
        this.da(U(this));
      };
      k.wc = function() {
        this.Bb();
      };
      k.xc = function() {
        this.Bb();
      };
      function Qn(a, b) {
        var c = null, d2 = null;
        return T(a, b.then(function(e) {
          c = qh(e);
          d2 = og(e);
          return Tn(a, e);
        }, function(e) {
          var f = null;
          e && e.code === "auth/multi-factor-auth-required" && (f = mm(e.w(), a, q(a.kc, a)));
          throw f || e;
        }).then(function() {
          return kf({ user: U(a), credential: c, additionalUserInfo: d2, operationType: "signIn" });
        }));
      }
      k.kc = function(a) {
        var b = this;
        return this.h.then(function() {
          return Qn(b, E(a));
        });
      };
      k.zc = function(a) {
        var b = this;
        this.addAuthTokenListener(function() {
          a.next(U(b));
        });
      };
      k.Ac = function(a) {
        var b = this;
        Vn(this, function() {
          a.next(U(b));
        });
      };
      k.Ic = function(a, b, c) {
        var d2 = this;
        this.ba && Promise.resolve().then(function() {
          typeof a === "function" ? a(U(d2)) : typeof a.next === "function" && a.next(U(d2));
        });
        return this.Pa(a, b, c);
      };
      k.Hc = function(a, b, c) {
        var d2 = this;
        this.ba && Promise.resolve().then(function() {
          d2.W = d2.getUid();
          typeof a === "function" ? a(U(d2)) : typeof a.next === "function" && a.next(U(d2));
        });
        return this.ib(a, b, c);
      };
      k.nc = function(a) {
        var b = this, c = this.h.then(function() {
          return U(b) ? U(b).I(a).then(function(d2) {
            return { accessToken: d2 };
          }) : null;
        });
        return T(this, c);
      };
      k.Tc = function(a) {
        var b = this;
        return this.h.then(function() {
          return Qn(b, O(b.a, Kj, { token: a }));
        }).then(function(c) {
          var d2 = c.user;
          bn(d2, "isAnonymous", false);
          b.da(d2);
          return c;
        });
      };
      k.Uc = function(a, b) {
        var c = this;
        return this.h.then(function() {
          return Qn(c, O(c.a, ah, { email: a, password: b }));
        });
      };
      k.dc = function(a, b) {
        var c = this;
        return this.h.then(function() {
          return Qn(c, O(c.a, Ej, { email: a, password: b }));
        });
      };
      k.ab = function(a) {
        var b = this;
        return this.h.then(function() {
          return Qn(b, a.ka(b.a));
        });
      };
      k.Sc = function(a) {
        gf("firebase.auth.Auth.prototype.signInAndRetrieveDataWithCredential is deprecated. Please use firebase.auth.Auth.prototype.signInWithCredential instead.");
        return this.ab(a);
      };
      k.Ab = function() {
        var a = this;
        return this.h.then(function() {
          var b = U(a);
          if (b && b.isAnonymous) {
            var c = kf({ providerId: null, isNewUser: false });
            return kf({ user: b, credential: null, additionalUserInfo: c, operationType: "signIn" });
          }
          return Qn(a, a.a.Ab()).then(function(d2) {
            var e = d2.user;
            bn(e, "isAnonymous", true);
            a.da(e);
            return d2;
          });
        });
      };
      function S(a) {
        return a.app;
      }
      function U(a) {
        return a.currentUser;
      }
      k.getUid = function() {
        return U(this) && U(this).uid || null;
      };
      function Wn(a) {
        return U(a) && U(a)._lat || null;
      }
      function Sn(a) {
        if (a.ba) {
          for (var b = 0; b < a.s.length; b++)
            if (a.s[b])
              a.s[b](Wn(a));
          if (a.W !== a.getUid() && a.N.length) {
            for (a.W = a.getUid(), b = 0; b < a.N.length; b++)
              if (a.N[b])
                a.N[b](Wn(a));
          }
        }
      }
      k.cc = function(a) {
        this.addAuthTokenListener(a);
        this.u++;
        0 < this.u && U(this) && Sm(U(this));
      };
      k.Pc = function(a) {
        var b = this;
        w(this.s, function(c) {
          c == a && b.u--;
        });
        0 > this.u && (this.u = 0);
        this.u == 0 && U(this) && Tm(U(this));
        this.removeAuthTokenListener(a);
      };
      k.addAuthTokenListener = function(a) {
        var b = this;
        this.s.push(a);
        T(this, this.h.then(function() {
          b.l || Va(b.s, a) && a(Wn(b));
        }));
      };
      k.removeAuthTokenListener = function(a) {
        Xa(this.s, function(b) {
          return b == a;
        });
      };
      function Vn(a, b) {
        a.N.push(b);
        T(a, a.h.then(function() {
          !a.l && Va(a.N, b) && a.W !== a.getUid() && (a.W = a.getUid(), b(Wn(a)));
        }));
      }
      k.delete = function() {
        this.l = true;
        for (var a = 0; a < this.P.length; a++)
          this.P[a].cancel("app-deleted");
        this.P = [];
        this.i && (a = this.i, a.b.removeListener(xn("local"), a.a, this.ja));
        this.b && (Ql(this.b, this), $l(this.b.b));
        return Promise.resolve();
      };
      function T(a, b) {
        a.P.push(b);
        b.oa(function() {
          Wa(a.P, b);
        });
        return b;
      }
      k.hc = function(a) {
        return T(this, aj(this.a, a));
      };
      k.Bc = function(a) {
        return !!fh(a);
      };
      k.xb = function(a, b) {
        var c = this;
        return T(this, E().then(function() {
          var d2 = new Sf(b);
          if (!d2.c)
            throw new t("argument-error", $f + " must be true when sending sign in link to email");
          return bg(d2);
        }).then(function(d2) {
          return c.a.xb(a, d2);
        }).then(function() {
        }));
      };
      k.jd = function(a) {
        return this.Sa(a).then(function(b) {
          return b.data.email;
        });
      };
      k.ob = function(a, b) {
        return T(this, this.a.ob(a, b).then(function() {
        }));
      };
      k.Sa = function(a) {
        return T(this, this.a.Sa(a).then(function(b) {
          return new vf(b);
        }));
      };
      k.kb = function(a) {
        return T(this, this.a.kb(a).then(function() {
        }));
      };
      k.wb = function(a, b) {
        var c = this;
        return T(this, E().then(function() {
          return typeof b === "undefined" || mb(b) ? {} : bg(new Sf(b));
        }).then(function(d2) {
          return c.a.wb(a, d2);
        }).then(function() {
        }));
      };
      k.Wc = function(a, b) {
        return T(this, gm(this, a, b, q(this.ab, this)));
      };
      k.Vc = function(a, b) {
        var c = this;
        return T(this, E().then(function() {
          var d2 = b || re(), e = eh(a, d2);
          d2 = fh(d2);
          if (!d2)
            throw new t("argument-error", "Invalid email link!");
          if (d2.tenantId !== c.T())
            throw new t("tenant-id-mismatch");
          return c.ab(e);
        }));
      };
      function Xn() {
      }
      Xn.prototype.render = function() {
      };
      Xn.prototype.reset = function() {
      };
      Xn.prototype.getResponse = function() {
      };
      Xn.prototype.execute = function() {
      };
      function Yn() {
        this.a = {};
        this.b = 1e12;
      }
      var Zn = null;
      Yn.prototype.render = function(a, b) {
        this.a[this.b.toString()] = new $n(a, b);
        return this.b++;
      };
      Yn.prototype.reset = function(a) {
        var b = ao(this, a);
        a = bo(a);
        b && a && (b.delete(), delete this.a[a]);
      };
      Yn.prototype.getResponse = function(a) {
        return (a = ao(this, a)) ? a.getResponse() : null;
      };
      Yn.prototype.execute = function(a) {
        (a = ao(this, a)) && a.execute();
      };
      function ao(a, b) {
        return (b = bo(b)) ? a.a[b] || null : null;
      }
      function bo(a) {
        return (a = typeof a === "undefined" ? 1e12 : a) ? a.toString() : null;
      }
      function $n(a, b) {
        this.g = false;
        this.c = b;
        this.a = this.b = null;
        this.h = this.c.size !== "invisible";
        this.f = kc(a);
        var c = this;
        this.i = function() {
          c.execute();
        };
        this.h ? this.execute() : nd(this.f, "click", this.i);
      }
      $n.prototype.getResponse = function() {
        co(this);
        return this.b;
      };
      $n.prototype.execute = function() {
        co(this);
        var a = this;
        this.a || (this.a = setTimeout(function() {
          a.b = Me();
          var b = a.c.callback, c = a.c["expired-callback"];
          if (b)
            try {
              b(a.b);
            } catch (d2) {
            }
          a.a = setTimeout(function() {
            a.a = null;
            a.b = null;
            if (c)
              try {
                c();
              } catch (d2) {
              }
            a.h && a.execute();
          }, 6e4);
        }, 500));
      };
      $n.prototype.delete = function() {
        co(this);
        this.g = true;
        clearTimeout(this.a);
        this.a = null;
        xd(this.f, "click", this.i);
      };
      function co(a) {
        if (a.g)
          throw Error("reCAPTCHA mock was already deleted!");
      }
      ;
      function eo() {
      }
      M(eo, "FACTOR_ID", "phone");
      function fo() {
      }
      fo.prototype.g = function() {
        Zn || (Zn = new Yn());
        return E(Zn);
      };
      fo.prototype.c = function() {
      };
      var go = null;
      function ho() {
        this.b = l.grecaptcha ? Infinity : 0;
        this.f = null;
        this.a = "__rcb" + Math.floor(1e6 * Math.random()).toString();
      }
      var io = new qb(rb, "https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit&hl=%{hl}"), jo = new Ze(3e4, 6e4);
      ho.prototype.g = function(a) {
        var b = this;
        return new D(function(c, d2) {
          var e = setTimeout(function() {
            d2(new t("network-request-failed"));
          }, jo.get());
          if (!l.grecaptcha || a !== b.f && !b.b) {
            l[b.a] = function() {
              if (l.grecaptcha) {
                b.f = a;
                var g = l.grecaptcha.render;
                l.grecaptcha.render = function(h, m) {
                  h = g(h, m);
                  b.b++;
                  return h;
                };
                clearTimeout(e);
                c(l.grecaptcha);
              } else
                clearTimeout(e), d2(new t("internal-error"));
              delete l[b.a];
            };
            var f = zb(io, { onload: b.a, hl: a || "" });
            E(Bi(f)).o(function() {
              clearTimeout(e);
              d2(new t("internal-error", "Unable to load external reCAPTCHA dependencies!"));
            });
          } else
            clearTimeout(e), c(l.grecaptcha);
        });
      };
      ho.prototype.c = function() {
        this.b--;
      };
      var ko = null;
      function lo(a, b, c, d2, e, f, g) {
        M(this, "type", "recaptcha");
        this.c = this.f = null;
        this.J = false;
        this.v = b;
        this.g = null;
        g ? (go || (go = new fo()), g = go) : (ko || (ko = new ho()), g = ko);
        this.m = g;
        this.a = c || { theme: "light", type: "image" };
        this.h = [];
        if (this.a[mo])
          throw new t("argument-error", "sitekey should not be provided for reCAPTCHA as one is automatically provisioned for the current project.");
        this.i = this.a[no] === "invisible";
        if (!l.document)
          throw new t("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment with DOM support.");
        if (!kc(b) || !this.i && kc(b).hasChildNodes())
          throw new t("argument-error", "reCAPTCHA container is either not found or already contains inner elements!");
        this.s = new Ii(a, f || null, e || null);
        this.u = d2 || function() {
          return null;
        };
        var h = this;
        this.l = [];
        var m = this.a[oo];
        this.a[oo] = function(v) {
          po(h, v);
          if (typeof m === "function")
            m(v);
          else if (typeof m === "string") {
            var B = L(m, l);
            typeof B === "function" && B(v);
          }
        };
        var p = this.a[qo];
        this.a[qo] = function() {
          po(h, null);
          if (typeof p === "function")
            p();
          else if (typeof p === "string") {
            var v = L(p, l);
            typeof v === "function" && v();
          }
        };
      }
      var oo = "callback", qo = "expired-callback", mo = "sitekey", no = "size";
      function po(a, b) {
        for (var c = 0; c < a.l.length; c++)
          try {
            a.l[c](b);
          } catch (d2) {
          }
      }
      function ro(a, b) {
        Xa(a.l, function(c) {
          return c == b;
        });
      }
      function so(a, b) {
        a.h.push(b);
        b.oa(function() {
          Wa(a.h, b);
        });
        return b;
      }
      k = lo.prototype;
      k.Ia = function() {
        var a = this;
        return this.f ? this.f : this.f = so(this, E().then(function() {
          if (Se() && !Je())
            return Ee();
          throw new t("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment.");
        }).then(function() {
          return a.m.g(a.u());
        }).then(function(b) {
          a.g = b;
          return O(a.s, Jj, {});
        }).then(function(b) {
          a.a[mo] = b.recaptchaSiteKey;
        }).o(function(b) {
          a.f = null;
          throw b;
        }));
      };
      k.render = function() {
        to(this);
        var a = this;
        return so(this, this.Ia().then(function() {
          if (a.c === null) {
            var b = a.v;
            if (!a.i) {
              var c = kc(b);
              b = nc("DIV");
              c.appendChild(b);
            }
            a.c = a.g.render(b, a.a);
          }
          return a.c;
        }));
      };
      k.verify = function() {
        to(this);
        var a = this;
        return so(this, this.render().then(function(b) {
          return new D(function(c) {
            var d2 = a.g.getResponse(b);
            if (d2)
              c(d2);
            else {
              var e = function(f) {
                f && (ro(a, e), c(f));
              };
              a.l.push(e);
              a.i && a.g.execute(a.c);
            }
          });
        }));
      };
      k.reset = function() {
        to(this);
        this.c !== null && this.g.reset(this.c);
      };
      function to(a) {
        if (a.J)
          throw new t("internal-error", "RecaptchaVerifier instance has been destroyed.");
      }
      k.clear = function() {
        to(this);
        this.J = true;
        this.m.c();
        for (var a = 0; a < this.h.length; a++)
          this.h[a].cancel("RecaptchaVerifier instance has been destroyed.");
        if (!this.i) {
          a = kc(this.v);
          for (var b; b = a.firstChild; )
            a.removeChild(b);
        }
      };
      function uo(a, b, c) {
        var d2 = false;
        try {
          this.b = c || firebase2.app();
        } catch (g) {
          throw new t("argument-error", "No firebase.app.App instance is currently initialized.");
        }
        if (this.b.options && this.b.options.apiKey)
          c = this.b.options.apiKey;
        else
          throw new t("invalid-api-key");
        var e = this, f = null;
        try {
          f = this.b.auth().Ga();
        } catch (g) {
        }
        try {
          d2 = this.b.auth().settings.appVerificationDisabledForTesting;
        } catch (g) {
        }
        f = firebase2.SDK_VERSION ? Oe(firebase2.SDK_VERSION, f) : null;
        lo.call(this, c, a, b, function() {
          try {
            var g = e.b.auth().la();
          } catch (h) {
            g = null;
          }
          return g;
        }, f, Ca(Da), d2);
      }
      r(uo, lo);
      function vo(a, b, c, d2) {
        a: {
          c = Array.prototype.slice.call(c);
          var e = 0;
          for (var f = false, g = 0; g < b.length; g++)
            if (b[g].optional)
              f = true;
            else {
              if (f)
                throw new t("internal-error", "Argument validator encountered a required argument after an optional argument.");
              e++;
            }
          f = b.length;
          if (c.length < e || f < c.length)
            d2 = "Expected " + (e == f ? e == 1 ? "1 argument" : e + " arguments" : e + "-" + f + " arguments") + " but got " + c.length + ".";
          else {
            for (e = 0; e < c.length; e++)
              if (f = b[e].optional && c[e] === void 0, !b[e].M(c[e]) && !f) {
                b = b[e];
                if (0 > e || e >= wo.length)
                  throw new t("internal-error", "Argument validator received an unsupported number of arguments.");
                c = wo[e];
                d2 = (d2 ? "" : c + " argument ") + (b.name ? '"' + b.name + '" ' : "") + "must be " + b.K + ".";
                break a;
              }
            d2 = null;
          }
        }
        if (d2)
          throw new t("argument-error", a + " failed: " + d2);
      }
      var wo = "First Second Third Fourth Fifth Sixth Seventh Eighth Ninth".split(" ");
      function V(a, b) {
        return { name: a || "", K: "a valid string", optional: !!b, M: function(c) {
          return typeof c === "string";
        } };
      }
      function xo(a, b) {
        return { name: a || "", K: "a boolean", optional: !!b, M: function(c) {
          return typeof c === "boolean";
        } };
      }
      function W(a, b) {
        return { name: a || "", K: "a valid object", optional: !!b, M: n };
      }
      function yo(a, b) {
        return { name: a || "", K: "a function", optional: !!b, M: function(c) {
          return typeof c === "function";
        } };
      }
      function zo(a, b) {
        return { name: a || "", K: "null", optional: !!b, M: function(c) {
          return c === null;
        } };
      }
      function Ao() {
        return { name: "", K: "an HTML element", optional: false, M: function(a) {
          return !!(a && a instanceof Element);
        } };
      }
      function Bo() {
        return { name: "auth", K: "an instance of Firebase Auth", optional: true, M: function(a) {
          return !!(a && a instanceof Fn);
        } };
      }
      function Co() {
        return { name: "app", K: "an instance of Firebase App", optional: true, M: function(a) {
          return !!(a && a instanceof firebase2.app.App);
        } };
      }
      function Do(a) {
        return { name: a ? a + "Credential" : "credential", K: a ? "a valid " + a + " credential" : "a valid credential", optional: false, M: function(b) {
          if (!b)
            return false;
          var c = !a || b.providerId === a;
          return !(!b.ka || !c);
        } };
      }
      function Eo() {
        return { name: "multiFactorAssertion", K: "a valid multiFactorAssertion", optional: false, M: function(a) {
          return a ? !!a.tb : false;
        } };
      }
      function Fo() {
        return { name: "authProvider", K: "a valid Auth provider", optional: false, M: function(a) {
          return !!(a && a.providerId && a.hasOwnProperty && a.hasOwnProperty("isOAuthProvider"));
        } };
      }
      function Go(a, b) {
        return n(a) && typeof a.type === "string" && a.type === b && typeof a.Ha === "function";
      }
      function Ho(a) {
        return n(a) && typeof a.uid === "string";
      }
      function Io() {
        return { name: "applicationVerifier", K: "an implementation of firebase.auth.ApplicationVerifier", optional: false, M: function(a) {
          return !(!a || typeof a.type !== "string" || typeof a.verify !== "function");
        } };
      }
      function X(a, b, c, d2) {
        return { name: c || "", K: a.K + " or " + b.K, optional: !!d2, M: function(e) {
          return a.M(e) || b.M(e);
        } };
      }
      ;
      function Y(a, b) {
        for (var c in b) {
          var d2 = b[c].name;
          a[d2] = Jo(d2, a[c], b[c].j);
        }
      }
      function Ko(a, b) {
        for (var c in b) {
          var d2 = b[c].name;
          d2 !== c && Object.defineProperty(a, d2, { get: ua(function(e) {
            return this[e];
          }, c), set: ua(function(e, f, g, h) {
            vo(e, [g], [h], true);
            this[f] = h;
          }, d2, c, b[c].lb), enumerable: true });
        }
      }
      function Z(a, b, c, d2) {
        a[b] = Jo(b, c, d2);
      }
      function Jo(a, b, c) {
        function d2() {
          var g = Array.prototype.slice.call(arguments);
          vo(e, c, g);
          return b.apply(this, g);
        }
        if (!c)
          return b;
        var e = Lo(a), f;
        for (f in b)
          d2[f] = b[f];
        for (f in b.prototype)
          d2.prototype[f] = b.prototype[f];
        return d2;
      }
      function Lo(a) {
        a = a.split(".");
        return a[a.length - 1];
      }
      ;
      Y(Fn.prototype, {
        kb: { name: "applyActionCode", j: [V("code")] },
        Sa: { name: "checkActionCode", j: [V("code")] },
        ob: { name: "confirmPasswordReset", j: [V("code"), V("newPassword")] },
        dc: { name: "createUserWithEmailAndPassword", j: [V("email"), V("password")] },
        hc: { name: "fetchSignInMethodsForEmail", j: [V("email")] },
        ra: { name: "getRedirectResult", j: [] },
        Bc: { name: "isSignInWithEmailLink", j: [V("emailLink")] },
        Hc: { name: "onAuthStateChanged", j: [X(W(), yo(), "nextOrObserver"), yo("opt_error", true), yo("opt_completed", true)] },
        Ic: {
          name: "onIdTokenChanged",
          j: [X(W(), yo(), "nextOrObserver"), yo("opt_error", true), yo("opt_completed", true)]
        },
        wb: { name: "sendPasswordResetEmail", j: [V("email"), X(W("opt_actionCodeSettings", true), zo(null, true), "opt_actionCodeSettings", true)] },
        xb: { name: "sendSignInLinkToEmail", j: [V("email"), W("actionCodeSettings")] },
        yb: { name: "setPersistence", j: [V("persistence")] },
        Sc: { name: "signInAndRetrieveDataWithCredential", j: [Do()] },
        Ab: { name: "signInAnonymously", j: [] },
        ab: { name: "signInWithCredential", j: [Do()] },
        Tc: { name: "signInWithCustomToken", j: [V("token")] },
        Uc: { name: "signInWithEmailAndPassword", j: [V("email"), V("password")] },
        Vc: { name: "signInWithEmailLink", j: [V("email"), V("emailLink", true)] },
        Wc: { name: "signInWithPhoneNumber", j: [V("phoneNumber"), Io()] },
        Xc: { name: "signInWithPopup", j: [Fo()] },
        Yc: { name: "signInWithRedirect", j: [Fo()] },
        dd: { name: "updateCurrentUser", j: [X(function(a) {
          return { name: "user", K: "an instance of Firebase User", optional: !!a, M: function(b) {
            return !!(b && b instanceof Im);
          } };
        }(), zo(), "user")] },
        Bb: { name: "signOut", j: [] },
        toJSON: { name: "toJSON", j: [V(null, true)] },
        fd: { name: "useDeviceLanguage", j: [] },
        gd: { name: "useEmulator", j: [V("url"), W("options", true)] },
        jd: { name: "verifyPasswordResetCode", j: [V("code")] }
      });
      Ko(Fn.prototype, { lc: { name: "languageCode", lb: X(V(), zo(), "languageCode") }, ti: { name: "tenantId", lb: X(V(), zo(), "tenantId") } });
      Fn.Persistence = Rk;
      Fn.Persistence.LOCAL = "local";
      Fn.Persistence.SESSION = "session";
      Fn.Persistence.NONE = "none";
      Y(Im.prototype, {
        "delete": { name: "delete", j: [] },
        oc: { name: "getIdTokenResult", j: [xo("opt_forceRefresh", true)] },
        I: { name: "getIdToken", j: [xo("opt_forceRefresh", true)] },
        Cc: { name: "linkAndRetrieveDataWithCredential", j: [Do()] },
        rb: { name: "linkWithCredential", j: [Do()] },
        Dc: { name: "linkWithPhoneNumber", j: [V("phoneNumber"), Io()] },
        Ec: { name: "linkWithPopup", j: [Fo()] },
        Fc: { name: "linkWithRedirect", j: [Fo()] },
        Lc: { name: "reauthenticateAndRetrieveDataWithCredential", j: [Do()] },
        ub: { name: "reauthenticateWithCredential", j: [Do()] },
        Mc: {
          name: "reauthenticateWithPhoneNumber",
          j: [V("phoneNumber"), Io()]
        },
        Nc: { name: "reauthenticateWithPopup", j: [Fo()] },
        Oc: { name: "reauthenticateWithRedirect", j: [Fo()] },
        reload: { name: "reload", j: [] },
        vb: { name: "sendEmailVerification", j: [X(W("opt_actionCodeSettings", true), zo(null, true), "opt_actionCodeSettings", true)] },
        toJSON: { name: "toJSON", j: [V(null, true)] },
        cd: { name: "unlink", j: [V("provider")] },
        Cb: { name: "updateEmail", j: [V("email")] },
        Db: { name: "updatePassword", j: [V("password")] },
        ed: { name: "updatePhoneNumber", j: [Do("phone")] },
        Eb: { name: "updateProfile", j: [W("profile")] },
        Fb: { name: "verifyBeforeUpdateEmail", j: [V("email"), X(W("opt_actionCodeSettings", true), zo(null, true), "opt_actionCodeSettings", true)] }
      });
      Y(Yn.prototype, { execute: { name: "execute" }, render: { name: "render" }, reset: { name: "reset" }, getResponse: { name: "getResponse" } });
      Y(Xn.prototype, { execute: { name: "execute" }, render: { name: "render" }, reset: { name: "reset" }, getResponse: { name: "getResponse" } });
      Y(D.prototype, { oa: { name: "finally" }, o: { name: "catch" }, then: { name: "then" } });
      Ko(em.prototype, { appVerificationDisabled: { name: "appVerificationDisabledForTesting", lb: xo("appVerificationDisabledForTesting") } });
      Y(fm.prototype, { confirm: { name: "confirm", j: [V("verificationCode")] } });
      Z(Bg, "fromJSON", function(a) {
        a = typeof a === "string" ? JSON.parse(a) : a;
        for (var b, c = [Mg, dh, kh, Jg], d2 = 0; d2 < c.length; d2++)
          if (b = c[d2](a))
            return b;
        return null;
      }, [X(V(), W(), "json")]);
      Z(Zg, "credential", function(a, b) {
        return new Yg(a, b);
      }, [V("email"), V("password")]);
      Y(Yg.prototype, { w: { name: "toJSON", j: [V(null, true)] } });
      Y(Qg.prototype, { Ca: { name: "addScope", j: [V("scope")] }, Ka: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });
      Z(Qg, "credential", Rg, [X(V(), W(), "token")]);
      Z(Zg, "credentialWithLink", eh, [V("email"), V("emailLink")]);
      Y(Sg.prototype, { Ca: { name: "addScope", j: [V("scope")] }, Ka: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });
      Z(Sg, "credential", Tg, [X(V(), W(), "token")]);
      Y(Ug.prototype, { Ca: { name: "addScope", j: [V("scope")] }, Ka: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });
      Z(Ug, "credential", Vg, [X(V(), X(W(), zo()), "idToken"), X(V(), zo(), "accessToken", true)]);
      Y(Wg.prototype, { Ka: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });
      Z(Wg, "credential", Xg, [X(V(), W(), "token"), V("secret", true)]);
      Y(Pg.prototype, { Ca: { name: "addScope", j: [V("scope")] }, credential: { name: "credential", j: [X(V(), X(W(), zo()), "optionsOrIdToken"), X(V(), zo(), "accessToken", true)] }, Ka: { name: "setCustomParameters", j: [W("customOAuthParameters")] } });
      Y(Kg.prototype, { w: { name: "toJSON", j: [V(null, true)] } });
      Y(Eg.prototype, { w: { name: "toJSON", j: [V(null, true)] } });
      Z(lh, "credential", ph, [V("verificationId"), V("verificationCode")]);
      Y(lh.prototype, { gb: { name: "verifyPhoneNumber", j: [X(V(), function(a, b) {
        return { name: a || "phoneInfoOptions", K: "valid phone info options", optional: !!b, M: function(c) {
          return c ? c.session && c.phoneNumber ? Go(c.session, zg) && typeof c.phoneNumber === "string" : c.session && c.multiFactorHint ? Go(c.session, Ag) && Ho(c.multiFactorHint) : c.session && c.multiFactorUid ? Go(c.session, Ag) && typeof c.multiFactorUid === "string" : c.phoneNumber ? typeof c.phoneNumber === "string" : false : false;
        } };
      }(), "phoneInfoOptions"), Io()] } });
      Y(gh.prototype, { w: { name: "toJSON", j: [V(null, true)] } });
      Y(t.prototype, { toJSON: { name: "toJSON", j: [V(null, true)] } });
      Y(yh.prototype, { toJSON: { name: "toJSON", j: [V(null, true)] } });
      Y(xh.prototype, { toJSON: { name: "toJSON", j: [V(null, true)] } });
      Y(lm.prototype, { toJSON: { name: "toJSON", j: [V(null, true)] } });
      Y(im.prototype, { Rc: { name: "resolveSignIn", j: [Eo()] } });
      Y(tm.prototype, { Sb: { name: "getSession", j: [] }, fc: { name: "enroll", j: [Eo(), V("displayName", true)] }, bd: { name: "unenroll", j: [X({ name: "multiFactorInfo", K: "a valid multiFactorInfo", optional: false, M: Ho }, V(), "multiFactorInfoIdentifier")] } });
      Y(uo.prototype, { clear: { name: "clear", j: [] }, render: { name: "render", j: [] }, verify: { name: "verify", j: [] } });
      Z(Jf, "parseLink", Rf, [V("link")]);
      Z(eo, "assertion", function(a) {
        return new rm(a);
      }, [Do("phone")]);
      (function() {
        if (typeof firebase2 !== "undefined" && firebase2.INTERNAL && firebase2.INTERNAL.registerComponent) {
          var a = { ActionCodeInfo: { Operation: { EMAIL_SIGNIN: Af, PASSWORD_RESET: "PASSWORD_RESET", RECOVER_EMAIL: "RECOVER_EMAIL", REVERT_SECOND_FACTOR_ADDITION: Cf, VERIFY_AND_CHANGE_EMAIL: Bf, VERIFY_EMAIL: "VERIFY_EMAIL" } }, Auth: Fn, AuthCredential: Bg, Error: t };
          Z(a, "EmailAuthProvider", Zg, []);
          Z(a, "FacebookAuthProvider", Qg, []);
          Z(a, "GithubAuthProvider", Sg, []);
          Z(a, "GoogleAuthProvider", Ug, []);
          Z(a, "TwitterAuthProvider", Wg, []);
          Z(a, "OAuthProvider", Pg, [V("providerId")]);
          Z(a, "SAMLAuthProvider", Og, [V("providerId")]);
          Z(a, "PhoneAuthProvider", lh, [Bo()]);
          Z(a, "RecaptchaVerifier", uo, [X(V(), Ao(), "recaptchaContainer"), W("recaptchaParameters", true), Co()]);
          Z(a, "ActionCodeURL", Jf, []);
          Z(a, "PhoneMultiFactorGenerator", eo, []);
          firebase2.INTERNAL.registerComponent({ name: "auth", instanceFactory: function(b) {
            b = b.getProvider("app").getImmediate();
            return new Fn(b);
          }, multipleInstances: false, serviceProps: a, instantiationMode: "LAZY", type: "PUBLIC", onInstanceCreated: function(b) {
            b.getProvider("auth-internal").initialize();
          } });
          firebase2.INTERNAL.registerComponent({ name: "auth-internal", instanceFactory: function(b) {
            b = b.getProvider("auth").getImmediate();
            return { getUid: q(b.getUid, b), getToken: q(b.nc, b), addAuthTokenListener: q(b.cc, b), removeAuthTokenListener: q(b.Pc, b) };
          }, multipleInstances: false, instantiationMode: "LAZY", type: "PRIVATE" });
          firebase2.registerVersion("@firebase/auth", "0.16.8");
          firebase2.INTERNAL.extendNamespace({ User: Im });
        } else
          throw Error("Cannot find the firebase namespace; be sure to include firebase-app.js before this library.");
      })();
    }).apply(typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_shims();
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/websocket-driver/lib/websocket/streams.js
var require_streams = __commonJS({
  "node_modules/websocket-driver/lib/websocket/streams.js"(exports2) {
    init_shims();
    "use strict";
    var Stream2 = require("stream").Stream;
    var util = require("util");
    var IO = function(driver) {
      this.readable = this.writable = true;
      this._paused = false;
      this._driver = driver;
    };
    util.inherits(IO, Stream2);
    IO.prototype.pause = function() {
      this._paused = true;
      this._driver.messages._paused = true;
    };
    IO.prototype.resume = function() {
      this._paused = false;
      this.emit("drain");
      var messages = this._driver.messages;
      messages._paused = false;
      messages.emit("drain");
    };
    IO.prototype.write = function(chunk) {
      if (!this.writable)
        return false;
      this._driver.parse(chunk);
      return !this._paused;
    };
    IO.prototype.end = function(chunk) {
      if (!this.writable)
        return;
      if (chunk !== void 0)
        this.write(chunk);
      this.writable = false;
      var messages = this._driver.messages;
      if (messages.readable) {
        messages.readable = messages.writable = false;
        messages.emit("end");
      }
    };
    IO.prototype.destroy = function() {
      this.end();
    };
    var Messages = function(driver) {
      this.readable = this.writable = true;
      this._paused = false;
      this._driver = driver;
    };
    util.inherits(Messages, Stream2);
    Messages.prototype.pause = function() {
      this._driver.io._paused = true;
    };
    Messages.prototype.resume = function() {
      this._driver.io._paused = false;
      this._driver.io.emit("drain");
    };
    Messages.prototype.write = function(message) {
      if (!this.writable)
        return false;
      if (typeof message === "string")
        this._driver.text(message);
      else
        this._driver.binary(message);
      return !this._paused;
    };
    Messages.prototype.end = function(message) {
      if (message !== void 0)
        this.write(message);
    };
    Messages.prototype.destroy = function() {
    };
    exports2.IO = IO;
    exports2.Messages = Messages;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/headers.js
var require_headers = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/headers.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Headers2 = function() {
      this.clear();
    };
    Headers2.prototype.ALLOWED_DUPLICATES = ["set-cookie", "set-cookie2", "warning", "www-authenticate"];
    Headers2.prototype.clear = function() {
      this._sent = {};
      this._lines = [];
    };
    Headers2.prototype.set = function(name, value) {
      if (value === void 0)
        return;
      name = this._strip(name);
      value = this._strip(value);
      var key = name.toLowerCase();
      if (!this._sent.hasOwnProperty(key) || this.ALLOWED_DUPLICATES.indexOf(key) >= 0) {
        this._sent[key] = true;
        this._lines.push(name + ": " + value + "\r\n");
      }
    };
    Headers2.prototype.toString = function() {
      return this._lines.join("");
    };
    Headers2.prototype._strip = function(string) {
      return string.toString().replace(/^ */, "").replace(/ *$/, "");
    };
    module2.exports = Headers2;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/stream_reader.js
var require_stream_reader = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/stream_reader.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var StreamReader = function() {
      this._queue = [];
      this._queueSize = 0;
      this._offset = 0;
    };
    StreamReader.prototype.put = function(buffer) {
      if (!buffer || buffer.length === 0)
        return;
      if (!Buffer2.isBuffer(buffer))
        buffer = Buffer2.from(buffer);
      this._queue.push(buffer);
      this._queueSize += buffer.length;
    };
    StreamReader.prototype.read = function(length) {
      if (length > this._queueSize)
        return null;
      if (length === 0)
        return Buffer2.alloc(0);
      this._queueSize -= length;
      var queue = this._queue, remain = length, first = queue[0], buffers, buffer;
      if (first.length >= length) {
        if (first.length === length) {
          return queue.shift();
        } else {
          buffer = first.slice(0, length);
          queue[0] = first.slice(length);
          return buffer;
        }
      }
      for (var i = 0, n = queue.length; i < n; i++) {
        if (remain < queue[i].length)
          break;
        remain -= queue[i].length;
      }
      buffers = queue.splice(0, i);
      if (remain > 0 && queue.length > 0) {
        buffers.push(queue[0].slice(0, remain));
        queue[0] = queue[0].slice(remain);
      }
      return Buffer2.concat(buffers, length);
    };
    StreamReader.prototype.eachByte = function(callback, context) {
      var buffer, n, index2;
      while (this._queue.length > 0) {
        buffer = this._queue[0];
        n = buffer.length;
        while (this._offset < n) {
          index2 = this._offset;
          this._offset += 1;
          callback.call(context, buffer[index2]);
        }
        this._offset = 0;
        this._queue.shift();
      }
    };
    module2.exports = StreamReader;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/base.js
var require_base = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/base.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Emitter = require("events").EventEmitter;
    var util = require("util");
    var streams = require_streams();
    var Headers2 = require_headers();
    var Reader = require_stream_reader();
    var Base = function(request, url, options2) {
      Emitter.call(this);
      Base.validateOptions(options2 || {}, ["maxLength", "masking", "requireMasking", "protocols"]);
      this._request = request;
      this._reader = new Reader();
      this._options = options2 || {};
      this._maxLength = this._options.maxLength || this.MAX_LENGTH;
      this._headers = new Headers2();
      this.__queue = [];
      this.readyState = 0;
      this.url = url;
      this.io = new streams.IO(this);
      this.messages = new streams.Messages(this);
      this._bindEventListeners();
    };
    util.inherits(Base, Emitter);
    Base.isWebSocket = function(request) {
      var connection = request.headers.connection || "", upgrade = request.headers.upgrade || "";
      return request.method === "GET" && connection.toLowerCase().split(/ *, */).indexOf("upgrade") >= 0 && upgrade.toLowerCase() === "websocket";
    };
    Base.validateOptions = function(options2, validKeys) {
      for (var key2 in options2) {
        if (validKeys.indexOf(key2) < 0)
          throw new Error("Unrecognized option: " + key2);
      }
    };
    var instance = {
      MAX_LENGTH: 67108863,
      STATES: ["connecting", "open", "closing", "closed"],
      _bindEventListeners: function() {
        var self2 = this;
        this.messages.on("error", function() {
        });
        this.on("message", function(event) {
          var messages = self2.messages;
          if (messages.readable)
            messages.emit("data", event.data);
        });
        this.on("error", function(error3) {
          var messages = self2.messages;
          if (messages.readable)
            messages.emit("error", error3);
        });
        this.on("close", function() {
          var messages = self2.messages;
          if (!messages.readable)
            return;
          messages.readable = messages.writable = false;
          messages.emit("end");
        });
      },
      getState: function() {
        return this.STATES[this.readyState] || null;
      },
      addExtension: function(extension) {
        return false;
      },
      setHeader: function(name, value) {
        if (this.readyState > 0)
          return false;
        this._headers.set(name, value);
        return true;
      },
      start: function() {
        if (this.readyState !== 0)
          return false;
        if (!Base.isWebSocket(this._request))
          return this._failHandshake(new Error("Not a WebSocket request"));
        var response;
        try {
          response = this._handshakeResponse();
        } catch (error3) {
          return this._failHandshake(error3);
        }
        this._write(response);
        if (this._stage !== -1)
          this._open();
        return true;
      },
      _failHandshake: function(error3) {
        var headers = new Headers2();
        headers.set("Content-Type", "text/plain");
        headers.set("Content-Length", Buffer2.byteLength(error3.message, "utf8"));
        headers = ["HTTP/1.1 400 Bad Request", headers.toString(), error3.message];
        this._write(Buffer2.from(headers.join("\r\n"), "utf8"));
        this._fail("protocol_error", error3.message);
        return false;
      },
      text: function(message) {
        return this.frame(message);
      },
      binary: function(message) {
        return false;
      },
      ping: function() {
        return false;
      },
      pong: function() {
        return false;
      },
      close: function(reason, code) {
        if (this.readyState !== 1)
          return false;
        this.readyState = 3;
        this.emit("close", new Base.CloseEvent(null, null));
        return true;
      },
      _open: function() {
        this.readyState = 1;
        this.__queue.forEach(function(args) {
          this.frame.apply(this, args);
        }, this);
        this.__queue = [];
        this.emit("open", new Base.OpenEvent());
      },
      _queue: function(message) {
        this.__queue.push(message);
        return true;
      },
      _write: function(chunk) {
        var io = this.io;
        if (io.readable)
          io.emit("data", chunk);
      },
      _fail: function(type, message) {
        this.readyState = 2;
        this.emit("error", new Error(message));
        this.close();
      }
    };
    for (key in instance)
      Base.prototype[key] = instance[key];
    var key;
    Base.ConnectEvent = function() {
    };
    Base.OpenEvent = function() {
    };
    Base.CloseEvent = function(code, reason) {
      this.code = code;
      this.reason = reason;
    };
    Base.MessageEvent = function(data) {
      this.data = data;
    };
    Base.PingEvent = function(data) {
      this.data = data;
    };
    Base.PongEvent = function(data) {
      this.data = data;
    };
    module2.exports = Base;
  }
});

// node_modules/http-parser-js/http-parser.js
var require_http_parser = __commonJS({
  "node_modules/http-parser-js/http-parser.js"(exports2) {
    init_shims();
    var assert = require("assert");
    exports2.HTTPParser = HTTPParser;
    function HTTPParser(type) {
      assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === void 0);
      if (type === void 0) {
      } else {
        this.initialize(type);
      }
    }
    HTTPParser.prototype.initialize = function(type, async_resource) {
      assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);
      this.type = type;
      this.state = type + "_LINE";
      this.info = {
        headers: [],
        upgrade: false
      };
      this.trailers = [];
      this.line = "";
      this.isChunked = false;
      this.connection = "";
      this.headerSize = 0;
      this.body_bytes = null;
      this.isUserCall = false;
      this.hadError = false;
    };
    HTTPParser.encoding = "ascii";
    HTTPParser.maxHeaderSize = 80 * 1024;
    HTTPParser.REQUEST = "REQUEST";
    HTTPParser.RESPONSE = "RESPONSE";
    var kOnHeaders = HTTPParser.kOnHeaders = 1;
    var kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;
    var kOnBody = HTTPParser.kOnBody = 3;
    var kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;
    HTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function() {
    };
    var compatMode0_12 = true;
    Object.defineProperty(HTTPParser, "kOnExecute", {
      get: function() {
        compatMode0_12 = false;
        return 99;
      }
    });
    var methods = exports2.methods = HTTPParser.methods = [
      "DELETE",
      "GET",
      "HEAD",
      "POST",
      "PUT",
      "CONNECT",
      "OPTIONS",
      "TRACE",
      "COPY",
      "LOCK",
      "MKCOL",
      "MOVE",
      "PROPFIND",
      "PROPPATCH",
      "SEARCH",
      "UNLOCK",
      "BIND",
      "REBIND",
      "UNBIND",
      "ACL",
      "REPORT",
      "MKACTIVITY",
      "CHECKOUT",
      "MERGE",
      "M-SEARCH",
      "NOTIFY",
      "SUBSCRIBE",
      "UNSUBSCRIBE",
      "PATCH",
      "PURGE",
      "MKCALENDAR",
      "LINK",
      "UNLINK"
    ];
    var method_connect = methods.indexOf("CONNECT");
    HTTPParser.prototype.reinitialize = HTTPParser;
    HTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function() {
    };
    HTTPParser.prototype._compatMode0_11 = false;
    HTTPParser.prototype.getAsyncId = function() {
      return 0;
    };
    var headerState = {
      REQUEST_LINE: true,
      RESPONSE_LINE: true,
      HEADER: true
    };
    HTTPParser.prototype.execute = function(chunk, start, length) {
      if (!(this instanceof HTTPParser)) {
        throw new TypeError("not a HTTPParser");
      }
      start = start || 0;
      length = typeof length === "number" ? length : chunk.length;
      this.chunk = chunk;
      this.offset = start;
      var end = this.end = start + length;
      try {
        while (this.offset < end) {
          if (this[this.state]()) {
            break;
          }
        }
      } catch (err) {
        if (this.isUserCall) {
          throw err;
        }
        this.hadError = true;
        return err;
      }
      this.chunk = null;
      length = this.offset - start;
      if (headerState[this.state]) {
        this.headerSize += length;
        if (this.headerSize > HTTPParser.maxHeaderSize) {
          return new Error("max header size exceeded");
        }
      }
      return length;
    };
    var stateFinishAllowed = {
      REQUEST_LINE: true,
      RESPONSE_LINE: true,
      BODY_RAW: true
    };
    HTTPParser.prototype.finish = function() {
      if (this.hadError) {
        return;
      }
      if (!stateFinishAllowed[this.state]) {
        return new Error("invalid state for EOF");
      }
      if (this.state === "BODY_RAW") {
        this.userCall()(this[kOnMessageComplete]());
      }
    };
    HTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function() {
    };
    HTTPParser.prototype.userCall = function() {
      this.isUserCall = true;
      var self2 = this;
      return function(ret) {
        self2.isUserCall = false;
        return ret;
      };
    };
    HTTPParser.prototype.nextRequest = function() {
      this.userCall()(this[kOnMessageComplete]());
      this.reinitialize(this.type);
    };
    HTTPParser.prototype.consumeLine = function() {
      var end = this.end, chunk = this.chunk;
      for (var i = this.offset; i < end; i++) {
        if (chunk[i] === 10) {
          var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);
          if (line.charAt(line.length - 1) === "\r") {
            line = line.substr(0, line.length - 1);
          }
          this.line = "";
          this.offset = i + 1;
          return line;
        }
      }
      this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);
      this.offset = this.end;
    };
    var headerExp = /^([^: \t]+):[ \t]*((?:.*[^ \t])|)/;
    var headerContinueExp = /^[ \t]+(.*[^ \t])/;
    HTTPParser.prototype.parseHeader = function(line, headers) {
      if (line.indexOf("\r") !== -1) {
        throw parseErrorCode("HPE_LF_EXPECTED");
      }
      var match = headerExp.exec(line);
      var k = match && match[1];
      if (k) {
        headers.push(k);
        headers.push(match[2]);
      } else {
        var matchContinue = headerContinueExp.exec(line);
        if (matchContinue && headers.length) {
          if (headers[headers.length - 1]) {
            headers[headers.length - 1] += " ";
          }
          headers[headers.length - 1] += matchContinue[1];
        }
      }
    };
    var requestExp = /^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;
    HTTPParser.prototype.REQUEST_LINE = function() {
      var line = this.consumeLine();
      if (!line) {
        return;
      }
      var match = requestExp.exec(line);
      if (match === null) {
        throw parseErrorCode("HPE_INVALID_CONSTANT");
      }
      this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);
      if (this.info.method === -1) {
        throw new Error("invalid request method");
      }
      this.info.url = match[2];
      this.info.versionMajor = +match[3];
      this.info.versionMinor = +match[4];
      this.body_bytes = 0;
      this.state = "HEADER";
    };
    var responseExp = /^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;
    HTTPParser.prototype.RESPONSE_LINE = function() {
      var line = this.consumeLine();
      if (!line) {
        return;
      }
      var match = responseExp.exec(line);
      if (match === null) {
        throw parseErrorCode("HPE_INVALID_CONSTANT");
      }
      this.info.versionMajor = +match[1];
      this.info.versionMinor = +match[2];
      var statusCode = this.info.statusCode = +match[3];
      this.info.statusMessage = match[4];
      if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {
        this.body_bytes = 0;
      }
      this.state = "HEADER";
    };
    HTTPParser.prototype.shouldKeepAlive = function() {
      if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {
        if (this.connection.indexOf("close") !== -1) {
          return false;
        }
      } else if (this.connection.indexOf("keep-alive") === -1) {
        return false;
      }
      if (this.body_bytes !== null || this.isChunked) {
        return true;
      }
      return false;
    };
    HTTPParser.prototype.HEADER = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      var info = this.info;
      if (line) {
        this.parseHeader(line, info.headers);
      } else {
        var headers = info.headers;
        var hasContentLength = false;
        var currentContentLengthValue;
        var hasUpgradeHeader = false;
        for (var i = 0; i < headers.length; i += 2) {
          switch (headers[i].toLowerCase()) {
            case "transfer-encoding":
              this.isChunked = headers[i + 1].toLowerCase() === "chunked";
              break;
            case "content-length":
              currentContentLengthValue = +headers[i + 1];
              if (hasContentLength) {
                if (currentContentLengthValue !== this.body_bytes) {
                  throw parseErrorCode("HPE_UNEXPECTED_CONTENT_LENGTH");
                }
              } else {
                hasContentLength = true;
                this.body_bytes = currentContentLengthValue;
              }
              break;
            case "connection":
              this.connection += headers[i + 1].toLowerCase();
              break;
            case "upgrade":
              hasUpgradeHeader = true;
              break;
          }
        }
        if (this.isChunked && hasContentLength) {
          hasContentLength = false;
          this.body_bytes = null;
        }
        if (hasUpgradeHeader && this.connection.indexOf("upgrade") != -1) {
          info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;
        } else {
          info.upgrade = info.method === method_connect;
        }
        if (this.isChunked && info.upgrade) {
          this.isChunked = false;
        }
        info.shouldKeepAlive = this.shouldKeepAlive();
        var skipBody;
        if (compatMode0_12) {
          skipBody = this.userCall()(this[kOnHeadersComplete](info));
        } else {
          skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));
        }
        if (skipBody === 2) {
          this.nextRequest();
          return true;
        } else if (this.isChunked && !skipBody) {
          this.state = "BODY_CHUNKHEAD";
        } else if (skipBody || this.body_bytes === 0) {
          this.nextRequest();
          return info.upgrade;
        } else if (this.body_bytes === null) {
          this.state = "BODY_RAW";
        } else {
          this.state = "BODY_SIZED";
        }
      }
    };
    HTTPParser.prototype.BODY_CHUNKHEAD = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      this.body_bytes = parseInt(line, 16);
      if (!this.body_bytes) {
        this.state = "BODY_CHUNKTRAILERS";
      } else {
        this.state = "BODY_CHUNK";
      }
    };
    HTTPParser.prototype.BODY_CHUNK = function() {
      var length = Math.min(this.end - this.offset, this.body_bytes);
      this.userCall()(this[kOnBody](this.chunk, this.offset, length));
      this.offset += length;
      this.body_bytes -= length;
      if (!this.body_bytes) {
        this.state = "BODY_CHUNKEMPTYLINE";
      }
    };
    HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      assert.equal(line, "");
      this.state = "BODY_CHUNKHEAD";
    };
    HTTPParser.prototype.BODY_CHUNKTRAILERS = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      if (line) {
        this.parseHeader(line, this.trailers);
      } else {
        if (this.trailers.length) {
          this.userCall()(this[kOnHeaders](this.trailers, ""));
        }
        this.nextRequest();
      }
    };
    HTTPParser.prototype.BODY_RAW = function() {
      var length = this.end - this.offset;
      this.userCall()(this[kOnBody](this.chunk, this.offset, length));
      this.offset = this.end;
    };
    HTTPParser.prototype.BODY_SIZED = function() {
      var length = Math.min(this.end - this.offset, this.body_bytes);
      this.userCall()(this[kOnBody](this.chunk, this.offset, length));
      this.offset += length;
      this.body_bytes -= length;
      if (!this.body_bytes) {
        this.nextRequest();
      }
    };
    ["Headers", "HeadersComplete", "Body", "MessageComplete"].forEach(function(name) {
      var k = HTTPParser["kOn" + name];
      Object.defineProperty(HTTPParser.prototype, "on" + name, {
        get: function() {
          return this[k];
        },
        set: function(to) {
          this._compatMode0_11 = true;
          method_connect = "CONNECT";
          return this[k] = to;
        }
      });
    });
    function parseErrorCode(code) {
      var err = new Error("Parse Error");
      err.code = code;
      return err;
    }
  }
});

// node_modules/websocket-driver/lib/websocket/http_parser.js
var require_http_parser2 = __commonJS({
  "node_modules/websocket-driver/lib/websocket/http_parser.js"(exports2, module2) {
    init_shims();
    "use strict";
    var NodeHTTPParser = require_http_parser().HTTPParser;
    var Buffer2 = require_safe_buffer().Buffer;
    var TYPES = {
      request: NodeHTTPParser.REQUEST || "request",
      response: NodeHTTPParser.RESPONSE || "response"
    };
    var HttpParser = function(type) {
      this._type = type;
      this._parser = new NodeHTTPParser(TYPES[type]);
      this._complete = false;
      this.headers = {};
      var current = null, self2 = this;
      this._parser.onHeaderField = function(b, start, length) {
        current = b.toString("utf8", start, start + length).toLowerCase();
      };
      this._parser.onHeaderValue = function(b, start, length) {
        var value = b.toString("utf8", start, start + length);
        if (self2.headers.hasOwnProperty(current))
          self2.headers[current] += ", " + value;
        else
          self2.headers[current] = value;
      };
      this._parser.onHeadersComplete = this._parser[NodeHTTPParser.kOnHeadersComplete] = function(majorVersion, minorVersion, headers, method, pathname, statusCode) {
        var info = arguments[0];
        if (typeof info === "object") {
          method = info.method;
          pathname = info.url;
          statusCode = info.statusCode;
          headers = info.headers;
        }
        self2.method = typeof method === "number" ? HttpParser.METHODS[method] : method;
        self2.statusCode = statusCode;
        self2.url = pathname;
        if (!headers)
          return;
        for (var i = 0, n = headers.length, key, value; i < n; i += 2) {
          key = headers[i].toLowerCase();
          value = headers[i + 1];
          if (self2.headers.hasOwnProperty(key))
            self2.headers[key] += ", " + value;
          else
            self2.headers[key] = value;
        }
        self2._complete = true;
      };
    };
    HttpParser.METHODS = {
      0: "DELETE",
      1: "GET",
      2: "HEAD",
      3: "POST",
      4: "PUT",
      5: "CONNECT",
      6: "OPTIONS",
      7: "TRACE",
      8: "COPY",
      9: "LOCK",
      10: "MKCOL",
      11: "MOVE",
      12: "PROPFIND",
      13: "PROPPATCH",
      14: "SEARCH",
      15: "UNLOCK",
      16: "BIND",
      17: "REBIND",
      18: "UNBIND",
      19: "ACL",
      20: "REPORT",
      21: "MKACTIVITY",
      22: "CHECKOUT",
      23: "MERGE",
      24: "M-SEARCH",
      25: "NOTIFY",
      26: "SUBSCRIBE",
      27: "UNSUBSCRIBE",
      28: "PATCH",
      29: "PURGE",
      30: "MKCALENDAR",
      31: "LINK",
      32: "UNLINK"
    };
    var VERSION = process.version ? process.version.match(/[0-9]+/g).map(function(n) {
      return parseInt(n, 10);
    }) : [];
    if (VERSION[0] === 0 && VERSION[1] === 12) {
      HttpParser.METHODS[16] = "REPORT";
      HttpParser.METHODS[17] = "MKACTIVITY";
      HttpParser.METHODS[18] = "CHECKOUT";
      HttpParser.METHODS[19] = "MERGE";
      HttpParser.METHODS[20] = "M-SEARCH";
      HttpParser.METHODS[21] = "NOTIFY";
      HttpParser.METHODS[22] = "SUBSCRIBE";
      HttpParser.METHODS[23] = "UNSUBSCRIBE";
      HttpParser.METHODS[24] = "PATCH";
      HttpParser.METHODS[25] = "PURGE";
    }
    HttpParser.prototype.isComplete = function() {
      return this._complete;
    };
    HttpParser.prototype.parse = function(chunk) {
      var consumed = this._parser.execute(chunk, 0, chunk.length);
      if (typeof consumed !== "number") {
        this.error = consumed;
        this._complete = true;
        return;
      }
      if (this._complete)
        this.body = consumed < chunk.length ? chunk.slice(consumed) : Buffer2.alloc(0);
    };
    module2.exports = HttpParser;
  }
});

// node_modules/websocket-extensions/lib/parser.js
var require_parser = __commonJS({
  "node_modules/websocket-extensions/lib/parser.js"(exports2, module2) {
    init_shims();
    "use strict";
    var TOKEN = /([!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+)/;
    var NOTOKEN = /([^!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z])/g;
    var QUOTED = /"((?:\\[\x00-\x7f]|[^\x00-\x08\x0a-\x1f\x7f"\\])*)"/;
    var PARAM = new RegExp(TOKEN.source + "(?:=(?:" + TOKEN.source + "|" + QUOTED.source + "))?");
    var EXT = new RegExp(TOKEN.source + "(?: *; *" + PARAM.source + ")*", "g");
    var EXT_LIST = new RegExp("^" + EXT.source + "(?: *, *" + EXT.source + ")*$");
    var NUMBER = /^-?(0|[1-9][0-9]*)(\.[0-9]+)?$/;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var Parser = {
      parseHeader: function(header) {
        var offers = new Offers();
        if (header === "" || header === void 0)
          return offers;
        if (!EXT_LIST.test(header))
          throw new SyntaxError("Invalid Sec-WebSocket-Extensions header: " + header);
        var values = header.match(EXT);
        values.forEach(function(value) {
          var params = value.match(new RegExp(PARAM.source, "g")), name = params.shift(), offer = {};
          params.forEach(function(param) {
            var args = param.match(PARAM), key = args[1], data;
            if (args[2] !== void 0) {
              data = args[2];
            } else if (args[3] !== void 0) {
              data = args[3].replace(/\\/g, "");
            } else {
              data = true;
            }
            if (NUMBER.test(data))
              data = parseFloat(data);
            if (hasOwnProperty.call(offer, key)) {
              offer[key] = [].concat(offer[key]);
              offer[key].push(data);
            } else {
              offer[key] = data;
            }
          }, this);
          offers.push(name, offer);
        }, this);
        return offers;
      },
      serializeParams: function(name, params) {
        var values = [];
        var print = function(key2, value) {
          if (value instanceof Array) {
            value.forEach(function(v) {
              print(key2, v);
            });
          } else if (value === true) {
            values.push(key2);
          } else if (typeof value === "number") {
            values.push(key2 + "=" + value);
          } else if (NOTOKEN.test(value)) {
            values.push(key2 + '="' + value.replace(/"/g, '\\"') + '"');
          } else {
            values.push(key2 + "=" + value);
          }
        };
        for (var key in params)
          print(key, params[key]);
        return [name].concat(values).join("; ");
      }
    };
    var Offers = function() {
      this._byName = {};
      this._inOrder = [];
    };
    Offers.prototype.push = function(name, params) {
      if (!hasOwnProperty.call(this._byName, name))
        this._byName[name] = [];
      this._byName[name].push(params);
      this._inOrder.push({ name, params });
    };
    Offers.prototype.eachOffer = function(callback, context) {
      var list = this._inOrder;
      for (var i = 0, n = list.length; i < n; i++)
        callback.call(context, list[i].name, list[i].params);
    };
    Offers.prototype.byName = function(name) {
      return this._byName[name] || [];
    };
    Offers.prototype.toArray = function() {
      return this._inOrder.slice();
    };
    module2.exports = Parser;
  }
});

// node_modules/websocket-extensions/lib/pipeline/ring_buffer.js
var require_ring_buffer = __commonJS({
  "node_modules/websocket-extensions/lib/pipeline/ring_buffer.js"(exports2, module2) {
    init_shims();
    "use strict";
    var RingBuffer = function(bufferSize) {
      this._bufferSize = bufferSize;
      this.clear();
    };
    RingBuffer.prototype.clear = function() {
      this._buffer = new Array(this._bufferSize);
      this._ringOffset = 0;
      this._ringSize = this._bufferSize;
      this._head = 0;
      this._tail = 0;
      this.length = 0;
    };
    RingBuffer.prototype.push = function(value) {
      var expandBuffer = false, expandRing = false;
      if (this._ringSize < this._bufferSize) {
        expandBuffer = this._tail === 0;
      } else if (this._ringOffset === this._ringSize) {
        expandBuffer = true;
        expandRing = this._tail === 0;
      }
      if (expandBuffer) {
        this._tail = this._bufferSize;
        this._buffer = this._buffer.concat(new Array(this._bufferSize));
        this._bufferSize = this._buffer.length;
        if (expandRing)
          this._ringSize = this._bufferSize;
      }
      this._buffer[this._tail] = value;
      this.length += 1;
      if (this._tail < this._ringSize)
        this._ringOffset += 1;
      this._tail = (this._tail + 1) % this._bufferSize;
    };
    RingBuffer.prototype.peek = function() {
      if (this.length === 0)
        return void 0;
      return this._buffer[this._head];
    };
    RingBuffer.prototype.shift = function() {
      if (this.length === 0)
        return void 0;
      var value = this._buffer[this._head];
      this._buffer[this._head] = void 0;
      this.length -= 1;
      this._ringOffset -= 1;
      if (this._ringOffset === 0 && this.length > 0) {
        this._head = this._ringSize;
        this._ringOffset = this.length;
        this._ringSize = this._bufferSize;
      } else {
        this._head = (this._head + 1) % this._ringSize;
      }
      return value;
    };
    module2.exports = RingBuffer;
  }
});

// node_modules/websocket-extensions/lib/pipeline/functor.js
var require_functor = __commonJS({
  "node_modules/websocket-extensions/lib/pipeline/functor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var RingBuffer = require_ring_buffer();
    var Functor = function(session, method) {
      this._session = session;
      this._method = method;
      this._queue = new RingBuffer(Functor.QUEUE_SIZE);
      this._stopped = false;
      this.pending = 0;
    };
    Functor.QUEUE_SIZE = 8;
    Functor.prototype.call = function(error3, message, callback, context) {
      if (this._stopped)
        return;
      var record = { error: error3, message, callback, context, done: false }, called = false, self2 = this;
      this._queue.push(record);
      if (record.error) {
        record.done = true;
        this._stop();
        return this._flushQueue();
      }
      var handler2 = function(err, msg) {
        if (!(called ^ (called = true)))
          return;
        if (err) {
          self2._stop();
          record.error = err;
          record.message = null;
        } else {
          record.message = msg;
        }
        record.done = true;
        self2._flushQueue();
      };
      try {
        this._session[this._method](message, handler2);
      } catch (err) {
        handler2(err);
      }
    };
    Functor.prototype._stop = function() {
      this.pending = this._queue.length;
      this._stopped = true;
    };
    Functor.prototype._flushQueue = function() {
      var queue = this._queue, record;
      while (queue.length > 0 && queue.peek().done) {
        record = queue.shift();
        if (record.error) {
          this.pending = 0;
          queue.clear();
        } else {
          this.pending -= 1;
        }
        record.callback.call(record.context, record.error, record.message);
      }
    };
    module2.exports = Functor;
  }
});

// node_modules/websocket-extensions/lib/pipeline/pledge.js
var require_pledge = __commonJS({
  "node_modules/websocket-extensions/lib/pipeline/pledge.js"(exports2, module2) {
    init_shims();
    "use strict";
    var RingBuffer = require_ring_buffer();
    var Pledge = function() {
      this._complete = false;
      this._callbacks = new RingBuffer(Pledge.QUEUE_SIZE);
    };
    Pledge.QUEUE_SIZE = 4;
    Pledge.all = function(list) {
      var pledge = new Pledge(), pending = list.length, n = pending;
      if (pending === 0)
        pledge.done();
      while (n--)
        list[n].then(function() {
          pending -= 1;
          if (pending === 0)
            pledge.done();
        });
      return pledge;
    };
    Pledge.prototype.then = function(callback) {
      if (this._complete)
        callback();
      else
        this._callbacks.push(callback);
    };
    Pledge.prototype.done = function() {
      this._complete = true;
      var callbacks = this._callbacks, callback;
      while (callback = callbacks.shift())
        callback();
    };
    module2.exports = Pledge;
  }
});

// node_modules/websocket-extensions/lib/pipeline/cell.js
var require_cell = __commonJS({
  "node_modules/websocket-extensions/lib/pipeline/cell.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Functor = require_functor();
    var Pledge = require_pledge();
    var Cell = function(tuple) {
      this._ext = tuple[0];
      this._session = tuple[1];
      this._functors = {
        incoming: new Functor(this._session, "processIncomingMessage"),
        outgoing: new Functor(this._session, "processOutgoingMessage")
      };
    };
    Cell.prototype.pending = function(direction) {
      var functor = this._functors[direction];
      if (!functor._stopped)
        functor.pending += 1;
    };
    Cell.prototype.incoming = function(error3, message, callback, context) {
      this._exec("incoming", error3, message, callback, context);
    };
    Cell.prototype.outgoing = function(error3, message, callback, context) {
      this._exec("outgoing", error3, message, callback, context);
    };
    Cell.prototype.close = function() {
      this._closed = this._closed || new Pledge();
      this._doClose();
      return this._closed;
    };
    Cell.prototype._exec = function(direction, error3, message, callback, context) {
      this._functors[direction].call(error3, message, function(err, msg) {
        if (err)
          err.message = this._ext.name + ": " + err.message;
        callback.call(context, err, msg);
        this._doClose();
      }, this);
    };
    Cell.prototype._doClose = function() {
      var fin = this._functors.incoming, fout = this._functors.outgoing;
      if (!this._closed || fin.pending + fout.pending !== 0)
        return;
      if (this._session)
        this._session.close();
      this._session = null;
      this._closed.done();
    };
    module2.exports = Cell;
  }
});

// node_modules/websocket-extensions/lib/pipeline/index.js
var require_pipeline = __commonJS({
  "node_modules/websocket-extensions/lib/pipeline/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Cell = require_cell();
    var Pledge = require_pledge();
    var Pipeline = function(sessions) {
      this._cells = sessions.map(function(session) {
        return new Cell(session);
      });
      this._stopped = { incoming: false, outgoing: false };
    };
    Pipeline.prototype.processIncomingMessage = function(message, callback, context) {
      if (this._stopped.incoming)
        return;
      this._loop("incoming", this._cells.length - 1, -1, -1, message, callback, context);
    };
    Pipeline.prototype.processOutgoingMessage = function(message, callback, context) {
      if (this._stopped.outgoing)
        return;
      this._loop("outgoing", 0, this._cells.length, 1, message, callback, context);
    };
    Pipeline.prototype.close = function(callback, context) {
      this._stopped = { incoming: true, outgoing: true };
      var closed = this._cells.map(function(a) {
        return a.close();
      });
      if (callback)
        Pledge.all(closed).then(function() {
          callback.call(context);
        });
    };
    Pipeline.prototype._loop = function(direction, start, end, step, message, callback, context) {
      var cells = this._cells, n = cells.length, self2 = this;
      while (n--)
        cells[n].pending(direction);
      var pipe = function(index2, error3, msg) {
        if (index2 === end)
          return callback.call(context, error3, msg);
        cells[index2][direction](error3, msg, function(err, m) {
          if (err)
            self2._stopped[direction] = true;
          pipe(index2 + step, err, m);
        });
      };
      pipe(start, null, message);
    };
    module2.exports = Pipeline;
  }
});

// node_modules/websocket-extensions/lib/websocket_extensions.js
var require_websocket_extensions = __commonJS({
  "node_modules/websocket-extensions/lib/websocket_extensions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Parser = require_parser();
    var Pipeline = require_pipeline();
    var Extensions = function() {
      this._rsv1 = this._rsv2 = this._rsv3 = null;
      this._byName = {};
      this._inOrder = [];
      this._sessions = [];
      this._index = {};
    };
    Extensions.MESSAGE_OPCODES = [1, 2];
    var instance = {
      add: function(ext) {
        if (typeof ext.name !== "string")
          throw new TypeError("extension.name must be a string");
        if (ext.type !== "permessage")
          throw new TypeError('extension.type must be "permessage"');
        if (typeof ext.rsv1 !== "boolean")
          throw new TypeError("extension.rsv1 must be true or false");
        if (typeof ext.rsv2 !== "boolean")
          throw new TypeError("extension.rsv2 must be true or false");
        if (typeof ext.rsv3 !== "boolean")
          throw new TypeError("extension.rsv3 must be true or false");
        if (this._byName.hasOwnProperty(ext.name))
          throw new TypeError('An extension with name "' + ext.name + '" is already registered');
        this._byName[ext.name] = ext;
        this._inOrder.push(ext);
      },
      generateOffer: function() {
        var sessions = [], offer = [], index2 = {};
        this._inOrder.forEach(function(ext) {
          var session = ext.createClientSession();
          if (!session)
            return;
          var record = [ext, session];
          sessions.push(record);
          index2[ext.name] = record;
          var offers = session.generateOffer();
          offers = offers ? [].concat(offers) : [];
          offers.forEach(function(off) {
            offer.push(Parser.serializeParams(ext.name, off));
          }, this);
        }, this);
        this._sessions = sessions;
        this._index = index2;
        return offer.length > 0 ? offer.join(", ") : null;
      },
      activate: function(header) {
        var responses = Parser.parseHeader(header), sessions = [];
        responses.eachOffer(function(name, params) {
          var record = this._index[name];
          if (!record)
            throw new Error('Server sent an extension response for unknown extension "' + name + '"');
          var ext = record[0], session = record[1], reserved2 = this._reserved(ext);
          if (reserved2)
            throw new Error("Server sent two extension responses that use the RSV" + reserved2[0] + ' bit: "' + reserved2[1] + '" and "' + ext.name + '"');
          if (session.activate(params) !== true)
            throw new Error("Server sent unacceptable extension parameters: " + Parser.serializeParams(name, params));
          this._reserve(ext);
          sessions.push(record);
        }, this);
        this._sessions = sessions;
        this._pipeline = new Pipeline(sessions);
      },
      generateResponse: function(header) {
        var sessions = [], response = [], offers = Parser.parseHeader(header);
        this._inOrder.forEach(function(ext) {
          var offer = offers.byName(ext.name);
          if (offer.length === 0 || this._reserved(ext))
            return;
          var session = ext.createServerSession(offer);
          if (!session)
            return;
          this._reserve(ext);
          sessions.push([ext, session]);
          response.push(Parser.serializeParams(ext.name, session.generateResponse()));
        }, this);
        this._sessions = sessions;
        this._pipeline = new Pipeline(sessions);
        return response.length > 0 ? response.join(", ") : null;
      },
      validFrameRsv: function(frame) {
        var allowed = { rsv1: false, rsv2: false, rsv3: false }, ext;
        if (Extensions.MESSAGE_OPCODES.indexOf(frame.opcode) >= 0) {
          for (var i = 0, n = this._sessions.length; i < n; i++) {
            ext = this._sessions[i][0];
            allowed.rsv1 = allowed.rsv1 || ext.rsv1;
            allowed.rsv2 = allowed.rsv2 || ext.rsv2;
            allowed.rsv3 = allowed.rsv3 || ext.rsv3;
          }
        }
        return (allowed.rsv1 || !frame.rsv1) && (allowed.rsv2 || !frame.rsv2) && (allowed.rsv3 || !frame.rsv3);
      },
      processIncomingMessage: function(message, callback, context) {
        this._pipeline.processIncomingMessage(message, callback, context);
      },
      processOutgoingMessage: function(message, callback, context) {
        this._pipeline.processOutgoingMessage(message, callback, context);
      },
      close: function(callback, context) {
        if (!this._pipeline)
          return callback.call(context);
        this._pipeline.close(callback, context);
      },
      _reserve: function(ext) {
        this._rsv1 = this._rsv1 || ext.rsv1 && ext.name;
        this._rsv2 = this._rsv2 || ext.rsv2 && ext.name;
        this._rsv3 = this._rsv3 || ext.rsv3 && ext.name;
      },
      _reserved: function(ext) {
        if (this._rsv1 && ext.rsv1)
          return [1, this._rsv1];
        if (this._rsv2 && ext.rsv2)
          return [2, this._rsv2];
        if (this._rsv3 && ext.rsv3)
          return [3, this._rsv3];
        return false;
      }
    };
    for (key in instance)
      Extensions.prototype[key] = instance[key];
    var key;
    module2.exports = Extensions;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/hybi/frame.js
var require_frame = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/hybi/frame.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Frame = function() {
    };
    var instance = {
      final: false,
      rsv1: false,
      rsv2: false,
      rsv3: false,
      opcode: null,
      masked: false,
      maskingKey: null,
      lengthBytes: 1,
      length: 0,
      payload: null
    };
    for (key in instance)
      Frame.prototype[key] = instance[key];
    var key;
    module2.exports = Frame;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/hybi/message.js
var require_message = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/hybi/message.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Message = function() {
      this.rsv1 = false;
      this.rsv2 = false;
      this.rsv3 = false;
      this.opcode = null;
      this.length = 0;
      this._chunks = [];
    };
    var instance = {
      read: function() {
        return this.data = this.data || Buffer2.concat(this._chunks, this.length);
      },
      pushFrame: function(frame) {
        this.rsv1 = this.rsv1 || frame.rsv1;
        this.rsv2 = this.rsv2 || frame.rsv2;
        this.rsv3 = this.rsv3 || frame.rsv3;
        if (this.opcode === null)
          this.opcode = frame.opcode;
        this._chunks.push(frame.payload);
        this.length += frame.length;
      }
    };
    for (key in instance)
      Message.prototype[key] = instance[key];
    var key;
    module2.exports = Message;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/hybi.js
var require_hybi = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/hybi.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto = require("crypto");
    var util = require("util");
    var Extensions = require_websocket_extensions();
    var Base = require_base();
    var Frame = require_frame();
    var Message = require_message();
    var Hybi = function(request, url, options2) {
      Base.apply(this, arguments);
      this._extensions = new Extensions();
      this._stage = 0;
      this._masking = this._options.masking;
      this._protocols = this._options.protocols || [];
      this._requireMasking = this._options.requireMasking;
      this._pingCallbacks = {};
      if (typeof this._protocols === "string")
        this._protocols = this._protocols.split(/ *, */);
      if (!this._request)
        return;
      var protos = this._request.headers["sec-websocket-protocol"], supported = this._protocols;
      if (protos !== void 0) {
        if (typeof protos === "string")
          protos = protos.split(/ *, */);
        this.protocol = protos.filter(function(p) {
          return supported.indexOf(p) >= 0;
        })[0];
      }
      this.version = "hybi-" + Hybi.VERSION;
    };
    util.inherits(Hybi, Base);
    Hybi.VERSION = "13";
    Hybi.mask = function(payload, mask, offset) {
      if (!mask || mask.length === 0)
        return payload;
      offset = offset || 0;
      for (var i = 0, n = payload.length - offset; i < n; i++) {
        payload[offset + i] = payload[offset + i] ^ mask[i % 4];
      }
      return payload;
    };
    Hybi.generateAccept = function(key2) {
      var sha1 = crypto.createHash("sha1");
      sha1.update(key2 + Hybi.GUID);
      return sha1.digest("base64");
    };
    Hybi.GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var instance = {
      FIN: 128,
      MASK: 128,
      RSV1: 64,
      RSV2: 32,
      RSV3: 16,
      OPCODE: 15,
      LENGTH: 127,
      OPCODES: {
        continuation: 0,
        text: 1,
        binary: 2,
        close: 8,
        ping: 9,
        pong: 10
      },
      OPCODE_CODES: [0, 1, 2, 8, 9, 10],
      MESSAGE_OPCODES: [0, 1, 2],
      OPENING_OPCODES: [1, 2],
      ERRORS: {
        normal_closure: 1e3,
        going_away: 1001,
        protocol_error: 1002,
        unacceptable: 1003,
        encoding_error: 1007,
        policy_violation: 1008,
        too_large: 1009,
        extension_error: 1010,
        unexpected_condition: 1011
      },
      ERROR_CODES: [1e3, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011],
      DEFAULT_ERROR_CODE: 1e3,
      MIN_RESERVED_ERROR: 3e3,
      MAX_RESERVED_ERROR: 4999,
      UTF8_MATCH: /^([\x00-\x7F]|[\xC2-\xDF][\x80-\xBF]|\xE0[\xA0-\xBF][\x80-\xBF]|[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}|\xED[\x80-\x9F][\x80-\xBF]|\xF0[\x90-\xBF][\x80-\xBF]{2}|[\xF1-\xF3][\x80-\xBF]{3}|\xF4[\x80-\x8F][\x80-\xBF]{2})*$/,
      addExtension: function(extension) {
        this._extensions.add(extension);
        return true;
      },
      parse: function(chunk) {
        this._reader.put(chunk);
        var buffer = true;
        while (buffer) {
          switch (this._stage) {
            case 0:
              buffer = this._reader.read(1);
              if (buffer)
                this._parseOpcode(buffer[0]);
              break;
            case 1:
              buffer = this._reader.read(1);
              if (buffer)
                this._parseLength(buffer[0]);
              break;
            case 2:
              buffer = this._reader.read(this._frame.lengthBytes);
              if (buffer)
                this._parseExtendedLength(buffer);
              break;
            case 3:
              buffer = this._reader.read(4);
              if (buffer) {
                this._stage = 4;
                this._frame.maskingKey = buffer;
              }
              break;
            case 4:
              buffer = this._reader.read(this._frame.length);
              if (buffer) {
                this._stage = 0;
                this._emitFrame(buffer);
              }
              break;
            default:
              buffer = null;
          }
        }
      },
      text: function(message) {
        if (this.readyState > 1)
          return false;
        return this.frame(message, "text");
      },
      binary: function(message) {
        if (this.readyState > 1)
          return false;
        return this.frame(message, "binary");
      },
      ping: function(message, callback) {
        if (this.readyState > 1)
          return false;
        message = message || "";
        if (callback)
          this._pingCallbacks[message] = callback;
        return this.frame(message, "ping");
      },
      pong: function(message) {
        if (this.readyState > 1)
          return false;
        message = message || "";
        return this.frame(message, "pong");
      },
      close: function(reason, code) {
        reason = reason || "";
        code = code || this.ERRORS.normal_closure;
        if (this.readyState <= 0) {
          this.readyState = 3;
          this.emit("close", new Base.CloseEvent(code, reason));
          return true;
        } else if (this.readyState === 1) {
          this.readyState = 2;
          this._extensions.close(function() {
            this.frame(reason, "close", code);
          }, this);
          return true;
        } else {
          return false;
        }
      },
      frame: function(buffer, type, code) {
        if (this.readyState <= 0)
          return this._queue([buffer, type, code]);
        if (this.readyState > 2)
          return false;
        if (buffer instanceof Array)
          buffer = Buffer2.from(buffer);
        if (typeof buffer === "number")
          buffer = buffer.toString();
        var message = new Message(), isText = typeof buffer === "string", payload, copy;
        message.rsv1 = message.rsv2 = message.rsv3 = false;
        message.opcode = this.OPCODES[type || (isText ? "text" : "binary")];
        payload = isText ? Buffer2.from(buffer, "utf8") : buffer;
        if (code) {
          copy = payload;
          payload = Buffer2.allocUnsafe(2 + copy.length);
          payload.writeUInt16BE(code, 0);
          copy.copy(payload, 2);
        }
        message.data = payload;
        var onMessageReady = function(message2) {
          var frame = new Frame();
          frame.final = true;
          frame.rsv1 = message2.rsv1;
          frame.rsv2 = message2.rsv2;
          frame.rsv3 = message2.rsv3;
          frame.opcode = message2.opcode;
          frame.masked = !!this._masking;
          frame.length = message2.data.length;
          frame.payload = message2.data;
          if (frame.masked)
            frame.maskingKey = crypto.randomBytes(4);
          this._sendFrame(frame);
        };
        if (this.MESSAGE_OPCODES.indexOf(message.opcode) >= 0)
          this._extensions.processOutgoingMessage(message, function(error3, message2) {
            if (error3)
              return this._fail("extension_error", error3.message);
            onMessageReady.call(this, message2);
          }, this);
        else
          onMessageReady.call(this, message);
        return true;
      },
      _sendFrame: function(frame) {
        var length = frame.length, header = length <= 125 ? 2 : length <= 65535 ? 4 : 10, offset = header + (frame.masked ? 4 : 0), buffer = Buffer2.allocUnsafe(offset + length), masked = frame.masked ? this.MASK : 0;
        buffer[0] = (frame.final ? this.FIN : 0) | (frame.rsv1 ? this.RSV1 : 0) | (frame.rsv2 ? this.RSV2 : 0) | (frame.rsv3 ? this.RSV3 : 0) | frame.opcode;
        if (length <= 125) {
          buffer[1] = masked | length;
        } else if (length <= 65535) {
          buffer[1] = masked | 126;
          buffer.writeUInt16BE(length, 2);
        } else {
          buffer[1] = masked | 127;
          buffer.writeUInt32BE(Math.floor(length / 4294967296), 2);
          buffer.writeUInt32BE(length % 4294967296, 6);
        }
        frame.payload.copy(buffer, offset);
        if (frame.masked) {
          frame.maskingKey.copy(buffer, header);
          Hybi.mask(buffer, frame.maskingKey, offset);
        }
        this._write(buffer);
      },
      _handshakeResponse: function() {
        var secKey = this._request.headers["sec-websocket-key"], version = this._request.headers["sec-websocket-version"];
        if (version !== Hybi.VERSION)
          throw new Error("Unsupported WebSocket version: " + version);
        if (typeof secKey !== "string")
          throw new Error("Missing handshake request header: Sec-WebSocket-Key");
        this._headers.set("Upgrade", "websocket");
        this._headers.set("Connection", "Upgrade");
        this._headers.set("Sec-WebSocket-Accept", Hybi.generateAccept(secKey));
        if (this.protocol)
          this._headers.set("Sec-WebSocket-Protocol", this.protocol);
        var extensions = this._extensions.generateResponse(this._request.headers["sec-websocket-extensions"]);
        if (extensions)
          this._headers.set("Sec-WebSocket-Extensions", extensions);
        var start = "HTTP/1.1 101 Switching Protocols", headers = [start, this._headers.toString(), ""];
        return Buffer2.from(headers.join("\r\n"), "utf8");
      },
      _shutdown: function(code, reason, error3) {
        delete this._frame;
        delete this._message;
        this._stage = 5;
        var sendCloseFrame = this.readyState === 1;
        this.readyState = 2;
        this._extensions.close(function() {
          if (sendCloseFrame)
            this.frame(reason, "close", code);
          this.readyState = 3;
          if (error3)
            this.emit("error", new Error(reason));
          this.emit("close", new Base.CloseEvent(code, reason));
        }, this);
      },
      _fail: function(type, message) {
        if (this.readyState > 1)
          return;
        this._shutdown(this.ERRORS[type], message, true);
      },
      _parseOpcode: function(octet) {
        var rsvs = [this.RSV1, this.RSV2, this.RSV3].map(function(rsv) {
          return (octet & rsv) === rsv;
        });
        var frame = this._frame = new Frame();
        frame.final = (octet & this.FIN) === this.FIN;
        frame.rsv1 = rsvs[0];
        frame.rsv2 = rsvs[1];
        frame.rsv3 = rsvs[2];
        frame.opcode = octet & this.OPCODE;
        this._stage = 1;
        if (!this._extensions.validFrameRsv(frame))
          return this._fail("protocol_error", "One or more reserved bits are on: reserved1 = " + (frame.rsv1 ? 1 : 0) + ", reserved2 = " + (frame.rsv2 ? 1 : 0) + ", reserved3 = " + (frame.rsv3 ? 1 : 0));
        if (this.OPCODE_CODES.indexOf(frame.opcode) < 0)
          return this._fail("protocol_error", "Unrecognized frame opcode: " + frame.opcode);
        if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && !frame.final)
          return this._fail("protocol_error", "Received fragmented control frame: opcode = " + frame.opcode);
        if (this._message && this.OPENING_OPCODES.indexOf(frame.opcode) >= 0)
          return this._fail("protocol_error", "Received new data frame but previous continuous frame is unfinished");
      },
      _parseLength: function(octet) {
        var frame = this._frame;
        frame.masked = (octet & this.MASK) === this.MASK;
        frame.length = octet & this.LENGTH;
        if (frame.length >= 0 && frame.length <= 125) {
          this._stage = frame.masked ? 3 : 4;
          if (!this._checkFrameLength())
            return;
        } else {
          this._stage = 2;
          frame.lengthBytes = frame.length === 126 ? 2 : 8;
        }
        if (this._requireMasking && !frame.masked)
          return this._fail("unacceptable", "Received unmasked frame but masking is required");
      },
      _parseExtendedLength: function(buffer) {
        var frame = this._frame;
        frame.length = this._readUInt(buffer);
        this._stage = frame.masked ? 3 : 4;
        if (this.MESSAGE_OPCODES.indexOf(frame.opcode) < 0 && frame.length > 125)
          return this._fail("protocol_error", "Received control frame having too long payload: " + frame.length);
        if (!this._checkFrameLength())
          return;
      },
      _checkFrameLength: function() {
        var length = this._message ? this._message.length : 0;
        if (length + this._frame.length > this._maxLength) {
          this._fail("too_large", "WebSocket frame length too large");
          return false;
        } else {
          return true;
        }
      },
      _emitFrame: function(buffer) {
        var frame = this._frame, payload = frame.payload = Hybi.mask(buffer, frame.maskingKey), opcode = frame.opcode, message, code, reason, callbacks, callback;
        delete this._frame;
        if (opcode === this.OPCODES.continuation) {
          if (!this._message)
            return this._fail("protocol_error", "Received unexpected continuation frame");
          this._message.pushFrame(frame);
        }
        if (opcode === this.OPCODES.text || opcode === this.OPCODES.binary) {
          this._message = new Message();
          this._message.pushFrame(frame);
        }
        if (frame.final && this.MESSAGE_OPCODES.indexOf(opcode) >= 0)
          return this._emitMessage(this._message);
        if (opcode === this.OPCODES.close) {
          code = payload.length >= 2 ? payload.readUInt16BE(0) : null;
          reason = payload.length > 2 ? this._encode(payload.slice(2)) : null;
          if (!(payload.length === 0) && !(code !== null && code >= this.MIN_RESERVED_ERROR && code <= this.MAX_RESERVED_ERROR) && this.ERROR_CODES.indexOf(code) < 0)
            code = this.ERRORS.protocol_error;
          if (payload.length > 125 || payload.length > 2 && !reason)
            code = this.ERRORS.protocol_error;
          this._shutdown(code || this.DEFAULT_ERROR_CODE, reason || "");
        }
        if (opcode === this.OPCODES.ping) {
          this.frame(payload, "pong");
          this.emit("ping", new Base.PingEvent(payload.toString()));
        }
        if (opcode === this.OPCODES.pong) {
          callbacks = this._pingCallbacks;
          message = this._encode(payload);
          callback = callbacks[message];
          delete callbacks[message];
          if (callback)
            callback();
          this.emit("pong", new Base.PongEvent(payload.toString()));
        }
      },
      _emitMessage: function(message) {
        var message = this._message;
        message.read();
        delete this._message;
        this._extensions.processIncomingMessage(message, function(error3, message2) {
          if (error3)
            return this._fail("extension_error", error3.message);
          var payload = message2.data;
          if (message2.opcode === this.OPCODES.text)
            payload = this._encode(payload);
          if (payload === null)
            return this._fail("encoding_error", "Could not decode a text frame as UTF-8");
          else
            this.emit("message", new Base.MessageEvent(payload));
        }, this);
      },
      _encode: function(buffer) {
        try {
          var string = buffer.toString("binary", 0, buffer.length);
          if (!this.UTF8_MATCH.test(string))
            return null;
        } catch (e) {
        }
        return buffer.toString("utf8", 0, buffer.length);
      },
      _readUInt: function(buffer) {
        if (buffer.length === 2)
          return buffer.readUInt16BE(0);
        return buffer.readUInt32BE(0) * 4294967296 + buffer.readUInt32BE(4);
      }
    };
    for (key in instance)
      Hybi.prototype[key] = instance[key];
    var key;
    module2.exports = Hybi;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/proxy.js
var require_proxy = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/proxy.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream2 = require("stream").Stream;
    var url = require("url");
    var util = require("util");
    var Base = require_base();
    var Headers2 = require_headers();
    var HttpParser = require_http_parser2();
    var PORTS = { "ws:": 80, "wss:": 443 };
    var Proxy2 = function(client, origin, options2) {
      this._client = client;
      this._http = new HttpParser("response");
      this._origin = typeof client.url === "object" ? client.url : url.parse(client.url);
      this._url = typeof origin === "object" ? origin : url.parse(origin);
      this._options = options2 || {};
      this._state = 0;
      this.readable = this.writable = true;
      this._paused = false;
      this._headers = new Headers2();
      this._headers.set("Host", this._origin.host);
      this._headers.set("Connection", "keep-alive");
      this._headers.set("Proxy-Connection", "keep-alive");
      var auth2 = this._url.auth && Buffer2.from(this._url.auth, "utf8").toString("base64");
      if (auth2)
        this._headers.set("Proxy-Authorization", "Basic " + auth2);
    };
    util.inherits(Proxy2, Stream2);
    var instance = {
      setHeader: function(name, value) {
        if (this._state !== 0)
          return false;
        this._headers.set(name, value);
        return true;
      },
      start: function() {
        if (this._state !== 0)
          return false;
        this._state = 1;
        var origin = this._origin, port = origin.port || PORTS[origin.protocol], start = "CONNECT " + origin.hostname + ":" + port + " HTTP/1.1";
        var headers = [start, this._headers.toString(), ""];
        this.emit("data", Buffer2.from(headers.join("\r\n"), "utf8"));
        return true;
      },
      pause: function() {
        this._paused = true;
      },
      resume: function() {
        this._paused = false;
        this.emit("drain");
      },
      write: function(chunk) {
        if (!this.writable)
          return false;
        this._http.parse(chunk);
        if (!this._http.isComplete())
          return !this._paused;
        this.statusCode = this._http.statusCode;
        this.headers = this._http.headers;
        if (this.statusCode === 200) {
          this.emit("connect", new Base.ConnectEvent());
        } else {
          var message = "Can't establish a connection to the server at " + this._origin.href;
          this.emit("error", new Error(message));
        }
        this.end();
        return !this._paused;
      },
      end: function(chunk) {
        if (!this.writable)
          return;
        if (chunk !== void 0)
          this.write(chunk);
        this.readable = this.writable = false;
        this.emit("close");
        this.emit("end");
      },
      destroy: function() {
        this.end();
      }
    };
    for (key in instance)
      Proxy2.prototype[key] = instance[key];
    var key;
    module2.exports = Proxy2;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/client.js
var require_client = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/client.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto = require("crypto");
    var url = require("url");
    var util = require("util");
    var HttpParser = require_http_parser2();
    var Base = require_base();
    var Hybi = require_hybi();
    var Proxy2 = require_proxy();
    var Client = function(_url, options2) {
      this.version = "hybi-" + Hybi.VERSION;
      Hybi.call(this, null, _url, options2);
      this.readyState = -1;
      this._key = Client.generateKey();
      this._accept = Hybi.generateAccept(this._key);
      this._http = new HttpParser("response");
      var uri = url.parse(this.url), auth2 = uri.auth && Buffer2.from(uri.auth, "utf8").toString("base64");
      if (this.VALID_PROTOCOLS.indexOf(uri.protocol) < 0)
        throw new Error(this.url + " is not a valid WebSocket URL");
      this._pathname = (uri.pathname || "/") + (uri.search || "");
      this._headers.set("Host", uri.host);
      this._headers.set("Upgrade", "websocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("Sec-WebSocket-Key", this._key);
      this._headers.set("Sec-WebSocket-Version", Hybi.VERSION);
      if (this._protocols.length > 0)
        this._headers.set("Sec-WebSocket-Protocol", this._protocols.join(", "));
      if (auth2)
        this._headers.set("Authorization", "Basic " + auth2);
    };
    util.inherits(Client, Hybi);
    Client.generateKey = function() {
      return crypto.randomBytes(16).toString("base64");
    };
    var instance = {
      VALID_PROTOCOLS: ["ws:", "wss:"],
      proxy: function(origin, options2) {
        return new Proxy2(this, origin, options2);
      },
      start: function() {
        if (this.readyState !== -1)
          return false;
        this._write(this._handshakeRequest());
        this.readyState = 0;
        return true;
      },
      parse: function(chunk) {
        if (this.readyState === 3)
          return;
        if (this.readyState > 0)
          return Hybi.prototype.parse.call(this, chunk);
        this._http.parse(chunk);
        if (!this._http.isComplete())
          return;
        this._validateHandshake();
        if (this.readyState === 3)
          return;
        this._open();
        this.parse(this._http.body);
      },
      _handshakeRequest: function() {
        var extensions = this._extensions.generateOffer();
        if (extensions)
          this._headers.set("Sec-WebSocket-Extensions", extensions);
        var start = "GET " + this._pathname + " HTTP/1.1", headers = [start, this._headers.toString(), ""];
        return Buffer2.from(headers.join("\r\n"), "utf8");
      },
      _failHandshake: function(message) {
        message = "Error during WebSocket handshake: " + message;
        this.readyState = 3;
        this.emit("error", new Error(message));
        this.emit("close", new Base.CloseEvent(this.ERRORS.protocol_error, message));
      },
      _validateHandshake: function() {
        this.statusCode = this._http.statusCode;
        this.headers = this._http.headers;
        if (this._http.error)
          return this._failHandshake(this._http.error.message);
        if (this._http.statusCode !== 101)
          return this._failHandshake("Unexpected response code: " + this._http.statusCode);
        var headers = this._http.headers, upgrade = headers["upgrade"] || "", connection = headers["connection"] || "", accept = headers["sec-websocket-accept"] || "", protocol = headers["sec-websocket-protocol"] || "";
        if (upgrade === "")
          return this._failHandshake("'Upgrade' header is missing");
        if (upgrade.toLowerCase() !== "websocket")
          return this._failHandshake("'Upgrade' header value is not 'WebSocket'");
        if (connection === "")
          return this._failHandshake("'Connection' header is missing");
        if (connection.toLowerCase() !== "upgrade")
          return this._failHandshake("'Connection' header value is not 'Upgrade'");
        if (accept !== this._accept)
          return this._failHandshake("Sec-WebSocket-Accept mismatch");
        this.protocol = null;
        if (protocol !== "") {
          if (this._protocols.indexOf(protocol) < 0)
            return this._failHandshake("Sec-WebSocket-Protocol mismatch");
          else
            this.protocol = protocol;
        }
        try {
          this._extensions.activate(this.headers["sec-websocket-extensions"]);
        } catch (e) {
          return this._failHandshake(e.message);
        }
      }
    };
    for (key in instance)
      Client.prototype[key] = instance[key];
    var key;
    module2.exports = Client;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/draft75.js
var require_draft75 = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/draft75.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Base = require_base();
    var util = require("util");
    var Draft75 = function(request, url, options2) {
      Base.apply(this, arguments);
      this._stage = 0;
      this.version = "hixie-75";
      this._headers.set("Upgrade", "WebSocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("WebSocket-Origin", this._request.headers.origin);
      this._headers.set("WebSocket-Location", this.url);
    };
    util.inherits(Draft75, Base);
    var instance = {
      close: function() {
        if (this.readyState === 3)
          return false;
        this.readyState = 3;
        this.emit("close", new Base.CloseEvent(null, null));
        return true;
      },
      parse: function(chunk) {
        if (this.readyState > 1)
          return;
        this._reader.put(chunk);
        this._reader.eachByte(function(octet) {
          var message;
          switch (this._stage) {
            case -1:
              this._body.push(octet);
              this._sendHandshakeBody();
              break;
            case 0:
              this._parseLeadingByte(octet);
              break;
            case 1:
              this._length = (octet & 127) + 128 * this._length;
              if (this._closing && this._length === 0) {
                return this.close();
              } else if ((octet & 128) !== 128) {
                if (this._length === 0) {
                  this._stage = 0;
                } else {
                  this._skipped = 0;
                  this._stage = 2;
                }
              }
              break;
            case 2:
              if (octet === 255) {
                this._stage = 0;
                message = Buffer2.from(this._buffer).toString("utf8", 0, this._buffer.length);
                this.emit("message", new Base.MessageEvent(message));
              } else {
                if (this._length) {
                  this._skipped += 1;
                  if (this._skipped === this._length)
                    this._stage = 0;
                } else {
                  this._buffer.push(octet);
                  if (this._buffer.length > this._maxLength)
                    return this.close();
                }
              }
              break;
          }
        }, this);
      },
      frame: function(buffer) {
        if (this.readyState === 0)
          return this._queue([buffer]);
        if (this.readyState > 1)
          return false;
        if (typeof buffer !== "string")
          buffer = buffer.toString();
        var length = Buffer2.byteLength(buffer), frame = Buffer2.allocUnsafe(length + 2);
        frame[0] = 0;
        frame.write(buffer, 1);
        frame[frame.length - 1] = 255;
        this._write(frame);
        return true;
      },
      _handshakeResponse: function() {
        var start = "HTTP/1.1 101 Web Socket Protocol Handshake", headers = [start, this._headers.toString(), ""];
        return Buffer2.from(headers.join("\r\n"), "utf8");
      },
      _parseLeadingByte: function(octet) {
        if ((octet & 128) === 128) {
          this._length = 0;
          this._stage = 1;
        } else {
          delete this._length;
          delete this._skipped;
          this._buffer = [];
          this._stage = 2;
        }
      }
    };
    for (key in instance)
      Draft75.prototype[key] = instance[key];
    var key;
    module2.exports = Draft75;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/draft76.js
var require_draft76 = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/draft76.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Base = require_base();
    var Draft75 = require_draft75();
    var crypto = require("crypto");
    var util = require("util");
    var numberFromKey = function(key2) {
      return parseInt((key2.match(/[0-9]/g) || []).join(""), 10);
    };
    var spacesInKey = function(key2) {
      return (key2.match(/ /g) || []).length;
    };
    var Draft76 = function(request, url, options2) {
      Draft75.apply(this, arguments);
      this._stage = -1;
      this._body = [];
      this.version = "hixie-76";
      this._headers.clear();
      this._headers.set("Upgrade", "WebSocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("Sec-WebSocket-Origin", this._request.headers.origin);
      this._headers.set("Sec-WebSocket-Location", this.url);
    };
    util.inherits(Draft76, Draft75);
    var instance = {
      BODY_SIZE: 8,
      start: function() {
        if (!Draft75.prototype.start.call(this))
          return false;
        this._started = true;
        this._sendHandshakeBody();
        return true;
      },
      close: function() {
        if (this.readyState === 3)
          return false;
        if (this.readyState === 1)
          this._write(Buffer2.from([255, 0]));
        this.readyState = 3;
        this.emit("close", new Base.CloseEvent(null, null));
        return true;
      },
      _handshakeResponse: function() {
        var headers = this._request.headers, key1 = headers["sec-websocket-key1"], key2 = headers["sec-websocket-key2"];
        if (!key1)
          throw new Error("Missing required header: Sec-WebSocket-Key1");
        if (!key2)
          throw new Error("Missing required header: Sec-WebSocket-Key2");
        var number1 = numberFromKey(key1), spaces1 = spacesInKey(key1), number2 = numberFromKey(key2), spaces2 = spacesInKey(key2);
        if (number1 % spaces1 !== 0 || number2 % spaces2 !== 0)
          throw new Error("Client sent invalid Sec-WebSocket-Key headers");
        this._keyValues = [number1 / spaces1, number2 / spaces2];
        var start = "HTTP/1.1 101 WebSocket Protocol Handshake", headers = [start, this._headers.toString(), ""];
        return Buffer2.from(headers.join("\r\n"), "binary");
      },
      _handshakeSignature: function() {
        if (this._body.length < this.BODY_SIZE)
          return null;
        var md5 = crypto.createHash("md5"), buffer = Buffer2.allocUnsafe(8 + this.BODY_SIZE);
        buffer.writeUInt32BE(this._keyValues[0], 0);
        buffer.writeUInt32BE(this._keyValues[1], 4);
        Buffer2.from(this._body).copy(buffer, 8, 0, this.BODY_SIZE);
        md5.update(buffer);
        return Buffer2.from(md5.digest("binary"), "binary");
      },
      _sendHandshakeBody: function() {
        if (!this._started)
          return;
        var signature = this._handshakeSignature();
        if (!signature)
          return;
        this._write(signature);
        this._stage = 0;
        this._open();
        if (this._body.length > this.BODY_SIZE)
          this.parse(this._body.slice(this.BODY_SIZE));
      },
      _parseLeadingByte: function(octet) {
        if (octet !== 255)
          return Draft75.prototype._parseLeadingByte.call(this, octet);
        this._closing = true;
        this._length = 0;
        this._stage = 1;
      }
    };
    for (key in instance)
      Draft76.prototype[key] = instance[key];
    var key;
    module2.exports = Draft76;
  }
});

// node_modules/websocket-driver/lib/websocket/driver/server.js
var require_server = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver/server.js"(exports2, module2) {
    init_shims();
    "use strict";
    var util = require("util");
    var HttpParser = require_http_parser2();
    var Base = require_base();
    var Draft75 = require_draft75();
    var Draft76 = require_draft76();
    var Hybi = require_hybi();
    var Server = function(options2) {
      Base.call(this, null, null, options2);
      this._http = new HttpParser("request");
    };
    util.inherits(Server, Base);
    var instance = {
      EVENTS: ["open", "message", "error", "close", "ping", "pong"],
      _bindEventListeners: function() {
        this.messages.on("error", function() {
        });
        this.on("error", function() {
        });
      },
      parse: function(chunk) {
        if (this._delegate)
          return this._delegate.parse(chunk);
        this._http.parse(chunk);
        if (!this._http.isComplete())
          return;
        this.method = this._http.method;
        this.url = this._http.url;
        this.headers = this._http.headers;
        this.body = this._http.body;
        var self2 = this;
        this._delegate = Server.http(this, this._options);
        this._delegate.messages = this.messages;
        this._delegate.io = this.io;
        this._open();
        this.EVENTS.forEach(function(event) {
          this._delegate.on(event, function(e) {
            self2.emit(event, e);
          });
        }, this);
        this.protocol = this._delegate.protocol;
        this.version = this._delegate.version;
        this.parse(this._http.body);
        this.emit("connect", new Base.ConnectEvent());
      },
      _open: function() {
        this.__queue.forEach(function(msg) {
          this._delegate[msg[0]].apply(this._delegate, msg[1]);
        }, this);
        this.__queue = [];
      }
    };
    ["addExtension", "setHeader", "start", "frame", "text", "binary", "ping", "close"].forEach(function(method) {
      instance[method] = function() {
        if (this._delegate) {
          return this._delegate[method].apply(this._delegate, arguments);
        } else {
          this.__queue.push([method, arguments]);
          return true;
        }
      };
    });
    for (key in instance)
      Server.prototype[key] = instance[key];
    var key;
    Server.isSecureRequest = function(request) {
      if (request.connection && request.connection.authorized !== void 0)
        return true;
      if (request.socket && request.socket.secure)
        return true;
      var headers = request.headers;
      if (!headers)
        return false;
      if (headers["https"] === "on")
        return true;
      if (headers["x-forwarded-ssl"] === "on")
        return true;
      if (headers["x-forwarded-scheme"] === "https")
        return true;
      if (headers["x-forwarded-proto"] === "https")
        return true;
      return false;
    };
    Server.determineUrl = function(request) {
      var scheme = this.isSecureRequest(request) ? "wss:" : "ws:";
      return scheme + "//" + request.headers.host + request.url;
    };
    Server.http = function(request, options2) {
      options2 = options2 || {};
      if (options2.requireMasking === void 0)
        options2.requireMasking = true;
      var headers = request.headers, version = headers["sec-websocket-version"], key2 = headers["sec-websocket-key"], key1 = headers["sec-websocket-key1"], key22 = headers["sec-websocket-key2"], url = this.determineUrl(request);
      if (version || key2)
        return new Hybi(request, url, options2);
      else if (key1 || key22)
        return new Draft76(request, url, options2);
      else
        return new Draft75(request, url, options2);
    };
    module2.exports = Server;
  }
});

// node_modules/websocket-driver/lib/websocket/driver.js
var require_driver = __commonJS({
  "node_modules/websocket-driver/lib/websocket/driver.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Base = require_base();
    var Client = require_client();
    var Server = require_server();
    var Driver = {
      client: function(url, options2) {
        options2 = options2 || {};
        if (options2.masking === void 0)
          options2.masking = true;
        return new Client(url, options2);
      },
      server: function(options2) {
        options2 = options2 || {};
        if (options2.requireMasking === void 0)
          options2.requireMasking = true;
        return new Server(options2);
      },
      http: function() {
        return Server.http.apply(Server, arguments);
      },
      isSecureRequest: function(request) {
        return Server.isSecureRequest(request);
      },
      isWebSocket: function(request) {
        return Base.isWebSocket(request);
      },
      validateOptions: function(options2, validKeys) {
        Base.validateOptions(options2, validKeys);
      }
    };
    module2.exports = Driver;
  }
});

// node_modules/faye-websocket/lib/faye/websocket/api/event.js
var require_event = __commonJS({
  "node_modules/faye-websocket/lib/faye/websocket/api/event.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Event = function(eventType, options2) {
      this.type = eventType;
      for (var key in options2)
        this[key] = options2[key];
    };
    Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
      this.type = eventType;
      this.bubbles = canBubble;
      this.cancelable = cancelable;
    };
    Event.prototype.stopPropagation = function() {
    };
    Event.prototype.preventDefault = function() {
    };
    Event.CAPTURING_PHASE = 1;
    Event.AT_TARGET = 2;
    Event.BUBBLING_PHASE = 3;
    module2.exports = Event;
  }
});

// node_modules/faye-websocket/lib/faye/websocket/api/event_target.js
var require_event_target = __commonJS({
  "node_modules/faye-websocket/lib/faye/websocket/api/event_target.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Event = require_event();
    var EventTarget = {
      onopen: null,
      onmessage: null,
      onerror: null,
      onclose: null,
      addEventListener: function(eventType, listener, useCapture) {
        this.on(eventType, listener);
      },
      removeEventListener: function(eventType, listener, useCapture) {
        this.removeListener(eventType, listener);
      },
      dispatchEvent: function(event) {
        event.target = event.currentTarget = this;
        event.eventPhase = Event.AT_TARGET;
        if (this["on" + event.type])
          this["on" + event.type](event);
        this.emit(event.type, event);
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/faye-websocket/lib/faye/websocket/api.js
var require_api = __commonJS({
  "node_modules/faye-websocket/lib/faye/websocket/api.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Stream2 = require("stream").Stream;
    var util = require("util");
    var driver = require_driver();
    var EventTarget = require_event_target();
    var Event = require_event();
    var API = function(options2) {
      options2 = options2 || {};
      driver.validateOptions(options2, ["headers", "extensions", "maxLength", "ping", "proxy", "tls", "ca"]);
      this.readable = this.writable = true;
      var headers = options2.headers;
      if (headers) {
        for (var name in headers)
          this._driver.setHeader(name, headers[name]);
      }
      var extensions = options2.extensions;
      if (extensions) {
        [].concat(extensions).forEach(this._driver.addExtension, this._driver);
      }
      this._ping = options2.ping;
      this._pingId = 0;
      this.readyState = API.CONNECTING;
      this.bufferedAmount = 0;
      this.protocol = "";
      this.url = this._driver.url;
      this.version = this._driver.version;
      var self2 = this;
      this._driver.on("open", function(e) {
        self2._open();
      });
      this._driver.on("message", function(e) {
        self2._receiveMessage(e.data);
      });
      this._driver.on("close", function(e) {
        self2._beginClose(e.reason, e.code);
      });
      this._driver.on("error", function(error3) {
        self2._emitError(error3.message);
      });
      this.on("error", function() {
      });
      this._driver.messages.on("drain", function() {
        self2.emit("drain");
      });
      if (this._ping)
        this._pingTimer = setInterval(function() {
          self2._pingId += 1;
          self2.ping(self2._pingId.toString());
        }, this._ping * 1e3);
      this._configureStream();
      if (!this._proxy) {
        this._stream.pipe(this._driver.io);
        this._driver.io.pipe(this._stream);
      }
    };
    util.inherits(API, Stream2);
    API.CONNECTING = 0;
    API.OPEN = 1;
    API.CLOSING = 2;
    API.CLOSED = 3;
    API.CLOSE_TIMEOUT = 3e4;
    var instance = {
      write: function(data) {
        return this.send(data);
      },
      end: function(data) {
        if (data !== void 0)
          this.send(data);
        this.close();
      },
      pause: function() {
        return this._driver.messages.pause();
      },
      resume: function() {
        return this._driver.messages.resume();
      },
      send: function(data) {
        if (this.readyState > API.OPEN)
          return false;
        if (!(data instanceof Buffer))
          data = String(data);
        return this._driver.messages.write(data);
      },
      ping: function(message, callback) {
        if (this.readyState > API.OPEN)
          return false;
        return this._driver.ping(message, callback);
      },
      close: function(code, reason) {
        if (code === void 0)
          code = 1e3;
        if (reason === void 0)
          reason = "";
        if (code !== 1e3 && (code < 3e3 || code > 4999))
          throw new Error("Failed to execute 'close' on WebSocket: The code must be either 1000, or between 3000 and 4999. " + code + " is neither.");
        if (this.readyState !== API.CLOSED)
          this.readyState = API.CLOSING;
        var self2 = this;
        this._closeTimer = setTimeout(function() {
          self2._beginClose("", 1006);
        }, API.CLOSE_TIMEOUT);
        this._driver.close(reason, code);
      },
      _configureStream: function() {
        var self2 = this;
        this._stream.setTimeout(0);
        this._stream.setNoDelay(true);
        ["close", "end"].forEach(function(event) {
          this._stream.on(event, function() {
            self2._finalizeClose();
          });
        }, this);
        this._stream.on("error", function(error3) {
          self2._emitError("Network error: " + self2.url + ": " + error3.message);
          self2._finalizeClose();
        });
      },
      _open: function() {
        if (this.readyState !== API.CONNECTING)
          return;
        this.readyState = API.OPEN;
        this.protocol = this._driver.protocol || "";
        var event = new Event("open");
        event.initEvent("open", false, false);
        this.dispatchEvent(event);
      },
      _receiveMessage: function(data) {
        if (this.readyState > API.OPEN)
          return false;
        if (this.readable)
          this.emit("data", data);
        var event = new Event("message", { data });
        event.initEvent("message", false, false);
        this.dispatchEvent(event);
      },
      _emitError: function(message) {
        if (this.readyState >= API.CLOSING)
          return;
        var event = new Event("error", { message });
        event.initEvent("error", false, false);
        this.dispatchEvent(event);
      },
      _beginClose: function(reason, code) {
        if (this.readyState === API.CLOSED)
          return;
        this.readyState = API.CLOSING;
        this._closeParams = [reason, code];
        if (this._stream) {
          this._stream.destroy();
          if (!this._stream.readable)
            this._finalizeClose();
        }
      },
      _finalizeClose: function() {
        if (this.readyState === API.CLOSED)
          return;
        this.readyState = API.CLOSED;
        if (this._closeTimer)
          clearTimeout(this._closeTimer);
        if (this._pingTimer)
          clearInterval(this._pingTimer);
        if (this._stream)
          this._stream.end();
        if (this.readable)
          this.emit("end");
        this.readable = this.writable = false;
        var reason = this._closeParams ? this._closeParams[0] : "", code = this._closeParams ? this._closeParams[1] : 1006;
        var event = new Event("close", { code, reason });
        event.initEvent("close", false, false);
        this.dispatchEvent(event);
      }
    };
    for (method in instance)
      API.prototype[method] = instance[method];
    var method;
    for (key in EventTarget)
      API.prototype[key] = EventTarget[key];
    var key;
    module2.exports = API;
  }
});

// node_modules/faye-websocket/lib/faye/websocket/client.js
var require_client2 = __commonJS({
  "node_modules/faye-websocket/lib/faye/websocket/client.js"(exports2, module2) {
    init_shims();
    "use strict";
    var util = require("util");
    var net = require("net");
    var tls = require("tls");
    var url = require("url");
    var driver = require_driver();
    var API = require_api();
    var Event = require_event();
    var DEFAULT_PORTS = { "http:": 80, "https:": 443, "ws:": 80, "wss:": 443 };
    var SECURE_PROTOCOLS = ["https:", "wss:"];
    var Client = function(_url, protocols, options2) {
      options2 = options2 || {};
      this.url = _url;
      this._driver = driver.client(this.url, { maxLength: options2.maxLength, protocols });
      ["open", "error"].forEach(function(event) {
        this._driver.on(event, function() {
          self2.headers = self2._driver.headers;
          self2.statusCode = self2._driver.statusCode;
        });
      }, this);
      var proxy = options2.proxy || {}, endpoint = url.parse(proxy.origin || this.url), port = endpoint.port || DEFAULT_PORTS[endpoint.protocol], secure = SECURE_PROTOCOLS.indexOf(endpoint.protocol) >= 0, onConnect = function() {
        self2._onConnect();
      }, netOptions = options2.net || {}, originTLS = options2.tls || {}, socketTLS = proxy.origin ? proxy.tls || {} : originTLS, self2 = this;
      netOptions.host = socketTLS.host = endpoint.hostname;
      netOptions.port = socketTLS.port = port;
      originTLS.ca = originTLS.ca || options2.ca;
      socketTLS.servername = socketTLS.servername || endpoint.hostname;
      this._stream = secure ? tls.connect(socketTLS, onConnect) : net.connect(netOptions, onConnect);
      if (proxy.origin)
        this._configureProxy(proxy, originTLS);
      API.call(this, options2);
    };
    util.inherits(Client, API);
    Client.prototype._onConnect = function() {
      var worker = this._proxy || this._driver;
      worker.start();
    };
    Client.prototype._configureProxy = function(proxy, originTLS) {
      var uri = url.parse(this.url), secure = SECURE_PROTOCOLS.indexOf(uri.protocol) >= 0, self2 = this, name;
      this._proxy = this._driver.proxy(proxy.origin);
      if (proxy.headers) {
        for (name in proxy.headers)
          this._proxy.setHeader(name, proxy.headers[name]);
      }
      this._proxy.pipe(this._stream, { end: false });
      this._stream.pipe(this._proxy);
      this._proxy.on("connect", function() {
        if (secure) {
          var options2 = { socket: self2._stream, servername: uri.hostname };
          for (name in originTLS)
            options2[name] = originTLS[name];
          self2._stream = tls.connect(options2);
          self2._configureStream();
        }
        self2._driver.io.pipe(self2._stream);
        self2._stream.pipe(self2._driver.io);
        self2._driver.start();
      });
      this._proxy.on("error", function(error3) {
        self2._driver.emit("error", error3);
      });
    };
    module2.exports = Client;
  }
});

// node_modules/faye-websocket/lib/faye/eventsource.js
var require_eventsource = __commonJS({
  "node_modules/faye-websocket/lib/faye/eventsource.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Stream2 = require("stream").Stream;
    var util = require("util");
    var driver = require_driver();
    var Headers2 = require_headers();
    var API = require_api();
    var EventTarget = require_event_target();
    var Event = require_event();
    var EventSource = function(request, response, options2) {
      this.writable = true;
      options2 = options2 || {};
      this._stream = response.socket;
      this._ping = options2.ping || this.DEFAULT_PING;
      this._retry = options2.retry || this.DEFAULT_RETRY;
      var scheme = driver.isSecureRequest(request) ? "https:" : "http:";
      this.url = scheme + "//" + request.headers.host + request.url;
      this.lastEventId = request.headers["last-event-id"] || "";
      this.readyState = API.CONNECTING;
      var headers = new Headers2(), self2 = this;
      if (options2.headers) {
        for (var key2 in options2.headers)
          headers.set(key2, options2.headers[key2]);
      }
      if (!this._stream || !this._stream.writable)
        return;
      process.nextTick(function() {
        self2._open();
      });
      this._stream.setTimeout(0);
      this._stream.setNoDelay(true);
      var handshake = "HTTP/1.1 200 OK\r\nContent-Type: text/event-stream\r\nCache-Control: no-cache, no-store\r\nConnection: close\r\n" + headers.toString() + "\r\nretry: " + Math.floor(this._retry * 1e3) + "\r\n\r\n";
      this._write(handshake);
      this._stream.on("drain", function() {
        self2.emit("drain");
      });
      if (this._ping)
        this._pingTimer = setInterval(function() {
          self2.ping();
        }, this._ping * 1e3);
      ["error", "end"].forEach(function(event) {
        self2._stream.on(event, function() {
          self2.close();
        });
      });
    };
    util.inherits(EventSource, Stream2);
    EventSource.isEventSource = function(request) {
      if (request.method !== "GET")
        return false;
      var accept = (request.headers.accept || "").split(/\s*,\s*/);
      return accept.indexOf("text/event-stream") >= 0;
    };
    var instance = {
      DEFAULT_PING: 10,
      DEFAULT_RETRY: 5,
      _write: function(chunk) {
        if (!this.writable)
          return false;
        try {
          return this._stream.write(chunk, "utf8");
        } catch (e) {
          return false;
        }
      },
      _open: function() {
        if (this.readyState !== API.CONNECTING)
          return;
        this.readyState = API.OPEN;
        var event = new Event("open");
        event.initEvent("open", false, false);
        this.dispatchEvent(event);
      },
      write: function(message) {
        return this.send(message);
      },
      end: function(message) {
        if (message !== void 0)
          this.write(message);
        this.close();
      },
      send: function(message, options2) {
        if (this.readyState > API.OPEN)
          return false;
        message = String(message).replace(/(\r\n|\r|\n)/g, "$1data: ");
        options2 = options2 || {};
        var frame = "";
        if (options2.event)
          frame += "event: " + options2.event + "\r\n";
        if (options2.id)
          frame += "id: " + options2.id + "\r\n";
        frame += "data: " + message + "\r\n\r\n";
        return this._write(frame);
      },
      ping: function() {
        return this._write(":\r\n\r\n");
      },
      close: function() {
        if (this.readyState > API.OPEN)
          return false;
        this.readyState = API.CLOSED;
        this.writable = false;
        if (this._pingTimer)
          clearInterval(this._pingTimer);
        if (this._stream)
          this._stream.end();
        var event = new Event("close");
        event.initEvent("close", false, false);
        this.dispatchEvent(event);
        return true;
      }
    };
    for (method in instance)
      EventSource.prototype[method] = instance[method];
    var method;
    for (key in EventTarget)
      EventSource.prototype[key] = EventTarget[key];
    var key;
    module2.exports = EventSource;
  }
});

// node_modules/faye-websocket/lib/faye/websocket.js
var require_websocket = __commonJS({
  "node_modules/faye-websocket/lib/faye/websocket.js"(exports2, module2) {
    init_shims();
    "use strict";
    var util = require("util");
    var driver = require_driver();
    var API = require_api();
    var WebSocket2 = function(request, socket, body, protocols, options2) {
      options2 = options2 || {};
      this._stream = socket;
      this._driver = driver.http(request, { maxLength: options2.maxLength, protocols });
      var self2 = this;
      if (!this._stream || !this._stream.writable)
        return;
      if (!this._stream.readable)
        return this._stream.end();
      var catchup = function() {
        self2._stream.removeListener("data", catchup);
      };
      this._stream.on("data", catchup);
      API.call(this, options2);
      process.nextTick(function() {
        self2._driver.start();
        self2._driver.io.write(body);
      });
    };
    util.inherits(WebSocket2, API);
    WebSocket2.isWebSocket = function(request) {
      return driver.isWebSocket(request);
    };
    WebSocket2.validateOptions = function(options2, validKeys) {
      driver.validateOptions(options2, validKeys);
    };
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.Client = require_client2();
    WebSocket2.EventSource = require_eventsource();
    module2.exports = WebSocket2;
  }
});

// node_modules/@firebase/database/dist/index.node.cjs.js
var require_index_node_cjs3 = __commonJS({
  "node_modules/@firebase/database/dist/index.node.cjs.js"(exports2, module2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var component = require_index_cjs();
    var util = require_index_node_cjs();
    var fayeWebsocket = require_websocket();
    var tslib = require_tslib();
    var logger$1 = require_index_cjs2();
    var name = "@firebase/database";
    var version = "0.10.9";
    var SDK_VERSION = "";
    function setSDKVersion(version2) {
      SDK_VERSION = version2;
    }
    var DOMStorageWrapper = function() {
      function DOMStorageWrapper2(domStorage_) {
        this.domStorage_ = domStorage_;
        this.prefix_ = "firebase:";
      }
      DOMStorageWrapper2.prototype.set = function(key, value) {
        if (value == null) {
          this.domStorage_.removeItem(this.prefixedName_(key));
        } else {
          this.domStorage_.setItem(this.prefixedName_(key), util.stringify(value));
        }
      };
      DOMStorageWrapper2.prototype.get = function(key) {
        var storedVal = this.domStorage_.getItem(this.prefixedName_(key));
        if (storedVal == null) {
          return null;
        } else {
          return util.jsonEval(storedVal);
        }
      };
      DOMStorageWrapper2.prototype.remove = function(key) {
        this.domStorage_.removeItem(this.prefixedName_(key));
      };
      DOMStorageWrapper2.prototype.prefixedName_ = function(name2) {
        return this.prefix_ + name2;
      };
      DOMStorageWrapper2.prototype.toString = function() {
        return this.domStorage_.toString();
      };
      return DOMStorageWrapper2;
    }();
    var MemoryStorage = function() {
      function MemoryStorage2() {
        this.cache_ = {};
        this.isInMemoryStorage = true;
      }
      MemoryStorage2.prototype.set = function(key, value) {
        if (value == null) {
          delete this.cache_[key];
        } else {
          this.cache_[key] = value;
        }
      };
      MemoryStorage2.prototype.get = function(key) {
        if (util.contains(this.cache_, key)) {
          return this.cache_[key];
        }
        return null;
      };
      MemoryStorage2.prototype.remove = function(key) {
        delete this.cache_[key];
      };
      return MemoryStorage2;
    }();
    var createStoragefor = function(domStorageName) {
      try {
        if (typeof window !== "undefined" && typeof window[domStorageName] !== "undefined") {
          var domStorage = window[domStorageName];
          domStorage.setItem("firebase:sentinel", "cache");
          domStorage.removeItem("firebase:sentinel");
          return new DOMStorageWrapper(domStorage);
        }
      } catch (e) {
      }
      return new MemoryStorage();
    };
    var PersistentStorage = createStoragefor("localStorage");
    var SessionStorage = createStoragefor("sessionStorage");
    var logClient = new logger$1.Logger("@firebase/database");
    var LUIDGenerator = function() {
      var id = 1;
      return function() {
        return id++;
      };
    }();
    var sha1 = function(str) {
      var utf8Bytes = util.stringToByteArray(str);
      var sha12 = new util.Sha1();
      sha12.update(utf8Bytes);
      var sha1Bytes = sha12.digest();
      return util.base64.encodeByteArray(sha1Bytes);
    };
    var buildLogMessage_ = function() {
      var varArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
      }
      var message = "";
      for (var i = 0; i < varArgs.length; i++) {
        var arg = varArgs[i];
        if (Array.isArray(arg) || arg && typeof arg === "object" && typeof arg.length === "number") {
          message += buildLogMessage_.apply(null, arg);
        } else if (typeof arg === "object") {
          message += util.stringify(arg);
        } else {
          message += arg;
        }
        message += " ";
      }
      return message;
    };
    var logger = null;
    var firstLog_ = true;
    var enableLogging$1 = function(logger_, persistent) {
      util.assert(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
      if (logger_ === true) {
        logClient.logLevel = logger$1.LogLevel.VERBOSE;
        logger = logClient.log.bind(logClient);
        if (persistent) {
          SessionStorage.set("logging_enabled", true);
        }
      } else if (typeof logger_ === "function") {
        logger = logger_;
      } else {
        logger = null;
        SessionStorage.remove("logging_enabled");
      }
    };
    var log = function() {
      var varArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
      }
      if (firstLog_ === true) {
        firstLog_ = false;
        if (logger === null && SessionStorage.get("logging_enabled") === true) {
          enableLogging$1(true);
        }
      }
      if (logger) {
        var message = buildLogMessage_.apply(null, varArgs);
        logger(message);
      }
    };
    var logWrapper = function(prefix) {
      return function() {
        var varArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          varArgs[_i] = arguments[_i];
        }
        log.apply(void 0, tslib.__spreadArray([prefix], tslib.__read(varArgs)));
      };
    };
    var error3 = function() {
      var varArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
      }
      var message = "FIREBASE INTERNAL ERROR: " + buildLogMessage_.apply(void 0, tslib.__spreadArray([], tslib.__read(varArgs)));
      logClient.error(message);
    };
    var fatal = function() {
      var varArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
      }
      var message = "FIREBASE FATAL ERROR: " + buildLogMessage_.apply(void 0, tslib.__spreadArray([], tslib.__read(varArgs)));
      logClient.error(message);
      throw new Error(message);
    };
    var warn = function() {
      var varArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
      }
      var message = "FIREBASE WARNING: " + buildLogMessage_.apply(void 0, tslib.__spreadArray([], tslib.__read(varArgs)));
      logClient.warn(message);
    };
    var warnIfPageIsSecure = function() {
      if (typeof window !== "undefined" && window.location && window.location.protocol && window.location.protocol.indexOf("https:") !== -1) {
        warn("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
      }
    };
    var isInvalidJSONNumber = function(data) {
      return typeof data === "number" && (data !== data || data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY);
    };
    var executeWhenDOMReady = function(fn) {
      if (util.isNodeSdk() || document.readyState === "complete") {
        fn();
      } else {
        var called_1 = false;
        var wrappedFn_1 = function() {
          if (!document.body) {
            setTimeout(wrappedFn_1, Math.floor(10));
            return;
          }
          if (!called_1) {
            called_1 = true;
            fn();
          }
        };
        if (document.addEventListener) {
          document.addEventListener("DOMContentLoaded", wrappedFn_1, false);
          window.addEventListener("load", wrappedFn_1, false);
        } else if (document.attachEvent) {
          document.attachEvent("onreadystatechange", function() {
            if (document.readyState === "complete") {
              wrappedFn_1();
            }
          });
          window.attachEvent("onload", wrappedFn_1);
        }
      }
    };
    var MIN_NAME = "[MIN_NAME]";
    var MAX_NAME = "[MAX_NAME]";
    var nameCompare = function(a, b) {
      if (a === b) {
        return 0;
      } else if (a === MIN_NAME || b === MAX_NAME) {
        return -1;
      } else if (b === MIN_NAME || a === MAX_NAME) {
        return 1;
      } else {
        var aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
        if (aAsInt !== null) {
          if (bAsInt !== null) {
            return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;
          } else {
            return -1;
          }
        } else if (bAsInt !== null) {
          return 1;
        } else {
          return a < b ? -1 : 1;
        }
      }
    };
    var stringCompare = function(a, b) {
      if (a === b) {
        return 0;
      } else if (a < b) {
        return -1;
      } else {
        return 1;
      }
    };
    var requireKey = function(key, obj) {
      if (obj && key in obj) {
        return obj[key];
      } else {
        throw new Error("Missing required key (" + key + ") in object: " + util.stringify(obj));
      }
    };
    var ObjectToUniqueKey = function(obj) {
      if (typeof obj !== "object" || obj === null) {
        return util.stringify(obj);
      }
      var keys = [];
      for (var k in obj) {
        keys.push(k);
      }
      keys.sort();
      var key = "{";
      for (var i = 0; i < keys.length; i++) {
        if (i !== 0) {
          key += ",";
        }
        key += util.stringify(keys[i]);
        key += ":";
        key += ObjectToUniqueKey(obj[keys[i]]);
      }
      key += "}";
      return key;
    };
    var splitStringBySize = function(str, segsize) {
      var len = str.length;
      if (len <= segsize) {
        return [str];
      }
      var dataSegs = [];
      for (var c = 0; c < len; c += segsize) {
        if (c + segsize > len) {
          dataSegs.push(str.substring(c, len));
        } else {
          dataSegs.push(str.substring(c, c + segsize));
        }
      }
      return dataSegs;
    };
    function each2(obj, fn) {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          fn(key, obj[key]);
        }
      }
    }
    var doubleToIEEE754String = function(v) {
      util.assert(!isInvalidJSONNumber(v), "Invalid JSON number");
      var ebits = 11, fbits = 52;
      var bias = (1 << ebits - 1) - 1;
      var s2, e, f, ln, i;
      if (v === 0) {
        e = 0;
        f = 0;
        s2 = 1 / v === -Infinity ? 1 : 0;
      } else {
        s2 = v < 0;
        v = Math.abs(v);
        if (v >= Math.pow(2, 1 - bias)) {
          ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
          e = ln + bias;
          f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
        } else {
          e = 0;
          f = Math.round(v / Math.pow(2, 1 - bias - fbits));
        }
      }
      var bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
      }
      bits.push(s2 ? 1 : 0);
      bits.reverse();
      var str = bits.join("");
      var hexByteString = "";
      for (i = 0; i < 64; i += 8) {
        var hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1) {
          hexByte = "0" + hexByte;
        }
        hexByteString = hexByteString + hexByte;
      }
      return hexByteString.toLowerCase();
    };
    var isChromeExtensionContentScript = function() {
      return !!(typeof window === "object" && window["chrome"] && window["chrome"]["extension"] && !/^chrome/.test(window.location.href));
    };
    var isWindowsStoreApp = function() {
      return typeof Windows === "object" && typeof Windows.UI === "object";
    };
    function errorForServerCode(code, query2) {
      var reason = "Unknown Error";
      if (code === "too_big") {
        reason = "The data requested exceeds the maximum size that can be accessed with a single request.";
      } else if (code === "permission_denied") {
        reason = "Client doesn't have permission to access the desired data.";
      } else if (code === "unavailable") {
        reason = "The service is unavailable";
      }
      var error4 = new Error(code + " at " + query2._path.toString() + ": " + reason);
      error4.code = code.toUpperCase();
      return error4;
    }
    var INTEGER_REGEXP_ = new RegExp("^-?(0*)\\d{1,10}$");
    var INTEGER_32_MIN = -2147483648;
    var INTEGER_32_MAX = 2147483647;
    var tryParseInt = function(str) {
      if (INTEGER_REGEXP_.test(str)) {
        var intVal = Number(str);
        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {
          return intVal;
        }
      }
      return null;
    };
    var exceptionGuard = function(fn) {
      try {
        fn();
      } catch (e) {
        setTimeout(function() {
          var stack = e.stack || "";
          warn("Exception was thrown by user callback.", stack);
          throw e;
        }, Math.floor(0));
      }
    };
    var beingCrawled = function() {
      var userAgent = typeof window === "object" && window["navigator"] && window["navigator"]["userAgent"] || "";
      return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;
    };
    var setTimeoutNonBlocking = function(fn, time) {
      var timeout = setTimeout(fn, time);
      if (typeof timeout === "object" && timeout["unref"]) {
        timeout["unref"]();
      }
      return timeout;
    };
    var AppCheckTokenProvider = function() {
      function AppCheckTokenProvider2(appName_, appCheckProvider) {
        var _this = this;
        this.appName_ = appName_;
        this.appCheckProvider = appCheckProvider;
        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });
        if (!this.appCheck) {
          appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then(function(appCheck) {
            return _this.appCheck = appCheck;
          });
        }
      }
      AppCheckTokenProvider2.prototype.getToken = function(forceRefresh) {
        var _this = this;
        if (!this.appCheck) {
          return new Promise(function(resolve2, reject) {
            setTimeout(function() {
              if (_this.appCheck) {
                _this.getToken(forceRefresh).then(resolve2, reject);
              } else {
                resolve2(null);
              }
            }, 0);
          });
        }
        return this.appCheck.getToken(forceRefresh);
      };
      AppCheckTokenProvider2.prototype.addTokenChangeListener = function(listener) {
        var _a;
        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then(function(appCheck) {
          return appCheck.addTokenListener(listener);
        });
      };
      AppCheckTokenProvider2.prototype.notifyForInvalidToken = function() {
        warn('Provided AppCheck credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly.');
      };
      return AppCheckTokenProvider2;
    }();
    var FirebaseAuthTokenProvider = function() {
      function FirebaseAuthTokenProvider2(appName_, firebaseOptions_, authProvider_) {
        var _this = this;
        this.appName_ = appName_;
        this.firebaseOptions_ = firebaseOptions_;
        this.authProvider_ = authProvider_;
        this.auth_ = null;
        this.auth_ = authProvider_.getImmediate({ optional: true });
        if (!this.auth_) {
          authProvider_.onInit(function(auth2) {
            return _this.auth_ = auth2;
          });
        }
      }
      FirebaseAuthTokenProvider2.prototype.getToken = function(forceRefresh) {
        var _this = this;
        if (!this.auth_) {
          return new Promise(function(resolve2, reject) {
            setTimeout(function() {
              if (_this.auth_) {
                _this.getToken(forceRefresh).then(resolve2, reject);
              } else {
                resolve2(null);
              }
            }, 0);
          });
        }
        return this.auth_.getToken(forceRefresh).catch(function(error4) {
          if (error4 && error4.code === "auth/token-not-initialized") {
            log("Got auth/token-not-initialized error.  Treating as null token.");
            return null;
          } else {
            return Promise.reject(error4);
          }
        });
      };
      FirebaseAuthTokenProvider2.prototype.addTokenChangeListener = function(listener) {
        if (this.auth_) {
          this.auth_.addAuthTokenListener(listener);
        } else {
          this.authProvider_.get().then(function(auth2) {
            return auth2.addAuthTokenListener(listener);
          });
        }
      };
      FirebaseAuthTokenProvider2.prototype.removeTokenChangeListener = function(listener) {
        this.authProvider_.get().then(function(auth2) {
          return auth2.removeAuthTokenListener(listener);
        });
      };
      FirebaseAuthTokenProvider2.prototype.notifyForInvalidToken = function() {
        var errorMessage = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
        if ("credential" in this.firebaseOptions_) {
          errorMessage += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
        } else if ("serviceAccount" in this.firebaseOptions_) {
          errorMessage += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
        } else {
          errorMessage += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.';
        }
        warn(errorMessage);
      };
      return FirebaseAuthTokenProvider2;
    }();
    var EmulatorTokenProvider = function() {
      function EmulatorTokenProvider2(accessToken) {
        this.accessToken = accessToken;
      }
      EmulatorTokenProvider2.prototype.getToken = function(forceRefresh) {
        return Promise.resolve({
          accessToken: this.accessToken
        });
      };
      EmulatorTokenProvider2.prototype.addTokenChangeListener = function(listener) {
        listener(this.accessToken);
      };
      EmulatorTokenProvider2.prototype.removeTokenChangeListener = function(listener) {
      };
      EmulatorTokenProvider2.prototype.notifyForInvalidToken = function() {
      };
      EmulatorTokenProvider2.OWNER = "owner";
      return EmulatorTokenProvider2;
    }();
    var PROTOCOL_VERSION = "5";
    var VERSION_PARAM = "v";
    var TRANSPORT_SESSION_PARAM = "s";
    var REFERER_PARAM = "r";
    var FORGE_REF = "f";
    var FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
    var LAST_SESSION_PARAM = "ls";
    var APPLICATION_ID_PARAM = "p";
    var APP_CHECK_TOKEN_PARAM = "ac";
    var WEBSOCKET = "websocket";
    var LONG_POLLING = "long_polling";
    var RepoInfo = function() {
      function RepoInfo2(host, secure, namespace, webSocketOnly, nodeAdmin, persistenceKey, includeNamespaceInQueryParams) {
        if (nodeAdmin === void 0) {
          nodeAdmin = false;
        }
        if (persistenceKey === void 0) {
          persistenceKey = "";
        }
        if (includeNamespaceInQueryParams === void 0) {
          includeNamespaceInQueryParams = false;
        }
        this.secure = secure;
        this.namespace = namespace;
        this.webSocketOnly = webSocketOnly;
        this.nodeAdmin = nodeAdmin;
        this.persistenceKey = persistenceKey;
        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;
        this._host = host.toLowerCase();
        this._domain = this._host.substr(this._host.indexOf(".") + 1);
        this.internalHost = PersistentStorage.get("host:" + host) || this._host;
      }
      RepoInfo2.prototype.isCacheableHost = function() {
        return this.internalHost.substr(0, 2) === "s-";
      };
      RepoInfo2.prototype.isCustomHost = function() {
        return this._domain !== "firebaseio.com" && this._domain !== "firebaseio-demo.com";
      };
      Object.defineProperty(RepoInfo2.prototype, "host", {
        get: function() {
          return this._host;
        },
        set: function(newHost) {
          if (newHost !== this.internalHost) {
            this.internalHost = newHost;
            if (this.isCacheableHost()) {
              PersistentStorage.set("host:" + this._host, this.internalHost);
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      RepoInfo2.prototype.toString = function() {
        var str = this.toURLString();
        if (this.persistenceKey) {
          str += "<" + this.persistenceKey + ">";
        }
        return str;
      };
      RepoInfo2.prototype.toURLString = function() {
        var protocol = this.secure ? "https://" : "http://";
        var query2 = this.includeNamespaceInQueryParams ? "?ns=" + this.namespace : "";
        return "" + protocol + this.host + "/" + query2;
      };
      return RepoInfo2;
    }();
    function repoInfoNeedsQueryParam(repoInfo) {
      return repoInfo.host !== repoInfo.internalHost || repoInfo.isCustomHost() || repoInfo.includeNamespaceInQueryParams;
    }
    function repoInfoConnectionURL(repoInfo, type, params) {
      util.assert(typeof type === "string", "typeof type must == string");
      util.assert(typeof params === "object", "typeof params must == object");
      var connURL;
      if (type === WEBSOCKET) {
        connURL = (repoInfo.secure ? "wss://" : "ws://") + repoInfo.internalHost + "/.ws?";
      } else if (type === LONG_POLLING) {
        connURL = (repoInfo.secure ? "https://" : "http://") + repoInfo.internalHost + "/.lp?";
      } else {
        throw new Error("Unknown connection type: " + type);
      }
      if (repoInfoNeedsQueryParam(repoInfo)) {
        params["ns"] = repoInfo.namespace;
      }
      var pairs = [];
      each2(params, function(key, value) {
        pairs.push(key + "=" + value);
      });
      return connURL + pairs.join("&");
    }
    var StatsCollection = function() {
      function StatsCollection2() {
        this.counters_ = {};
      }
      StatsCollection2.prototype.incrementCounter = function(name2, amount) {
        if (amount === void 0) {
          amount = 1;
        }
        if (!util.contains(this.counters_, name2)) {
          this.counters_[name2] = 0;
        }
        this.counters_[name2] += amount;
      };
      StatsCollection2.prototype.get = function() {
        return util.deepCopy(this.counters_);
      };
      return StatsCollection2;
    }();
    var collections = {};
    var reporters = {};
    function statsManagerGetCollection(repoInfo) {
      var hashString = repoInfo.toString();
      if (!collections[hashString]) {
        collections[hashString] = new StatsCollection();
      }
      return collections[hashString];
    }
    function statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {
      var hashString = repoInfo.toString();
      if (!reporters[hashString]) {
        reporters[hashString] = creatorFunction();
      }
      return reporters[hashString];
    }
    var PacketReceiver = function() {
      function PacketReceiver2(onMessage_) {
        this.onMessage_ = onMessage_;
        this.pendingResponses = [];
        this.currentResponseNum = 0;
        this.closeAfterResponse = -1;
        this.onClose = null;
      }
      PacketReceiver2.prototype.closeAfter = function(responseNum, callback) {
        this.closeAfterResponse = responseNum;
        this.onClose = callback;
        if (this.closeAfterResponse < this.currentResponseNum) {
          this.onClose();
          this.onClose = null;
        }
      };
      PacketReceiver2.prototype.handleResponse = function(requestNum, data) {
        var _this = this;
        this.pendingResponses[requestNum] = data;
        var _loop_1 = function() {
          var toProcess = this_1.pendingResponses[this_1.currentResponseNum];
          delete this_1.pendingResponses[this_1.currentResponseNum];
          var _loop_2 = function(i2) {
            if (toProcess[i2]) {
              exceptionGuard(function() {
                _this.onMessage_(toProcess[i2]);
              });
            }
          };
          for (var i = 0; i < toProcess.length; ++i) {
            _loop_2(i);
          }
          if (this_1.currentResponseNum === this_1.closeAfterResponse) {
            if (this_1.onClose) {
              this_1.onClose();
              this_1.onClose = null;
            }
            return "break";
          }
          this_1.currentResponseNum++;
        };
        var this_1 = this;
        while (this.pendingResponses[this.currentResponseNum]) {
          var state_1 = _loop_1();
          if (state_1 === "break")
            break;
        }
      };
      return PacketReceiver2;
    }();
    var FIREBASE_LONGPOLL_START_PARAM = "start";
    var FIREBASE_LONGPOLL_CLOSE_COMMAND = "close";
    var FIREBASE_LONGPOLL_COMMAND_CB_NAME = "pLPCommand";
    var FIREBASE_LONGPOLL_DATA_CB_NAME = "pRTLPCB";
    var FIREBASE_LONGPOLL_ID_PARAM = "id";
    var FIREBASE_LONGPOLL_PW_PARAM = "pw";
    var FIREBASE_LONGPOLL_SERIAL_PARAM = "ser";
    var FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = "cb";
    var FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = "seg";
    var FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = "ts";
    var FIREBASE_LONGPOLL_DATA_PARAM = "d";
    var FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = "dframe";
    var MAX_URL_DATA_SIZE = 1870;
    var SEG_HEADER_SIZE = 30;
    var MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
    var KEEPALIVE_REQUEST_INTERVAL = 25e3;
    var LP_CONNECT_TIMEOUT = 3e4;
    var BrowserPollConnection = function() {
      function BrowserPollConnection2(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        var _this = this;
        this.connId = connId;
        this.repoInfo = repoInfo;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.transportSessionId = transportSessionId;
        this.lastSessionId = lastSessionId;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.everConnected_ = false;
        this.log_ = logWrapper(connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.urlFn = function(params) {
          if (_this.appCheckToken) {
            params[APP_CHECK_TOKEN_PARAM] = _this.appCheckToken;
          }
          return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);
        };
      }
      BrowserPollConnection2.prototype.open = function(onMessage, onDisconnect) {
        var _this = this;
        this.curSegmentNum = 0;
        this.onDisconnect_ = onDisconnect;
        this.myPacketOrderer = new PacketReceiver(onMessage);
        this.isClosed_ = false;
        this.connectTimeoutTimer_ = setTimeout(function() {
          _this.log_("Timed out trying to connect.");
          _this.onClosed_();
          _this.connectTimeoutTimer_ = null;
        }, Math.floor(LP_CONNECT_TIMEOUT));
        executeWhenDOMReady(function() {
          if (_this.isClosed_) {
            return;
          }
          _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var _a = tslib.__read(args, 5), command = _a[0], arg1 = _a[1], arg2 = _a[2];
            _a[3];
            _a[4];
            _this.incrementIncomingBytes_(args);
            if (!_this.scriptTagHolder) {
              return;
            }
            if (_this.connectTimeoutTimer_) {
              clearTimeout(_this.connectTimeoutTimer_);
              _this.connectTimeoutTimer_ = null;
            }
            _this.everConnected_ = true;
            if (command === FIREBASE_LONGPOLL_START_PARAM) {
              _this.id = arg1;
              _this.password = arg2;
            } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {
              if (arg1) {
                _this.scriptTagHolder.sendNewPolls = false;
                _this.myPacketOrderer.closeAfter(arg1, function() {
                  _this.onClosed_();
                });
              } else {
                _this.onClosed_();
              }
            } else {
              throw new Error("Unrecognized command received: " + command);
            }
          }, function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var _a = tslib.__read(args, 2), pN = _a[0], data = _a[1];
            _this.incrementIncomingBytes_(args);
            _this.myPacketOrderer.handleResponse(pN, data);
          }, function() {
            _this.onClosed_();
          }, _this.urlFn);
          var urlParams = {};
          urlParams[FIREBASE_LONGPOLL_START_PARAM] = "t";
          urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 1e8);
          if (_this.scriptTagHolder.uniqueCallbackIdentifier) {
            urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;
          }
          urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
          if (_this.transportSessionId) {
            urlParams[TRANSPORT_SESSION_PARAM] = _this.transportSessionId;
          }
          if (_this.lastSessionId) {
            urlParams[LAST_SESSION_PARAM] = _this.lastSessionId;
          }
          if (_this.applicationId) {
            urlParams[APPLICATION_ID_PARAM] = _this.applicationId;
          }
          if (_this.appCheckToken) {
            urlParams[APP_CHECK_TOKEN_PARAM] = _this.appCheckToken;
          }
          if (typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
            urlParams[REFERER_PARAM] = FORGE_REF;
          }
          var connectURL = _this.urlFn(urlParams);
          _this.log_("Connecting via long-poll to " + connectURL);
          _this.scriptTagHolder.addTag(connectURL, function() {
          });
        });
      };
      BrowserPollConnection2.prototype.start = function() {
        this.scriptTagHolder.startLongPoll(this.id, this.password);
        this.addDisconnectPingFrame(this.id, this.password);
      };
      BrowserPollConnection2.forceAllow = function() {
        BrowserPollConnection2.forceAllow_ = true;
      };
      BrowserPollConnection2.forceDisallow = function() {
        BrowserPollConnection2.forceDisallow_ = true;
      };
      BrowserPollConnection2.isAvailable = function() {
        if (util.isNodeSdk()) {
          return false;
        } else if (BrowserPollConnection2.forceAllow_) {
          return true;
        } else {
          return !BrowserPollConnection2.forceDisallow_ && typeof document !== "undefined" && document.createElement != null && !isChromeExtensionContentScript() && !isWindowsStoreApp();
        }
      };
      BrowserPollConnection2.prototype.markConnectionHealthy = function() {
      };
      BrowserPollConnection2.prototype.shutdown_ = function() {
        this.isClosed_ = true;
        if (this.scriptTagHolder) {
          this.scriptTagHolder.close();
          this.scriptTagHolder = null;
        }
        if (this.myDisconnFrame) {
          document.body.removeChild(this.myDisconnFrame);
          this.myDisconnFrame = null;
        }
        if (this.connectTimeoutTimer_) {
          clearTimeout(this.connectTimeoutTimer_);
          this.connectTimeoutTimer_ = null;
        }
      };
      BrowserPollConnection2.prototype.onClosed_ = function() {
        if (!this.isClosed_) {
          this.log_("Longpoll is closing itself");
          this.shutdown_();
          if (this.onDisconnect_) {
            this.onDisconnect_(this.everConnected_);
            this.onDisconnect_ = null;
          }
        }
      };
      BrowserPollConnection2.prototype.close = function() {
        if (!this.isClosed_) {
          this.log_("Longpoll is being closed.");
          this.shutdown_();
        }
      };
      BrowserPollConnection2.prototype.send = function(data) {
        var dataStr = util.stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter("bytes_sent", dataStr.length);
        var base64data = util.base64Encode(dataStr);
        var dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
        for (var i = 0; i < dataSegs.length; i++) {
          this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
          this.curSegmentNum++;
        }
      };
      BrowserPollConnection2.prototype.addDisconnectPingFrame = function(id, pw) {
        if (util.isNodeSdk()) {
          return;
        }
        this.myDisconnFrame = document.createElement("iframe");
        var urlParams = {};
        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = "t";
        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;
        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
        this.myDisconnFrame.src = this.urlFn(urlParams);
        this.myDisconnFrame.style.display = "none";
        document.body.appendChild(this.myDisconnFrame);
      };
      BrowserPollConnection2.prototype.incrementIncomingBytes_ = function(args) {
        var bytesReceived = util.stringify(args).length;
        this.bytesReceived += bytesReceived;
        this.stats_.incrementCounter("bytes_received", bytesReceived);
      };
      return BrowserPollConnection2;
    }();
    var FirebaseIFrameScriptHolder = function() {
      function FirebaseIFrameScriptHolder2(commandCB, onMessageCB, onDisconnect, urlFn) {
        this.onDisconnect = onDisconnect;
        this.urlFn = urlFn;
        this.outstandingRequests = new Set();
        this.pendingSegs = [];
        this.currentSerial = Math.floor(Math.random() * 1e8);
        this.sendNewPolls = true;
        if (!util.isNodeSdk()) {
          this.uniqueCallbackIdentifier = LUIDGenerator();
          window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
          window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
          this.myIFrame = FirebaseIFrameScriptHolder2.createIFrame_();
          var script = "";
          if (this.myIFrame.src && this.myIFrame.src.substr(0, "javascript:".length) === "javascript:") {
            var currentDomain = document.domain;
            script = '<script>document.domain="' + currentDomain + '";<\/script>';
          }
          var iframeContents = "<html><body>" + script + "</body></html>";
          try {
            this.myIFrame.doc.open();
            this.myIFrame.doc.write(iframeContents);
            this.myIFrame.doc.close();
          } catch (e) {
            log("frame writing exception");
            if (e.stack) {
              log(e.stack);
            }
            log(e);
          }
        } else {
          this.commandCB = commandCB;
          this.onMessageCB = onMessageCB;
        }
      }
      FirebaseIFrameScriptHolder2.createIFrame_ = function() {
        var iframe = document.createElement("iframe");
        iframe.style.display = "none";
        if (document.body) {
          document.body.appendChild(iframe);
          try {
            var a = iframe.contentWindow.document;
            if (!a) {
              log("No IE domain setting required");
            }
          } catch (e) {
            var domain = document.domain;
            iframe.src = "javascript:void((function(){document.open();document.domain='" + domain + "';document.close();})())";
          }
        } else {
          throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
        }
        if (iframe.contentDocument) {
          iframe.doc = iframe.contentDocument;
        } else if (iframe.contentWindow) {
          iframe.doc = iframe.contentWindow.document;
        } else if (iframe.document) {
          iframe.doc = iframe.document;
        }
        return iframe;
      };
      FirebaseIFrameScriptHolder2.prototype.close = function() {
        var _this = this;
        this.alive = false;
        if (this.myIFrame) {
          this.myIFrame.doc.body.innerHTML = "";
          setTimeout(function() {
            if (_this.myIFrame !== null) {
              document.body.removeChild(_this.myIFrame);
              _this.myIFrame = null;
            }
          }, Math.floor(0));
        }
        var onDisconnect = this.onDisconnect;
        if (onDisconnect) {
          this.onDisconnect = null;
          onDisconnect();
        }
      };
      FirebaseIFrameScriptHolder2.prototype.startLongPoll = function(id, pw) {
        this.myID = id;
        this.myPW = pw;
        this.alive = true;
        while (this.newRequest_()) {
        }
      };
      FirebaseIFrameScriptHolder2.prototype.newRequest_ = function() {
        if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
          this.currentSerial++;
          var urlParams = {};
          urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
          urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
          urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
          var theURL = this.urlFn(urlParams);
          var curDataString = "";
          var i = 0;
          while (this.pendingSegs.length > 0) {
            var nextSeg = this.pendingSegs[0];
            if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {
              var theSeg = this.pendingSegs.shift();
              curDataString = curDataString + "&" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + "=" + theSeg.seg + "&" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + "=" + theSeg.ts + "&" + FIREBASE_LONGPOLL_DATA_PARAM + i + "=" + theSeg.d;
              i++;
            } else {
              break;
            }
          }
          theURL = theURL + curDataString;
          this.addLongPollTag_(theURL, this.currentSerial);
          return true;
        } else {
          return false;
        }
      };
      FirebaseIFrameScriptHolder2.prototype.enqueueSegment = function(segnum, totalsegs, data) {
        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
        if (this.alive) {
          this.newRequest_();
        }
      };
      FirebaseIFrameScriptHolder2.prototype.addLongPollTag_ = function(url, serial) {
        var _this = this;
        this.outstandingRequests.add(serial);
        var doNewRequest = function() {
          _this.outstandingRequests.delete(serial);
          _this.newRequest_();
        };
        var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        var readyStateCB = function() {
          clearTimeout(keepaliveTimeout);
          doNewRequest();
        };
        this.addTag(url, readyStateCB);
      };
      FirebaseIFrameScriptHolder2.prototype.addTag = function(url, loadCB) {
        var _this = this;
        if (util.isNodeSdk()) {
          this.doNodeLongPoll(url, loadCB);
        } else {
          setTimeout(function() {
            try {
              if (!_this.sendNewPolls) {
                return;
              }
              var newScript_1 = _this.myIFrame.doc.createElement("script");
              newScript_1.type = "text/javascript";
              newScript_1.async = true;
              newScript_1.src = url;
              newScript_1.onload = newScript_1.onreadystatechange = function() {
                var rstate = newScript_1.readyState;
                if (!rstate || rstate === "loaded" || rstate === "complete") {
                  newScript_1.onload = newScript_1.onreadystatechange = null;
                  if (newScript_1.parentNode) {
                    newScript_1.parentNode.removeChild(newScript_1);
                  }
                  loadCB();
                }
              };
              newScript_1.onerror = function() {
                log("Long-poll script failed to load: " + url);
                _this.sendNewPolls = false;
                _this.close();
              };
              _this.myIFrame.doc.body.appendChild(newScript_1);
            } catch (e) {
            }
          }, Math.floor(1));
        }
      };
      return FirebaseIFrameScriptHolder2;
    }();
    var WEBSOCKET_MAX_FRAME_SIZE = 16384;
    var WEBSOCKET_KEEPALIVE_INTERVAL = 45e3;
    var WebSocketImpl = null;
    if (typeof MozWebSocket !== "undefined") {
      WebSocketImpl = MozWebSocket;
    } else if (typeof WebSocket !== "undefined") {
      WebSocketImpl = WebSocket;
    }
    function setWebSocketImpl(impl) {
      WebSocketImpl = impl;
    }
    var WebSocketConnection = function() {
      function WebSocketConnection2(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.keepaliveTimer = null;
        this.frames = null;
        this.totalFrames = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.log_ = logWrapper(this.connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.connURL = WebSocketConnection2.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken);
        this.nodeAdmin = repoInfo.nodeAdmin;
      }
      WebSocketConnection2.connectionURL_ = function(repoInfo, transportSessionId, lastSessionId, appCheckToken) {
        var urlParams = {};
        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
        if (!util.isNodeSdk() && typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
          urlParams[REFERER_PARAM] = FORGE_REF;
        }
        if (transportSessionId) {
          urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;
        }
        if (lastSessionId) {
          urlParams[LAST_SESSION_PARAM] = lastSessionId;
        }
        if (appCheckToken) {
          urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;
        }
        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);
      };
      WebSocketConnection2.prototype.open = function(onMessage, onDisconnect) {
        var _this = this;
        this.onDisconnect = onDisconnect;
        this.onMessage = onMessage;
        this.log_("Websocket connecting to " + this.connURL);
        this.everConnected_ = false;
        PersistentStorage.set("previous_websocket_failure", true);
        try {
          if (util.isNodeSdk()) {
            var device = this.nodeAdmin ? "AdminNode" : "Node";
            var options2 = {
              headers: {
                "User-Agent": "Firebase/" + PROTOCOL_VERSION + "/" + SDK_VERSION + "/" + process.platform + "/" + device,
                "X-Firebase-GMPID": this.applicationId || ""
              }
            };
            if (this.authToken) {
              options2.headers["Authorization"] = "Bearer " + this.authToken;
            }
            if (this.appCheckToken) {
              options2.headers["X-Firebase-AppCheck"] = this.appCheckToken;
            }
            var env = process["env"];
            var proxy = this.connURL.indexOf("wss://") === 0 ? env["HTTPS_PROXY"] || env["https_proxy"] : env["HTTP_PROXY"] || env["http_proxy"];
            if (proxy) {
              options2["proxy"] = { origin: proxy };
            }
            this.mySock = new WebSocketImpl(this.connURL, [], options2);
          } else {
            var options2 = {
              headers: {
                "X-Firebase-GMPID": this.applicationId || "",
                "X-Firebase-AppCheck": this.appCheckToken || ""
              }
            };
            this.mySock = new WebSocketImpl(this.connURL, [], options2);
          }
        } catch (e) {
          this.log_("Error instantiating WebSocket.");
          var error4 = e.message || e.data;
          if (error4) {
            this.log_(error4);
          }
          this.onClosed_();
          return;
        }
        this.mySock.onopen = function() {
          _this.log_("Websocket connected.");
          _this.everConnected_ = true;
        };
        this.mySock.onclose = function() {
          _this.log_("Websocket connection was disconnected.");
          _this.mySock = null;
          _this.onClosed_();
        };
        this.mySock.onmessage = function(m) {
          _this.handleIncomingFrame(m);
        };
        this.mySock.onerror = function(e) {
          _this.log_("WebSocket error.  Closing connection.");
          var error5 = e.message || e.data;
          if (error5) {
            _this.log_(error5);
          }
          _this.onClosed_();
        };
      };
      WebSocketConnection2.prototype.start = function() {
      };
      WebSocketConnection2.forceDisallow = function() {
        WebSocketConnection2.forceDisallow_ = true;
      };
      WebSocketConnection2.isAvailable = function() {
        var isOldAndroid = false;
        if (typeof navigator !== "undefined" && navigator.userAgent) {
          var oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
          var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
          if (oldAndroidMatch && oldAndroidMatch.length > 1) {
            if (parseFloat(oldAndroidMatch[1]) < 4.4) {
              isOldAndroid = true;
            }
          }
        }
        return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection2.forceDisallow_;
      };
      WebSocketConnection2.previouslyFailed = function() {
        return PersistentStorage.isInMemoryStorage || PersistentStorage.get("previous_websocket_failure") === true;
      };
      WebSocketConnection2.prototype.markConnectionHealthy = function() {
        PersistentStorage.remove("previous_websocket_failure");
      };
      WebSocketConnection2.prototype.appendFrame_ = function(data) {
        this.frames.push(data);
        if (this.frames.length === this.totalFrames) {
          var fullMess = this.frames.join("");
          this.frames = null;
          var jsonMess = util.jsonEval(fullMess);
          this.onMessage(jsonMess);
        }
      };
      WebSocketConnection2.prototype.handleNewFrameCount_ = function(frameCount) {
        this.totalFrames = frameCount;
        this.frames = [];
      };
      WebSocketConnection2.prototype.extractFrameCount_ = function(data) {
        util.assert(this.frames === null, "We already have a frame buffer");
        if (data.length <= 6) {
          var frameCount = Number(data);
          if (!isNaN(frameCount)) {
            this.handleNewFrameCount_(frameCount);
            return null;
          }
        }
        this.handleNewFrameCount_(1);
        return data;
      };
      WebSocketConnection2.prototype.handleIncomingFrame = function(mess) {
        if (this.mySock === null) {
          return;
        }
        var data = mess["data"];
        this.bytesReceived += data.length;
        this.stats_.incrementCounter("bytes_received", data.length);
        this.resetKeepAlive();
        if (this.frames !== null) {
          this.appendFrame_(data);
        } else {
          var remainingData = this.extractFrameCount_(data);
          if (remainingData !== null) {
            this.appendFrame_(remainingData);
          }
        }
      };
      WebSocketConnection2.prototype.send = function(data) {
        this.resetKeepAlive();
        var dataStr = util.stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter("bytes_sent", dataStr.length);
        var dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
        if (dataSegs.length > 1) {
          this.sendString_(String(dataSegs.length));
        }
        for (var i = 0; i < dataSegs.length; i++) {
          this.sendString_(dataSegs[i]);
        }
      };
      WebSocketConnection2.prototype.shutdown_ = function() {
        this.isClosed_ = true;
        if (this.keepaliveTimer) {
          clearInterval(this.keepaliveTimer);
          this.keepaliveTimer = null;
        }
        if (this.mySock) {
          this.mySock.close();
          this.mySock = null;
        }
      };
      WebSocketConnection2.prototype.onClosed_ = function() {
        if (!this.isClosed_) {
          this.log_("WebSocket is closing itself");
          this.shutdown_();
          if (this.onDisconnect) {
            this.onDisconnect(this.everConnected_);
            this.onDisconnect = null;
          }
        }
      };
      WebSocketConnection2.prototype.close = function() {
        if (!this.isClosed_) {
          this.log_("WebSocket is being closed");
          this.shutdown_();
        }
      };
      WebSocketConnection2.prototype.resetKeepAlive = function() {
        var _this = this;
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = setInterval(function() {
          if (_this.mySock) {
            _this.sendString_("0");
          }
          _this.resetKeepAlive();
        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
      };
      WebSocketConnection2.prototype.sendString_ = function(str) {
        try {
          this.mySock.send(str);
        } catch (e) {
          this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection.");
          setTimeout(this.onClosed_.bind(this), 0);
        }
      };
      WebSocketConnection2.responsesRequiredToBeHealthy = 2;
      WebSocketConnection2.healthyTimeout = 3e4;
      return WebSocketConnection2;
    }();
    var TransportManager = function() {
      function TransportManager2(repoInfo) {
        this.initTransports_(repoInfo);
      }
      Object.defineProperty(TransportManager2, "ALL_TRANSPORTS", {
        get: function() {
          return [BrowserPollConnection, WebSocketConnection];
        },
        enumerable: false,
        configurable: true
      });
      TransportManager2.prototype.initTransports_ = function(repoInfo) {
        var e_1, _a;
        var isWebSocketsAvailable2 = WebSocketConnection && WebSocketConnection["isAvailable"]();
        var isSkipPollConnection = isWebSocketsAvailable2 && !WebSocketConnection.previouslyFailed();
        if (repoInfo.webSocketOnly) {
          if (!isWebSocketsAvailable2) {
            warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
          }
          isSkipPollConnection = true;
        }
        if (isSkipPollConnection) {
          this.transports_ = [WebSocketConnection];
        } else {
          var transports = this.transports_ = [];
          try {
            for (var _b = tslib.__values(TransportManager2.ALL_TRANSPORTS), _c = _b.next(); !_c.done; _c = _b.next()) {
              var transport = _c.value;
              if (transport && transport["isAvailable"]()) {
                transports.push(transport);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      };
      TransportManager2.prototype.initialTransport = function() {
        if (this.transports_.length > 0) {
          return this.transports_[0];
        } else {
          throw new Error("No transports available");
        }
      };
      TransportManager2.prototype.upgradeTransport = function() {
        if (this.transports_.length > 1) {
          return this.transports_[1];
        } else {
          return null;
        }
      };
      return TransportManager2;
    }();
    var UPGRADE_TIMEOUT = 6e4;
    var DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5e3;
    var BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
    var BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
    var MESSAGE_TYPE = "t";
    var MESSAGE_DATA = "d";
    var CONTROL_SHUTDOWN = "s";
    var CONTROL_RESET = "r";
    var CONTROL_ERROR = "e";
    var CONTROL_PONG = "o";
    var SWITCH_ACK = "a";
    var END_TRANSMISSION = "n";
    var PING = "p";
    var SERVER_HELLO = "h";
    var Connection = function() {
      function Connection2(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
        this.id = id;
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.appCheckToken_ = appCheckToken_;
        this.authToken_ = authToken_;
        this.onMessage_ = onMessage_;
        this.onReady_ = onReady_;
        this.onDisconnect_ = onDisconnect_;
        this.onKill_ = onKill_;
        this.lastSessionId = lastSessionId;
        this.connectionCount = 0;
        this.pendingDataMessages = [];
        this.state_ = 0;
        this.log_ = logWrapper("c:" + this.id + ":");
        this.transportManager_ = new TransportManager(repoInfo_);
        this.log_("Connection created");
        this.start_();
      }
      Connection2.prototype.start_ = function() {
        var _this = this;
        var conn = this.transportManager_.initialTransport();
        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);
        this.primaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
        var onMessageReceived = this.connReceiver_(this.conn_);
        var onConnectionLost = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_;
        this.rx_ = this.conn_;
        this.secondaryConn_ = null;
        this.isHealthy_ = false;
        setTimeout(function() {
          _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);
        }, Math.floor(0));
        var healthyTimeoutMS = conn["healthyTimeout"] || 0;
        if (healthyTimeoutMS > 0) {
          this.healthyTimeout_ = setTimeoutNonBlocking(function() {
            _this.healthyTimeout_ = null;
            if (!_this.isHealthy_) {
              if (_this.conn_ && _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
                _this.log_("Connection exceeded healthy timeout but has received " + _this.conn_.bytesReceived + " bytes.  Marking connection healthy.");
                _this.isHealthy_ = true;
                _this.conn_.markConnectionHealthy();
              } else if (_this.conn_ && _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
                _this.log_("Connection exceeded healthy timeout but has sent " + _this.conn_.bytesSent + " bytes.  Leaving connection alive.");
              } else {
                _this.log_("Closing unhealthy connection after timeout.");
                _this.close();
              }
            }
          }, Math.floor(healthyTimeoutMS));
        }
      };
      Connection2.prototype.nextTransportId_ = function() {
        return "c:" + this.id + ":" + this.connectionCount++;
      };
      Connection2.prototype.disconnReceiver_ = function(conn) {
        var _this = this;
        return function(everConnected) {
          if (conn === _this.conn_) {
            _this.onConnectionLost_(everConnected);
          } else if (conn === _this.secondaryConn_) {
            _this.log_("Secondary connection lost.");
            _this.onSecondaryConnectionLost_();
          } else {
            _this.log_("closing an old connection");
          }
        };
      };
      Connection2.prototype.connReceiver_ = function(conn) {
        var _this = this;
        return function(message) {
          if (_this.state_ !== 2) {
            if (conn === _this.rx_) {
              _this.onPrimaryMessageReceived_(message);
            } else if (conn === _this.secondaryConn_) {
              _this.onSecondaryMessageReceived_(message);
            } else {
              _this.log_("message on old connection");
            }
          }
        };
      };
      Connection2.prototype.sendRequest = function(dataMsg) {
        var msg = { t: "d", d: dataMsg };
        this.sendData_(msg);
      };
      Connection2.prototype.tryCleanupConnection = function() {
        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
          this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId);
          this.conn_ = this.secondaryConn_;
          this.secondaryConn_ = null;
        }
      };
      Connection2.prototype.onSecondaryControl_ = function(controlData) {
        if (MESSAGE_TYPE in controlData) {
          var cmd = controlData[MESSAGE_TYPE];
          if (cmd === SWITCH_ACK) {
            this.upgradeIfSecondaryHealthy_();
          } else if (cmd === CONTROL_RESET) {
            this.log_("Got a reset on secondary, closing it");
            this.secondaryConn_.close();
            if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {
              this.close();
            }
          } else if (cmd === CONTROL_PONG) {
            this.log_("got pong on secondary.");
            this.secondaryResponsesRequired_--;
            this.upgradeIfSecondaryHealthy_();
          }
        }
      };
      Connection2.prototype.onSecondaryMessageReceived_ = function(parsedData) {
        var layer = requireKey("t", parsedData);
        var data = requireKey("d", parsedData);
        if (layer === "c") {
          this.onSecondaryControl_(data);
        } else if (layer === "d") {
          this.pendingDataMessages.push(data);
        } else {
          throw new Error("Unknown protocol layer: " + layer);
        }
      };
      Connection2.prototype.upgradeIfSecondaryHealthy_ = function() {
        if (this.secondaryResponsesRequired_ <= 0) {
          this.log_("Secondary connection is healthy.");
          this.isHealthy_ = true;
          this.secondaryConn_.markConnectionHealthy();
          this.proceedWithUpgrade_();
        } else {
          this.log_("sending ping on secondary.");
          this.secondaryConn_.send({ t: "c", d: { t: PING, d: {} } });
        }
      };
      Connection2.prototype.proceedWithUpgrade_ = function() {
        this.secondaryConn_.start();
        this.log_("sending client ack on secondary");
        this.secondaryConn_.send({ t: "c", d: { t: SWITCH_ACK, d: {} } });
        this.log_("Ending transmission on primary");
        this.conn_.send({ t: "c", d: { t: END_TRANSMISSION, d: {} } });
        this.tx_ = this.secondaryConn_;
        this.tryCleanupConnection();
      };
      Connection2.prototype.onPrimaryMessageReceived_ = function(parsedData) {
        var layer = requireKey("t", parsedData);
        var data = requireKey("d", parsedData);
        if (layer === "c") {
          this.onControl_(data);
        } else if (layer === "d") {
          this.onDataMessage_(data);
        }
      };
      Connection2.prototype.onDataMessage_ = function(message) {
        this.onPrimaryResponse_();
        this.onMessage_(message);
      };
      Connection2.prototype.onPrimaryResponse_ = function() {
        if (!this.isHealthy_) {
          this.primaryResponsesRequired_--;
          if (this.primaryResponsesRequired_ <= 0) {
            this.log_("Primary connection is healthy.");
            this.isHealthy_ = true;
            this.conn_.markConnectionHealthy();
          }
        }
      };
      Connection2.prototype.onControl_ = function(controlData) {
        var cmd = requireKey(MESSAGE_TYPE, controlData);
        if (MESSAGE_DATA in controlData) {
          var payload = controlData[MESSAGE_DATA];
          if (cmd === SERVER_HELLO) {
            this.onHandshake_(payload);
          } else if (cmd === END_TRANSMISSION) {
            this.log_("recvd end transmission on primary");
            this.rx_ = this.secondaryConn_;
            for (var i = 0; i < this.pendingDataMessages.length; ++i) {
              this.onDataMessage_(this.pendingDataMessages[i]);
            }
            this.pendingDataMessages = [];
            this.tryCleanupConnection();
          } else if (cmd === CONTROL_SHUTDOWN) {
            this.onConnectionShutdown_(payload);
          } else if (cmd === CONTROL_RESET) {
            this.onReset_(payload);
          } else if (cmd === CONTROL_ERROR) {
            error3("Server Error: " + payload);
          } else if (cmd === CONTROL_PONG) {
            this.log_("got pong on primary.");
            this.onPrimaryResponse_();
            this.sendPingOnPrimaryIfNecessary_();
          } else {
            error3("Unknown control packet command: " + cmd);
          }
        }
      };
      Connection2.prototype.onHandshake_ = function(handshake) {
        var timestamp = handshake.ts;
        var version2 = handshake.v;
        var host = handshake.h;
        this.sessionId = handshake.s;
        this.repoInfo_.host = host;
        if (this.state_ === 0) {
          this.conn_.start();
          this.onConnectionEstablished_(this.conn_, timestamp);
          if (PROTOCOL_VERSION !== version2) {
            warn("Protocol version mismatch detected");
          }
          this.tryStartUpgrade_();
        }
      };
      Connection2.prototype.tryStartUpgrade_ = function() {
        var conn = this.transportManager_.upgradeTransport();
        if (conn) {
          this.startUpgrade_(conn);
        }
      };
      Connection2.prototype.startUpgrade_ = function(conn) {
        var _this = this;
        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);
        this.secondaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
        var onMessage = this.connReceiver_(this.secondaryConn_);
        var onDisconnect = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(onMessage, onDisconnect);
        setTimeoutNonBlocking(function() {
          if (_this.secondaryConn_) {
            _this.log_("Timed out trying to upgrade.");
            _this.secondaryConn_.close();
          }
        }, Math.floor(UPGRADE_TIMEOUT));
      };
      Connection2.prototype.onReset_ = function(host) {
        this.log_("Reset packet received.  New host: " + host);
        this.repoInfo_.host = host;
        if (this.state_ === 1) {
          this.close();
        } else {
          this.closeConnections_();
          this.start_();
        }
      };
      Connection2.prototype.onConnectionEstablished_ = function(conn, timestamp) {
        var _this = this;
        this.log_("Realtime connection established.");
        this.conn_ = conn;
        this.state_ = 1;
        if (this.onReady_) {
          this.onReady_(timestamp, this.sessionId);
          this.onReady_ = null;
        }
        if (this.primaryResponsesRequired_ === 0) {
          this.log_("Primary connection is healthy.");
          this.isHealthy_ = true;
        } else {
          setTimeoutNonBlocking(function() {
            _this.sendPingOnPrimaryIfNecessary_();
          }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
        }
      };
      Connection2.prototype.sendPingOnPrimaryIfNecessary_ = function() {
        if (!this.isHealthy_ && this.state_ === 1) {
          this.log_("sending ping on primary.");
          this.sendData_({ t: "c", d: { t: PING, d: {} } });
        }
      };
      Connection2.prototype.onSecondaryConnectionLost_ = function() {
        var conn = this.secondaryConn_;
        this.secondaryConn_ = null;
        if (this.tx_ === conn || this.rx_ === conn) {
          this.close();
        }
      };
      Connection2.prototype.onConnectionLost_ = function(everConnected) {
        this.conn_ = null;
        if (!everConnected && this.state_ === 0) {
          this.log_("Realtime connection failed.");
          if (this.repoInfo_.isCacheableHost()) {
            PersistentStorage.remove("host:" + this.repoInfo_.host);
            this.repoInfo_.internalHost = this.repoInfo_.host;
          }
        } else if (this.state_ === 1) {
          this.log_("Realtime connection lost.");
        }
        this.close();
      };
      Connection2.prototype.onConnectionShutdown_ = function(reason) {
        this.log_("Connection shutdown command received. Shutting down...");
        if (this.onKill_) {
          this.onKill_(reason);
          this.onKill_ = null;
        }
        this.onDisconnect_ = null;
        this.close();
      };
      Connection2.prototype.sendData_ = function(data) {
        if (this.state_ !== 1) {
          throw "Connection is not connected";
        } else {
          this.tx_.send(data);
        }
      };
      Connection2.prototype.close = function() {
        if (this.state_ !== 2) {
          this.log_("Closing realtime connection.");
          this.state_ = 2;
          this.closeConnections_();
          if (this.onDisconnect_) {
            this.onDisconnect_();
            this.onDisconnect_ = null;
          }
        }
      };
      Connection2.prototype.closeConnections_ = function() {
        this.log_("Shutting down all connections");
        if (this.conn_) {
          this.conn_.close();
          this.conn_ = null;
        }
        if (this.secondaryConn_) {
          this.secondaryConn_.close();
          this.secondaryConn_ = null;
        }
        if (this.healthyTimeout_) {
          clearTimeout(this.healthyTimeout_);
          this.healthyTimeout_ = null;
        }
      };
      return Connection2;
    }();
    var ServerActions = function() {
      function ServerActions2() {
      }
      ServerActions2.prototype.put = function(pathString, data, onComplete, hash2) {
      };
      ServerActions2.prototype.merge = function(pathString, data, onComplete, hash2) {
      };
      ServerActions2.prototype.refreshAuthToken = function(token) {
      };
      ServerActions2.prototype.refreshAppCheckToken = function(token) {
      };
      ServerActions2.prototype.onDisconnectPut = function(pathString, data, onComplete) {
      };
      ServerActions2.prototype.onDisconnectMerge = function(pathString, data, onComplete) {
      };
      ServerActions2.prototype.onDisconnectCancel = function(pathString, onComplete) {
      };
      ServerActions2.prototype.reportStats = function(stats2) {
      };
      return ServerActions2;
    }();
    var EventEmitter = function() {
      function EventEmitter2(allowedEvents_) {
        this.allowedEvents_ = allowedEvents_;
        this.listeners_ = {};
        util.assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, "Requires a non-empty array");
      }
      EventEmitter2.prototype.trigger = function(eventType) {
        var varArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          varArgs[_i - 1] = arguments[_i];
        }
        if (Array.isArray(this.listeners_[eventType])) {
          var listeners = tslib.__spreadArray([], tslib.__read(this.listeners_[eventType]));
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].callback.apply(listeners[i].context, varArgs);
          }
        }
      };
      EventEmitter2.prototype.on = function(eventType, callback, context) {
        this.validateEventType_(eventType);
        this.listeners_[eventType] = this.listeners_[eventType] || [];
        this.listeners_[eventType].push({ callback, context });
        var eventData = this.getInitialEvent(eventType);
        if (eventData) {
          callback.apply(context, eventData);
        }
      };
      EventEmitter2.prototype.off = function(eventType, callback, context) {
        this.validateEventType_(eventType);
        var listeners = this.listeners_[eventType] || [];
        for (var i = 0; i < listeners.length; i++) {
          if (listeners[i].callback === callback && (!context || context === listeners[i].context)) {
            listeners.splice(i, 1);
            return;
          }
        }
      };
      EventEmitter2.prototype.validateEventType_ = function(eventType) {
        util.assert(this.allowedEvents_.find(function(et) {
          return et === eventType;
        }), "Unknown event: " + eventType);
      };
      return EventEmitter2;
    }();
    var OnlineMonitor = function(_super) {
      tslib.__extends(OnlineMonitor2, _super);
      function OnlineMonitor2() {
        var _this = _super.call(this, ["online"]) || this;
        _this.online_ = true;
        if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined" && !util.isMobileCordova()) {
          window.addEventListener("online", function() {
            if (!_this.online_) {
              _this.online_ = true;
              _this.trigger("online", true);
            }
          }, false);
          window.addEventListener("offline", function() {
            if (_this.online_) {
              _this.online_ = false;
              _this.trigger("online", false);
            }
          }, false);
        }
        return _this;
      }
      OnlineMonitor2.getInstance = function() {
        return new OnlineMonitor2();
      };
      OnlineMonitor2.prototype.getInitialEvent = function(eventType) {
        util.assert(eventType === "online", "Unknown event type: " + eventType);
        return [this.online_];
      };
      OnlineMonitor2.prototype.currentlyOnline = function() {
        return this.online_;
      };
      return OnlineMonitor2;
    }(EventEmitter);
    var MAX_PATH_DEPTH = 32;
    var MAX_PATH_LENGTH_BYTES = 768;
    var Path = function() {
      function Path2(pathOrString, pieceNum) {
        if (pieceNum === void 0) {
          this.pieces_ = pathOrString.split("/");
          var copyTo = 0;
          for (var i = 0; i < this.pieces_.length; i++) {
            if (this.pieces_[i].length > 0) {
              this.pieces_[copyTo] = this.pieces_[i];
              copyTo++;
            }
          }
          this.pieces_.length = copyTo;
          this.pieceNum_ = 0;
        } else {
          this.pieces_ = pathOrString;
          this.pieceNum_ = pieceNum;
        }
      }
      Path2.prototype.toString = function() {
        var pathString = "";
        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {
          if (this.pieces_[i] !== "") {
            pathString += "/" + this.pieces_[i];
          }
        }
        return pathString || "/";
      };
      return Path2;
    }();
    function newEmptyPath() {
      return new Path("");
    }
    function pathGetFront(path) {
      if (path.pieceNum_ >= path.pieces_.length) {
        return null;
      }
      return path.pieces_[path.pieceNum_];
    }
    function pathGetLength(path) {
      return path.pieces_.length - path.pieceNum_;
    }
    function pathPopFront(path) {
      var pieceNum = path.pieceNum_;
      if (pieceNum < path.pieces_.length) {
        pieceNum++;
      }
      return new Path(path.pieces_, pieceNum);
    }
    function pathGetBack(path) {
      if (path.pieceNum_ < path.pieces_.length) {
        return path.pieces_[path.pieces_.length - 1];
      }
      return null;
    }
    function pathToUrlEncodedString(path) {
      var pathString = "";
      for (var i = path.pieceNum_; i < path.pieces_.length; i++) {
        if (path.pieces_[i] !== "") {
          pathString += "/" + encodeURIComponent(String(path.pieces_[i]));
        }
      }
      return pathString || "/";
    }
    function pathSlice(path, begin) {
      if (begin === void 0) {
        begin = 0;
      }
      return path.pieces_.slice(path.pieceNum_ + begin);
    }
    function pathParent(path) {
      if (path.pieceNum_ >= path.pieces_.length) {
        return null;
      }
      var pieces = [];
      for (var i = path.pieceNum_; i < path.pieces_.length - 1; i++) {
        pieces.push(path.pieces_[i]);
      }
      return new Path(pieces, 0);
    }
    function pathChild(path, childPathObj) {
      var pieces = [];
      for (var i = path.pieceNum_; i < path.pieces_.length; i++) {
        pieces.push(path.pieces_[i]);
      }
      if (childPathObj instanceof Path) {
        for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
          pieces.push(childPathObj.pieces_[i]);
        }
      } else {
        var childPieces = childPathObj.split("/");
        for (var i = 0; i < childPieces.length; i++) {
          if (childPieces[i].length > 0) {
            pieces.push(childPieces[i]);
          }
        }
      }
      return new Path(pieces, 0);
    }
    function pathIsEmpty(path) {
      return path.pieceNum_ >= path.pieces_.length;
    }
    function newRelativePath(outerPath, innerPath) {
      var outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);
      if (outer === null) {
        return innerPath;
      } else if (outer === inner) {
        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));
      } else {
        throw new Error("INTERNAL ERROR: innerPath (" + innerPath + ") is not within outerPath (" + outerPath + ")");
      }
    }
    function pathCompare(left, right) {
      var leftKeys = pathSlice(left, 0);
      var rightKeys = pathSlice(right, 0);
      for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
        var cmp = nameCompare(leftKeys[i], rightKeys[i]);
        if (cmp !== 0) {
          return cmp;
        }
      }
      if (leftKeys.length === rightKeys.length) {
        return 0;
      }
      return leftKeys.length < rightKeys.length ? -1 : 1;
    }
    function pathEquals(path, other) {
      if (pathGetLength(path) !== pathGetLength(other)) {
        return false;
      }
      for (var i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++) {
        if (path.pieces_[i] !== other.pieces_[j]) {
          return false;
        }
      }
      return true;
    }
    function pathContains(path, other) {
      var i = path.pieceNum_;
      var j = other.pieceNum_;
      if (pathGetLength(path) > pathGetLength(other)) {
        return false;
      }
      while (i < path.pieces_.length) {
        if (path.pieces_[i] !== other.pieces_[j]) {
          return false;
        }
        ++i;
        ++j;
      }
      return true;
    }
    var ValidationPath = function() {
      function ValidationPath2(path, errorPrefix_) {
        this.errorPrefix_ = errorPrefix_;
        this.parts_ = pathSlice(path, 0);
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (var i = 0; i < this.parts_.length; i++) {
          this.byteLength_ += util.stringLength(this.parts_[i]);
        }
        validationPathCheckValid(this);
      }
      return ValidationPath2;
    }();
    function validationPathPush(validationPath, child2) {
      if (validationPath.parts_.length > 0) {
        validationPath.byteLength_ += 1;
      }
      validationPath.parts_.push(child2);
      validationPath.byteLength_ += util.stringLength(child2);
      validationPathCheckValid(validationPath);
    }
    function validationPathPop(validationPath) {
      var last = validationPath.parts_.pop();
      validationPath.byteLength_ -= util.stringLength(last);
      if (validationPath.parts_.length > 0) {
        validationPath.byteLength_ -= 1;
      }
    }
    function validationPathCheckValid(validationPath) {
      if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {
        throw new Error(validationPath.errorPrefix_ + "has a key path longer than " + MAX_PATH_LENGTH_BYTES + " bytes (" + validationPath.byteLength_ + ").");
      }
      if (validationPath.parts_.length > MAX_PATH_DEPTH) {
        throw new Error(validationPath.errorPrefix_ + "path specified exceeds the maximum depth that can be written (" + MAX_PATH_DEPTH + ") or object contains a cycle " + validationPathToErrorString(validationPath));
      }
    }
    function validationPathToErrorString(validationPath) {
      if (validationPath.parts_.length === 0) {
        return "";
      }
      return "in property '" + validationPath.parts_.join(".") + "'";
    }
    var VisibilityMonitor = function(_super) {
      tslib.__extends(VisibilityMonitor2, _super);
      function VisibilityMonitor2() {
        var _this = _super.call(this, ["visible"]) || this;
        var hidden;
        var visibilityChange;
        if (typeof document !== "undefined" && typeof document.addEventListener !== "undefined") {
          if (typeof document["hidden"] !== "undefined") {
            visibilityChange = "visibilitychange";
            hidden = "hidden";
          } else if (typeof document["mozHidden"] !== "undefined") {
            visibilityChange = "mozvisibilitychange";
            hidden = "mozHidden";
          } else if (typeof document["msHidden"] !== "undefined") {
            visibilityChange = "msvisibilitychange";
            hidden = "msHidden";
          } else if (typeof document["webkitHidden"] !== "undefined") {
            visibilityChange = "webkitvisibilitychange";
            hidden = "webkitHidden";
          }
        }
        _this.visible_ = true;
        if (visibilityChange) {
          document.addEventListener(visibilityChange, function() {
            var visible = !document[hidden];
            if (visible !== _this.visible_) {
              _this.visible_ = visible;
              _this.trigger("visible", visible);
            }
          }, false);
        }
        return _this;
      }
      VisibilityMonitor2.getInstance = function() {
        return new VisibilityMonitor2();
      };
      VisibilityMonitor2.prototype.getInitialEvent = function(eventType) {
        util.assert(eventType === "visible", "Unknown event type: " + eventType);
        return [this.visible_];
      };
      return VisibilityMonitor2;
    }(EventEmitter);
    var RECONNECT_MIN_DELAY = 1e3;
    var RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1e3;
    var GET_CONNECT_TIMEOUT = 3 * 1e3;
    var RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1e3;
    var RECONNECT_DELAY_MULTIPLIER = 1.3;
    var RECONNECT_DELAY_RESET_TIMEOUT = 3e4;
    var SERVER_KILL_INTERRUPT_REASON = "server_kill";
    var INVALID_TOKEN_THRESHOLD = 3;
    var PersistentConnection = function(_super) {
      tslib.__extends(PersistentConnection2, _super);
      function PersistentConnection2(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) {
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.applicationId_ = applicationId_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.onConnectStatus_ = onConnectStatus_;
        _this.onServerInfoUpdate_ = onServerInfoUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        _this.appCheckTokenProvider_ = appCheckTokenProvider_;
        _this.authOverride_ = authOverride_;
        _this.id = PersistentConnection2.nextPersistentConnectionId_++;
        _this.log_ = logWrapper("p:" + _this.id + ":");
        _this.interruptReasons_ = {};
        _this.listens = new Map();
        _this.outstandingPuts_ = [];
        _this.outstandingGets_ = [];
        _this.outstandingPutCount_ = 0;
        _this.outstandingGetCount_ = 0;
        _this.onDisconnectRequestQueue_ = [];
        _this.connected_ = false;
        _this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
        _this.securityDebugCallback_ = null;
        _this.lastSessionId = null;
        _this.establishConnectionTimer_ = null;
        _this.visible_ = false;
        _this.requestCBHash_ = {};
        _this.requestNumber_ = 0;
        _this.realtime_ = null;
        _this.authToken_ = null;
        _this.appCheckToken_ = null;
        _this.forceTokenRefresh_ = false;
        _this.invalidAuthTokenCount_ = 0;
        _this.invalidAppCheckTokenCount_ = 0;
        _this.firstConnection_ = true;
        _this.lastConnectionAttemptTime_ = null;
        _this.lastConnectionEstablishedTime_ = null;
        if (authOverride_ && !util.isNodeSdk()) {
          throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
        }
        VisibilityMonitor.getInstance().on("visible", _this.onVisible_, _this);
        if (repoInfo_.host.indexOf("fblocal") === -1) {
          OnlineMonitor.getInstance().on("online", _this.onOnline_, _this);
        }
        return _this;
      }
      PersistentConnection2.prototype.sendRequest = function(action, body, onResponse) {
        var curReqNum = ++this.requestNumber_;
        var msg = { r: curReqNum, a: action, b: body };
        this.log_(util.stringify(msg));
        util.assert(this.connected_, "sendRequest call when we're not connected not allowed.");
        this.realtime_.sendRequest(msg);
        if (onResponse) {
          this.requestCBHash_[curReqNum] = onResponse;
        }
      };
      PersistentConnection2.prototype.get = function(query2) {
        var _this = this;
        this.initConnection_();
        var deferred = new util.Deferred();
        var request = {
          p: query2._path.toString(),
          q: query2._queryObject
        };
        var outstandingGet = {
          action: "g",
          request,
          onComplete: function(message) {
            var payload = message["d"];
            if (message["s"] === "ok") {
              _this.onDataUpdate_(request["p"], payload, false, null);
              deferred.resolve(payload);
            } else {
              deferred.reject(payload);
            }
          }
        };
        this.outstandingGets_.push(outstandingGet);
        this.outstandingGetCount_++;
        var index2 = this.outstandingGets_.length - 1;
        if (!this.connected_) {
          setTimeout(function() {
            var get2 = _this.outstandingGets_[index2];
            if (get2 === void 0 || outstandingGet !== get2) {
              return;
            }
            delete _this.outstandingGets_[index2];
            _this.outstandingGetCount_--;
            if (_this.outstandingGetCount_ === 0) {
              _this.outstandingGets_ = [];
            }
            _this.log_("get " + index2 + " timed out on connection");
            deferred.reject(new Error("Client is offline."));
          }, GET_CONNECT_TIMEOUT);
        }
        if (this.connected_) {
          this.sendGet_(index2);
        }
        return deferred.promise;
      };
      PersistentConnection2.prototype.listen = function(query2, currentHashFn, tag, onComplete) {
        this.initConnection_();
        var queryId = query2._queryIdentifier;
        var pathString = query2._path.toString();
        this.log_("Listen called for " + pathString + " " + queryId);
        if (!this.listens.has(pathString)) {
          this.listens.set(pathString, new Map());
        }
        util.assert(query2._queryParams.isDefault() || !query2._queryParams.loadsAllData(), "listen() called for non-default but complete query");
        util.assert(!this.listens.get(pathString).has(queryId), "listen() called twice for same path/queryId.");
        var listenSpec = {
          onComplete,
          hashFn: currentHashFn,
          query: query2,
          tag
        };
        this.listens.get(pathString).set(queryId, listenSpec);
        if (this.connected_) {
          this.sendListen_(listenSpec);
        }
      };
      PersistentConnection2.prototype.sendGet_ = function(index2) {
        var _this = this;
        var get2 = this.outstandingGets_[index2];
        this.sendRequest("g", get2.request, function(message) {
          delete _this.outstandingGets_[index2];
          _this.outstandingGetCount_--;
          if (_this.outstandingGetCount_ === 0) {
            _this.outstandingGets_ = [];
          }
          if (get2.onComplete) {
            get2.onComplete(message);
          }
        });
      };
      PersistentConnection2.prototype.sendListen_ = function(listenSpec) {
        var _this = this;
        var query2 = listenSpec.query;
        var pathString = query2._path.toString();
        var queryId = query2._queryIdentifier;
        this.log_("Listen on " + pathString + " for " + queryId);
        var req = { p: pathString };
        var action = "q";
        if (listenSpec.tag) {
          req["q"] = query2._queryObject;
          req["t"] = listenSpec.tag;
        }
        req["h"] = listenSpec.hashFn();
        this.sendRequest(action, req, function(message) {
          var payload = message["d"];
          var status = message["s"];
          PersistentConnection2.warnOnListenWarnings_(payload, query2);
          var currentListenSpec = _this.listens.get(pathString) && _this.listens.get(pathString).get(queryId);
          if (currentListenSpec === listenSpec) {
            _this.log_("listen response", message);
            if (status !== "ok") {
              _this.removeListen_(pathString, queryId);
            }
            if (listenSpec.onComplete) {
              listenSpec.onComplete(status, payload);
            }
          }
        });
      };
      PersistentConnection2.warnOnListenWarnings_ = function(payload, query2) {
        if (payload && typeof payload === "object" && util.contains(payload, "w")) {
          var warnings = util.safeGet(payload, "w");
          if (Array.isArray(warnings) && ~warnings.indexOf("no_index")) {
            var indexSpec = '".indexOn": "' + query2._queryParams.getIndex().toString() + '"';
            var indexPath = query2._path.toString();
            warn("Using an unspecified index. Your data will be downloaded and " + ("filtered on the client. Consider adding " + indexSpec + " at ") + (indexPath + " to your security rules for better performance."));
          }
        }
      };
      PersistentConnection2.prototype.refreshAuthToken = function(token) {
        this.authToken_ = token;
        this.log_("Auth token refreshed");
        if (this.authToken_) {
          this.tryAuth();
        } else {
          if (this.connected_) {
            this.sendRequest("unauth", {}, function() {
            });
          }
        }
        this.reduceReconnectDelayIfAdminCredential_(token);
      };
      PersistentConnection2.prototype.reduceReconnectDelayIfAdminCredential_ = function(credential) {
        var isFirebaseSecret = credential && credential.length === 40;
        if (isFirebaseSecret || util.isAdmin(credential)) {
          this.log_("Admin auth credential detected.  Reducing max reconnect time.");
          this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
        }
      };
      PersistentConnection2.prototype.refreshAppCheckToken = function(token) {
        this.appCheckToken_ = token;
        this.log_("App check token refreshed");
        if (this.appCheckToken_) {
          this.tryAppCheck();
        } else {
          if (this.connected_) {
            this.sendRequest("unappeck", {}, function() {
            });
          }
        }
      };
      PersistentConnection2.prototype.tryAuth = function() {
        var _this = this;
        if (this.connected_ && this.authToken_) {
          var token_1 = this.authToken_;
          var authMethod = util.isValidFormat(token_1) ? "auth" : "gauth";
          var requestData = { cred: token_1 };
          if (this.authOverride_ === null) {
            requestData["noauth"] = true;
          } else if (typeof this.authOverride_ === "object") {
            requestData["authvar"] = this.authOverride_;
          }
          this.sendRequest(authMethod, requestData, function(res) {
            var status = res["s"];
            var data = res["d"] || "error";
            if (_this.authToken_ === token_1) {
              if (status === "ok") {
                _this.invalidAuthTokenCount_ = 0;
              } else {
                _this.onAuthRevoked_(status, data);
              }
            }
          });
        }
      };
      PersistentConnection2.prototype.tryAppCheck = function() {
        var _this = this;
        if (this.connected_ && this.appCheckToken_) {
          this.sendRequest("appcheck", { "token": this.appCheckToken_ }, function(res) {
            var status = res["s"];
            var data = res["d"] || "error";
            if (status === "ok") {
              _this.invalidAppCheckTokenCount_ = 0;
            } else {
              _this.onAppCheckRevoked_(status, data);
            }
          });
        }
      };
      PersistentConnection2.prototype.unlisten = function(query2, tag) {
        var pathString = query2._path.toString();
        var queryId = query2._queryIdentifier;
        this.log_("Unlisten called for " + pathString + " " + queryId);
        util.assert(query2._queryParams.isDefault() || !query2._queryParams.loadsAllData(), "unlisten() called for non-default but complete query");
        var listen = this.removeListen_(pathString, queryId);
        if (listen && this.connected_) {
          this.sendUnlisten_(pathString, queryId, query2._queryObject, tag);
        }
      };
      PersistentConnection2.prototype.sendUnlisten_ = function(pathString, queryId, queryObj, tag) {
        this.log_("Unlisten on " + pathString + " for " + queryId);
        var req = { p: pathString };
        var action = "n";
        if (tag) {
          req["q"] = queryObj;
          req["t"] = tag;
        }
        this.sendRequest(action, req);
      };
      PersistentConnection2.prototype.onDisconnectPut = function(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
          this.sendOnDisconnect_("o", pathString, data, onComplete);
        } else {
          this.onDisconnectRequestQueue_.push({
            pathString,
            action: "o",
            data,
            onComplete
          });
        }
      };
      PersistentConnection2.prototype.onDisconnectMerge = function(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
          this.sendOnDisconnect_("om", pathString, data, onComplete);
        } else {
          this.onDisconnectRequestQueue_.push({
            pathString,
            action: "om",
            data,
            onComplete
          });
        }
      };
      PersistentConnection2.prototype.onDisconnectCancel = function(pathString, onComplete) {
        this.initConnection_();
        if (this.connected_) {
          this.sendOnDisconnect_("oc", pathString, null, onComplete);
        } else {
          this.onDisconnectRequestQueue_.push({
            pathString,
            action: "oc",
            data: null,
            onComplete
          });
        }
      };
      PersistentConnection2.prototype.sendOnDisconnect_ = function(action, pathString, data, onComplete) {
        var request = { p: pathString, d: data };
        this.log_("onDisconnect " + action, request);
        this.sendRequest(action, request, function(response) {
          if (onComplete) {
            setTimeout(function() {
              onComplete(response["s"], response["d"]);
            }, Math.floor(0));
          }
        });
      };
      PersistentConnection2.prototype.put = function(pathString, data, onComplete, hash2) {
        this.putInternal("p", pathString, data, onComplete, hash2);
      };
      PersistentConnection2.prototype.merge = function(pathString, data, onComplete, hash2) {
        this.putInternal("m", pathString, data, onComplete, hash2);
      };
      PersistentConnection2.prototype.putInternal = function(action, pathString, data, onComplete, hash2) {
        this.initConnection_();
        var request = {
          p: pathString,
          d: data
        };
        if (hash2 !== void 0) {
          request["h"] = hash2;
        }
        this.outstandingPuts_.push({
          action,
          request,
          onComplete
        });
        this.outstandingPutCount_++;
        var index2 = this.outstandingPuts_.length - 1;
        if (this.connected_) {
          this.sendPut_(index2);
        } else {
          this.log_("Buffering put: " + pathString);
        }
      };
      PersistentConnection2.prototype.sendPut_ = function(index2) {
        var _this = this;
        var action = this.outstandingPuts_[index2].action;
        var request = this.outstandingPuts_[index2].request;
        var onComplete = this.outstandingPuts_[index2].onComplete;
        this.outstandingPuts_[index2].queued = this.connected_;
        this.sendRequest(action, request, function(message) {
          _this.log_(action + " response", message);
          delete _this.outstandingPuts_[index2];
          _this.outstandingPutCount_--;
          if (_this.outstandingPutCount_ === 0) {
            _this.outstandingPuts_ = [];
          }
          if (onComplete) {
            onComplete(message["s"], message["d"]);
          }
        });
      };
      PersistentConnection2.prototype.reportStats = function(stats2) {
        var _this = this;
        if (this.connected_) {
          var request = { c: stats2 };
          this.log_("reportStats", request);
          this.sendRequest("s", request, function(result) {
            var status = result["s"];
            if (status !== "ok") {
              var errorReason = result["d"];
              _this.log_("reportStats", "Error sending stats: " + errorReason);
            }
          });
        }
      };
      PersistentConnection2.prototype.onDataMessage_ = function(message) {
        if ("r" in message) {
          this.log_("from server: " + util.stringify(message));
          var reqNum = message["r"];
          var onResponse = this.requestCBHash_[reqNum];
          if (onResponse) {
            delete this.requestCBHash_[reqNum];
            onResponse(message["b"]);
          }
        } else if ("error" in message) {
          throw "A server-side error has occurred: " + message["error"];
        } else if ("a" in message) {
          this.onDataPush_(message["a"], message["b"]);
        }
      };
      PersistentConnection2.prototype.onDataPush_ = function(action, body) {
        this.log_("handleServerMessage", action, body);
        if (action === "d") {
          this.onDataUpdate_(body["p"], body["d"], false, body["t"]);
        } else if (action === "m") {
          this.onDataUpdate_(body["p"], body["d"], true, body["t"]);
        } else if (action === "c") {
          this.onListenRevoked_(body["p"], body["q"]);
        } else if (action === "ac") {
          this.onAuthRevoked_(body["s"], body["d"]);
        } else if (action === "apc") {
          this.onAppCheckRevoked_(body["s"], body["d"]);
        } else if (action === "sd") {
          this.onSecurityDebugPacket_(body);
        } else {
          error3("Unrecognized action received from server: " + util.stringify(action) + "\nAre you using the latest client?");
        }
      };
      PersistentConnection2.prototype.onReady_ = function(timestamp, sessionId) {
        this.log_("connection ready");
        this.connected_ = true;
        this.lastConnectionEstablishedTime_ = new Date().getTime();
        this.handleTimestamp_(timestamp);
        this.lastSessionId = sessionId;
        if (this.firstConnection_) {
          this.sendConnectStats_();
        }
        this.restoreState_();
        this.firstConnection_ = false;
        this.onConnectStatus_(true);
      };
      PersistentConnection2.prototype.scheduleConnect_ = function(timeout) {
        var _this = this;
        util.assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
        if (this.establishConnectionTimer_) {
          clearTimeout(this.establishConnectionTimer_);
        }
        this.establishConnectionTimer_ = setTimeout(function() {
          _this.establishConnectionTimer_ = null;
          _this.establishConnection_();
        }, Math.floor(timeout));
      };
      PersistentConnection2.prototype.initConnection_ = function() {
        if (!this.realtime_ && this.firstConnection_) {
          this.scheduleConnect_(0);
        }
      };
      PersistentConnection2.prototype.onVisible_ = function(visible) {
        if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {
          this.log_("Window became visible.  Reducing delay.");
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          if (!this.realtime_) {
            this.scheduleConnect_(0);
          }
        }
        this.visible_ = visible;
      };
      PersistentConnection2.prototype.onOnline_ = function(online) {
        if (online) {
          this.log_("Browser went online.");
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          if (!this.realtime_) {
            this.scheduleConnect_(0);
          }
        } else {
          this.log_("Browser went offline.  Killing connection.");
          if (this.realtime_) {
            this.realtime_.close();
          }
        }
      };
      PersistentConnection2.prototype.onRealtimeDisconnect_ = function() {
        this.log_("data client disconnected");
        this.connected_ = false;
        this.realtime_ = null;
        this.cancelSentTransactions_();
        this.requestCBHash_ = {};
        if (this.shouldReconnect_()) {
          if (!this.visible_) {
            this.log_("Window isn't visible.  Delaying reconnect.");
            this.reconnectDelay_ = this.maxReconnectDelay_;
            this.lastConnectionAttemptTime_ = new Date().getTime();
          } else if (this.lastConnectionEstablishedTime_) {
            var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
            if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {
              this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            }
            this.lastConnectionEstablishedTime_ = null;
          }
          var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
          var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
          reconnectDelay = Math.random() * reconnectDelay;
          this.log_("Trying to reconnect in " + reconnectDelay + "ms");
          this.scheduleConnect_(reconnectDelay);
          this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
        }
        this.onConnectStatus_(false);
      };
      PersistentConnection2.prototype.establishConnection_ = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var onDataMessage, onReady, onDisconnect_1, connId, lastSessionId, canceled_1, connection_1, closeFn, sendRequestFn, forceRefresh, _a, authToken, appCheckToken, error_1;
          var _this = this;
          return tslib.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!this.shouldReconnect_())
                  return [3, 4];
                this.log_("Making a connection attempt");
                this.lastConnectionAttemptTime_ = new Date().getTime();
                this.lastConnectionEstablishedTime_ = null;
                onDataMessage = this.onDataMessage_.bind(this);
                onReady = this.onReady_.bind(this);
                onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);
                connId = this.id + ":" + PersistentConnection2.nextConnectionId_++;
                lastSessionId = this.lastSessionId;
                canceled_1 = false;
                connection_1 = null;
                closeFn = function() {
                  if (connection_1) {
                    connection_1.close();
                  } else {
                    canceled_1 = true;
                    onDisconnect_1();
                  }
                };
                sendRequestFn = function(msg) {
                  util.assert(connection_1, "sendRequest call when we're not connected not allowed.");
                  connection_1.sendRequest(msg);
                };
                this.realtime_ = {
                  close: closeFn,
                  sendRequest: sendRequestFn
                };
                forceRefresh = this.forceTokenRefresh_;
                this.forceTokenRefresh_ = false;
                _b.label = 1;
              case 1:
                _b.trys.push([1, 3, , 4]);
                return [4, Promise.all([
                  this.authTokenProvider_.getToken(forceRefresh),
                  this.appCheckTokenProvider_.getToken(forceRefresh)
                ])];
              case 2:
                _a = tslib.__read.apply(void 0, [_b.sent(), 2]), authToken = _a[0], appCheckToken = _a[1];
                if (!canceled_1) {
                  log("getToken() completed. Creating connection.");
                  this.authToken_ = authToken && authToken.accessToken;
                  this.appCheckToken_ = appCheckToken && appCheckToken.token;
                  connection_1 = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect_1, function(reason) {
                    warn(reason + " (" + _this.repoInfo_.toString() + ")");
                    _this.interrupt(SERVER_KILL_INTERRUPT_REASON);
                  }, lastSessionId);
                } else {
                  log("getToken() completed but was canceled");
                }
                return [3, 4];
              case 3:
                error_1 = _b.sent();
                this.log_("Failed to get token: " + error_1);
                if (!canceled_1) {
                  if (this.repoInfo_.nodeAdmin) {
                    warn(error_1);
                  }
                  closeFn();
                }
                return [3, 4];
              case 4:
                return [2];
            }
          });
        });
      };
      PersistentConnection2.prototype.interrupt = function(reason) {
        log("Interrupting connection for reason: " + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) {
          this.realtime_.close();
        } else {
          if (this.establishConnectionTimer_) {
            clearTimeout(this.establishConnectionTimer_);
            this.establishConnectionTimer_ = null;
          }
          if (this.connected_) {
            this.onRealtimeDisconnect_();
          }
        }
      };
      PersistentConnection2.prototype.resume = function(reason) {
        log("Resuming connection for reason: " + reason);
        delete this.interruptReasons_[reason];
        if (util.isEmpty(this.interruptReasons_)) {
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          if (!this.realtime_) {
            this.scheduleConnect_(0);
          }
        }
      };
      PersistentConnection2.prototype.handleTimestamp_ = function(timestamp) {
        var delta = timestamp - new Date().getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: delta });
      };
      PersistentConnection2.prototype.cancelSentTransactions_ = function() {
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
          var put = this.outstandingPuts_[i];
          if (put && "h" in put.request && put.queued) {
            if (put.onComplete) {
              put.onComplete("disconnect");
            }
            delete this.outstandingPuts_[i];
            this.outstandingPutCount_--;
          }
        }
        if (this.outstandingPutCount_ === 0) {
          this.outstandingPuts_ = [];
        }
      };
      PersistentConnection2.prototype.onListenRevoked_ = function(pathString, query2) {
        var queryId;
        if (!query2) {
          queryId = "default";
        } else {
          queryId = query2.map(function(q) {
            return ObjectToUniqueKey(q);
          }).join("$");
        }
        var listen = this.removeListen_(pathString, queryId);
        if (listen && listen.onComplete) {
          listen.onComplete("permission_denied");
        }
      };
      PersistentConnection2.prototype.removeListen_ = function(pathString, queryId) {
        var normalizedPathString = new Path(pathString).toString();
        var listen;
        if (this.listens.has(normalizedPathString)) {
          var map = this.listens.get(normalizedPathString);
          listen = map.get(queryId);
          map.delete(queryId);
          if (map.size === 0) {
            this.listens.delete(normalizedPathString);
          }
        } else {
          listen = void 0;
        }
        return listen;
      };
      PersistentConnection2.prototype.onAuthRevoked_ = function(statusCode, explanation) {
        log("Auth token revoked: " + statusCode + "/" + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === "invalid_token" || statusCode === "permission_denied") {
          this.invalidAuthTokenCount_++;
          if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
            this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
            this.authTokenProvider_.notifyForInvalidToken();
          }
        }
      };
      PersistentConnection2.prototype.onAppCheckRevoked_ = function(statusCode, explanation) {
        log("App check token revoked: " + statusCode + "/" + explanation);
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = true;
        if (statusCode === "invalid_token" || statusCode === "permission_denied") {
          this.invalidAppCheckTokenCount_++;
          if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
            this.appCheckTokenProvider_.notifyForInvalidToken();
          }
        }
      };
      PersistentConnection2.prototype.onSecurityDebugPacket_ = function(body) {
        if (this.securityDebugCallback_) {
          this.securityDebugCallback_(body);
        } else {
          if ("msg" in body) {
            console.log("FIREBASE: " + body["msg"].replace("\n", "\nFIREBASE: "));
          }
        }
      };
      PersistentConnection2.prototype.restoreState_ = function() {
        var e_1, _a, e_2, _b;
        this.tryAuth();
        this.tryAppCheck();
        try {
          for (var _c = tslib.__values(this.listens.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var queries = _d.value;
            try {
              for (var _e = (e_2 = void 0, tslib.__values(queries.values())), _f = _e.next(); !_f.done; _f = _e.next()) {
                var listenSpec = _f.value;
                this.sendListen_(listenSpec);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_f && !_f.done && (_b = _e.return))
                  _b.call(_e);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return))
              _a.call(_c);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
          if (this.outstandingPuts_[i]) {
            this.sendPut_(i);
          }
        }
        while (this.onDisconnectRequestQueue_.length) {
          var request = this.onDisconnectRequestQueue_.shift();
          this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
        }
        for (var i = 0; i < this.outstandingGets_.length; i++) {
          if (this.outstandingGets_[i]) {
            this.sendGet_(i);
          }
        }
      };
      PersistentConnection2.prototype.sendConnectStats_ = function() {
        var stats2 = {};
        var clientName = "js";
        if (util.isNodeSdk()) {
          if (this.repoInfo_.nodeAdmin) {
            clientName = "admin_node";
          } else {
            clientName = "node";
          }
        }
        stats2["sdk." + clientName + "." + SDK_VERSION.replace(/\./g, "-")] = 1;
        if (util.isMobileCordova()) {
          stats2["framework.cordova"] = 1;
        } else if (util.isReactNative()) {
          stats2["framework.reactnative"] = 1;
        }
        this.reportStats(stats2);
      };
      PersistentConnection2.prototype.shouldReconnect_ = function() {
        var online = OnlineMonitor.getInstance().currentlyOnline();
        return util.isEmpty(this.interruptReasons_) && online;
      };
      PersistentConnection2.nextPersistentConnectionId_ = 0;
      PersistentConnection2.nextConnectionId_ = 0;
      return PersistentConnection2;
    }(ServerActions);
    var NamedNode = function() {
      function NamedNode2(name2, node) {
        this.name = name2;
        this.node = node;
      }
      NamedNode2.Wrap = function(name2, node) {
        return new NamedNode2(name2, node);
      };
      return NamedNode2;
    }();
    var Index = function() {
      function Index2() {
      }
      Index2.prototype.getCompare = function() {
        return this.compare.bind(this);
      };
      Index2.prototype.indexedValueChanged = function(oldNode, newNode) {
        var oldWrapped = new NamedNode(MIN_NAME, oldNode);
        var newWrapped = new NamedNode(MIN_NAME, newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
      };
      Index2.prototype.minPost = function() {
        return NamedNode.MIN;
      };
      return Index2;
    }();
    var __EMPTY_NODE;
    var KeyIndex = function(_super) {
      tslib.__extends(KeyIndex2, _super);
      function KeyIndex2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(KeyIndex2, "__EMPTY_NODE", {
        get: function() {
          return __EMPTY_NODE;
        },
        set: function(val) {
          __EMPTY_NODE = val;
        },
        enumerable: false,
        configurable: true
      });
      KeyIndex2.prototype.compare = function(a, b) {
        return nameCompare(a.name, b.name);
      };
      KeyIndex2.prototype.isDefinedOn = function(node) {
        throw util.assertionError("KeyIndex.isDefinedOn not expected to be called.");
      };
      KeyIndex2.prototype.indexedValueChanged = function(oldNode, newNode) {
        return false;
      };
      KeyIndex2.prototype.minPost = function() {
        return NamedNode.MIN;
      };
      KeyIndex2.prototype.maxPost = function() {
        return new NamedNode(MAX_NAME, __EMPTY_NODE);
      };
      KeyIndex2.prototype.makePost = function(indexValue, name2) {
        util.assert(typeof indexValue === "string", "KeyIndex indexValue must always be a string.");
        return new NamedNode(indexValue, __EMPTY_NODE);
      };
      KeyIndex2.prototype.toString = function() {
        return ".key";
      };
      return KeyIndex2;
    }(Index);
    var KEY_INDEX = new KeyIndex();
    var SortedMapIterator = function() {
      function SortedMapIterator2(node, startKey, comparator, isReverse_, resultGenerator_) {
        if (resultGenerator_ === void 0) {
          resultGenerator_ = null;
        }
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        this.nodeStack_ = [];
        var cmp = 1;
        while (!node.isEmpty()) {
          node = node;
          cmp = startKey ? comparator(node.key, startKey) : 1;
          if (isReverse_) {
            cmp *= -1;
          }
          if (cmp < 0) {
            if (this.isReverse_) {
              node = node.left;
            } else {
              node = node.right;
            }
          } else if (cmp === 0) {
            this.nodeStack_.push(node);
            break;
          } else {
            this.nodeStack_.push(node);
            if (this.isReverse_) {
              node = node.right;
            } else {
              node = node.left;
            }
          }
        }
      }
      SortedMapIterator2.prototype.getNext = function() {
        if (this.nodeStack_.length === 0) {
          return null;
        }
        var node = this.nodeStack_.pop();
        var result;
        if (this.resultGenerator_) {
          result = this.resultGenerator_(node.key, node.value);
        } else {
          result = { key: node.key, value: node.value };
        }
        if (this.isReverse_) {
          node = node.left;
          while (!node.isEmpty()) {
            this.nodeStack_.push(node);
            node = node.right;
          }
        } else {
          node = node.right;
          while (!node.isEmpty()) {
            this.nodeStack_.push(node);
            node = node.left;
          }
        }
        return result;
      };
      SortedMapIterator2.prototype.hasNext = function() {
        return this.nodeStack_.length > 0;
      };
      SortedMapIterator2.prototype.peek = function() {
        if (this.nodeStack_.length === 0) {
          return null;
        }
        var node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) {
          return this.resultGenerator_(node.key, node.value);
        } else {
          return { key: node.key, value: node.value };
        }
      };
      return SortedMapIterator2;
    }();
    var LLRBNode = function() {
      function LLRBNode2(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode2.RED;
        this.left = left != null ? left : SortedMap.EMPTY_NODE;
        this.right = right != null ? right : SortedMap.EMPTY_NODE;
      }
      LLRBNode2.prototype.copy = function(key, value, color, left, right) {
        return new LLRBNode2(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
      };
      LLRBNode2.prototype.count = function() {
        return this.left.count() + 1 + this.right.count();
      };
      LLRBNode2.prototype.isEmpty = function() {
        return false;
      };
      LLRBNode2.prototype.inorderTraversal = function(action) {
        return this.left.inorderTraversal(action) || !!action(this.key, this.value) || this.right.inorderTraversal(action);
      };
      LLRBNode2.prototype.reverseTraversal = function(action) {
        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
      };
      LLRBNode2.prototype.min_ = function() {
        if (this.left.isEmpty()) {
          return this;
        } else {
          return this.left.min_();
        }
      };
      LLRBNode2.prototype.minKey = function() {
        return this.min_().key;
      };
      LLRBNode2.prototype.maxKey = function() {
        if (this.right.isEmpty()) {
          return this.key;
        } else {
          return this.right.maxKey();
        }
      };
      LLRBNode2.prototype.insert = function(key, value, comparator) {
        var n = this;
        var cmp = comparator(key, n.key);
        if (cmp < 0) {
          n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        } else if (cmp === 0) {
          n = n.copy(null, value, null, null, null);
        } else {
          n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp_();
      };
      LLRBNode2.prototype.removeMin_ = function() {
        if (this.left.isEmpty()) {
          return SortedMap.EMPTY_NODE;
        }
        var n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_()) {
          n = n.moveRedLeft_();
        }
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
      };
      LLRBNode2.prototype.remove = function(key, comparator) {
        var n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) {
          if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
            n = n.moveRedLeft_();
          }
          n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        } else {
          if (n.left.isRed_()) {
            n = n.rotateRight_();
          }
          if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
            n = n.moveRedRight_();
          }
          if (comparator(key, n.key) === 0) {
            if (n.right.isEmpty()) {
              return SortedMap.EMPTY_NODE;
            } else {
              smallest = n.right.min_();
              n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
            }
          }
          n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp_();
      };
      LLRBNode2.prototype.isRed_ = function() {
        return this.color;
      };
      LLRBNode2.prototype.fixUp_ = function() {
        var n = this;
        if (n.right.isRed_() && !n.left.isRed_()) {
          n = n.rotateLeft_();
        }
        if (n.left.isRed_() && n.left.left.isRed_()) {
          n = n.rotateRight_();
        }
        if (n.left.isRed_() && n.right.isRed_()) {
          n = n.colorFlip_();
        }
        return n;
      };
      LLRBNode2.prototype.moveRedLeft_ = function() {
        var n = this.colorFlip_();
        if (n.right.left.isRed_()) {
          n = n.copy(null, null, null, null, n.right.rotateRight_());
          n = n.rotateLeft_();
          n = n.colorFlip_();
        }
        return n;
      };
      LLRBNode2.prototype.moveRedRight_ = function() {
        var n = this.colorFlip_();
        if (n.left.left.isRed_()) {
          n = n.rotateRight_();
          n = n.colorFlip_();
        }
        return n;
      };
      LLRBNode2.prototype.rotateLeft_ = function() {
        var nl = this.copy(null, null, LLRBNode2.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
      };
      LLRBNode2.prototype.rotateRight_ = function() {
        var nr = this.copy(null, null, LLRBNode2.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
      };
      LLRBNode2.prototype.colorFlip_ = function() {
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
      };
      LLRBNode2.prototype.checkMaxDepth_ = function() {
        var blackDepth = this.check_();
        return Math.pow(2, blackDepth) <= this.count() + 1;
      };
      LLRBNode2.prototype.check_ = function() {
        if (this.isRed_() && this.left.isRed_()) {
          throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
        }
        if (this.right.isRed_()) {
          throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
        }
        var blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) {
          throw new Error("Black depths differ");
        } else {
          return blackDepth + (this.isRed_() ? 0 : 1);
        }
      };
      LLRBNode2.RED = true;
      LLRBNode2.BLACK = false;
      return LLRBNode2;
    }();
    var LLRBEmptyNode = function() {
      function LLRBEmptyNode2() {
      }
      LLRBEmptyNode2.prototype.copy = function(key, value, color, left, right) {
        return this;
      };
      LLRBEmptyNode2.prototype.insert = function(key, value, comparator) {
        return new LLRBNode(key, value, null);
      };
      LLRBEmptyNode2.prototype.remove = function(key, comparator) {
        return this;
      };
      LLRBEmptyNode2.prototype.count = function() {
        return 0;
      };
      LLRBEmptyNode2.prototype.isEmpty = function() {
        return true;
      };
      LLRBEmptyNode2.prototype.inorderTraversal = function(action) {
        return false;
      };
      LLRBEmptyNode2.prototype.reverseTraversal = function(action) {
        return false;
      };
      LLRBEmptyNode2.prototype.minKey = function() {
        return null;
      };
      LLRBEmptyNode2.prototype.maxKey = function() {
        return null;
      };
      LLRBEmptyNode2.prototype.check_ = function() {
        return 0;
      };
      LLRBEmptyNode2.prototype.isRed_ = function() {
        return false;
      };
      return LLRBEmptyNode2;
    }();
    var SortedMap = function() {
      function SortedMap2(comparator_, root_) {
        if (root_ === void 0) {
          root_ = SortedMap2.EMPTY_NODE;
        }
        this.comparator_ = comparator_;
        this.root_ = root_;
      }
      SortedMap2.prototype.insert = function(key, value) {
        return new SortedMap2(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
      };
      SortedMap2.prototype.remove = function(key) {
        return new SortedMap2(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
      };
      SortedMap2.prototype.get = function(key) {
        var cmp;
        var node = this.root_;
        while (!node.isEmpty()) {
          cmp = this.comparator_(key, node.key);
          if (cmp === 0) {
            return node.value;
          } else if (cmp < 0) {
            node = node.left;
          } else if (cmp > 0) {
            node = node.right;
          }
        }
        return null;
      };
      SortedMap2.prototype.getPredecessorKey = function(key) {
        var cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) {
          cmp = this.comparator_(key, node.key);
          if (cmp === 0) {
            if (!node.left.isEmpty()) {
              node = node.left;
              while (!node.right.isEmpty()) {
                node = node.right;
              }
              return node.key;
            } else if (rightParent) {
              return rightParent.key;
            } else {
              return null;
            }
          } else if (cmp < 0) {
            node = node.left;
          } else if (cmp > 0) {
            rightParent = node;
            node = node.right;
          }
        }
        throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?");
      };
      SortedMap2.prototype.isEmpty = function() {
        return this.root_.isEmpty();
      };
      SortedMap2.prototype.count = function() {
        return this.root_.count();
      };
      SortedMap2.prototype.minKey = function() {
        return this.root_.minKey();
      };
      SortedMap2.prototype.maxKey = function() {
        return this.root_.maxKey();
      };
      SortedMap2.prototype.inorderTraversal = function(action) {
        return this.root_.inorderTraversal(action);
      };
      SortedMap2.prototype.reverseTraversal = function(action) {
        return this.root_.reverseTraversal(action);
      };
      SortedMap2.prototype.getIterator = function(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
      };
      SortedMap2.prototype.getIteratorFrom = function(key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
      };
      SortedMap2.prototype.getReverseIteratorFrom = function(key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
      };
      SortedMap2.prototype.getReverseIterator = function(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
      };
      SortedMap2.EMPTY_NODE = new LLRBEmptyNode();
      return SortedMap2;
    }();
    function NAME_ONLY_COMPARATOR(left, right) {
      return nameCompare(left.name, right.name);
    }
    function NAME_COMPARATOR(left, right) {
      return nameCompare(left, right);
    }
    var MAX_NODE$2;
    function setMaxNode$1(val) {
      MAX_NODE$2 = val;
    }
    var priorityHashText = function(priority) {
      if (typeof priority === "number") {
        return "number:" + doubleToIEEE754String(priority);
      } else {
        return "string:" + priority;
      }
    };
    var validatePriorityNode = function(priorityNode) {
      if (priorityNode.isLeafNode()) {
        var val = priorityNode.val();
        util.assert(typeof val === "string" || typeof val === "number" || typeof val === "object" && util.contains(val, ".sv"), "Priority must be a string or number.");
      } else {
        util.assert(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), "priority of unexpected type.");
      }
      util.assert(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
    };
    var __childrenNodeConstructor;
    var LeafNode = function() {
      function LeafNode2(value_, priorityNode_) {
        if (priorityNode_ === void 0) {
          priorityNode_ = LeafNode2.__childrenNodeConstructor.EMPTY_NODE;
        }
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        util.assert(this.value_ !== void 0 && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        validatePriorityNode(this.priorityNode_);
      }
      Object.defineProperty(LeafNode2, "__childrenNodeConstructor", {
        get: function() {
          return __childrenNodeConstructor;
        },
        set: function(val) {
          __childrenNodeConstructor = val;
        },
        enumerable: false,
        configurable: true
      });
      LeafNode2.prototype.isLeafNode = function() {
        return true;
      };
      LeafNode2.prototype.getPriority = function() {
        return this.priorityNode_;
      };
      LeafNode2.prototype.updatePriority = function(newPriorityNode) {
        return new LeafNode2(this.value_, newPriorityNode);
      };
      LeafNode2.prototype.getImmediateChild = function(childName) {
        if (childName === ".priority") {
          return this.priorityNode_;
        } else {
          return LeafNode2.__childrenNodeConstructor.EMPTY_NODE;
        }
      };
      LeafNode2.prototype.getChild = function(path) {
        if (pathIsEmpty(path)) {
          return this;
        } else if (pathGetFront(path) === ".priority") {
          return this.priorityNode_;
        } else {
          return LeafNode2.__childrenNodeConstructor.EMPTY_NODE;
        }
      };
      LeafNode2.prototype.hasChild = function() {
        return false;
      };
      LeafNode2.prototype.getPredecessorChildName = function(childName, childNode) {
        return null;
      };
      LeafNode2.prototype.updateImmediateChild = function(childName, newChildNode) {
        if (childName === ".priority") {
          return this.updatePriority(newChildNode);
        } else if (newChildNode.isEmpty() && childName !== ".priority") {
          return this;
        } else {
          return LeafNode2.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
        }
      };
      LeafNode2.prototype.updateChild = function(path, newChildNode) {
        var front = pathGetFront(path);
        if (front === null) {
          return newChildNode;
        } else if (newChildNode.isEmpty() && front !== ".priority") {
          return this;
        } else {
          util.assert(front !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
          return this.updateImmediateChild(front, LeafNode2.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));
        }
      };
      LeafNode2.prototype.isEmpty = function() {
        return false;
      };
      LeafNode2.prototype.numChildren = function() {
        return 0;
      };
      LeafNode2.prototype.forEachChild = function(index2, action) {
        return false;
      };
      LeafNode2.prototype.val = function(exportFormat) {
        if (exportFormat && !this.getPriority().isEmpty()) {
          return {
            ".value": this.getValue(),
            ".priority": this.getPriority().val()
          };
        } else {
          return this.getValue();
        }
      };
      LeafNode2.prototype.hash = function() {
        if (this.lazyHash_ === null) {
          var toHash = "";
          if (!this.priorityNode_.isEmpty()) {
            toHash += "priority:" + priorityHashText(this.priorityNode_.val()) + ":";
          }
          var type = typeof this.value_;
          toHash += type + ":";
          if (type === "number") {
            toHash += doubleToIEEE754String(this.value_);
          } else {
            toHash += this.value_;
          }
          this.lazyHash_ = sha1(toHash);
        }
        return this.lazyHash_;
      };
      LeafNode2.prototype.getValue = function() {
        return this.value_;
      };
      LeafNode2.prototype.compareTo = function(other) {
        if (other === LeafNode2.__childrenNodeConstructor.EMPTY_NODE) {
          return 1;
        } else if (other instanceof LeafNode2.__childrenNodeConstructor) {
          return -1;
        } else {
          util.assert(other.isLeafNode(), "Unknown node type");
          return this.compareToLeafNode_(other);
        }
      };
      LeafNode2.prototype.compareToLeafNode_ = function(otherLeaf) {
        var otherLeafType = typeof otherLeaf.value_;
        var thisLeafType = typeof this.value_;
        var otherIndex = LeafNode2.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        var thisIndex = LeafNode2.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        util.assert(otherIndex >= 0, "Unknown leaf type: " + otherLeafType);
        util.assert(thisIndex >= 0, "Unknown leaf type: " + thisLeafType);
        if (otherIndex === thisIndex) {
          if (thisLeafType === "object") {
            return 0;
          } else {
            if (this.value_ < otherLeaf.value_) {
              return -1;
            } else if (this.value_ === otherLeaf.value_) {
              return 0;
            } else {
              return 1;
            }
          }
        } else {
          return thisIndex - otherIndex;
        }
      };
      LeafNode2.prototype.withIndex = function() {
        return this;
      };
      LeafNode2.prototype.isIndexed = function() {
        return true;
      };
      LeafNode2.prototype.equals = function(other) {
        if (other === this) {
          return true;
        } else if (other.isLeafNode()) {
          var otherLeaf = other;
          return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);
        } else {
          return false;
        }
      };
      LeafNode2.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
      return LeafNode2;
    }();
    var nodeFromJSON$1;
    var MAX_NODE$1;
    function setNodeFromJSON(val) {
      nodeFromJSON$1 = val;
    }
    function setMaxNode(val) {
      MAX_NODE$1 = val;
    }
    var PriorityIndex = function(_super) {
      tslib.__extends(PriorityIndex2, _super);
      function PriorityIndex2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PriorityIndex2.prototype.compare = function(a, b) {
        var aPriority = a.node.getPriority();
        var bPriority = b.node.getPriority();
        var indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) {
          return nameCompare(a.name, b.name);
        } else {
          return indexCmp;
        }
      };
      PriorityIndex2.prototype.isDefinedOn = function(node) {
        return !node.getPriority().isEmpty();
      };
      PriorityIndex2.prototype.indexedValueChanged = function(oldNode, newNode) {
        return !oldNode.getPriority().equals(newNode.getPriority());
      };
      PriorityIndex2.prototype.minPost = function() {
        return NamedNode.MIN;
      };
      PriorityIndex2.prototype.maxPost = function() {
        return new NamedNode(MAX_NAME, new LeafNode("[PRIORITY-POST]", MAX_NODE$1));
      };
      PriorityIndex2.prototype.makePost = function(indexValue, name2) {
        var priorityNode = nodeFromJSON$1(indexValue);
        return new NamedNode(name2, new LeafNode("[PRIORITY-POST]", priorityNode));
      };
      PriorityIndex2.prototype.toString = function() {
        return ".priority";
      };
      return PriorityIndex2;
    }(Index);
    var PRIORITY_INDEX = new PriorityIndex();
    var LOG_2 = Math.log(2);
    var Base12Num = function() {
      function Base12Num2(length) {
        var logBase2 = function(num) {
          return parseInt(Math.log(num) / LOG_2, 10);
        };
        var bitMask = function(bits) {
          return parseInt(Array(bits + 1).join("1"), 2);
        };
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        var mask = bitMask(this.count);
        this.bits_ = length + 1 & mask;
      }
      Base12Num2.prototype.nextBitIsOne = function() {
        var result = !(this.bits_ & 1 << this.current_);
        this.current_--;
        return result;
      };
      return Base12Num2;
    }();
    var buildChildSet = function(childList, cmp, keyFn, mapSortFn) {
      childList.sort(cmp);
      var buildBalancedTree = function(low, high) {
        var length = high - low;
        var namedNode;
        var key;
        if (length === 0) {
          return null;
        } else if (length === 1) {
          namedNode = childList[low];
          key = keyFn ? keyFn(namedNode) : namedNode;
          return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
        } else {
          var middle = parseInt(length / 2, 10) + low;
          var left = buildBalancedTree(low, middle);
          var right = buildBalancedTree(middle + 1, high);
          namedNode = childList[middle];
          key = keyFn ? keyFn(namedNode) : namedNode;
          return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
        }
      };
      var buildFrom12Array = function(base122) {
        var node = null;
        var root2 = null;
        var index2 = childList.length;
        var buildPennant = function(chunkSize2, color) {
          var low = index2 - chunkSize2;
          var high = index2;
          index2 -= chunkSize2;
          var childTree = buildBalancedTree(low + 1, high);
          var namedNode = childList[low];
          var key = keyFn ? keyFn(namedNode) : namedNode;
          attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
        };
        var attachPennant = function(pennant) {
          if (node) {
            node.left = pennant;
            node = pennant;
          } else {
            root2 = pennant;
            node = pennant;
          }
        };
        for (var i = 0; i < base122.count; ++i) {
          var isOne = base122.nextBitIsOne();
          var chunkSize = Math.pow(2, base122.count - (i + 1));
          if (isOne) {
            buildPennant(chunkSize, LLRBNode.BLACK);
          } else {
            buildPennant(chunkSize, LLRBNode.BLACK);
            buildPennant(chunkSize, LLRBNode.RED);
          }
        }
        return root2;
      };
      var base12 = new Base12Num(childList.length);
      var root = buildFrom12Array(base12);
      return new SortedMap(mapSortFn || cmp, root);
    };
    var _defaultIndexMap;
    var fallbackObject = {};
    var IndexMap = function() {
      function IndexMap2(indexes_, indexSet_) {
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
      }
      Object.defineProperty(IndexMap2, "Default", {
        get: function() {
          util.assert(fallbackObject && PRIORITY_INDEX, "ChildrenNode.ts has not been loaded");
          _defaultIndexMap = _defaultIndexMap || new IndexMap2({ ".priority": fallbackObject }, { ".priority": PRIORITY_INDEX });
          return _defaultIndexMap;
        },
        enumerable: false,
        configurable: true
      });
      IndexMap2.prototype.get = function(indexKey) {
        var sortedMap = util.safeGet(this.indexes_, indexKey);
        if (!sortedMap) {
          throw new Error("No index defined for " + indexKey);
        }
        if (sortedMap instanceof SortedMap) {
          return sortedMap;
        } else {
          return null;
        }
      };
      IndexMap2.prototype.hasIndex = function(indexDefinition) {
        return util.contains(this.indexSet_, indexDefinition.toString());
      };
      IndexMap2.prototype.addIndex = function(indexDefinition, existingChildren) {
        util.assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        var childList = [];
        var sawIndexedValue = false;
        var iter = existingChildren.getIterator(NamedNode.Wrap);
        var next = iter.getNext();
        while (next) {
          sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);
          childList.push(next);
          next = iter.getNext();
        }
        var newIndex;
        if (sawIndexedValue) {
          newIndex = buildChildSet(childList, indexDefinition.getCompare());
        } else {
          newIndex = fallbackObject;
        }
        var indexName = indexDefinition.toString();
        var newIndexSet = tslib.__assign({}, this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        var newIndexes = tslib.__assign({}, this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap2(newIndexes, newIndexSet);
      };
      IndexMap2.prototype.addToIndexes = function(namedNode, existingChildren) {
        var _this = this;
        var newIndexes = util.map(this.indexes_, function(indexedChildren, indexName) {
          var index2 = util.safeGet(_this.indexSet_, indexName);
          util.assert(index2, "Missing index implementation for " + indexName);
          if (indexedChildren === fallbackObject) {
            if (index2.isDefinedOn(namedNode.node)) {
              var childList = [];
              var iter = existingChildren.getIterator(NamedNode.Wrap);
              var next = iter.getNext();
              while (next) {
                if (next.name !== namedNode.name) {
                  childList.push(next);
                }
                next = iter.getNext();
              }
              childList.push(namedNode);
              return buildChildSet(childList, index2.getCompare());
            } else {
              return fallbackObject;
            }
          } else {
            var existingSnap = existingChildren.get(namedNode.name);
            var newChildren = indexedChildren;
            if (existingSnap) {
              newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
            }
            return newChildren.insert(namedNode, namedNode.node);
          }
        });
        return new IndexMap2(newIndexes, this.indexSet_);
      };
      IndexMap2.prototype.removeFromIndexes = function(namedNode, existingChildren) {
        var newIndexes = util.map(this.indexes_, function(indexedChildren) {
          if (indexedChildren === fallbackObject) {
            return indexedChildren;
          } else {
            var existingSnap = existingChildren.get(namedNode.name);
            if (existingSnap) {
              return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
            } else {
              return indexedChildren;
            }
          }
        });
        return new IndexMap2(newIndexes, this.indexSet_);
      };
      return IndexMap2;
    }();
    var EMPTY_NODE;
    var ChildrenNode = function() {
      function ChildrenNode2(children_, priorityNode_, indexMap_) {
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        if (this.priorityNode_) {
          validatePriorityNode(this.priorityNode_);
        }
        if (this.children_.isEmpty()) {
          util.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority");
        }
      }
      Object.defineProperty(ChildrenNode2, "EMPTY_NODE", {
        get: function() {
          return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode2(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));
        },
        enumerable: false,
        configurable: true
      });
      ChildrenNode2.prototype.isLeafNode = function() {
        return false;
      };
      ChildrenNode2.prototype.getPriority = function() {
        return this.priorityNode_ || EMPTY_NODE;
      };
      ChildrenNode2.prototype.updatePriority = function(newPriorityNode) {
        if (this.children_.isEmpty()) {
          return this;
        } else {
          return new ChildrenNode2(this.children_, newPriorityNode, this.indexMap_);
        }
      };
      ChildrenNode2.prototype.getImmediateChild = function(childName) {
        if (childName === ".priority") {
          return this.getPriority();
        } else {
          var child2 = this.children_.get(childName);
          return child2 === null ? EMPTY_NODE : child2;
        }
      };
      ChildrenNode2.prototype.getChild = function(path) {
        var front = pathGetFront(path);
        if (front === null) {
          return this;
        }
        return this.getImmediateChild(front).getChild(pathPopFront(path));
      };
      ChildrenNode2.prototype.hasChild = function(childName) {
        return this.children_.get(childName) !== null;
      };
      ChildrenNode2.prototype.updateImmediateChild = function(childName, newChildNode) {
        util.assert(newChildNode, "We should always be passing snapshot nodes");
        if (childName === ".priority") {
          return this.updatePriority(newChildNode);
        } else {
          var namedNode = new NamedNode(childName, newChildNode);
          var newChildren = void 0, newIndexMap = void 0;
          if (newChildNode.isEmpty()) {
            newChildren = this.children_.remove(childName);
            newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
          } else {
            newChildren = this.children_.insert(childName, newChildNode);
            newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
          }
          var newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
          return new ChildrenNode2(newChildren, newPriority, newIndexMap);
        }
      };
      ChildrenNode2.prototype.updateChild = function(path, newChildNode) {
        var front = pathGetFront(path);
        if (front === null) {
          return newChildNode;
        } else {
          util.assert(pathGetFront(path) !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
          var newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);
          return this.updateImmediateChild(front, newImmediateChild);
        }
      };
      ChildrenNode2.prototype.isEmpty = function() {
        return this.children_.isEmpty();
      };
      ChildrenNode2.prototype.numChildren = function() {
        return this.children_.count();
      };
      ChildrenNode2.prototype.val = function(exportFormat) {
        if (this.isEmpty()) {
          return null;
        }
        var obj = {};
        var numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PRIORITY_INDEX, function(key2, childNode) {
          obj[key2] = childNode.val(exportFormat);
          numKeys++;
          if (allIntegerKeys && ChildrenNode2.INTEGER_REGEXP_.test(key2)) {
            maxKey = Math.max(maxKey, Number(key2));
          } else {
            allIntegerKeys = false;
          }
        });
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
          var array = [];
          for (var key in obj) {
            array[key] = obj[key];
          }
          return array;
        } else {
          if (exportFormat && !this.getPriority().isEmpty()) {
            obj[".priority"] = this.getPriority().val();
          }
          return obj;
        }
      };
      ChildrenNode2.prototype.hash = function() {
        if (this.lazyHash_ === null) {
          var toHash_1 = "";
          if (!this.getPriority().isEmpty()) {
            toHash_1 += "priority:" + priorityHashText(this.getPriority().val()) + ":";
          }
          this.forEachChild(PRIORITY_INDEX, function(key, childNode) {
            var childHash = childNode.hash();
            if (childHash !== "") {
              toHash_1 += ":" + key + ":" + childHash;
            }
          });
          this.lazyHash_ = toHash_1 === "" ? "" : sha1(toHash_1);
        }
        return this.lazyHash_;
      };
      ChildrenNode2.prototype.getPredecessorChildName = function(childName, childNode, index2) {
        var idx = this.resolveIndex_(index2);
        if (idx) {
          var predecessor2 = idx.getPredecessorKey(new NamedNode(childName, childNode));
          return predecessor2 ? predecessor2.name : null;
        } else {
          return this.children_.getPredecessorKey(childName);
        }
      };
      ChildrenNode2.prototype.getFirstChildName = function(indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          var minKey = idx.minKey();
          return minKey && minKey.name;
        } else {
          return this.children_.minKey();
        }
      };
      ChildrenNode2.prototype.getFirstChild = function(indexDefinition) {
        var minKey = this.getFirstChildName(indexDefinition);
        if (minKey) {
          return new NamedNode(minKey, this.children_.get(minKey));
        } else {
          return null;
        }
      };
      ChildrenNode2.prototype.getLastChildName = function(indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          var maxKey = idx.maxKey();
          return maxKey && maxKey.name;
        } else {
          return this.children_.maxKey();
        }
      };
      ChildrenNode2.prototype.getLastChild = function(indexDefinition) {
        var maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) {
          return new NamedNode(maxKey, this.children_.get(maxKey));
        } else {
          return null;
        }
      };
      ChildrenNode2.prototype.forEachChild = function(index2, action) {
        var idx = this.resolveIndex_(index2);
        if (idx) {
          return idx.inorderTraversal(function(wrappedNode) {
            return action(wrappedNode.name, wrappedNode.node);
          });
        } else {
          return this.children_.inorderTraversal(action);
        }
      };
      ChildrenNode2.prototype.getIterator = function(indexDefinition) {
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
      };
      ChildrenNode2.prototype.getIteratorFrom = function(startPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          return idx.getIteratorFrom(startPost, function(key) {
            return key;
          });
        } else {
          var iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
          var next = iterator.peek();
          while (next != null && indexDefinition.compare(next, startPost) < 0) {
            iterator.getNext();
            next = iterator.peek();
          }
          return iterator;
        }
      };
      ChildrenNode2.prototype.getReverseIterator = function(indexDefinition) {
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
      };
      ChildrenNode2.prototype.getReverseIteratorFrom = function(endPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          return idx.getReverseIteratorFrom(endPost, function(key) {
            return key;
          });
        } else {
          var iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
          var next = iterator.peek();
          while (next != null && indexDefinition.compare(next, endPost) > 0) {
            iterator.getNext();
            next = iterator.peek();
          }
          return iterator;
        }
      };
      ChildrenNode2.prototype.compareTo = function(other) {
        if (this.isEmpty()) {
          if (other.isEmpty()) {
            return 0;
          } else {
            return -1;
          }
        } else if (other.isLeafNode() || other.isEmpty()) {
          return 1;
        } else if (other === MAX_NODE) {
          return -1;
        } else {
          return 0;
        }
      };
      ChildrenNode2.prototype.withIndex = function(indexDefinition) {
        if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {
          return this;
        } else {
          var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
          return new ChildrenNode2(this.children_, this.priorityNode_, newIndexMap);
        }
      };
      ChildrenNode2.prototype.isIndexed = function(index2) {
        return index2 === KEY_INDEX || this.indexMap_.hasIndex(index2);
      };
      ChildrenNode2.prototype.equals = function(other) {
        if (other === this) {
          return true;
        } else if (other.isLeafNode()) {
          return false;
        } else {
          var otherChildrenNode = other;
          if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
            return false;
          } else if (this.children_.count() === otherChildrenNode.children_.count()) {
            var thisIter = this.getIterator(PRIORITY_INDEX);
            var otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
            var thisCurrent = thisIter.getNext();
            var otherCurrent = otherIter.getNext();
            while (thisCurrent && otherCurrent) {
              if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {
                return false;
              }
              thisCurrent = thisIter.getNext();
              otherCurrent = otherIter.getNext();
            }
            return thisCurrent === null && otherCurrent === null;
          } else {
            return false;
          }
        }
      };
      ChildrenNode2.prototype.resolveIndex_ = function(indexDefinition) {
        if (indexDefinition === KEY_INDEX) {
          return null;
        } else {
          return this.indexMap_.get(indexDefinition.toString());
        }
      };
      ChildrenNode2.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
      return ChildrenNode2;
    }();
    var MaxNode = function(_super) {
      tslib.__extends(MaxNode2, _super);
      function MaxNode2() {
        return _super.call(this, new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default) || this;
      }
      MaxNode2.prototype.compareTo = function(other) {
        if (other === this) {
          return 0;
        } else {
          return 1;
        }
      };
      MaxNode2.prototype.equals = function(other) {
        return other === this;
      };
      MaxNode2.prototype.getPriority = function() {
        return this;
      };
      MaxNode2.prototype.getImmediateChild = function(childName) {
        return ChildrenNode.EMPTY_NODE;
      };
      MaxNode2.prototype.isEmpty = function() {
        return false;
      };
      return MaxNode2;
    }(ChildrenNode);
    var MAX_NODE = new MaxNode();
    Object.defineProperties(NamedNode, {
      MIN: {
        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
      },
      MAX: {
        value: new NamedNode(MAX_NAME, MAX_NODE)
      }
    });
    KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
    LeafNode.__childrenNodeConstructor = ChildrenNode;
    setMaxNode$1(MAX_NODE);
    setMaxNode(MAX_NODE);
    var USE_HINZE = true;
    function nodeFromJSON(json, priority) {
      if (priority === void 0) {
        priority = null;
      }
      if (json === null) {
        return ChildrenNode.EMPTY_NODE;
      }
      if (typeof json === "object" && ".priority" in json) {
        priority = json[".priority"];
      }
      util.assert(priority === null || typeof priority === "string" || typeof priority === "number" || typeof priority === "object" && ".sv" in priority, "Invalid priority type found: " + typeof priority);
      if (typeof json === "object" && ".value" in json && json[".value"] !== null) {
        json = json[".value"];
      }
      if (typeof json !== "object" || ".sv" in json) {
        var jsonLeaf = json;
        return new LeafNode(jsonLeaf, nodeFromJSON(priority));
      }
      if (!(json instanceof Array) && USE_HINZE) {
        var children_1 = [];
        var childrenHavePriority_1 = false;
        var hinzeJsonObj = json;
        each2(hinzeJsonObj, function(key, child2) {
          if (key.substring(0, 1) !== ".") {
            var childNode = nodeFromJSON(child2);
            if (!childNode.isEmpty()) {
              childrenHavePriority_1 = childrenHavePriority_1 || !childNode.getPriority().isEmpty();
              children_1.push(new NamedNode(key, childNode));
            }
          }
        });
        if (children_1.length === 0) {
          return ChildrenNode.EMPTY_NODE;
        }
        var childSet = buildChildSet(children_1, NAME_ONLY_COMPARATOR, function(namedNode) {
          return namedNode.name;
        }, NAME_COMPARATOR);
        if (childrenHavePriority_1) {
          var sortedChildSet = buildChildSet(children_1, PRIORITY_INDEX.getCompare());
          return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({ ".priority": sortedChildSet }, { ".priority": PRIORITY_INDEX }));
        } else {
          return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);
        }
      } else {
        var node_1 = ChildrenNode.EMPTY_NODE;
        each2(json, function(key, childData) {
          if (util.contains(json, key)) {
            if (key.substring(0, 1) !== ".") {
              var childNode = nodeFromJSON(childData);
              if (childNode.isLeafNode() || !childNode.isEmpty()) {
                node_1 = node_1.updateImmediateChild(key, childNode);
              }
            }
          }
        });
        return node_1.updatePriority(nodeFromJSON(priority));
      }
    }
    setNodeFromJSON(nodeFromJSON);
    var PathIndex = function(_super) {
      tslib.__extends(PathIndex2, _super);
      function PathIndex2(indexPath_) {
        var _this = _super.call(this) || this;
        _this.indexPath_ = indexPath_;
        util.assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== ".priority", "Can't create PathIndex with empty path or .priority key");
        return _this;
      }
      PathIndex2.prototype.extractChild = function(snap) {
        return snap.getChild(this.indexPath_);
      };
      PathIndex2.prototype.isDefinedOn = function(node) {
        return !node.getChild(this.indexPath_).isEmpty();
      };
      PathIndex2.prototype.compare = function(a, b) {
        var aChild = this.extractChild(a.node);
        var bChild = this.extractChild(b.node);
        var indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) {
          return nameCompare(a.name, b.name);
        } else {
          return indexCmp;
        }
      };
      PathIndex2.prototype.makePost = function(indexValue, name2) {
        var valueNode = nodeFromJSON(indexValue);
        var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new NamedNode(name2, node);
      };
      PathIndex2.prototype.maxPost = function() {
        var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
        return new NamedNode(MAX_NAME, node);
      };
      PathIndex2.prototype.toString = function() {
        return pathSlice(this.indexPath_, 0).join("/");
      };
      return PathIndex2;
    }(Index);
    var ValueIndex = function(_super) {
      tslib.__extends(ValueIndex2, _super);
      function ValueIndex2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ValueIndex2.prototype.compare = function(a, b) {
        var indexCmp = a.node.compareTo(b.node);
        if (indexCmp === 0) {
          return nameCompare(a.name, b.name);
        } else {
          return indexCmp;
        }
      };
      ValueIndex2.prototype.isDefinedOn = function(node) {
        return true;
      };
      ValueIndex2.prototype.indexedValueChanged = function(oldNode, newNode) {
        return !oldNode.equals(newNode);
      };
      ValueIndex2.prototype.minPost = function() {
        return NamedNode.MIN;
      };
      ValueIndex2.prototype.maxPost = function() {
        return NamedNode.MAX;
      };
      ValueIndex2.prototype.makePost = function(indexValue, name2) {
        var valueNode = nodeFromJSON(indexValue);
        return new NamedNode(name2, valueNode);
      };
      ValueIndex2.prototype.toString = function() {
        return ".value";
      };
      return ValueIndex2;
    }(Index);
    var VALUE_INDEX = new ValueIndex();
    var PUSH_CHARS = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
    var MIN_PUSH_CHAR = "-";
    var MAX_PUSH_CHAR = "z";
    var MAX_KEY_LEN = 786;
    var nextPushId = function() {
      var lastPushTime = 0;
      var lastRandChars = [];
      return function(now) {
        var duplicateTime = now === lastPushTime;
        lastPushTime = now;
        var i;
        var timeStampChars = new Array(8);
        for (i = 7; i >= 0; i--) {
          timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
          now = Math.floor(now / 64);
        }
        util.assert(now === 0, "Cannot push at time == 0");
        var id = timeStampChars.join("");
        if (!duplicateTime) {
          for (i = 0; i < 12; i++) {
            lastRandChars[i] = Math.floor(Math.random() * 64);
          }
        } else {
          for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
            lastRandChars[i] = 0;
          }
          lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
          id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        util.assert(id.length === 20, "nextPushId: Length should be 20.");
        return id;
      };
    }();
    var successor = function(key) {
      if (key === "" + INTEGER_32_MAX) {
        return MIN_PUSH_CHAR;
      }
      var keyAsInt = tryParseInt(key);
      if (keyAsInt != null) {
        return "" + (keyAsInt + 1);
      }
      var next = new Array(key.length);
      for (var i_1 = 0; i_1 < next.length; i_1++) {
        next[i_1] = key.charAt(i_1);
      }
      if (next.length < MAX_KEY_LEN) {
        next.push(MIN_PUSH_CHAR);
        return next.join("");
      }
      var i = next.length - 1;
      while (i >= 0 && next[i] === MAX_PUSH_CHAR) {
        i--;
      }
      if (i === -1) {
        return MAX_NAME;
      }
      var source = next[i];
      var sourcePlusOne = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(source) + 1);
      next[i] = sourcePlusOne;
      return next.slice(0, i + 1).join("");
    };
    var predecessor = function(key) {
      if (key === "" + INTEGER_32_MIN) {
        return MIN_NAME;
      }
      var keyAsInt = tryParseInt(key);
      if (keyAsInt != null) {
        return "" + (keyAsInt - 1);
      }
      var next = new Array(key.length);
      for (var i = 0; i < next.length; i++) {
        next[i] = key.charAt(i);
      }
      if (next[next.length - 1] === MIN_PUSH_CHAR) {
        if (next.length === 1) {
          return "" + INTEGER_32_MAX;
        }
        delete next[next.length - 1];
        return next.join("");
      }
      next[next.length - 1] = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(next[next.length - 1]) - 1);
      return next.join("") + MAX_PUSH_CHAR.repeat(MAX_KEY_LEN - next.length);
    };
    function changeValue(snapshotNode) {
      return { type: "value", snapshotNode };
    }
    function changeChildAdded(childName, snapshotNode) {
      return { type: "child_added", snapshotNode, childName };
    }
    function changeChildRemoved(childName, snapshotNode) {
      return { type: "child_removed", snapshotNode, childName };
    }
    function changeChildChanged(childName, snapshotNode, oldSnap) {
      return {
        type: "child_changed",
        snapshotNode,
        childName,
        oldSnap
      };
    }
    function changeChildMoved(childName, snapshotNode) {
      return { type: "child_moved", snapshotNode, childName };
    }
    var IndexedFilter = function() {
      function IndexedFilter2(index_) {
        this.index_ = index_;
      }
      IndexedFilter2.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        util.assert(snap.isIndexed(this.index_), "A node must be indexed if only a child is updated");
        var oldChild = snap.getImmediateChild(key);
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
          if (oldChild.isEmpty() === newChild.isEmpty()) {
            return snap;
          }
        }
        if (optChangeAccumulator != null) {
          if (newChild.isEmpty()) {
            if (snap.hasChild(key)) {
              optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));
            } else {
              util.assert(snap.isLeafNode(), "A child remove without an old child only makes sense on a leaf node");
            }
          } else if (oldChild.isEmpty()) {
            optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));
          } else {
            optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));
          }
        }
        if (snap.isLeafNode() && newChild.isEmpty()) {
          return snap;
        } else {
          return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
        }
      };
      IndexedFilter2.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
        if (optChangeAccumulator != null) {
          if (!oldSnap.isLeafNode()) {
            oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
              if (!newSnap.hasChild(key)) {
                optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));
              }
            });
          }
          if (!newSnap.isLeafNode()) {
            newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
              if (oldSnap.hasChild(key)) {
                var oldChild = oldSnap.getImmediateChild(key);
                if (!oldChild.equals(childNode)) {
                  optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));
                }
              } else {
                optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));
              }
            });
          }
        }
        return newSnap.withIndex(this.index_);
      };
      IndexedFilter2.prototype.updatePriority = function(oldSnap, newPriority) {
        if (oldSnap.isEmpty()) {
          return ChildrenNode.EMPTY_NODE;
        } else {
          return oldSnap.updatePriority(newPriority);
        }
      };
      IndexedFilter2.prototype.filtersNodes = function() {
        return false;
      };
      IndexedFilter2.prototype.getIndexedFilter = function() {
        return this;
      };
      IndexedFilter2.prototype.getIndex = function() {
        return this.index_;
      };
      return IndexedFilter2;
    }();
    var RangedFilter = function() {
      function RangedFilter2(params) {
        this.indexedFilter_ = new IndexedFilter(params.getIndex());
        this.index_ = params.getIndex();
        this.startPost_ = RangedFilter2.getStartPost_(params);
        this.endPost_ = RangedFilter2.getEndPost_(params);
      }
      RangedFilter2.prototype.getStartPost = function() {
        return this.startPost_;
      };
      RangedFilter2.prototype.getEndPost = function() {
        return this.endPost_;
      };
      RangedFilter2.prototype.matches = function(node) {
        return this.index_.compare(this.getStartPost(), node) <= 0 && this.index_.compare(node, this.getEndPost()) <= 0;
      };
      RangedFilter2.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.matches(new NamedNode(key, newChild))) {
          newChild = ChildrenNode.EMPTY_NODE;
        }
        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
      };
      RangedFilter2.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
        if (newSnap.isLeafNode()) {
          newSnap = ChildrenNode.EMPTY_NODE;
        }
        var filtered = newSnap.withIndex(this.index_);
        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
        var self2 = this;
        newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
          if (!self2.matches(new NamedNode(key, childNode))) {
            filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);
          }
        });
        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
      };
      RangedFilter2.prototype.updatePriority = function(oldSnap, newPriority) {
        return oldSnap;
      };
      RangedFilter2.prototype.filtersNodes = function() {
        return true;
      };
      RangedFilter2.prototype.getIndexedFilter = function() {
        return this.indexedFilter_;
      };
      RangedFilter2.prototype.getIndex = function() {
        return this.index_;
      };
      RangedFilter2.getStartPost_ = function(params) {
        if (params.hasStart()) {
          var startName = params.getIndexStartName();
          return params.getIndex().makePost(params.getIndexStartValue(), startName);
        } else {
          return params.getIndex().minPost();
        }
      };
      RangedFilter2.getEndPost_ = function(params) {
        if (params.hasEnd()) {
          var endName = params.getIndexEndName();
          return params.getIndex().makePost(params.getIndexEndValue(), endName);
        } else {
          return params.getIndex().maxPost();
        }
      };
      return RangedFilter2;
    }();
    var LimitedFilter = function() {
      function LimitedFilter2(params) {
        this.rangedFilter_ = new RangedFilter(params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
      }
      LimitedFilter2.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {
          newChild = ChildrenNode.EMPTY_NODE;
        }
        if (snap.getImmediateChild(key).equals(newChild)) {
          return snap;
        } else if (snap.numChildren() < this.limit_) {
          return this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
        } else {
          return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
        }
      };
      LimitedFilter2.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
        var filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) {
          filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        } else {
          if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {
            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
            var iterator = void 0;
            if (this.reverse_) {
              iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
            } else {
              iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
            }
            var count = 0;
            while (iterator.hasNext() && count < this.limit_) {
              var next = iterator.getNext();
              var inRange = void 0;
              if (this.reverse_) {
                inRange = this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;
              } else {
                inRange = this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;
              }
              if (inRange) {
                filtered = filtered.updateImmediateChild(next.name, next.node);
                count++;
              } else {
                break;
              }
            }
          } else {
            filtered = newSnap.withIndex(this.index_);
            filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
            var startPost = void 0;
            var endPost = void 0;
            var cmp = void 0;
            var iterator = void 0;
            if (this.reverse_) {
              iterator = filtered.getReverseIterator(this.index_);
              startPost = this.rangedFilter_.getEndPost();
              endPost = this.rangedFilter_.getStartPost();
              var indexCompare_1 = this.index_.getCompare();
              cmp = function(a, b) {
                return indexCompare_1(b, a);
              };
            } else {
              iterator = filtered.getIterator(this.index_);
              startPost = this.rangedFilter_.getStartPost();
              endPost = this.rangedFilter_.getEndPost();
              cmp = this.index_.getCompare();
            }
            var count = 0;
            var foundStartPost = false;
            while (iterator.hasNext()) {
              var next = iterator.getNext();
              if (!foundStartPost && cmp(startPost, next) <= 0) {
                foundStartPost = true;
              }
              var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;
              if (inRange) {
                count++;
              } else {
                filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
              }
            }
          }
        }
        return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);
      };
      LimitedFilter2.prototype.updatePriority = function(oldSnap, newPriority) {
        return oldSnap;
      };
      LimitedFilter2.prototype.filtersNodes = function() {
        return true;
      };
      LimitedFilter2.prototype.getIndexedFilter = function() {
        return this.rangedFilter_.getIndexedFilter();
      };
      LimitedFilter2.prototype.getIndex = function() {
        return this.index_;
      };
      LimitedFilter2.prototype.fullLimitUpdateChild_ = function(snap, childKey, childSnap, source, changeAccumulator) {
        var cmp;
        if (this.reverse_) {
          var indexCmp_1 = this.index_.getCompare();
          cmp = function(a, b) {
            return indexCmp_1(b, a);
          };
        } else {
          cmp = this.index_.getCompare();
        }
        var oldEventCache = snap;
        util.assert(oldEventCache.numChildren() === this.limit_, "");
        var newChildNamedNode = new NamedNode(childKey, childSnap);
        var windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);
        var inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) {
          var oldChildSnap = oldEventCache.getImmediateChild(childKey);
          var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
          while (nextChild != null && (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {
            nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
          }
          var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
          var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
          if (remainsInWindow) {
            if (changeAccumulator != null) {
              changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));
            }
            return oldEventCache.updateImmediateChild(childKey, childSnap);
          } else {
            if (changeAccumulator != null) {
              changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));
            }
            var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
            var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
            if (nextChildInRange) {
              if (changeAccumulator != null) {
                changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));
              }
              return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
            } else {
              return newEventCache;
            }
          }
        } else if (childSnap.isEmpty()) {
          return snap;
        } else if (inRange) {
          if (cmp(windowBoundary, newChildNamedNode) >= 0) {
            if (changeAccumulator != null) {
              changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));
              changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));
            }
            return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
          } else {
            return snap;
          }
        } else {
          return snap;
        }
      };
      return LimitedFilter2;
    }();
    var QueryParams = function() {
      function QueryParams2() {
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.startAfterSet_ = false;
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.endBeforeSet_ = false;
        this.limit_ = 0;
        this.viewFrom_ = "";
        this.indexStartValue_ = null;
        this.indexStartName_ = "";
        this.indexEndValue_ = null;
        this.indexEndName_ = "";
        this.index_ = PRIORITY_INDEX;
      }
      QueryParams2.prototype.hasStart = function() {
        return this.startSet_;
      };
      QueryParams2.prototype.hasStartAfter = function() {
        return this.startAfterSet_;
      };
      QueryParams2.prototype.hasEndBefore = function() {
        return this.endBeforeSet_;
      };
      QueryParams2.prototype.isViewFromLeft = function() {
        if (this.viewFrom_ === "") {
          return this.startSet_;
        } else {
          return this.viewFrom_ === "l";
        }
      };
      QueryParams2.prototype.getIndexStartValue = function() {
        util.assert(this.startSet_, "Only valid if start has been set");
        return this.indexStartValue_;
      };
      QueryParams2.prototype.getIndexStartName = function() {
        util.assert(this.startSet_, "Only valid if start has been set");
        if (this.startNameSet_) {
          return this.indexStartName_;
        } else {
          return MIN_NAME;
        }
      };
      QueryParams2.prototype.hasEnd = function() {
        return this.endSet_;
      };
      QueryParams2.prototype.getIndexEndValue = function() {
        util.assert(this.endSet_, "Only valid if end has been set");
        return this.indexEndValue_;
      };
      QueryParams2.prototype.getIndexEndName = function() {
        util.assert(this.endSet_, "Only valid if end has been set");
        if (this.endNameSet_) {
          return this.indexEndName_;
        } else {
          return MAX_NAME;
        }
      };
      QueryParams2.prototype.hasLimit = function() {
        return this.limitSet_;
      };
      QueryParams2.prototype.hasAnchoredLimit = function() {
        return this.limitSet_ && this.viewFrom_ !== "";
      };
      QueryParams2.prototype.getLimit = function() {
        util.assert(this.limitSet_, "Only valid if limit has been set");
        return this.limit_;
      };
      QueryParams2.prototype.getIndex = function() {
        return this.index_;
      };
      QueryParams2.prototype.loadsAllData = function() {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
      };
      QueryParams2.prototype.isDefault = function() {
        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
      };
      QueryParams2.prototype.copy = function() {
        var copy = new QueryParams2();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
      };
      return QueryParams2;
    }();
    function queryParamsGetNodeFilter(queryParams) {
      if (queryParams.loadsAllData()) {
        return new IndexedFilter(queryParams.getIndex());
      } else if (queryParams.hasLimit()) {
        return new LimitedFilter(queryParams);
      } else {
        return new RangedFilter(queryParams);
      }
    }
    function queryParamsLimitToFirst(queryParams, newLimit) {
      var newParams = queryParams.copy();
      newParams.limitSet_ = true;
      newParams.limit_ = newLimit;
      newParams.viewFrom_ = "l";
      return newParams;
    }
    function queryParamsLimitToLast(queryParams, newLimit) {
      var newParams = queryParams.copy();
      newParams.limitSet_ = true;
      newParams.limit_ = newLimit;
      newParams.viewFrom_ = "r";
      return newParams;
    }
    function queryParamsStartAt(queryParams, indexValue, key) {
      var newParams = queryParams.copy();
      newParams.startSet_ = true;
      if (indexValue === void 0) {
        indexValue = null;
      }
      newParams.indexStartValue_ = indexValue;
      if (key != null) {
        newParams.startNameSet_ = true;
        newParams.indexStartName_ = key;
      } else {
        newParams.startNameSet_ = false;
        newParams.indexStartName_ = "";
      }
      return newParams;
    }
    function queryParamsStartAfter(queryParams, indexValue, key) {
      var params;
      if (queryParams.index_ === KEY_INDEX) {
        if (typeof indexValue === "string") {
          indexValue = successor(indexValue);
        }
        params = queryParamsStartAt(queryParams, indexValue, key);
      } else {
        var childKey = void 0;
        if (key == null) {
          childKey = MAX_NAME;
        } else {
          childKey = successor(key);
        }
        params = queryParamsStartAt(queryParams, indexValue, childKey);
      }
      params.startAfterSet_ = true;
      return params;
    }
    function queryParamsEndAt(queryParams, indexValue, key) {
      var newParams = queryParams.copy();
      newParams.endSet_ = true;
      if (indexValue === void 0) {
        indexValue = null;
      }
      newParams.indexEndValue_ = indexValue;
      if (key !== void 0) {
        newParams.endNameSet_ = true;
        newParams.indexEndName_ = key;
      } else {
        newParams.endNameSet_ = false;
        newParams.indexEndName_ = "";
      }
      return newParams;
    }
    function queryParamsEndBefore(queryParams, indexValue, key) {
      var childKey;
      var params;
      if (queryParams.index_ === KEY_INDEX) {
        if (typeof indexValue === "string") {
          indexValue = predecessor(indexValue);
        }
        params = queryParamsEndAt(queryParams, indexValue, key);
      } else {
        if (key == null) {
          childKey = MIN_NAME;
        } else {
          childKey = predecessor(key);
        }
        params = queryParamsEndAt(queryParams, indexValue, childKey);
      }
      params.endBeforeSet_ = true;
      return params;
    }
    function queryParamsOrderBy(queryParams, index2) {
      var newParams = queryParams.copy();
      newParams.index_ = index2;
      return newParams;
    }
    function queryParamsToRestQueryStringParameters(queryParams) {
      var qs = {};
      if (queryParams.isDefault()) {
        return qs;
      }
      var orderBy;
      if (queryParams.index_ === PRIORITY_INDEX) {
        orderBy = "$priority";
      } else if (queryParams.index_ === VALUE_INDEX) {
        orderBy = "$value";
      } else if (queryParams.index_ === KEY_INDEX) {
        orderBy = "$key";
      } else {
        util.assert(queryParams.index_ instanceof PathIndex, "Unrecognized index type!");
        orderBy = queryParams.index_.toString();
      }
      qs["orderBy"] = util.stringify(orderBy);
      if (queryParams.startSet_) {
        qs["startAt"] = util.stringify(queryParams.indexStartValue_);
        if (queryParams.startNameSet_) {
          qs["startAt"] += "," + util.stringify(queryParams.indexStartName_);
        }
      }
      if (queryParams.endSet_) {
        qs["endAt"] = util.stringify(queryParams.indexEndValue_);
        if (queryParams.endNameSet_) {
          qs["endAt"] += "," + util.stringify(queryParams.indexEndName_);
        }
      }
      if (queryParams.limitSet_) {
        if (queryParams.isViewFromLeft()) {
          qs["limitToFirst"] = queryParams.limit_;
        } else {
          qs["limitToLast"] = queryParams.limit_;
        }
      }
      return qs;
    }
    function queryParamsGetQueryObject(queryParams) {
      var obj = {};
      if (queryParams.startSet_) {
        obj["sp"] = queryParams.indexStartValue_;
        if (queryParams.startNameSet_) {
          obj["sn"] = queryParams.indexStartName_;
        }
      }
      if (queryParams.endSet_) {
        obj["ep"] = queryParams.indexEndValue_;
        if (queryParams.endNameSet_) {
          obj["en"] = queryParams.indexEndName_;
        }
      }
      if (queryParams.limitSet_) {
        obj["l"] = queryParams.limit_;
        var viewFrom = queryParams.viewFrom_;
        if (viewFrom === "") {
          if (queryParams.isViewFromLeft()) {
            viewFrom = "l";
          } else {
            viewFrom = "r";
          }
        }
        obj["vf"] = viewFrom;
      }
      if (queryParams.index_ !== PRIORITY_INDEX) {
        obj["i"] = queryParams.index_.toString();
      }
      return obj;
    }
    var ReadonlyRestClient = function(_super) {
      tslib.__extends(ReadonlyRestClient2, _super);
      function ReadonlyRestClient2(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        _this.appCheckTokenProvider_ = appCheckTokenProvider_;
        _this.log_ = logWrapper("p:rest:");
        _this.listens_ = {};
        return _this;
      }
      ReadonlyRestClient2.prototype.reportStats = function(stats2) {
        throw new Error("Method not implemented.");
      };
      ReadonlyRestClient2.getListenId_ = function(query2, tag) {
        if (tag !== void 0) {
          return "tag$" + tag;
        } else {
          util.assert(query2._queryParams.isDefault(), "should have a tag if it's not a default query.");
          return query2._path.toString();
        }
      };
      ReadonlyRestClient2.prototype.listen = function(query2, currentHashFn, tag, onComplete) {
        var _this = this;
        var pathString = query2._path.toString();
        this.log_("Listen called for " + pathString + " " + query2._queryIdentifier);
        var listenId = ReadonlyRestClient2.getListenId_(query2, tag);
        var thisListen = {};
        this.listens_[listenId] = thisListen;
        var queryStringParameters = queryParamsToRestQueryStringParameters(query2._queryParams);
        this.restRequest_(pathString + ".json", queryStringParameters, function(error4, result) {
          var data = result;
          if (error4 === 404) {
            data = null;
            error4 = null;
          }
          if (error4 === null) {
            _this.onDataUpdate_(pathString, data, false, tag);
          }
          if (util.safeGet(_this.listens_, listenId) === thisListen) {
            var status_1;
            if (!error4) {
              status_1 = "ok";
            } else if (error4 === 401) {
              status_1 = "permission_denied";
            } else {
              status_1 = "rest_error:" + error4;
            }
            onComplete(status_1, null);
          }
        });
      };
      ReadonlyRestClient2.prototype.unlisten = function(query2, tag) {
        var listenId = ReadonlyRestClient2.getListenId_(query2, tag);
        delete this.listens_[listenId];
      };
      ReadonlyRestClient2.prototype.get = function(query2) {
        var _this = this;
        var queryStringParameters = queryParamsToRestQueryStringParameters(query2._queryParams);
        var pathString = query2._path.toString();
        var deferred = new util.Deferred();
        this.restRequest_(pathString + ".json", queryStringParameters, function(error4, result) {
          var data = result;
          if (error4 === 404) {
            data = null;
            error4 = null;
          }
          if (error4 === null) {
            _this.onDataUpdate_(pathString, data, false, null);
            deferred.resolve(data);
          } else {
            deferred.reject(new Error(data));
          }
        });
        return deferred.promise;
      };
      ReadonlyRestClient2.prototype.refreshAuthToken = function(token) {
      };
      ReadonlyRestClient2.prototype.restRequest_ = function(pathString, queryStringParameters, callback) {
        var _this = this;
        if (queryStringParameters === void 0) {
          queryStringParameters = {};
        }
        queryStringParameters["format"] = "export";
        return Promise.all([
          this.authTokenProvider_.getToken(false),
          this.appCheckTokenProvider_.getToken(false)
        ]).then(function(_a) {
          var _b = tslib.__read(_a, 2), authToken = _b[0], appCheckToken = _b[1];
          if (authToken && authToken.accessToken) {
            queryStringParameters["auth"] = authToken.accessToken;
          }
          if (appCheckToken && appCheckToken.token) {
            queryStringParameters["ac"] = appCheckToken.token;
          }
          var url = (_this.repoInfo_.secure ? "https://" : "http://") + _this.repoInfo_.host + pathString + "?ns=" + _this.repoInfo_.namespace + util.querystring(queryStringParameters);
          _this.log_("Sending REST request for " + url);
          var xhr = new XMLHttpRequest();
          xhr.onreadystatechange = function() {
            if (callback && xhr.readyState === 4) {
              _this.log_("REST Response for " + url + " received. status:", xhr.status, "response:", xhr.responseText);
              var res = null;
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  res = util.jsonEval(xhr.responseText);
                } catch (e) {
                  warn("Failed to parse JSON response for " + url + ": " + xhr.responseText);
                }
                callback(null, res);
              } else {
                if (xhr.status !== 401 && xhr.status !== 404) {
                  warn("Got unsuccessful REST response for " + url + " Status: " + xhr.status);
                }
                callback(xhr.status);
              }
              callback = null;
            }
          };
          xhr.open("GET", url, true);
          xhr.send();
        });
      };
      return ReadonlyRestClient2;
    }(ServerActions);
    var SnapshotHolder = function() {
      function SnapshotHolder2() {
        this.rootNode_ = ChildrenNode.EMPTY_NODE;
      }
      SnapshotHolder2.prototype.getNode = function(path) {
        return this.rootNode_.getChild(path);
      };
      SnapshotHolder2.prototype.updateSnapshot = function(path, newSnapshotNode) {
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
      };
      return SnapshotHolder2;
    }();
    function newSparseSnapshotTree() {
      return {
        value: null,
        children: new Map()
      };
    }
    function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {
      if (pathIsEmpty(path)) {
        sparseSnapshotTree.value = data;
        sparseSnapshotTree.children.clear();
      } else if (sparseSnapshotTree.value !== null) {
        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);
      } else {
        var childKey = pathGetFront(path);
        if (!sparseSnapshotTree.children.has(childKey)) {
          sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
        }
        var child2 = sparseSnapshotTree.children.get(childKey);
        path = pathPopFront(path);
        sparseSnapshotTreeRemember(child2, path, data);
      }
    }
    function sparseSnapshotTreeForget(sparseSnapshotTree, path) {
      if (pathIsEmpty(path)) {
        sparseSnapshotTree.value = null;
        sparseSnapshotTree.children.clear();
        return true;
      } else {
        if (sparseSnapshotTree.value !== null) {
          if (sparseSnapshotTree.value.isLeafNode()) {
            return false;
          } else {
            var value = sparseSnapshotTree.value;
            sparseSnapshotTree.value = null;
            value.forEachChild(PRIORITY_INDEX, function(key, tree) {
              sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);
            });
            return sparseSnapshotTreeForget(sparseSnapshotTree, path);
          }
        } else if (sparseSnapshotTree.children.size > 0) {
          var childKey = pathGetFront(path);
          path = pathPopFront(path);
          if (sparseSnapshotTree.children.has(childKey)) {
            var safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);
            if (safeToRemove) {
              sparseSnapshotTree.children.delete(childKey);
            }
          }
          return sparseSnapshotTree.children.size === 0;
        } else {
          return true;
        }
      }
    }
    function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {
      if (sparseSnapshotTree.value !== null) {
        func(prefixPath, sparseSnapshotTree.value);
      } else {
        sparseSnapshotTreeForEachChild(sparseSnapshotTree, function(key, tree) {
          var path = new Path(prefixPath.toString() + "/" + key);
          sparseSnapshotTreeForEachTree(tree, path, func);
        });
      }
    }
    function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {
      sparseSnapshotTree.children.forEach(function(tree, key) {
        func(key, tree);
      });
    }
    var StatsListener = function() {
      function StatsListener2(collection_) {
        this.collection_ = collection_;
        this.last_ = null;
      }
      StatsListener2.prototype.get = function() {
        var newStats = this.collection_.get();
        var delta = tslib.__assign({}, newStats);
        if (this.last_) {
          each2(this.last_, function(stat, value) {
            delta[stat] = delta[stat] - value;
          });
        }
        this.last_ = newStats;
        return delta;
      };
      return StatsListener2;
    }();
    var FIRST_STATS_MIN_TIME = 10 * 1e3;
    var FIRST_STATS_MAX_TIME = 30 * 1e3;
    var REPORT_STATS_INTERVAL = 5 * 60 * 1e3;
    var StatsReporter = function() {
      function StatsReporter2(collection, server_) {
        this.server_ = server_;
        this.statsToReport_ = {};
        this.statsListener_ = new StatsListener(collection);
        var timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
      }
      StatsReporter2.prototype.reportStats_ = function() {
        var _this = this;
        var stats2 = this.statsListener_.get();
        var reportedStats = {};
        var haveStatsToReport = false;
        each2(stats2, function(stat, value) {
          if (value > 0 && util.contains(_this.statsToReport_, stat)) {
            reportedStats[stat] = value;
            haveStatsToReport = true;
          }
        });
        if (haveStatsToReport) {
          this.server_.reportStats(reportedStats);
        }
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
      };
      return StatsReporter2;
    }();
    function statsReporterIncludeStat(reporter, stat) {
      reporter.statsToReport_[stat] = true;
    }
    var OperationType;
    (function(OperationType2) {
      OperationType2[OperationType2["OVERWRITE"] = 0] = "OVERWRITE";
      OperationType2[OperationType2["MERGE"] = 1] = "MERGE";
      OperationType2[OperationType2["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
      OperationType2[OperationType2["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
    })(OperationType || (OperationType = {}));
    function newOperationSourceUser() {
      return {
        fromUser: true,
        fromServer: false,
        queryId: null,
        tagged: false
      };
    }
    function newOperationSourceServer() {
      return {
        fromUser: false,
        fromServer: true,
        queryId: null,
        tagged: false
      };
    }
    function newOperationSourceServerTaggedQuery(queryId) {
      return {
        fromUser: false,
        fromServer: true,
        queryId,
        tagged: true
      };
    }
    var AckUserWrite = function() {
      function AckUserWrite2(path, affectedTree, revert) {
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        this.type = OperationType.ACK_USER_WRITE;
        this.source = newOperationSourceUser();
      }
      AckUserWrite2.prototype.operationForChild = function(childName) {
        if (!pathIsEmpty(this.path)) {
          util.assert(pathGetFront(this.path) === childName, "operationForChild called for unrelated child.");
          return new AckUserWrite2(pathPopFront(this.path), this.affectedTree, this.revert);
        } else if (this.affectedTree.value != null) {
          util.assert(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths.");
          return this;
        } else {
          var childTree = this.affectedTree.subtree(new Path(childName));
          return new AckUserWrite2(newEmptyPath(), childTree, this.revert);
        }
      };
      return AckUserWrite2;
    }();
    var ListenComplete = function() {
      function ListenComplete2(source, path) {
        this.source = source;
        this.path = path;
        this.type = OperationType.LISTEN_COMPLETE;
      }
      ListenComplete2.prototype.operationForChild = function(childName) {
        if (pathIsEmpty(this.path)) {
          return new ListenComplete2(this.source, newEmptyPath());
        } else {
          return new ListenComplete2(this.source, pathPopFront(this.path));
        }
      };
      return ListenComplete2;
    }();
    var Overwrite = function() {
      function Overwrite2(source, path, snap) {
        this.source = source;
        this.path = path;
        this.snap = snap;
        this.type = OperationType.OVERWRITE;
      }
      Overwrite2.prototype.operationForChild = function(childName) {
        if (pathIsEmpty(this.path)) {
          return new Overwrite2(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
        } else {
          return new Overwrite2(this.source, pathPopFront(this.path), this.snap);
        }
      };
      return Overwrite2;
    }();
    var Merge = function() {
      function Merge2(source, path, children) {
        this.source = source;
        this.path = path;
        this.children = children;
        this.type = OperationType.MERGE;
      }
      Merge2.prototype.operationForChild = function(childName) {
        if (pathIsEmpty(this.path)) {
          var childTree = this.children.subtree(new Path(childName));
          if (childTree.isEmpty()) {
            return null;
          } else if (childTree.value) {
            return new Overwrite(this.source, newEmptyPath(), childTree.value);
          } else {
            return new Merge2(this.source, newEmptyPath(), childTree);
          }
        } else {
          util.assert(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
          return new Merge2(this.source, pathPopFront(this.path), this.children);
        }
      };
      Merge2.prototype.toString = function() {
        return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")";
      };
      return Merge2;
    }();
    var CacheNode = function() {
      function CacheNode2(node_, fullyInitialized_, filtered_) {
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
      }
      CacheNode2.prototype.isFullyInitialized = function() {
        return this.fullyInitialized_;
      };
      CacheNode2.prototype.isFiltered = function() {
        return this.filtered_;
      };
      CacheNode2.prototype.isCompleteForPath = function(path) {
        if (pathIsEmpty(path)) {
          return this.isFullyInitialized() && !this.filtered_;
        }
        var childKey = pathGetFront(path);
        return this.isCompleteForChild(childKey);
      };
      CacheNode2.prototype.isCompleteForChild = function(key) {
        return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key);
      };
      CacheNode2.prototype.getNode = function() {
        return this.node_;
      };
      return CacheNode2;
    }();
    var EventGenerator = function() {
      function EventGenerator2(query_) {
        this.query_ = query_;
        this.index_ = this.query_._queryParams.getIndex();
      }
      return EventGenerator2;
    }();
    function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {
      var events = [];
      var moves = [];
      changes.forEach(function(change) {
        if (change.type === "child_changed" && eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
          moves.push(changeChildMoved(change.childName, change.snapshotNode));
        }
      });
      eventGeneratorGenerateEventsForType(eventGenerator, events, "child_removed", changes, eventRegistrations, eventCache);
      eventGeneratorGenerateEventsForType(eventGenerator, events, "child_added", changes, eventRegistrations, eventCache);
      eventGeneratorGenerateEventsForType(eventGenerator, events, "child_moved", moves, eventRegistrations, eventCache);
      eventGeneratorGenerateEventsForType(eventGenerator, events, "child_changed", changes, eventRegistrations, eventCache);
      eventGeneratorGenerateEventsForType(eventGenerator, events, "value", changes, eventRegistrations, eventCache);
      return events;
    }
    function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {
      var filteredChanges = changes.filter(function(change) {
        return change.type === eventType;
      });
      filteredChanges.sort(function(a, b) {
        return eventGeneratorCompareChanges(eventGenerator, a, b);
      });
      filteredChanges.forEach(function(change) {
        var materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
        registrations.forEach(function(registration) {
          if (registration.respondsTo(change.type)) {
            events.push(registration.createEvent(materializedChange, eventGenerator.query_));
          }
        });
      });
    }
    function eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {
      if (change.type === "value" || change.type === "child_removed") {
        return change;
      } else {
        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
        return change;
      }
    }
    function eventGeneratorCompareChanges(eventGenerator, a, b) {
      if (a.childName == null || b.childName == null) {
        throw util.assertionError("Should only compare child_ events.");
      }
      var aWrapped = new NamedNode(a.childName, a.snapshotNode);
      var bWrapped = new NamedNode(b.childName, b.snapshotNode);
      return eventGenerator.index_.compare(aWrapped, bWrapped);
    }
    function newViewCache(eventCache, serverCache) {
      return { eventCache, serverCache };
    }
    function viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {
      return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
    }
    function viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {
      return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
    }
    function viewCacheGetCompleteEventSnap(viewCache) {
      return viewCache.eventCache.isFullyInitialized() ? viewCache.eventCache.getNode() : null;
    }
    function viewCacheGetCompleteServerSnap(viewCache) {
      return viewCache.serverCache.isFullyInitialized() ? viewCache.serverCache.getNode() : null;
    }
    var emptyChildrenSingleton;
    var EmptyChildren = function() {
      if (!emptyChildrenSingleton) {
        emptyChildrenSingleton = new SortedMap(stringCompare);
      }
      return emptyChildrenSingleton;
    };
    var ImmutableTree = function() {
      function ImmutableTree2(value, children) {
        if (children === void 0) {
          children = EmptyChildren();
        }
        this.value = value;
        this.children = children;
      }
      ImmutableTree2.fromObject = function(obj) {
        var tree = new ImmutableTree2(null);
        each2(obj, function(childPath, childSnap) {
          tree = tree.set(new Path(childPath), childSnap);
        });
        return tree;
      };
      ImmutableTree2.prototype.isEmpty = function() {
        return this.value === null && this.children.isEmpty();
      };
      ImmutableTree2.prototype.findRootMostMatchingPathAndValue = function(relativePath, predicate) {
        if (this.value != null && predicate(this.value)) {
          return { path: newEmptyPath(), value: this.value };
        } else {
          if (pathIsEmpty(relativePath)) {
            return null;
          } else {
            var front = pathGetFront(relativePath);
            var child2 = this.children.get(front);
            if (child2 !== null) {
              var childExistingPathAndValue = child2.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
              if (childExistingPathAndValue != null) {
                var fullPath = pathChild(new Path(front), childExistingPathAndValue.path);
                return { path: fullPath, value: childExistingPathAndValue.value };
              } else {
                return null;
              }
            } else {
              return null;
            }
          }
        }
      };
      ImmutableTree2.prototype.findRootMostValueAndPath = function(relativePath) {
        return this.findRootMostMatchingPathAndValue(relativePath, function() {
          return true;
        });
      };
      ImmutableTree2.prototype.subtree = function(relativePath) {
        if (pathIsEmpty(relativePath)) {
          return this;
        } else {
          var front = pathGetFront(relativePath);
          var childTree = this.children.get(front);
          if (childTree !== null) {
            return childTree.subtree(pathPopFront(relativePath));
          } else {
            return new ImmutableTree2(null);
          }
        }
      };
      ImmutableTree2.prototype.set = function(relativePath, toSet) {
        if (pathIsEmpty(relativePath)) {
          return new ImmutableTree2(toSet, this.children);
        } else {
          var front = pathGetFront(relativePath);
          var child2 = this.children.get(front) || new ImmutableTree2(null);
          var newChild = child2.set(pathPopFront(relativePath), toSet);
          var newChildren = this.children.insert(front, newChild);
          return new ImmutableTree2(this.value, newChildren);
        }
      };
      ImmutableTree2.prototype.remove = function(relativePath) {
        if (pathIsEmpty(relativePath)) {
          if (this.children.isEmpty()) {
            return new ImmutableTree2(null);
          } else {
            return new ImmutableTree2(null, this.children);
          }
        } else {
          var front = pathGetFront(relativePath);
          var child2 = this.children.get(front);
          if (child2) {
            var newChild = child2.remove(pathPopFront(relativePath));
            var newChildren = void 0;
            if (newChild.isEmpty()) {
              newChildren = this.children.remove(front);
            } else {
              newChildren = this.children.insert(front, newChild);
            }
            if (this.value === null && newChildren.isEmpty()) {
              return new ImmutableTree2(null);
            } else {
              return new ImmutableTree2(this.value, newChildren);
            }
          } else {
            return this;
          }
        }
      };
      ImmutableTree2.prototype.get = function(relativePath) {
        if (pathIsEmpty(relativePath)) {
          return this.value;
        } else {
          var front = pathGetFront(relativePath);
          var child2 = this.children.get(front);
          if (child2) {
            return child2.get(pathPopFront(relativePath));
          } else {
            return null;
          }
        }
      };
      ImmutableTree2.prototype.setTree = function(relativePath, newTree) {
        if (pathIsEmpty(relativePath)) {
          return newTree;
        } else {
          var front = pathGetFront(relativePath);
          var child2 = this.children.get(front) || new ImmutableTree2(null);
          var newChild = child2.setTree(pathPopFront(relativePath), newTree);
          var newChildren = void 0;
          if (newChild.isEmpty()) {
            newChildren = this.children.remove(front);
          } else {
            newChildren = this.children.insert(front, newChild);
          }
          return new ImmutableTree2(this.value, newChildren);
        }
      };
      ImmutableTree2.prototype.fold = function(fn) {
        return this.fold_(newEmptyPath(), fn);
      };
      ImmutableTree2.prototype.fold_ = function(pathSoFar, fn) {
        var accum = {};
        this.children.inorderTraversal(function(childKey, childTree) {
          accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);
        });
        return fn(pathSoFar, this.value, accum);
      };
      ImmutableTree2.prototype.findOnPath = function(path, f) {
        return this.findOnPath_(path, newEmptyPath(), f);
      };
      ImmutableTree2.prototype.findOnPath_ = function(pathToFollow, pathSoFar, f) {
        var result = this.value ? f(pathSoFar, this.value) : false;
        if (result) {
          return result;
        } else {
          if (pathIsEmpty(pathToFollow)) {
            return null;
          } else {
            var front = pathGetFront(pathToFollow);
            var nextChild = this.children.get(front);
            if (nextChild) {
              return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
            } else {
              return null;
            }
          }
        }
      };
      ImmutableTree2.prototype.foreachOnPath = function(path, f) {
        return this.foreachOnPath_(path, newEmptyPath(), f);
      };
      ImmutableTree2.prototype.foreachOnPath_ = function(pathToFollow, currentRelativePath, f) {
        if (pathIsEmpty(pathToFollow)) {
          return this;
        } else {
          if (this.value) {
            f(currentRelativePath, this.value);
          }
          var front = pathGetFront(pathToFollow);
          var nextChild = this.children.get(front);
          if (nextChild) {
            return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
          } else {
            return new ImmutableTree2(null);
          }
        }
      };
      ImmutableTree2.prototype.foreach = function(f) {
        this.foreach_(newEmptyPath(), f);
      };
      ImmutableTree2.prototype.foreach_ = function(currentRelativePath, f) {
        this.children.inorderTraversal(function(childName, childTree) {
          childTree.foreach_(pathChild(currentRelativePath, childName), f);
        });
        if (this.value) {
          f(currentRelativePath, this.value);
        }
      };
      ImmutableTree2.prototype.foreachChild = function(f) {
        this.children.inorderTraversal(function(childName, childTree) {
          if (childTree.value) {
            f(childName, childTree.value);
          }
        });
      };
      return ImmutableTree2;
    }();
    var CompoundWrite = function() {
      function CompoundWrite2(writeTree_) {
        this.writeTree_ = writeTree_;
      }
      CompoundWrite2.empty = function() {
        return new CompoundWrite2(new ImmutableTree(null));
      };
      return CompoundWrite2;
    }();
    function compoundWriteAddWrite(compoundWrite, path, node) {
      if (pathIsEmpty(path)) {
        return new CompoundWrite(new ImmutableTree(node));
      } else {
        var rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) {
          var rootMostPath = rootmost.path;
          var value = rootmost.value;
          var relativePath = newRelativePath(rootMostPath, path);
          value = value.updateChild(relativePath, node);
          return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
        } else {
          var subtree = new ImmutableTree(node);
          var newWriteTree2 = compoundWrite.writeTree_.setTree(path, subtree);
          return new CompoundWrite(newWriteTree2);
        }
      }
    }
    function compoundWriteAddWrites(compoundWrite, path, updates) {
      var newWrite = compoundWrite;
      each2(updates, function(childKey, node) {
        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);
      });
      return newWrite;
    }
    function compoundWriteRemoveWrite(compoundWrite, path) {
      if (pathIsEmpty(path)) {
        return CompoundWrite.empty();
      } else {
        var newWriteTree2 = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));
        return new CompoundWrite(newWriteTree2);
      }
    }
    function compoundWriteHasCompleteWrite(compoundWrite, path) {
      return compoundWriteGetCompleteNode(compoundWrite, path) != null;
    }
    function compoundWriteGetCompleteNode(compoundWrite, path) {
      var rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
      if (rootmost != null) {
        return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path, path));
      } else {
        return null;
      }
    }
    function compoundWriteGetCompleteChildren(compoundWrite) {
      var children = [];
      var node = compoundWrite.writeTree_.value;
      if (node != null) {
        if (!node.isLeafNode()) {
          node.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
            children.push(new NamedNode(childName, childNode));
          });
        }
      } else {
        compoundWrite.writeTree_.children.inorderTraversal(function(childName, childTree) {
          if (childTree.value != null) {
            children.push(new NamedNode(childName, childTree.value));
          }
        });
      }
      return children;
    }
    function compoundWriteChildCompoundWrite(compoundWrite, path) {
      if (pathIsEmpty(path)) {
        return compoundWrite;
      } else {
        var shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);
        if (shadowingNode != null) {
          return new CompoundWrite(new ImmutableTree(shadowingNode));
        } else {
          return new CompoundWrite(compoundWrite.writeTree_.subtree(path));
        }
      }
    }
    function compoundWriteIsEmpty(compoundWrite) {
      return compoundWrite.writeTree_.isEmpty();
    }
    function compoundWriteApply(compoundWrite, node) {
      return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
    }
    function applySubtreeWrite(relativePath, writeTree, node) {
      if (writeTree.value != null) {
        return node.updateChild(relativePath, writeTree.value);
      } else {
        var priorityWrite_1 = null;
        writeTree.children.inorderTraversal(function(childKey, childTree) {
          if (childKey === ".priority") {
            util.assert(childTree.value !== null, "Priority writes must always be leaf nodes");
            priorityWrite_1 = childTree.value;
          } else {
            node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
          }
        });
        if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {
          node = node.updateChild(pathChild(relativePath, ".priority"), priorityWrite_1);
        }
        return node;
      }
    }
    function writeTreeChildWrites(writeTree, path) {
      return newWriteTreeRef(path, writeTree);
    }
    function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {
      util.assert(writeId > writeTree.lastWriteId, "Stacking an older write on top of newer ones");
      if (visible === void 0) {
        visible = true;
      }
      writeTree.allWrites.push({
        path,
        snap,
        writeId,
        visible
      });
      if (visible) {
        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);
      }
      writeTree.lastWriteId = writeId;
    }
    function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {
      util.assert(writeId > writeTree.lastWriteId, "Stacking an older merge on top of newer ones");
      writeTree.allWrites.push({
        path,
        children: changedChildren,
        writeId,
        visible: true
      });
      writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);
      writeTree.lastWriteId = writeId;
    }
    function writeTreeGetWrite(writeTree, writeId) {
      for (var i = 0; i < writeTree.allWrites.length; i++) {
        var record = writeTree.allWrites[i];
        if (record.writeId === writeId) {
          return record;
        }
      }
      return null;
    }
    function writeTreeRemoveWrite(writeTree, writeId) {
      var idx = writeTree.allWrites.findIndex(function(s2) {
        return s2.writeId === writeId;
      });
      util.assert(idx >= 0, "removeWrite called with nonexistent writeId.");
      var writeToRemove = writeTree.allWrites[idx];
      writeTree.allWrites.splice(idx, 1);
      var removedWriteWasVisible = writeToRemove.visible;
      var removedWriteOverlapsWithOtherWrites = false;
      var i = writeTree.allWrites.length - 1;
      while (removedWriteWasVisible && i >= 0) {
        var currentWrite = writeTree.allWrites[i];
        if (currentWrite.visible) {
          if (i >= idx && writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {
            removedWriteWasVisible = false;
          } else if (pathContains(writeToRemove.path, currentWrite.path)) {
            removedWriteOverlapsWithOtherWrites = true;
          }
        }
        i--;
      }
      if (!removedWriteWasVisible) {
        return false;
      } else if (removedWriteOverlapsWithOtherWrites) {
        writeTreeResetTree_(writeTree);
        return true;
      } else {
        if (writeToRemove.snap) {
          writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
        } else {
          var children = writeToRemove.children;
          each2(children, function(childName) {
            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
          });
        }
        return true;
      }
    }
    function writeTreeRecordContainsPath_(writeRecord, path) {
      if (writeRecord.snap) {
        return pathContains(writeRecord.path, path);
      } else {
        for (var childName in writeRecord.children) {
          if (writeRecord.children.hasOwnProperty(childName) && pathContains(pathChild(writeRecord.path, childName), path)) {
            return true;
          }
        }
        return false;
      }
    }
    function writeTreeResetTree_(writeTree) {
      writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
      if (writeTree.allWrites.length > 0) {
        writeTree.lastWriteId = writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
      } else {
        writeTree.lastWriteId = -1;
      }
    }
    function writeTreeDefaultFilter_(write) {
      return write.visible;
    }
    function writeTreeLayerTree_(writes, filter, treeRoot) {
      var compoundWrite = CompoundWrite.empty();
      for (var i = 0; i < writes.length; ++i) {
        var write = writes[i];
        if (filter(write)) {
          var writePath = write.path;
          var relativePath = void 0;
          if (write.snap) {
            if (pathContains(treeRoot, writePath)) {
              relativePath = newRelativePath(treeRoot, writePath);
              compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);
            } else if (pathContains(writePath, treeRoot)) {
              relativePath = newRelativePath(writePath, treeRoot);
              compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));
            } else
              ;
          } else if (write.children) {
            if (pathContains(treeRoot, writePath)) {
              relativePath = newRelativePath(treeRoot, writePath);
              compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);
            } else if (pathContains(writePath, treeRoot)) {
              relativePath = newRelativePath(writePath, treeRoot);
              if (pathIsEmpty(relativePath)) {
                compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);
              } else {
                var child2 = util.safeGet(write.children, pathGetFront(relativePath));
                if (child2) {
                  var deepNode = child2.getChild(pathPopFront(relativePath));
                  compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
                }
              }
            } else
              ;
          } else {
            throw util.assertionError("WriteRecord should have .snap or .children");
          }
        }
      }
      return compoundWrite;
    }
    function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
      if (!writeIdsToExclude && !includeHiddenWrites) {
        var shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
        if (shadowingNode != null) {
          return shadowingNode;
        } else {
          var subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
          if (compoundWriteIsEmpty(subMerge)) {
            return completeServerCache;
          } else if (completeServerCache == null && !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {
            return null;
          } else {
            var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
            return compoundWriteApply(subMerge, layeredCache);
          }
        }
      } else {
        var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {
          return completeServerCache;
        } else {
          if (!includeHiddenWrites && completeServerCache == null && !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {
            return null;
          } else {
            var filter = function(write) {
              return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (pathContains(write.path, treePath) || pathContains(treePath, write.path));
            };
            var mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
            var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
            return compoundWriteApply(mergeAtPath, layeredCache);
          }
        }
      }
    }
    function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {
      var completeChildren = ChildrenNode.EMPTY_NODE;
      var topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
      if (topLevelSet) {
        if (!topLevelSet.isLeafNode()) {
          topLevelSet.forEachChild(PRIORITY_INDEX, function(childName, childSnap) {
            completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
          });
        }
        return completeChildren;
      } else if (completeServerChildren) {
        var merge_1 = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        completeServerChildren.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
          var node = compoundWriteApply(compoundWriteChildCompoundWrite(merge_1, new Path(childName)), childNode);
          completeChildren = completeChildren.updateImmediateChild(childName, node);
        });
        compoundWriteGetCompleteChildren(merge_1).forEach(function(namedNode) {
          completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
      } else {
        var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        compoundWriteGetCompleteChildren(merge).forEach(function(namedNode) {
          completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
      }
    }
    function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {
      util.assert(existingEventSnap || existingServerSnap, "Either existingEventSnap or existingServerSnap must exist");
      var path = pathChild(treePath, childPath);
      if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {
        return null;
      } else {
        var childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
        if (compoundWriteIsEmpty(childMerge)) {
          return existingServerSnap.getChild(childPath);
        } else {
          return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
        }
      }
    }
    function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {
      var path = pathChild(treePath, childKey);
      var shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
      if (shadowingNode != null) {
        return shadowingNode;
      } else {
        if (existingServerSnap.isCompleteForChild(childKey)) {
          var childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
          return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
        } else {
          return null;
        }
      }
    }
    function writeTreeShadowingWrite(writeTree, path) {
      return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
    }
    function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index2) {
      var toIterate;
      var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
      var shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
      if (shadowingNode != null) {
        toIterate = shadowingNode;
      } else if (completeServerData != null) {
        toIterate = compoundWriteApply(merge, completeServerData);
      } else {
        return [];
      }
      toIterate = toIterate.withIndex(index2);
      if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
        var nodes = [];
        var cmp = index2.getCompare();
        var iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index2) : toIterate.getIteratorFrom(startPost, index2);
        var next = iter.getNext();
        while (next && nodes.length < count) {
          if (cmp(next, startPost) !== 0) {
            nodes.push(next);
          }
          next = iter.getNext();
        }
        return nodes;
      } else {
        return [];
      }
    }
    function newWriteTree() {
      return {
        visibleWrites: CompoundWrite.empty(),
        allWrites: [],
        lastWriteId: -1
      };
    }
    function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
      return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
    }
    function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {
      return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
    }
    function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {
      return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);
    }
    function writeTreeRefShadowingWrite(writeTreeRef, path) {
      return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));
    }
    function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index2) {
      return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index2);
    }
    function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {
      return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
    }
    function writeTreeRefChild(writeTreeRef, childName) {
      return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
    }
    function newWriteTreeRef(path, writeTree) {
      return {
        treePath: path,
        writeTree
      };
    }
    var ChildChangeAccumulator = function() {
      function ChildChangeAccumulator2() {
        this.changeMap = new Map();
      }
      ChildChangeAccumulator2.prototype.trackChildChange = function(change) {
        var type = change.type;
        var childKey = change.childName;
        util.assert(type === "child_added" || type === "child_changed" || type === "child_removed", "Only child changes supported for tracking");
        util.assert(childKey !== ".priority", "Only non-priority child changes can be tracked.");
        var oldChange = this.changeMap.get(childKey);
        if (oldChange) {
          var oldType = oldChange.type;
          if (type === "child_added" && oldType === "child_removed") {
            this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
          } else if (type === "child_removed" && oldType === "child_added") {
            this.changeMap.delete(childKey);
          } else if (type === "child_removed" && oldType === "child_changed") {
            this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
          } else if (type === "child_changed" && oldType === "child_added") {
            this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
          } else if (type === "child_changed" && oldType === "child_changed") {
            this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
          } else {
            throw util.assertionError("Illegal combination of changes: " + change + " occurred after " + oldChange);
          }
        } else {
          this.changeMap.set(childKey, change);
        }
      };
      ChildChangeAccumulator2.prototype.getChanges = function() {
        return Array.from(this.changeMap.values());
      };
      return ChildChangeAccumulator2;
    }();
    var NoCompleteChildSource_ = function() {
      function NoCompleteChildSource_2() {
      }
      NoCompleteChildSource_2.prototype.getCompleteChild = function(childKey) {
        return null;
      };
      NoCompleteChildSource_2.prototype.getChildAfterChild = function(index2, child2, reverse) {
        return null;
      };
      return NoCompleteChildSource_2;
    }();
    var NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
    var WriteTreeCompleteChildSource = function() {
      function WriteTreeCompleteChildSource2(writes_, viewCache_, optCompleteServerCache_) {
        if (optCompleteServerCache_ === void 0) {
          optCompleteServerCache_ = null;
        }
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
      }
      WriteTreeCompleteChildSource2.prototype.getCompleteChild = function(childKey) {
        var node = this.viewCache_.eventCache;
        if (node.isCompleteForChild(childKey)) {
          return node.getNode().getImmediateChild(childKey);
        } else {
          var serverNode = this.optCompleteServerCache_ != null ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.serverCache;
          return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
        }
      };
      WriteTreeCompleteChildSource2.prototype.getChildAfterChild = function(index2, child2, reverse) {
        var completeServerData = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : viewCacheGetCompleteServerSnap(this.viewCache_);
        var nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child2, 1, reverse, index2);
        if (nodes.length === 0) {
          return null;
        } else {
          return nodes[0];
        }
      };
      return WriteTreeCompleteChildSource2;
    }();
    function newViewProcessor(filter) {
      return { filter };
    }
    function viewProcessorAssertIndexed(viewProcessor, viewCache) {
      util.assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Event snap not indexed");
      util.assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Server snap not indexed");
    }
    function viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {
      var accumulator = new ChildChangeAccumulator();
      var newViewCache2, filterServerNode;
      if (operation.type === OperationType.OVERWRITE) {
        var overwrite = operation;
        if (overwrite.source.fromUser) {
          newViewCache2 = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
        } else {
          util.assert(overwrite.source.fromServer, "Unknown source.");
          filterServerNode = overwrite.source.tagged || oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path);
          newViewCache2 = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
        }
      } else if (operation.type === OperationType.MERGE) {
        var merge = operation;
        if (merge.source.fromUser) {
          newViewCache2 = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
        } else {
          util.assert(merge.source.fromServer, "Unknown source.");
          filterServerNode = merge.source.tagged || oldViewCache.serverCache.isFiltered();
          newViewCache2 = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
        }
      } else if (operation.type === OperationType.ACK_USER_WRITE) {
        var ackUserWrite = operation;
        if (!ackUserWrite.revert) {
          newViewCache2 = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
        } else {
          newViewCache2 = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
        }
      } else if (operation.type === OperationType.LISTEN_COMPLETE) {
        newViewCache2 = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
      } else {
        throw util.assertionError("Unknown operation type: " + operation.type);
      }
      var changes = accumulator.getChanges();
      viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, changes);
      return { viewCache: newViewCache2, changes };
    }
    function viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, accumulator) {
      var eventSnap = newViewCache2.eventCache;
      if (eventSnap.isFullyInitialized()) {
        var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
        var oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
        if (accumulator.length > 0 || !oldViewCache.eventCache.isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {
          accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache2)));
        }
      }
    }
    function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {
      var oldEventSnap = viewCache.eventCache;
      if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {
        return viewCache;
      } else {
        var newEventCache = void 0, serverNode = void 0;
        if (pathIsEmpty(changePath)) {
          util.assert(viewCache.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data");
          if (viewCache.serverCache.isFiltered()) {
            var serverCache = viewCacheGetCompleteServerSnap(viewCache);
            var completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;
            var completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
            newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
          } else {
            var completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
            newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
          }
        } else {
          var childKey = pathGetFront(changePath);
          if (childKey === ".priority") {
            util.assert(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
            var oldEventNode = oldEventSnap.getNode();
            serverNode = viewCache.serverCache.getNode();
            var updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
            if (updatedPriority != null) {
              newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
            } else {
              newEventCache = oldEventSnap.getNode();
            }
          } else {
            var childChangePath = pathPopFront(changePath);
            var newEventChild = void 0;
            if (oldEventSnap.isCompleteForChild(childKey)) {
              serverNode = viewCache.serverCache.getNode();
              var eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
              if (eventChildUpdate != null) {
                newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);
              } else {
                newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
              }
            } else {
              newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
            }
            if (newEventChild != null) {
              newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
            } else {
              newEventCache = oldEventSnap.getNode();
            }
          }
        }
        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
      }
    }
    function viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
      var oldServerSnap = oldViewCache.serverCache;
      var newServerCache;
      var serverFilter = filterServerNode ? viewProcessor.filter : viewProcessor.filter.getIndexedFilter();
      if (pathIsEmpty(changePath)) {
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
      } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
        var newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
      } else {
        var childKey = pathGetFront(changePath);
        if (!oldServerSnap.isCompleteForPath(changePath) && pathGetLength(changePath) > 1) {
          return oldViewCache;
        }
        var childChangePath = pathPopFront(changePath);
        var childNode = oldServerSnap.getNode().getImmediateChild(childKey);
        var newChildNode = childNode.updateChild(childChangePath, changedSnap);
        if (childKey === ".priority") {
          newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
        } else {
          newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
        }
      }
      var newViewCache2 = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
      var source = new WriteTreeCompleteChildSource(writesCache, newViewCache2, completeCache);
      return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, changePath, writesCache, source, accumulator);
    }
    function viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
      var oldEventSnap = oldViewCache.eventCache;
      var newViewCache2, newEventCache;
      var source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
      if (pathIsEmpty(changePath)) {
        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
        newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
      } else {
        var childKey = pathGetFront(changePath);
        if (childKey === ".priority") {
          newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
          newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
        } else {
          var childChangePath = pathPopFront(changePath);
          var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
          var newChild = void 0;
          if (pathIsEmpty(childChangePath)) {
            newChild = changedSnap;
          } else {
            var childNode = source.getCompleteChild(childKey);
            if (childNode != null) {
              if (pathGetBack(childChangePath) === ".priority" && childNode.getChild(pathParent(childChangePath)).isEmpty()) {
                newChild = childNode;
              } else {
                newChild = childNode.updateChild(childChangePath, changedSnap);
              }
            } else {
              newChild = ChildrenNode.EMPTY_NODE;
            }
          }
          if (!oldChild.equals(newChild)) {
            var newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
            newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
          } else {
            newViewCache2 = oldViewCache;
          }
        }
      }
      return newViewCache2;
    }
    function viewProcessorCacheHasChild(viewCache, childKey) {
      return viewCache.eventCache.isCompleteForChild(childKey);
    }
    function viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
      var curViewCache = viewCache;
      changedChildren.foreach(function(relativePath, childNode) {
        var writePath = pathChild(path, relativePath);
        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
          curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
      });
      changedChildren.foreach(function(relativePath, childNode) {
        var writePath = pathChild(path, relativePath);
        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
          curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
      });
      return curViewCache;
    }
    function viewProcessorApplyMerge(viewProcessor, node, merge) {
      merge.foreach(function(relativePath, childNode) {
        node = node.updateChild(relativePath, childNode);
      });
      return node;
    }
    function viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
      if (viewCache.serverCache.getNode().isEmpty() && !viewCache.serverCache.isFullyInitialized()) {
        return viewCache;
      }
      var curViewCache = viewCache;
      var viewMergeTree;
      if (pathIsEmpty(path)) {
        viewMergeTree = changedChildren;
      } else {
        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);
      }
      var serverNode = viewCache.serverCache.getNode();
      viewMergeTree.children.inorderTraversal(function(childKey, childTree) {
        if (serverNode.hasChild(childKey)) {
          var serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
          var newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
          curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
      });
      viewMergeTree.children.inorderTraversal(function(childKey, childMergeTree) {
        var isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) && childMergeTree.value === void 0;
        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
          var serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
          var newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
          curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
      });
      return curViewCache;
    }
    function viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
      if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {
        return viewCache;
      }
      var filterServerNode = viewCache.serverCache.isFiltered();
      var serverCache = viewCache.serverCache;
      if (affectedTree.value != null) {
        if (pathIsEmpty(ackPath) && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {
          return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
        } else if (pathIsEmpty(ackPath)) {
          var changedChildren_1 = new ImmutableTree(null);
          serverCache.getNode().forEachChild(KEY_INDEX, function(name2, node) {
            changedChildren_1 = changedChildren_1.set(new Path(name2), node);
          });
          return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);
        } else {
          return viewCache;
        }
      } else {
        var changedChildren_2 = new ImmutableTree(null);
        affectedTree.foreach(function(mergePath, value) {
          var serverCachePath = pathChild(ackPath, mergePath);
          if (serverCache.isCompleteForPath(serverCachePath)) {
            changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));
          }
        });
        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);
      }
    }
    function viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {
      var oldServerNode = viewCache.serverCache;
      var newViewCache2 = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());
      return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
    }
    function viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {
      var complete;
      if (writeTreeRefShadowingWrite(writesCache, path) != null) {
        return viewCache;
      } else {
        var source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
        var oldEventCache = viewCache.eventCache.getNode();
        var newEventCache = void 0;
        if (pathIsEmpty(path) || pathGetFront(path) === ".priority") {
          var newNode = void 0;
          if (viewCache.serverCache.isFullyInitialized()) {
            newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
          } else {
            var serverChildren = viewCache.serverCache.getNode();
            util.assert(serverChildren instanceof ChildrenNode, "serverChildren would be complete if leaf node");
            newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
          }
          newNode = newNode;
          newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
        } else {
          var childKey = pathGetFront(path);
          var newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
          if (newChild == null && viewCache.serverCache.isCompleteForChild(childKey)) {
            newChild = oldEventCache.getImmediateChild(childKey);
          }
          if (newChild != null) {
            newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);
          } else if (viewCache.eventCache.getNode().hasChild(childKey)) {
            newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);
          } else {
            newEventCache = oldEventCache;
          }
          if (newEventCache.isEmpty() && viewCache.serverCache.isFullyInitialized()) {
            complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
            if (complete.isLeafNode()) {
              newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
            }
          }
        }
        complete = viewCache.serverCache.isFullyInitialized() || writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
      }
    }
    var View = function() {
      function View2(query_, initialViewCache) {
        this.query_ = query_;
        this.eventRegistrations_ = [];
        var params = this.query_._queryParams;
        var indexFilter = new IndexedFilter(params.getIndex());
        var filter = queryParamsGetNodeFilter(params);
        this.processor_ = newViewProcessor(filter);
        var initialServerCache = initialViewCache.serverCache;
        var initialEventCache = initialViewCache.eventCache;
        var serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
        var eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
        var newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        var newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        this.viewCache_ = newViewCache(newEventCache, newServerCache);
        this.eventGenerator_ = new EventGenerator(this.query_);
      }
      Object.defineProperty(View2.prototype, "query", {
        get: function() {
          return this.query_;
        },
        enumerable: false,
        configurable: true
      });
      return View2;
    }();
    function viewGetServerCache(view) {
      return view.viewCache_.serverCache.getNode();
    }
    function viewGetCompleteNode(view) {
      return viewCacheGetCompleteEventSnap(view.viewCache_);
    }
    function viewGetCompleteServerCache(view, path) {
      var cache = viewCacheGetCompleteServerSnap(view.viewCache_);
      if (cache) {
        if (view.query._queryParams.loadsAllData() || !pathIsEmpty(path) && !cache.getImmediateChild(pathGetFront(path)).isEmpty()) {
          return cache.getChild(path);
        }
      }
      return null;
    }
    function viewIsEmpty(view) {
      return view.eventRegistrations_.length === 0;
    }
    function viewAddEventRegistration(view, eventRegistration) {
      view.eventRegistrations_.push(eventRegistration);
    }
    function viewRemoveEventRegistration(view, eventRegistration, cancelError) {
      var cancelEvents = [];
      if (cancelError) {
        util.assert(eventRegistration == null, "A cancel should cancel all event registrations.");
        var path_1 = view.query._path;
        view.eventRegistrations_.forEach(function(registration) {
          var maybeEvent = registration.createCancelEvent(cancelError, path_1);
          if (maybeEvent) {
            cancelEvents.push(maybeEvent);
          }
        });
      }
      if (eventRegistration) {
        var remaining = [];
        for (var i = 0; i < view.eventRegistrations_.length; ++i) {
          var existing = view.eventRegistrations_[i];
          if (!existing.matches(eventRegistration)) {
            remaining.push(existing);
          } else if (eventRegistration.hasAnyCallback()) {
            remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));
            break;
          }
        }
        view.eventRegistrations_ = remaining;
      } else {
        view.eventRegistrations_ = [];
      }
      return cancelEvents;
    }
    function viewApplyOperation(view, operation, writesCache, completeServerCache) {
      if (operation.type === OperationType.MERGE && operation.source.queryId !== null) {
        util.assert(viewCacheGetCompleteServerSnap(view.viewCache_), "We should always have a full cache before handling merges");
        util.assert(viewCacheGetCompleteEventSnap(view.viewCache_), "Missing event cache, even though we have a server cache");
      }
      var oldViewCache = view.viewCache_;
      var result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
      viewProcessorAssertIndexed(view.processor_, result.viewCache);
      util.assert(result.viewCache.serverCache.isFullyInitialized() || !oldViewCache.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back");
      view.viewCache_ = result.viewCache;
      return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
    }
    function viewGetInitialEvents(view, registration) {
      var eventSnap = view.viewCache_.eventCache;
      var initialChanges = [];
      if (!eventSnap.getNode().isLeafNode()) {
        var eventNode = eventSnap.getNode();
        eventNode.forEachChild(PRIORITY_INDEX, function(key, childNode) {
          initialChanges.push(changeChildAdded(key, childNode));
        });
      }
      if (eventSnap.isFullyInitialized()) {
        initialChanges.push(changeValue(eventSnap.getNode()));
      }
      return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);
    }
    function viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {
      var registrations = eventRegistration ? [eventRegistration] : view.eventRegistrations_;
      return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
    }
    var referenceConstructor$1;
    var SyncPoint = function() {
      function SyncPoint2() {
        this.views = new Map();
      }
      return SyncPoint2;
    }();
    function syncPointSetReferenceConstructor(val) {
      util.assert(!referenceConstructor$1, "__referenceConstructor has already been defined");
      referenceConstructor$1 = val;
    }
    function syncPointGetReferenceConstructor() {
      util.assert(referenceConstructor$1, "Reference.ts has not been loaded");
      return referenceConstructor$1;
    }
    function syncPointIsEmpty(syncPoint) {
      return syncPoint.views.size === 0;
    }
    function syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {
      var e_1, _a;
      var queryId = operation.source.queryId;
      if (queryId !== null) {
        var view = syncPoint.views.get(queryId);
        util.assert(view != null, "SyncTree gave us an op for an invalid query.");
        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
      } else {
        var events = [];
        try {
          for (var _b = tslib.__values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var view = _c.value;
            events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return events;
      }
    }
    function syncPointGetView(syncPoint, query2, writesCache, serverCache, serverCacheComplete) {
      var queryId = query2._queryIdentifier;
      var view = syncPoint.views.get(queryId);
      if (!view) {
        var eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);
        var eventCacheComplete = false;
        if (eventCache) {
          eventCacheComplete = true;
        } else if (serverCache instanceof ChildrenNode) {
          eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);
          eventCacheComplete = false;
        } else {
          eventCache = ChildrenNode.EMPTY_NODE;
          eventCacheComplete = false;
        }
        var viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
        return new View(query2, viewCache);
      }
      return view;
    }
    function syncPointAddEventRegistration(syncPoint, query2, eventRegistration, writesCache, serverCache, serverCacheComplete) {
      var view = syncPointGetView(syncPoint, query2, writesCache, serverCache, serverCacheComplete);
      if (!syncPoint.views.has(query2._queryIdentifier)) {
        syncPoint.views.set(query2._queryIdentifier, view);
      }
      viewAddEventRegistration(view, eventRegistration);
      return viewGetInitialEvents(view, eventRegistration);
    }
    function syncPointRemoveEventRegistration(syncPoint, query2, eventRegistration, cancelError) {
      var e_2, _a;
      var queryId = query2._queryIdentifier;
      var removed = [];
      var cancelEvents = [];
      var hadCompleteView = syncPointHasCompleteView(syncPoint);
      if (queryId === "default") {
        try {
          for (var _b = tslib.__values(syncPoint.views.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = tslib.__read(_c.value, 2), viewQueryId = _d[0], view = _d[1];
            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
            if (viewIsEmpty(view)) {
              syncPoint.views.delete(viewQueryId);
              if (!view.query._queryParams.loadsAllData()) {
                removed.push(view.query);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      } else {
        var view = syncPoint.views.get(queryId);
        if (view) {
          cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
          if (viewIsEmpty(view)) {
            syncPoint.views.delete(queryId);
            if (!view.query._queryParams.loadsAllData()) {
              removed.push(view.query);
            }
          }
        }
      }
      if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {
        removed.push(new (syncPointGetReferenceConstructor())(query2._repo, query2._path));
      }
      return { removed, events: cancelEvents };
    }
    function syncPointGetQueryViews(syncPoint) {
      var e_3, _a;
      var result = [];
      try {
        for (var _b = tslib.__values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var view = _c.value;
          if (!view.query._queryParams.loadsAllData()) {
            result.push(view);
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return result;
    }
    function syncPointGetCompleteServerCache(syncPoint, path) {
      var e_4, _a;
      var serverCache = null;
      try {
        for (var _b = tslib.__values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var view = _c.value;
          serverCache = serverCache || viewGetCompleteServerCache(view, path);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return serverCache;
    }
    function syncPointViewForQuery(syncPoint, query2) {
      var params = query2._queryParams;
      if (params.loadsAllData()) {
        return syncPointGetCompleteView(syncPoint);
      } else {
        var queryId = query2._queryIdentifier;
        return syncPoint.views.get(queryId);
      }
    }
    function syncPointViewExistsForQuery(syncPoint, query2) {
      return syncPointViewForQuery(syncPoint, query2) != null;
    }
    function syncPointHasCompleteView(syncPoint) {
      return syncPointGetCompleteView(syncPoint) != null;
    }
    function syncPointGetCompleteView(syncPoint) {
      var e_5, _a;
      try {
        for (var _b = tslib.__values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var view = _c.value;
          if (view.query._queryParams.loadsAllData()) {
            return view;
          }
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      return null;
    }
    var referenceConstructor;
    function syncTreeSetReferenceConstructor(val) {
      util.assert(!referenceConstructor, "__referenceConstructor has already been defined");
      referenceConstructor = val;
    }
    function syncTreeGetReferenceConstructor() {
      util.assert(referenceConstructor, "Reference.ts has not been loaded");
      return referenceConstructor;
    }
    var syncTreeNextQueryTag_ = 1;
    var SyncTree = function() {
      function SyncTree2(listenProvider_) {
        this.listenProvider_ = listenProvider_;
        this.syncPointTree_ = new ImmutableTree(null);
        this.pendingWriteTree_ = newWriteTree();
        this.tagToQueryMap = new Map();
        this.queryToTagMap = new Map();
      }
      return SyncTree2;
    }();
    function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {
      writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);
      if (!visible) {
        return [];
      } else {
        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));
      }
    }
    function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {
      writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);
      var changeTree = ImmutableTree.fromObject(changedChildren);
      return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));
    }
    function syncTreeAckUserWrite(syncTree, writeId, revert) {
      if (revert === void 0) {
        revert = false;
      }
      var write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
      var needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
      if (!needToReevaluate) {
        return [];
      } else {
        var affectedTree_1 = new ImmutableTree(null);
        if (write.snap != null) {
          affectedTree_1 = affectedTree_1.set(newEmptyPath(), true);
        } else {
          each2(write.children, function(pathString) {
            affectedTree_1 = affectedTree_1.set(new Path(pathString), true);
          });
        }
        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree_1, revert));
      }
    }
    function syncTreeApplyServerOverwrite(syncTree, path, newData) {
      return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));
    }
    function syncTreeApplyServerMerge(syncTree, path, changedChildren) {
      var changeTree = ImmutableTree.fromObject(changedChildren);
      return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));
    }
    function syncTreeApplyListenComplete(syncTree, path) {
      return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));
    }
    function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {
      var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
      if (queryKey) {
        var r = syncTreeParseQueryKey_(queryKey);
        var queryPath = r.path, queryId = r.queryId;
        var relativePath = newRelativePath(queryPath, path);
        var op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
      } else {
        return [];
      }
    }
    function syncTreeRemoveEventRegistration(syncTree, query2, eventRegistration, cancelError) {
      var path = query2._path;
      var maybeSyncPoint = syncTree.syncPointTree_.get(path);
      var cancelEvents = [];
      if (maybeSyncPoint && (query2._queryIdentifier === "default" || syncPointViewExistsForQuery(maybeSyncPoint, query2))) {
        var removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query2, eventRegistration, cancelError);
        if (syncPointIsEmpty(maybeSyncPoint)) {
          syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);
        }
        var removed = removedAndEvents.removed;
        cancelEvents = removedAndEvents.events;
        var removingDefault = removed.findIndex(function(query3) {
          return query3._queryParams.loadsAllData();
        }) !== -1;
        var covered = syncTree.syncPointTree_.findOnPath(path, function(relativePath, parentSyncPoint) {
          return syncPointHasCompleteView(parentSyncPoint);
        });
        if (removingDefault && !covered) {
          var subtree = syncTree.syncPointTree_.subtree(path);
          if (!subtree.isEmpty()) {
            var newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);
            for (var i = 0; i < newViews.length; ++i) {
              var view = newViews[i], newQuery = view.query;
              var listener = syncTreeCreateListenerForView_(syncTree, view);
              syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery_(syncTree, newQuery), listener.hashFn, listener.onComplete);
            }
          }
        }
        if (!covered && removed.length > 0 && !cancelError) {
          if (removingDefault) {
            var defaultTag = null;
            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query2), defaultTag);
          } else {
            removed.forEach(function(queryToRemove) {
              var tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));
              syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);
            });
          }
        }
        syncTreeRemoveTags_(syncTree, removed);
      }
      return cancelEvents;
    }
    function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {
      var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
      if (queryKey != null) {
        var r = syncTreeParseQueryKey_(queryKey);
        var queryPath = r.path, queryId = r.queryId;
        var relativePath = newRelativePath(queryPath, path);
        var op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
      } else {
        return [];
      }
    }
    function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {
      var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
      if (queryKey) {
        var r = syncTreeParseQueryKey_(queryKey);
        var queryPath = r.path, queryId = r.queryId;
        var relativePath = newRelativePath(queryPath, path);
        var changeTree = ImmutableTree.fromObject(changedChildren);
        var op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
      } else {
        return [];
      }
    }
    function syncTreeAddEventRegistration(syncTree, query2, eventRegistration) {
      var path = query2._path;
      var serverCache = null;
      var foundAncestorDefaultView = false;
      syncTree.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {
        var relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(sp);
      });
      var syncPoint = syncTree.syncPointTree_.get(path);
      if (!syncPoint) {
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
      } else {
        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);
        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
      }
      var serverCacheComplete;
      if (serverCache != null) {
        serverCacheComplete = true;
      } else {
        serverCacheComplete = false;
        serverCache = ChildrenNode.EMPTY_NODE;
        var subtree = syncTree.syncPointTree_.subtree(path);
        subtree.foreachChild(function(childName, childSyncPoint) {
          var completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());
          if (completeCache) {
            serverCache = serverCache.updateImmediateChild(childName, completeCache);
          }
        });
      }
      var viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query2);
      if (!viewAlreadyExists && !query2._queryParams.loadsAllData()) {
        var queryKey = syncTreeMakeQueryKey_(query2);
        util.assert(!syncTree.queryToTagMap.has(queryKey), "View does not exist, but we have a tag");
        var tag = syncTreeGetNextQueryTag_();
        syncTree.queryToTagMap.set(queryKey, tag);
        syncTree.tagToQueryMap.set(tag, queryKey);
      }
      var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);
      var events = syncPointAddEventRegistration(syncPoint, query2, eventRegistration, writesCache, serverCache, serverCacheComplete);
      if (!viewAlreadyExists && !foundAncestorDefaultView) {
        var view = syncPointViewForQuery(syncPoint, query2);
        events = events.concat(syncTreeSetupListener_(syncTree, query2, view));
      }
      return events;
    }
    function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {
      var includeHiddenSets = true;
      var writeTree = syncTree.pendingWriteTree_;
      var serverCache = syncTree.syncPointTree_.findOnPath(path, function(pathSoFar, syncPoint) {
        var relativePath = newRelativePath(pathSoFar, path);
        var serverCache2 = syncPointGetCompleteServerCache(syncPoint, relativePath);
        if (serverCache2) {
          return serverCache2;
        }
      });
      return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);
    }
    function syncTreeGetServerValue(syncTree, query2) {
      var path = query2._path;
      var serverCache = null;
      syncTree.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {
        var relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
      });
      var syncPoint = syncTree.syncPointTree_.get(path);
      if (!syncPoint) {
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
      } else {
        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
      }
      var serverCacheComplete = serverCache != null;
      var serverCacheNode = serverCacheComplete ? new CacheNode(serverCache, true, false) : null;
      var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query2._path);
      var view = syncPointGetView(syncPoint, query2, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);
      return viewGetCompleteNode(view);
    }
    function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {
      return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));
    }
    function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {
      if (pathIsEmpty(operation.path)) {
        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
      } else {
        var syncPoint = syncPointTree.get(newEmptyPath());
        if (serverCache == null && syncPoint != null) {
          serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
        }
        var events = [];
        var childName = pathGetFront(operation.path);
        var childOperation = operation.operationForChild(childName);
        var childTree = syncPointTree.children.get(childName);
        if (childTree && childOperation) {
          var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
          var childWritesCache = writeTreeRefChild(writesCache, childName);
          events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
        if (syncPoint) {
          events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
        }
        return events;
      }
    }
    function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {
      var syncPoint = syncPointTree.get(newEmptyPath());
      if (serverCache == null && syncPoint != null) {
        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
      }
      var events = [];
      syncPointTree.children.inorderTraversal(function(childName, childTree) {
        var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
        var childWritesCache = writeTreeRefChild(writesCache, childName);
        var childOperation = operation.operationForChild(childName);
        if (childOperation) {
          events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
      });
      if (syncPoint) {
        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
      }
      return events;
    }
    function syncTreeCreateListenerForView_(syncTree, view) {
      var query2 = view.query;
      var tag = syncTreeTagForQuery_(syncTree, query2);
      return {
        hashFn: function() {
          var cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;
          return cache.hash();
        },
        onComplete: function(status) {
          if (status === "ok") {
            if (tag) {
              return syncTreeApplyTaggedListenComplete(syncTree, query2._path, tag);
            } else {
              return syncTreeApplyListenComplete(syncTree, query2._path);
            }
          } else {
            var error4 = errorForServerCode(status, query2);
            return syncTreeRemoveEventRegistration(syncTree, query2, null, error4);
          }
        }
      };
    }
    function syncTreeTagForQuery_(syncTree, query2) {
      var queryKey = syncTreeMakeQueryKey_(query2);
      return syncTree.queryToTagMap.get(queryKey);
    }
    function syncTreeMakeQueryKey_(query2) {
      return query2._path.toString() + "$" + query2._queryIdentifier;
    }
    function syncTreeQueryKeyForTag_(syncTree, tag) {
      return syncTree.tagToQueryMap.get(tag);
    }
    function syncTreeParseQueryKey_(queryKey) {
      var splitIndex = queryKey.indexOf("$");
      util.assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, "Bad queryKey.");
      return {
        queryId: queryKey.substr(splitIndex + 1),
        path: new Path(queryKey.substr(0, splitIndex))
      };
    }
    function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {
      var syncPoint = syncTree.syncPointTree_.get(queryPath);
      util.assert(syncPoint, "Missing sync point for query tag that we're tracking");
      var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
      return syncPointApplyOperation(syncPoint, operation, writesCache, null);
    }
    function syncTreeCollectDistinctViewsForSubTree_(subtree) {
      return subtree.fold(function(relativePath, maybeChildSyncPoint, childMap) {
        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
          var completeView = syncPointGetCompleteView(maybeChildSyncPoint);
          return [completeView];
        } else {
          var views_1 = [];
          if (maybeChildSyncPoint) {
            views_1 = syncPointGetQueryViews(maybeChildSyncPoint);
          }
          each2(childMap, function(_key, childViews) {
            views_1 = views_1.concat(childViews);
          });
          return views_1;
        }
      });
    }
    function syncTreeQueryForListening_(query2) {
      if (query2._queryParams.loadsAllData() && !query2._queryParams.isDefault()) {
        return new (syncTreeGetReferenceConstructor())(query2._repo, query2._path);
      } else {
        return query2;
      }
    }
    function syncTreeRemoveTags_(syncTree, queries) {
      for (var j = 0; j < queries.length; ++j) {
        var removedQuery = queries[j];
        if (!removedQuery._queryParams.loadsAllData()) {
          var removedQueryKey = syncTreeMakeQueryKey_(removedQuery);
          var removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);
          syncTree.queryToTagMap.delete(removedQueryKey);
          syncTree.tagToQueryMap.delete(removedQueryTag);
        }
      }
    }
    function syncTreeGetNextQueryTag_() {
      return syncTreeNextQueryTag_++;
    }
    function syncTreeSetupListener_(syncTree, query2, view) {
      var path = query2._path;
      var tag = syncTreeTagForQuery_(syncTree, query2);
      var listener = syncTreeCreateListenerForView_(syncTree, view);
      var events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query2), tag, listener.hashFn, listener.onComplete);
      var subtree = syncTree.syncPointTree_.subtree(path);
      if (tag) {
        util.assert(!syncPointHasCompleteView(subtree.value), "If we're adding a query, it shouldn't be shadowed");
      } else {
        var queriesToStop = subtree.fold(function(relativePath, maybeChildSyncPoint, childMap) {
          if (!pathIsEmpty(relativePath) && maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
            return [syncPointGetCompleteView(maybeChildSyncPoint).query];
          } else {
            var queries_1 = [];
            if (maybeChildSyncPoint) {
              queries_1 = queries_1.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(function(view2) {
                return view2.query;
              }));
            }
            each2(childMap, function(_key, childQueries) {
              queries_1 = queries_1.concat(childQueries);
            });
            return queries_1;
          }
        });
        for (var i = 0; i < queriesToStop.length; ++i) {
          var queryToStop = queriesToStop[i];
          syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery_(syncTree, queryToStop));
        }
      }
      return events;
    }
    var ExistingValueProvider = function() {
      function ExistingValueProvider2(node_) {
        this.node_ = node_;
      }
      ExistingValueProvider2.prototype.getImmediateChild = function(childName) {
        var child2 = this.node_.getImmediateChild(childName);
        return new ExistingValueProvider2(child2);
      };
      ExistingValueProvider2.prototype.node = function() {
        return this.node_;
      };
      return ExistingValueProvider2;
    }();
    var DeferredValueProvider = function() {
      function DeferredValueProvider2(syncTree, path) {
        this.syncTree_ = syncTree;
        this.path_ = path;
      }
      DeferredValueProvider2.prototype.getImmediateChild = function(childName) {
        var childPath = pathChild(this.path_, childName);
        return new DeferredValueProvider2(this.syncTree_, childPath);
      };
      DeferredValueProvider2.prototype.node = function() {
        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
      };
      return DeferredValueProvider2;
    }();
    var generateWithValues = function(values) {
      values = values || {};
      values["timestamp"] = values["timestamp"] || new Date().getTime();
      return values;
    };
    var resolveDeferredLeafValue = function(value, existingVal, serverValues) {
      if (!value || typeof value !== "object") {
        return value;
      }
      util.assert(".sv" in value, "Unexpected leaf node or priority contents");
      if (typeof value[".sv"] === "string") {
        return resolveScalarDeferredValue(value[".sv"], existingVal, serverValues);
      } else if (typeof value[".sv"] === "object") {
        return resolveComplexDeferredValue(value[".sv"], existingVal);
      } else {
        util.assert(false, "Unexpected server value: " + JSON.stringify(value, null, 2));
      }
    };
    var resolveScalarDeferredValue = function(op, existing, serverValues) {
      switch (op) {
        case "timestamp":
          return serverValues["timestamp"];
        default:
          util.assert(false, "Unexpected server value: " + op);
      }
    };
    var resolveComplexDeferredValue = function(op, existing, unused) {
      if (!op.hasOwnProperty("increment")) {
        util.assert(false, "Unexpected server value: " + JSON.stringify(op, null, 2));
      }
      var delta = op["increment"];
      if (typeof delta !== "number") {
        util.assert(false, "Unexpected increment value: " + delta);
      }
      var existingNode = existing.node();
      util.assert(existingNode !== null && typeof existingNode !== "undefined", "Expected ChildrenNode.EMPTY_NODE for nulls");
      if (!existingNode.isLeafNode()) {
        return delta;
      }
      var leaf = existingNode;
      var existingVal = leaf.getValue();
      if (typeof existingVal !== "number") {
        return delta;
      }
      return existingVal + delta;
    };
    var resolveDeferredValueTree = function(path, node, syncTree, serverValues) {
      return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);
    };
    var resolveDeferredValueSnapshot = function(node, existing, serverValues) {
      return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
    };
    function resolveDeferredValue(node, existingVal, serverValues) {
      var rawPri = node.getPriority().val();
      var priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild(".priority"), serverValues);
      var newNode;
      if (node.isLeafNode()) {
        var leafNode = node;
        var value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
        if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {
          return new LeafNode(value, nodeFromJSON(priority));
        } else {
          return node;
        }
      } else {
        var childrenNode = node;
        newNode = childrenNode;
        if (priority !== childrenNode.getPriority().val()) {
          newNode = newNode.updatePriority(new LeafNode(priority));
        }
        childrenNode.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
          var newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
          if (newChildNode !== childNode) {
            newNode = newNode.updateImmediateChild(childName, newChildNode);
          }
        });
        return newNode;
      }
    }
    var Tree = function() {
      function Tree2(name2, parent, node) {
        if (name2 === void 0) {
          name2 = "";
        }
        if (parent === void 0) {
          parent = null;
        }
        if (node === void 0) {
          node = { children: {}, childCount: 0 };
        }
        this.name = name2;
        this.parent = parent;
        this.node = node;
      }
      return Tree2;
    }();
    function treeSubTree(tree, pathObj) {
      var path = pathObj instanceof Path ? pathObj : new Path(pathObj);
      var child2 = tree, next = pathGetFront(path);
      while (next !== null) {
        var childNode = util.safeGet(child2.node.children, next) || {
          children: {},
          childCount: 0
        };
        child2 = new Tree(next, child2, childNode);
        path = pathPopFront(path);
        next = pathGetFront(path);
      }
      return child2;
    }
    function treeGetValue(tree) {
      return tree.node.value;
    }
    function treeSetValue(tree, value) {
      tree.node.value = value;
      treeUpdateParents(tree);
    }
    function treeHasChildren(tree) {
      return tree.node.childCount > 0;
    }
    function treeIsEmpty(tree) {
      return treeGetValue(tree) === void 0 && !treeHasChildren(tree);
    }
    function treeForEachChild(tree, action) {
      each2(tree.node.children, function(child2, childTree) {
        action(new Tree(child2, tree, childTree));
      });
    }
    function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {
      if (includeSelf && !childrenFirst) {
        action(tree);
      }
      treeForEachChild(tree, function(child2) {
        treeForEachDescendant(child2, action, true, childrenFirst);
      });
      if (includeSelf && childrenFirst) {
        action(tree);
      }
    }
    function treeForEachAncestor(tree, action, includeSelf) {
      var node = includeSelf ? tree : tree.parent;
      while (node !== null) {
        if (action(node)) {
          return true;
        }
        node = node.parent;
      }
      return false;
    }
    function treeGetPath(tree) {
      return new Path(tree.parent === null ? tree.name : treeGetPath(tree.parent) + "/" + tree.name);
    }
    function treeUpdateParents(tree) {
      if (tree.parent !== null) {
        treeUpdateChild(tree.parent, tree.name, tree);
      }
    }
    function treeUpdateChild(tree, childName, child2) {
      var childEmpty = treeIsEmpty(child2);
      var childExists = util.contains(tree.node.children, childName);
      if (childEmpty && childExists) {
        delete tree.node.children[childName];
        tree.node.childCount--;
        treeUpdateParents(tree);
      } else if (!childEmpty && !childExists) {
        tree.node.children[childName] = child2.node;
        tree.node.childCount++;
        treeUpdateParents(tree);
      }
    }
    var INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
    var INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
    var MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
    var isValidKey = function(key) {
      return typeof key === "string" && key.length !== 0 && !INVALID_KEY_REGEX_.test(key);
    };
    var isValidPathString = function(pathString) {
      return typeof pathString === "string" && pathString.length !== 0 && !INVALID_PATH_REGEX_.test(pathString);
    };
    var isValidRootPathString = function(pathString) {
      if (pathString) {
        pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
      }
      return isValidPathString(pathString);
    };
    var isValidPriority = function(priority) {
      return priority === null || typeof priority === "string" || typeof priority === "number" && !isInvalidJSONNumber(priority) || priority && typeof priority === "object" && util.contains(priority, ".sv");
    };
    var validateFirebaseDataArg = function(fnName, value, path, optional) {
      if (optional && value === void 0) {
        return;
      }
      validateFirebaseData(util.errorPrefix(fnName, "value"), value, path);
    };
    var validateFirebaseData = function(errorPrefix, data, path_) {
      var path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;
      if (data === void 0) {
        throw new Error(errorPrefix + "contains undefined " + validationPathToErrorString(path));
      }
      if (typeof data === "function") {
        throw new Error(errorPrefix + "contains a function " + validationPathToErrorString(path) + " with contents = " + data.toString());
      }
      if (isInvalidJSONNumber(data)) {
        throw new Error(errorPrefix + "contains " + data.toString() + " " + validationPathToErrorString(path));
      }
      if (typeof data === "string" && data.length > MAX_LEAF_SIZE_ / 3 && util.stringLength(data) > MAX_LEAF_SIZE_) {
        throw new Error(errorPrefix + "contains a string greater than " + MAX_LEAF_SIZE_ + " utf8 bytes " + validationPathToErrorString(path) + " ('" + data.substring(0, 50) + "...')");
      }
      if (data && typeof data === "object") {
        var hasDotValue_1 = false;
        var hasActualChild_1 = false;
        each2(data, function(key, value) {
          if (key === ".value") {
            hasDotValue_1 = true;
          } else if (key !== ".priority" && key !== ".sv") {
            hasActualChild_1 = true;
            if (!isValidKey(key)) {
              throw new Error(errorPrefix + " contains an invalid key (" + key + ") " + validationPathToErrorString(path) + `.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
            }
          }
          validationPathPush(path, key);
          validateFirebaseData(errorPrefix, value, path);
          validationPathPop(path);
        });
        if (hasDotValue_1 && hasActualChild_1) {
          throw new Error(errorPrefix + ' contains ".value" child ' + validationPathToErrorString(path) + " in addition to actual children.");
        }
      }
    };
    var validateFirebaseMergePaths = function(errorPrefix, mergePaths) {
      var i, curPath;
      for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        var keys = pathSlice(curPath);
        for (var j = 0; j < keys.length; j++) {
          if (keys[j] === ".priority" && j === keys.length - 1)
            ;
          else if (!isValidKey(keys[j])) {
            throw new Error(errorPrefix + "contains an invalid key (" + keys[j] + ") in path " + curPath.toString() + `. Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
          }
        }
      }
      mergePaths.sort(pathCompare);
      var prevPath = null;
      for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        if (prevPath !== null && pathContains(prevPath, curPath)) {
          throw new Error(errorPrefix + "contains a path " + prevPath.toString() + " that is ancestor of another path " + curPath.toString());
        }
        prevPath = curPath;
      }
    };
    var validateFirebaseMergeDataArg = function(fnName, data, path, optional) {
      if (optional && data === void 0) {
        return;
      }
      var errorPrefix = util.errorPrefix(fnName, "values");
      if (!(data && typeof data === "object") || Array.isArray(data)) {
        throw new Error(errorPrefix + " must be an object containing the children to replace.");
      }
      var mergePaths = [];
      each2(data, function(key, value) {
        var curPath = new Path(key);
        validateFirebaseData(errorPrefix, value, pathChild(path, curPath));
        if (pathGetBack(curPath) === ".priority") {
          if (!isValidPriority(value)) {
            throw new Error(errorPrefix + "contains an invalid value for '" + curPath.toString() + "', which must be a valid Firebase priority (a string, finite number, server value, or null).");
          }
        }
        mergePaths.push(curPath);
      });
      validateFirebaseMergePaths(errorPrefix, mergePaths);
    };
    var validatePriority = function(fnName, priority, optional) {
      if (optional && priority === void 0) {
        return;
      }
      if (isInvalidJSONNumber(priority)) {
        throw new Error(util.errorPrefix(fnName, "priority") + "is " + priority.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null).");
      }
      if (!isValidPriority(priority)) {
        throw new Error(util.errorPrefix(fnName, "priority") + "must be a valid Firebase priority (a string, finite number, server value, or null).");
      }
    };
    var validateEventType = function(fnName, eventType, optional) {
      if (optional && eventType === void 0) {
        return;
      }
      switch (eventType) {
        case "value":
        case "child_added":
        case "child_removed":
        case "child_changed":
        case "child_moved":
          break;
        default:
          throw new Error(util.errorPrefix(fnName, "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
      }
    };
    var validateKey = function(fnName, argumentName, key, optional) {
      if (optional && key === void 0) {
        return;
      }
      if (!isValidKey(key)) {
        throw new Error(util.errorPrefix(fnName, argumentName) + 'was an invalid key = "' + key + `".  Firebase keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]").`);
      }
    };
    var validatePathString = function(fnName, argumentName, pathString, optional) {
      if (optional && pathString === void 0) {
        return;
      }
      if (!isValidPathString(pathString)) {
        throw new Error(util.errorPrefix(fnName, argumentName) + 'was an invalid path = "' + pathString + `". Paths must be non-empty strings and can't contain ".", "#", "$", "[", or "]"`);
      }
    };
    var validateRootPathString = function(fnName, argumentName, pathString, optional) {
      if (pathString) {
        pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
      }
      validatePathString(fnName, argumentName, pathString, optional);
    };
    var validateWritablePath = function(fnName, path) {
      if (pathGetFront(path) === ".info") {
        throw new Error(fnName + " failed = Can't modify data under /.info/");
      }
    };
    var validateUrl = function(fnName, parsedUrl) {
      var pathString = parsedUrl.path.toString();
      if (!(typeof parsedUrl.repoInfo.host === "string") || parsedUrl.repoInfo.host.length === 0 || !isValidKey(parsedUrl.repoInfo.namespace) && parsedUrl.repoInfo.host.split(":")[0] !== "localhost" || pathString.length !== 0 && !isValidRootPathString(pathString)) {
        throw new Error(util.errorPrefix(fnName, "url") + `must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`);
      }
    };
    var validateBoolean = function(fnName, argumentName, bool, optional) {
      if (optional && bool === void 0) {
        return;
      }
      if (typeof bool !== "boolean") {
        throw new Error(util.errorPrefix(fnName, argumentName) + "must be a boolean.");
      }
    };
    var EventQueue = function() {
      function EventQueue2() {
        this.eventLists_ = [];
        this.recursionDepth_ = 0;
      }
      return EventQueue2;
    }();
    function eventQueueQueueEvents(eventQueue, eventDataList) {
      var currList = null;
      for (var i = 0; i < eventDataList.length; i++) {
        var data = eventDataList[i];
        var path = data.getPath();
        if (currList !== null && !pathEquals(path, currList.path)) {
          eventQueue.eventLists_.push(currList);
          currList = null;
        }
        if (currList === null) {
          currList = { events: [], path };
        }
        currList.events.push(data);
      }
      if (currList) {
        eventQueue.eventLists_.push(currList);
      }
    }
    function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {
      eventQueueQueueEvents(eventQueue, eventDataList);
      eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, function(eventPath) {
        return pathEquals(eventPath, path);
      });
    }
    function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {
      eventQueueQueueEvents(eventQueue, eventDataList);
      eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, function(eventPath) {
        return pathContains(eventPath, changedPath) || pathContains(changedPath, eventPath);
      });
    }
    function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {
      eventQueue.recursionDepth_++;
      var sentAll = true;
      for (var i = 0; i < eventQueue.eventLists_.length; i++) {
        var eventList = eventQueue.eventLists_[i];
        if (eventList) {
          var eventPath = eventList.path;
          if (predicate(eventPath)) {
            eventListRaise(eventQueue.eventLists_[i]);
            eventQueue.eventLists_[i] = null;
          } else {
            sentAll = false;
          }
        }
      }
      if (sentAll) {
        eventQueue.eventLists_ = [];
      }
      eventQueue.recursionDepth_--;
    }
    function eventListRaise(eventList) {
      for (var i = 0; i < eventList.events.length; i++) {
        var eventData = eventList.events[i];
        if (eventData !== null) {
          eventList.events[i] = null;
          var eventFn = eventData.getEventRunner();
          if (logger) {
            log("event: " + eventData.toString());
          }
          exceptionGuard(eventFn);
        }
      }
    }
    var INTERRUPT_REASON = "repo_interrupt";
    var MAX_TRANSACTION_RETRIES = 25;
    var Repo = function() {
      function Repo2(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {
        this.repoInfo_ = repoInfo_;
        this.forceRestClient_ = forceRestClient_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckProvider_ = appCheckProvider_;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        this.onDisconnect_ = newSparseSnapshotTree();
        this.transactionQueueTree_ = new Tree();
        this.persistentConnection_ = null;
        this.key = this.repoInfo_.toURLString();
      }
      Repo2.prototype.toString = function() {
        return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host;
      };
      return Repo2;
    }();
    function repoStart(repo, appId, authOverride) {
      repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
      if (repo.forceRestClient_ || beingCrawled()) {
        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, function(pathString, data, isMerge, tag) {
          repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, repo.authTokenProvider_, repo.appCheckProvider_);
        setTimeout(function() {
          return repoOnConnectStatus(repo, true);
        }, 0);
      } else {
        if (typeof authOverride !== "undefined" && authOverride !== null) {
          if (typeof authOverride !== "object") {
            throw new Error("Only objects are supported for option databaseAuthVariableOverride");
          }
          try {
            util.stringify(authOverride);
          } catch (e) {
            throw new Error("Invalid authOverride provided: " + e);
          }
        }
        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, function(pathString, data, isMerge, tag) {
          repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, function(connectStatus) {
          repoOnConnectStatus(repo, connectStatus);
        }, function(updates) {
          repoOnServerInfoUpdate(repo, updates);
        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);
        repo.server_ = repo.persistentConnection_;
      }
      repo.authTokenProvider_.addTokenChangeListener(function(token) {
        repo.server_.refreshAuthToken(token);
      });
      repo.appCheckProvider_.addTokenChangeListener(function(result) {
        repo.server_.refreshAppCheckToken(result.token);
      });
      repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, function() {
        return new StatsReporter(repo.stats_, repo.server_);
      });
      repo.infoData_ = new SnapshotHolder();
      repo.infoSyncTree_ = new SyncTree({
        startListening: function(query2, tag, currentHashFn, onComplete) {
          var infoEvents = [];
          var node = repo.infoData_.getNode(query2._path);
          if (!node.isEmpty()) {
            infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query2._path, node);
            setTimeout(function() {
              onComplete("ok");
            }, 0);
          }
          return infoEvents;
        },
        stopListening: function() {
        }
      });
      repoUpdateInfo(repo, "connected", false);
      repo.serverSyncTree_ = new SyncTree({
        startListening: function(query2, tag, currentHashFn, onComplete) {
          repo.server_.listen(query2, currentHashFn, tag, function(status, data) {
            var events = onComplete(status, data);
            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query2._path, events);
          });
          return [];
        },
        stopListening: function(query2, tag) {
          repo.server_.unlisten(query2, tag);
        }
      });
    }
    function repoServerTime(repo) {
      var offsetNode = repo.infoData_.getNode(new Path(".info/serverTimeOffset"));
      var offset = offsetNode.val() || 0;
      return new Date().getTime() + offset;
    }
    function repoGenerateServerValues(repo) {
      return generateWithValues({
        timestamp: repoServerTime(repo)
      });
    }
    function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {
      repo.dataUpdateCount++;
      var path = new Path(pathString);
      data = repo.interceptServerDataCallback_ ? repo.interceptServerDataCallback_(pathString, data) : data;
      var events = [];
      if (tag) {
        if (isMerge) {
          var taggedChildren = util.map(data, function(raw) {
            return nodeFromJSON(raw);
          });
          events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);
        } else {
          var taggedSnap = nodeFromJSON(data);
          events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);
        }
      } else if (isMerge) {
        var changedChildren = util.map(data, function(raw) {
          return nodeFromJSON(raw);
        });
        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);
      } else {
        var snap = nodeFromJSON(data);
        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);
      }
      var affectedPath = path;
      if (events.length > 0) {
        affectedPath = repoRerunTransactions(repo, path);
      }
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);
    }
    function repoInterceptServerData(repo, callback) {
      repo.interceptServerDataCallback_ = callback;
    }
    function repoOnConnectStatus(repo, connectStatus) {
      repoUpdateInfo(repo, "connected", connectStatus);
      if (connectStatus === false) {
        repoRunOnDisconnectEvents(repo);
      }
    }
    function repoOnServerInfoUpdate(repo, updates) {
      each2(updates, function(key, value) {
        repoUpdateInfo(repo, key, value);
      });
    }
    function repoUpdateInfo(repo, pathString, value) {
      var path = new Path("/.info/" + pathString);
      var newNode = nodeFromJSON(value);
      repo.infoData_.updateSnapshot(path, newNode);
      var events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
    }
    function repoGetNextWriteId(repo) {
      return repo.nextWriteId_++;
    }
    function repoGetValue(repo, query2) {
      var cached = syncTreeGetServerValue(repo.serverSyncTree_, query2);
      if (cached != null) {
        return Promise.resolve(cached);
      }
      return repo.server_.get(query2).then(function(payload) {
        var node = nodeFromJSON(payload).withIndex(query2._queryParams.getIndex());
        var events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query2._path, node);
        eventQueueRaiseEventsAtPath(repo.eventQueue_, query2._path, events);
        return Promise.resolve(node);
      }, function(err) {
        repoLog(repo, "get for query " + util.stringify(query2) + " failed: " + err);
        return Promise.reject(new Error(err));
      });
    }
    function repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {
      repoLog(repo, "set", {
        path: path.toString(),
        value: newVal,
        priority: newPriority
      });
      var serverValues = repoGenerateServerValues(repo);
      var newNodeUnresolved = nodeFromJSON(newVal, newPriority);
      var existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);
      var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);
      var writeId = repoGetNextWriteId(repo);
      var events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);
      eventQueueQueueEvents(repo.eventQueue_, events);
      repo.server_.put(path.toString(), newNodeUnresolved.val(true), function(status, errorReason) {
        var success = status === "ok";
        if (!success) {
          warn("set at " + path + " failed: " + status);
        }
        var clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
      var affectedPath = repoAbortTransactions(repo, path);
      repoRerunTransactions(repo, affectedPath);
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);
    }
    function repoUpdate(repo, path, childrenToMerge, onComplete) {
      repoLog(repo, "update", { path: path.toString(), value: childrenToMerge });
      var empty2 = true;
      var serverValues = repoGenerateServerValues(repo);
      var changedChildren = {};
      each2(childrenToMerge, function(changedKey, changedValue) {
        empty2 = false;
        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);
      });
      if (!empty2) {
        var writeId_1 = repoGetNextWriteId(repo);
        var events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId_1);
        eventQueueQueueEvents(repo.eventQueue_, events);
        repo.server_.merge(path.toString(), childrenToMerge, function(status, errorReason) {
          var success = status === "ok";
          if (!success) {
            warn("update at " + path + " failed: " + status);
          }
          var clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId_1, !success);
          var affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;
          eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);
          repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
        });
        each2(childrenToMerge, function(changedPath) {
          var affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));
          repoRerunTransactions(repo, affectedPath);
        });
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);
      } else {
        log("update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, "ok", void 0);
      }
    }
    function repoRunOnDisconnectEvents(repo) {
      repoLog(repo, "onDisconnectEvents");
      var serverValues = repoGenerateServerValues(repo);
      var resolvedOnDisconnectTree = newSparseSnapshotTree();
      sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), function(path, node) {
        var resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);
        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);
      });
      var events = [];
      sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), function(path, snap) {
        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));
        var affectedPath = repoAbortTransactions(repo, path);
        repoRerunTransactions(repo, affectedPath);
      });
      repo.onDisconnect_ = newSparseSnapshotTree();
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);
    }
    function repoOnDisconnectCancel(repo, path, onComplete) {
      repo.server_.onDisconnectCancel(path.toString(), function(status, errorReason) {
        if (status === "ok") {
          sparseSnapshotTreeForget(repo.onDisconnect_, path);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
    }
    function repoOnDisconnectSet(repo, path, value, onComplete) {
      var newNode = nodeFromJSON(value);
      repo.server_.onDisconnectPut(path.toString(), newNode.val(true), function(status, errorReason) {
        if (status === "ok") {
          sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
    }
    function repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {
      var newNode = nodeFromJSON(value, priority);
      repo.server_.onDisconnectPut(path.toString(), newNode.val(true), function(status, errorReason) {
        if (status === "ok") {
          sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
    }
    function repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {
      if (util.isEmpty(childrenToMerge)) {
        log("onDisconnect().update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, "ok", void 0);
        return;
      }
      repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, function(status, errorReason) {
        if (status === "ok") {
          each2(childrenToMerge, function(childName, childNode) {
            var newChildNode = nodeFromJSON(childNode);
            sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);
          });
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
    }
    function repoAddEventCallbackForQuery(repo, query2, eventRegistration) {
      var events;
      if (pathGetFront(query2._path) === ".info") {
        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query2, eventRegistration);
      } else {
        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query2, eventRegistration);
      }
      eventQueueRaiseEventsAtPath(repo.eventQueue_, query2._path, events);
    }
    function repoRemoveEventCallbackForQuery(repo, query2, eventRegistration) {
      var events;
      if (pathGetFront(query2._path) === ".info") {
        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query2, eventRegistration);
      } else {
        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query2, eventRegistration);
      }
      eventQueueRaiseEventsAtPath(repo.eventQueue_, query2._path, events);
    }
    function repoInterrupt(repo) {
      if (repo.persistentConnection_) {
        repo.persistentConnection_.interrupt(INTERRUPT_REASON);
      }
    }
    function repoResume(repo) {
      if (repo.persistentConnection_) {
        repo.persistentConnection_.resume(INTERRUPT_REASON);
      }
    }
    function repoStats(repo, showDelta) {
      if (showDelta === void 0) {
        showDelta = false;
      }
      if (typeof console === "undefined") {
        return;
      }
      var stats2;
      if (showDelta) {
        if (!repo.statsListener_) {
          repo.statsListener_ = new StatsListener(repo.stats_);
        }
        stats2 = repo.statsListener_.get();
      } else {
        stats2 = repo.stats_.get();
      }
      var longestName = Object.keys(stats2).reduce(function(previousValue, currentValue) {
        return Math.max(currentValue.length, previousValue);
      }, 0);
      each2(stats2, function(stat, value) {
        var paddedStat = stat;
        for (var i = stat.length; i < longestName + 2; i++) {
          paddedStat += " ";
        }
        console.log(paddedStat + value);
      });
    }
    function repoStatsIncrementCounter(repo, metric) {
      repo.stats_.incrementCounter(metric);
      statsReporterIncludeStat(repo.statsReporter_, metric);
    }
    function repoLog(repo) {
      var varArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        varArgs[_i - 1] = arguments[_i];
      }
      var prefix = "";
      if (repo.persistentConnection_) {
        prefix = repo.persistentConnection_.id + ":";
      }
      log.apply(void 0, tslib.__spreadArray([prefix], tslib.__read(varArgs)));
    }
    function repoCallOnCompleteCallback(repo, callback, status, errorReason) {
      if (callback) {
        exceptionGuard(function() {
          if (status === "ok") {
            callback(null);
          } else {
            var code = (status || "error").toUpperCase();
            var message = code;
            if (errorReason) {
              message += ": " + errorReason;
            }
            var error4 = new Error(message);
            error4.code = code;
            callback(error4);
          }
        });
      }
    }
    function repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {
      repoLog(repo, "transaction on " + path);
      var transaction = {
        path,
        update: transactionUpdate,
        onComplete,
        status: null,
        order: LUIDGenerator(),
        applyLocally,
        retryCount: 0,
        unwatcher,
        abortReason: null,
        currentWriteId: null,
        currentInputSnapshot: null,
        currentOutputSnapshotRaw: null,
        currentOutputSnapshotResolved: null
      };
      var currentState = repoGetLatestState(repo, path, void 0);
      transaction.currentInputSnapshot = currentState;
      var newVal = transaction.update(currentState.val());
      if (newVal === void 0) {
        transaction.unwatcher();
        transaction.currentOutputSnapshotRaw = null;
        transaction.currentOutputSnapshotResolved = null;
        if (transaction.onComplete) {
          transaction.onComplete(null, false, transaction.currentInputSnapshot);
        }
      } else {
        validateFirebaseData("transaction failed: Data returned ", newVal, transaction.path);
        transaction.status = 0;
        var queueNode = treeSubTree(repo.transactionQueueTree_, path);
        var nodeQueue = treeGetValue(queueNode) || [];
        nodeQueue.push(transaction);
        treeSetValue(queueNode, nodeQueue);
        var priorityForNode = void 0;
        if (typeof newVal === "object" && newVal !== null && util.contains(newVal, ".priority")) {
          priorityForNode = util.safeGet(newVal, ".priority");
          util.assert(isValidPriority(priorityForNode), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.");
        } else {
          var currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) || ChildrenNode.EMPTY_NODE;
          priorityForNode = currentNode.getPriority().val();
        }
        var serverValues = repoGenerateServerValues(repo);
        var newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);
        var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);
        transaction.currentOutputSnapshotRaw = newNodeUnresolved;
        transaction.currentOutputSnapshotResolved = newNode;
        transaction.currentWriteId = repoGetNextWriteId(repo);
        var events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        repoSendReadyTransactions(repo, repo.transactionQueueTree_);
      }
    }
    function repoGetLatestState(repo, path, excludeSets) {
      return syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) || ChildrenNode.EMPTY_NODE;
    }
    function repoSendReadyTransactions(repo, node) {
      if (node === void 0) {
        node = repo.transactionQueueTree_;
      }
      if (!node) {
        repoPruneCompletedTransactionsBelowNode(repo, node);
      }
      if (treeGetValue(node)) {
        var queue = repoBuildTransactionQueue(repo, node);
        util.assert(queue.length > 0, "Sending zero length transaction queue");
        var allRun = queue.every(function(transaction) {
          return transaction.status === 0;
        });
        if (allRun) {
          repoSendTransactionQueue(repo, treeGetPath(node), queue);
        }
      } else if (treeHasChildren(node)) {
        treeForEachChild(node, function(childNode) {
          repoSendReadyTransactions(repo, childNode);
        });
      }
    }
    function repoSendTransactionQueue(repo, path, queue) {
      var setsToIgnore = queue.map(function(txn2) {
        return txn2.currentWriteId;
      });
      var latestState = repoGetLatestState(repo, path, setsToIgnore);
      var snapToSend = latestState;
      var latestHash = latestState.hash();
      for (var i = 0; i < queue.length; i++) {
        var txn = queue[i];
        util.assert(txn.status === 0, "tryToSendTransactionQueue_: items in queue should all be run.");
        txn.status = 1;
        txn.retryCount++;
        var relativePath = newRelativePath(path, txn.path);
        snapToSend = snapToSend.updateChild(relativePath, txn.currentOutputSnapshotRaw);
      }
      var dataToSend = snapToSend.val(true);
      var pathToSend = path;
      repo.server_.put(pathToSend.toString(), dataToSend, function(status) {
        repoLog(repo, "transaction put response", {
          path: pathToSend.toString(),
          status
        });
        var events = [];
        if (status === "ok") {
          var callbacks = [];
          var _loop_1 = function(i3) {
            queue[i3].status = 2;
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i3].currentWriteId));
            if (queue[i3].onComplete) {
              callbacks.push(function() {
                return queue[i3].onComplete(null, true, queue[i3].currentOutputSnapshotResolved);
              });
            }
            queue[i3].unwatcher();
          };
          for (var i2 = 0; i2 < queue.length; i2++) {
            _loop_1(i2);
          }
          repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));
          repoSendReadyTransactions(repo, repo.transactionQueueTree_);
          eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
          for (var i2 = 0; i2 < callbacks.length; i2++) {
            exceptionGuard(callbacks[i2]);
          }
        } else {
          if (status === "datastale") {
            for (var i2 = 0; i2 < queue.length; i2++) {
              if (queue[i2].status === 3) {
                queue[i2].status = 4;
              } else {
                queue[i2].status = 0;
              }
            }
          } else {
            warn("transaction at " + pathToSend.toString() + " failed: " + status);
            for (var i2 = 0; i2 < queue.length; i2++) {
              queue[i2].status = 4;
              queue[i2].abortReason = status;
            }
          }
          repoRerunTransactions(repo, path);
        }
      }, latestHash);
    }
    function repoRerunTransactions(repo, changedPath) {
      var rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
      var path = treeGetPath(rootMostTransactionNode);
      var queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);
      repoRerunTransactionQueue(repo, queue, path);
      return path;
    }
    function repoRerunTransactionQueue(repo, queue, path) {
      if (queue.length === 0) {
        return;
      }
      var callbacks = [];
      var events = [];
      var txnsToRerun = queue.filter(function(q) {
        return q.status === 0;
      });
      var setsToIgnore = txnsToRerun.map(function(q) {
        return q.currentWriteId;
      });
      var _loop_2 = function(i2) {
        var transaction = queue[i2];
        var relativePath = newRelativePath(path, transaction.path);
        var abortTransaction = false, abortReason;
        util.assert(relativePath !== null, "rerunTransactionsUnderNode_: relativePath should not be null.");
        if (transaction.status === 4) {
          abortTransaction = true;
          abortReason = transaction.abortReason;
          events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
        } else if (transaction.status === 0) {
          if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {
            abortTransaction = true;
            abortReason = "maxretry";
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
          } else {
            var currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
            transaction.currentInputSnapshot = currentNode;
            var newData = queue[i2].update(currentNode.val());
            if (newData !== void 0) {
              validateFirebaseData("transaction failed: Data returned ", newData, transaction.path);
              var newDataNode = nodeFromJSON(newData);
              var hasExplicitPriority = typeof newData === "object" && newData != null && util.contains(newData, ".priority");
              if (!hasExplicitPriority) {
                newDataNode = newDataNode.updatePriority(currentNode.getPriority());
              }
              var oldWriteId = transaction.currentWriteId;
              var serverValues = repoGenerateServerValues(repo);
              var newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
              transaction.currentOutputSnapshotRaw = newDataNode;
              transaction.currentOutputSnapshotResolved = newNodeResolved;
              transaction.currentWriteId = repoGetNextWriteId(repo);
              setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
              events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
              events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
            } else {
              abortTransaction = true;
              abortReason = "nodata";
              events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
            }
          }
        }
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        events = [];
        if (abortTransaction) {
          queue[i2].status = 2;
          (function(unwatcher) {
            setTimeout(unwatcher, Math.floor(0));
          })(queue[i2].unwatcher);
          if (queue[i2].onComplete) {
            if (abortReason === "nodata") {
              callbacks.push(function() {
                return queue[i2].onComplete(null, false, queue[i2].currentInputSnapshot);
              });
            } else {
              callbacks.push(function() {
                return queue[i2].onComplete(new Error(abortReason), false, null);
              });
            }
          }
        }
      };
      for (var i = 0; i < queue.length; i++) {
        _loop_2(i);
      }
      repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
      for (var i = 0; i < callbacks.length; i++) {
        exceptionGuard(callbacks[i]);
      }
      repoSendReadyTransactions(repo, repo.transactionQueueTree_);
    }
    function repoGetAncestorTransactionNode(repo, path) {
      var front;
      var transactionNode = repo.transactionQueueTree_;
      front = pathGetFront(path);
      while (front !== null && treeGetValue(transactionNode) === void 0) {
        transactionNode = treeSubTree(transactionNode, front);
        path = pathPopFront(path);
        front = pathGetFront(path);
      }
      return transactionNode;
    }
    function repoBuildTransactionQueue(repo, transactionNode) {
      var transactionQueue = [];
      repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
      transactionQueue.sort(function(a, b) {
        return a.order - b.order;
      });
      return transactionQueue;
    }
    function repoAggregateTransactionQueuesForNode(repo, node, queue) {
      var nodeQueue = treeGetValue(node);
      if (nodeQueue) {
        for (var i = 0; i < nodeQueue.length; i++) {
          queue.push(nodeQueue[i]);
        }
      }
      treeForEachChild(node, function(child2) {
        repoAggregateTransactionQueuesForNode(repo, child2, queue);
      });
    }
    function repoPruneCompletedTransactionsBelowNode(repo, node) {
      var queue = treeGetValue(node);
      if (queue) {
        var to = 0;
        for (var from = 0; from < queue.length; from++) {
          if (queue[from].status !== 2) {
            queue[to] = queue[from];
            to++;
          }
        }
        queue.length = to;
        treeSetValue(node, queue.length > 0 ? queue : void 0);
      }
      treeForEachChild(node, function(childNode) {
        repoPruneCompletedTransactionsBelowNode(repo, childNode);
      });
    }
    function repoAbortTransactions(repo, path) {
      var affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));
      var transactionNode = treeSubTree(repo.transactionQueueTree_, path);
      treeForEachAncestor(transactionNode, function(node) {
        repoAbortTransactionsOnNode(repo, node);
      });
      repoAbortTransactionsOnNode(repo, transactionNode);
      treeForEachDescendant(transactionNode, function(node) {
        repoAbortTransactionsOnNode(repo, node);
      });
      return affectedPath;
    }
    function repoAbortTransactionsOnNode(repo, node) {
      var queue = treeGetValue(node);
      if (queue) {
        var callbacks = [];
        var events = [];
        var lastSent = -1;
        for (var i = 0; i < queue.length; i++) {
          if (queue[i].status === 3)
            ;
          else if (queue[i].status === 1) {
            util.assert(lastSent === i - 1, "All SENT items should be at beginning of queue.");
            lastSent = i;
            queue[i].status = 3;
            queue[i].abortReason = "set";
          } else {
            util.assert(queue[i].status === 0, "Unexpected transaction status in abort");
            queue[i].unwatcher();
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));
            if (queue[i].onComplete) {
              callbacks.push(queue[i].onComplete.bind(null, new Error("set"), false, null));
            }
          }
        }
        if (lastSent === -1) {
          treeSetValue(node, void 0);
        } else {
          queue.length = lastSent + 1;
        }
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);
        for (var i = 0; i < callbacks.length; i++) {
          exceptionGuard(callbacks[i]);
        }
      }
    }
    function decodePath(pathString) {
      var pathStringDecoded = "";
      var pieces = pathString.split("/");
      for (var i = 0; i < pieces.length; i++) {
        if (pieces[i].length > 0) {
          var piece = pieces[i];
          try {
            piece = decodeURIComponent(piece.replace(/\+/g, " "));
          } catch (e) {
          }
          pathStringDecoded += "/" + piece;
        }
      }
      return pathStringDecoded;
    }
    function decodeQuery(queryString) {
      var e_1, _a;
      var results = {};
      if (queryString.charAt(0) === "?") {
        queryString = queryString.substring(1);
      }
      try {
        for (var _b = tslib.__values(queryString.split("&")), _c = _b.next(); !_c.done; _c = _b.next()) {
          var segment = _c.value;
          if (segment.length === 0) {
            continue;
          }
          var kv = segment.split("=");
          if (kv.length === 2) {
            results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
          } else {
            warn("Invalid query segment '" + segment + "' in query '" + queryString + "'");
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return results;
    }
    var parseRepoInfo = function(dataURL, nodeAdmin) {
      var parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
      if (parsedUrl.domain === "firebase.com") {
        fatal(parsedUrl.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");
      }
      if ((!namespace || namespace === "undefined") && parsedUrl.domain !== "localhost") {
        fatal("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");
      }
      if (!parsedUrl.secure) {
        warnIfPageIsSecure();
      }
      var webSocketOnly = parsedUrl.scheme === "ws" || parsedUrl.scheme === "wss";
      return {
        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, nodeAdmin, webSocketOnly, "", namespace !== parsedUrl.subdomain),
        path: new Path(parsedUrl.pathString)
      };
    };
    var parseDatabaseURL = function(dataURL) {
      var host = "", domain = "", subdomain = "", pathString = "", namespace = "";
      var secure = true, scheme = "https", port = 443;
      if (typeof dataURL === "string") {
        var colonInd = dataURL.indexOf("//");
        if (colonInd >= 0) {
          scheme = dataURL.substring(0, colonInd - 1);
          dataURL = dataURL.substring(colonInd + 2);
        }
        var slashInd = dataURL.indexOf("/");
        if (slashInd === -1) {
          slashInd = dataURL.length;
        }
        var questionMarkInd = dataURL.indexOf("?");
        if (questionMarkInd === -1) {
          questionMarkInd = dataURL.length;
        }
        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
        if (slashInd < questionMarkInd) {
          pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
        }
        var queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
        colonInd = host.indexOf(":");
        if (colonInd >= 0) {
          secure = scheme === "https" || scheme === "wss";
          port = parseInt(host.substring(colonInd + 1), 10);
        } else {
          colonInd = host.length;
        }
        var hostWithoutPort = host.slice(0, colonInd);
        if (hostWithoutPort.toLowerCase() === "localhost") {
          domain = "localhost";
        } else if (hostWithoutPort.split(".").length <= 2) {
          domain = hostWithoutPort;
        } else {
          var dotInd = host.indexOf(".");
          subdomain = host.substring(0, dotInd).toLowerCase();
          domain = host.substring(dotInd + 1);
          namespace = subdomain;
        }
        if ("ns" in queryParams) {
          namespace = queryParams["ns"];
        }
      }
      return {
        host,
        port,
        domain,
        subdomain,
        secure,
        scheme,
        pathString,
        namespace
      };
    };
    var DataEvent = function() {
      function DataEvent2(eventType, eventRegistration, snapshot, prevName) {
        this.eventType = eventType;
        this.eventRegistration = eventRegistration;
        this.snapshot = snapshot;
        this.prevName = prevName;
      }
      DataEvent2.prototype.getPath = function() {
        var ref2 = this.snapshot.ref;
        if (this.eventType === "value") {
          return ref2._path;
        } else {
          return ref2.parent._path;
        }
      };
      DataEvent2.prototype.getEventType = function() {
        return this.eventType;
      };
      DataEvent2.prototype.getEventRunner = function() {
        return this.eventRegistration.getEventRunner(this);
      };
      DataEvent2.prototype.toString = function() {
        return this.getPath().toString() + ":" + this.eventType + ":" + util.stringify(this.snapshot.exportVal());
      };
      return DataEvent2;
    }();
    var CancelEvent = function() {
      function CancelEvent2(eventRegistration, error4, path) {
        this.eventRegistration = eventRegistration;
        this.error = error4;
        this.path = path;
      }
      CancelEvent2.prototype.getPath = function() {
        return this.path;
      };
      CancelEvent2.prototype.getEventType = function() {
        return "cancel";
      };
      CancelEvent2.prototype.getEventRunner = function() {
        return this.eventRegistration.getEventRunner(this);
      };
      CancelEvent2.prototype.toString = function() {
        return this.path.toString() + ":cancel";
      };
      return CancelEvent2;
    }();
    var CallbackContext = function() {
      function CallbackContext2(snapshotCallback, cancelCallback) {
        this.snapshotCallback = snapshotCallback;
        this.cancelCallback = cancelCallback;
      }
      CallbackContext2.prototype.onValue = function(expDataSnapshot, previousChildName) {
        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);
      };
      CallbackContext2.prototype.onCancel = function(error4) {
        util.assert(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback");
        return this.cancelCallback.call(null, error4);
      };
      Object.defineProperty(CallbackContext2.prototype, "hasCancelCallback", {
        get: function() {
          return !!this.cancelCallback;
        },
        enumerable: false,
        configurable: true
      });
      CallbackContext2.prototype.matches = function(other) {
        return this.snapshotCallback === other.snapshotCallback || this.snapshotCallback.userCallback === other.snapshotCallback.userCallback && this.snapshotCallback.context === other.snapshotCallback.context;
      };
      return CallbackContext2;
    }();
    var OnDisconnect$1 = function() {
      function OnDisconnect2(_repo, _path) {
        this._repo = _repo;
        this._path = _path;
      }
      OnDisconnect2.prototype.cancel = function() {
        var deferred = new util.Deferred();
        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(function() {
        }));
        return deferred.promise;
      };
      OnDisconnect2.prototype.remove = function() {
        validateWritablePath("OnDisconnect.remove", this._path);
        var deferred = new util.Deferred();
        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(function() {
        }));
        return deferred.promise;
      };
      OnDisconnect2.prototype.set = function(value) {
        validateWritablePath("OnDisconnect.set", this._path);
        validateFirebaseDataArg("OnDisconnect.set", value, this._path, false);
        var deferred = new util.Deferred();
        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(function() {
        }));
        return deferred.promise;
      };
      OnDisconnect2.prototype.setWithPriority = function(value, priority) {
        validateWritablePath("OnDisconnect.setWithPriority", this._path);
        validateFirebaseDataArg("OnDisconnect.setWithPriority", value, this._path, false);
        validatePriority("OnDisconnect.setWithPriority", priority, false);
        var deferred = new util.Deferred();
        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(function() {
        }));
        return deferred.promise;
      };
      OnDisconnect2.prototype.update = function(values) {
        validateWritablePath("OnDisconnect.update", this._path);
        validateFirebaseMergeDataArg("OnDisconnect.update", values, this._path, false);
        var deferred = new util.Deferred();
        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(function() {
        }));
        return deferred.promise;
      };
      return OnDisconnect2;
    }();
    var QueryImpl = function() {
      function QueryImpl2(_repo, _path, _queryParams, _orderByCalled) {
        this._repo = _repo;
        this._path = _path;
        this._queryParams = _queryParams;
        this._orderByCalled = _orderByCalled;
      }
      Object.defineProperty(QueryImpl2.prototype, "key", {
        get: function() {
          if (pathIsEmpty(this._path)) {
            return null;
          } else {
            return pathGetBack(this._path);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QueryImpl2.prototype, "ref", {
        get: function() {
          return new ReferenceImpl(this._repo, this._path);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QueryImpl2.prototype, "_queryIdentifier", {
        get: function() {
          var obj = queryParamsGetQueryObject(this._queryParams);
          var id = ObjectToUniqueKey(obj);
          return id === "{}" ? "default" : id;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QueryImpl2.prototype, "_queryObject", {
        get: function() {
          return queryParamsGetQueryObject(this._queryParams);
        },
        enumerable: false,
        configurable: true
      });
      QueryImpl2.prototype.isEqual = function(other) {
        other = util.getModularInstance(other);
        if (!(other instanceof QueryImpl2)) {
          return false;
        }
        var sameRepo = this._repo === other._repo;
        var samePath = pathEquals(this._path, other._path);
        var sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;
        return sameRepo && samePath && sameQueryIdentifier;
      };
      QueryImpl2.prototype.toJSON = function() {
        return this.toString();
      };
      QueryImpl2.prototype.toString = function() {
        return this._repo.toString() + pathToUrlEncodedString(this._path);
      };
      return QueryImpl2;
    }();
    function validateNoPreviousOrderByCall(query2, fnName) {
      if (query2._orderByCalled === true) {
        throw new Error(fnName + ": You can't combine multiple orderBy calls.");
      }
    }
    function validateQueryEndpoints(params) {
      var startNode = null;
      var endNode = null;
      if (params.hasStart()) {
        startNode = params.getIndexStartValue();
      }
      if (params.hasEnd()) {
        endNode = params.getIndexEndValue();
      }
      if (params.getIndex() === KEY_INDEX) {
        var tooManyArgsError = "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().";
        var wrongArgTypeError = "Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string.";
        if (params.hasStart()) {
          var startName = params.getIndexStartName();
          if (startName !== MIN_NAME) {
            throw new Error(tooManyArgsError);
          } else if (typeof startNode !== "string") {
            throw new Error(wrongArgTypeError);
          }
        }
        if (params.hasEnd()) {
          var endName = params.getIndexEndName();
          if (endName !== MAX_NAME) {
            throw new Error(tooManyArgsError);
          } else if (typeof endNode !== "string") {
            throw new Error(wrongArgTypeError);
          }
        }
      } else if (params.getIndex() === PRIORITY_INDEX) {
        if (startNode != null && !isValidPriority(startNode) || endNode != null && !isValidPriority(endNode)) {
          throw new Error("Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).");
        }
      } else {
        util.assert(params.getIndex() instanceof PathIndex || params.getIndex() === VALUE_INDEX, "unknown index type.");
        if (startNode != null && typeof startNode === "object" || endNode != null && typeof endNode === "object") {
          throw new Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.");
        }
      }
    }
    function validateLimit(params) {
      if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {
        throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead.");
      }
    }
    var ReferenceImpl = function(_super) {
      tslib.__extends(ReferenceImpl2, _super);
      function ReferenceImpl2(repo, path) {
        return _super.call(this, repo, path, new QueryParams(), false) || this;
      }
      Object.defineProperty(ReferenceImpl2.prototype, "parent", {
        get: function() {
          var parentPath = pathParent(this._path);
          return parentPath === null ? null : new ReferenceImpl2(this._repo, parentPath);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ReferenceImpl2.prototype, "root", {
        get: function() {
          var ref2 = this;
          while (ref2.parent !== null) {
            ref2 = ref2.parent;
          }
          return ref2;
        },
        enumerable: false,
        configurable: true
      });
      return ReferenceImpl2;
    }(QueryImpl);
    var DataSnapshot$1 = function() {
      function DataSnapshot2(_node, ref2, _index) {
        this._node = _node;
        this.ref = ref2;
        this._index = _index;
      }
      Object.defineProperty(DataSnapshot2.prototype, "priority", {
        get: function() {
          return this._node.getPriority().val();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DataSnapshot2.prototype, "key", {
        get: function() {
          return this.ref.key;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DataSnapshot2.prototype, "size", {
        get: function() {
          return this._node.numChildren();
        },
        enumerable: false,
        configurable: true
      });
      DataSnapshot2.prototype.child = function(path) {
        var childPath = new Path(path);
        var childRef = child(this.ref, path);
        return new DataSnapshot2(this._node.getChild(childPath), childRef, PRIORITY_INDEX);
      };
      DataSnapshot2.prototype.exists = function() {
        return !this._node.isEmpty();
      };
      DataSnapshot2.prototype.exportVal = function() {
        return this._node.val(true);
      };
      DataSnapshot2.prototype.forEach = function(action) {
        var _this = this;
        if (this._node.isLeafNode()) {
          return false;
        }
        var childrenNode = this._node;
        return !!childrenNode.forEachChild(this._index, function(key, node) {
          return action(new DataSnapshot2(node, child(_this.ref, key), PRIORITY_INDEX));
        });
      };
      DataSnapshot2.prototype.hasChild = function(path) {
        var childPath = new Path(path);
        return !this._node.getChild(childPath).isEmpty();
      };
      DataSnapshot2.prototype.hasChildren = function() {
        if (this._node.isLeafNode()) {
          return false;
        } else {
          return !this._node.isEmpty();
        }
      };
      DataSnapshot2.prototype.toJSON = function() {
        return this.exportVal();
      };
      DataSnapshot2.prototype.val = function() {
        return this._node.val();
      };
      return DataSnapshot2;
    }();
    function ref(db2, path) {
      db2 = util.getModularInstance(db2);
      db2._checkNotDeleted("ref");
      return path !== void 0 ? child(db2._root, path) : db2._root;
    }
    function refFromURL(db2, url) {
      db2 = util.getModularInstance(db2);
      db2._checkNotDeleted("refFromURL");
      var parsedURL = parseRepoInfo(url, db2._repo.repoInfo_.nodeAdmin);
      validateUrl("refFromURL", parsedURL);
      var repoInfo = parsedURL.repoInfo;
      if (!db2._repo.repoInfo_.isCustomHost() && repoInfo.host !== db2._repo.repoInfo_.host) {
        fatal("refFromURL: Host name does not match the current database: (found " + repoInfo.host + " but expected " + db2._repo.repoInfo_.host + ")");
      }
      return ref(db2, parsedURL.path.toString());
    }
    function child(parent, path) {
      parent = util.getModularInstance(parent);
      if (pathGetFront(parent._path) === null) {
        validateRootPathString("child", "path", path, false);
      } else {
        validatePathString("child", "path", path, false);
      }
      return new ReferenceImpl(parent._repo, pathChild(parent._path, path));
    }
    function push(parent, value) {
      parent = util.getModularInstance(parent);
      validateWritablePath("push", parent._path);
      validateFirebaseDataArg("push", value, parent._path, true);
      var now = repoServerTime(parent._repo);
      var name2 = nextPushId(now);
      var thennablePushRef = child(parent, name2);
      var pushRef = child(parent, name2);
      var promise;
      if (value != null) {
        promise = set(pushRef, value).then(function() {
          return pushRef;
        });
      } else {
        promise = Promise.resolve(pushRef);
      }
      thennablePushRef.then = promise.then.bind(promise);
      thennablePushRef.catch = promise.then.bind(promise, void 0);
      return thennablePushRef;
    }
    function remove(ref2) {
      validateWritablePath("remove", ref2._path);
      return set(ref2, null);
    }
    function set(ref2, value) {
      ref2 = util.getModularInstance(ref2);
      validateWritablePath("set", ref2._path);
      validateFirebaseDataArg("set", value, ref2._path, false);
      var deferred = new util.Deferred();
      repoSetWithPriority(ref2._repo, ref2._path, value, null, deferred.wrapCallback(function() {
      }));
      return deferred.promise;
    }
    function setPriority(ref2, priority) {
      ref2 = util.getModularInstance(ref2);
      validateWritablePath("setPriority", ref2._path);
      validatePriority("setPriority", priority, false);
      var deferred = new util.Deferred();
      repoSetWithPriority(ref2._repo, pathChild(ref2._path, ".priority"), priority, null, deferred.wrapCallback(function() {
      }));
      return deferred.promise;
    }
    function setWithPriority(ref2, value, priority) {
      validateWritablePath("setWithPriority", ref2._path);
      validateFirebaseDataArg("setWithPriority", value, ref2._path, false);
      validatePriority("setWithPriority", priority, false);
      if (ref2.key === ".length" || ref2.key === ".keys") {
        throw "setWithPriority failed: " + ref2.key + " is a read-only object.";
      }
      var deferred = new util.Deferred();
      repoSetWithPriority(ref2._repo, ref2._path, value, priority, deferred.wrapCallback(function() {
      }));
      return deferred.promise;
    }
    function update(ref2, values) {
      validateFirebaseMergeDataArg("update", values, ref2._path, false);
      var deferred = new util.Deferred();
      repoUpdate(ref2._repo, ref2._path, values, deferred.wrapCallback(function() {
      }));
      return deferred.promise;
    }
    function get(query2) {
      query2 = util.getModularInstance(query2);
      return repoGetValue(query2._repo, query2).then(function(node) {
        return new DataSnapshot$1(node, new ReferenceImpl(query2._repo, query2._path), query2._queryParams.getIndex());
      });
    }
    var ValueEventRegistration = function() {
      function ValueEventRegistration2(callbackContext) {
        this.callbackContext = callbackContext;
      }
      ValueEventRegistration2.prototype.respondsTo = function(eventType) {
        return eventType === "value";
      };
      ValueEventRegistration2.prototype.createEvent = function(change, query2) {
        var index2 = query2._queryParams.getIndex();
        return new DataEvent("value", this, new DataSnapshot$1(change.snapshotNode, new ReferenceImpl(query2._repo, query2._path), index2));
      };
      ValueEventRegistration2.prototype.getEventRunner = function(eventData) {
        var _this = this;
        if (eventData.getEventType() === "cancel") {
          return function() {
            return _this.callbackContext.onCancel(eventData.error);
          };
        } else {
          return function() {
            return _this.callbackContext.onValue(eventData.snapshot, null);
          };
        }
      };
      ValueEventRegistration2.prototype.createCancelEvent = function(error4, path) {
        if (this.callbackContext.hasCancelCallback) {
          return new CancelEvent(this, error4, path);
        } else {
          return null;
        }
      };
      ValueEventRegistration2.prototype.matches = function(other) {
        if (!(other instanceof ValueEventRegistration2)) {
          return false;
        } else if (!other.callbackContext || !this.callbackContext) {
          return true;
        } else {
          return other.callbackContext.matches(this.callbackContext);
        }
      };
      ValueEventRegistration2.prototype.hasAnyCallback = function() {
        return this.callbackContext !== null;
      };
      return ValueEventRegistration2;
    }();
    var ChildEventRegistration = function() {
      function ChildEventRegistration2(eventType, callbackContext) {
        this.eventType = eventType;
        this.callbackContext = callbackContext;
      }
      ChildEventRegistration2.prototype.respondsTo = function(eventType) {
        var eventToCheck = eventType === "children_added" ? "child_added" : eventType;
        eventToCheck = eventToCheck === "children_removed" ? "child_removed" : eventToCheck;
        return this.eventType === eventToCheck;
      };
      ChildEventRegistration2.prototype.createCancelEvent = function(error4, path) {
        if (this.callbackContext.hasCancelCallback) {
          return new CancelEvent(this, error4, path);
        } else {
          return null;
        }
      };
      ChildEventRegistration2.prototype.createEvent = function(change, query2) {
        util.assert(change.childName != null, "Child events should have a childName.");
        var childRef = child(new ReferenceImpl(query2._repo, query2._path), change.childName);
        var index2 = query2._queryParams.getIndex();
        return new DataEvent(change.type, this, new DataSnapshot$1(change.snapshotNode, childRef, index2), change.prevName);
      };
      ChildEventRegistration2.prototype.getEventRunner = function(eventData) {
        var _this = this;
        if (eventData.getEventType() === "cancel") {
          return function() {
            return _this.callbackContext.onCancel(eventData.error);
          };
        } else {
          return function() {
            return _this.callbackContext.onValue(eventData.snapshot, eventData.prevName);
          };
        }
      };
      ChildEventRegistration2.prototype.matches = function(other) {
        if (other instanceof ChildEventRegistration2) {
          return this.eventType === other.eventType && (!this.callbackContext || !other.callbackContext || this.callbackContext.matches(other.callbackContext));
        }
        return false;
      };
      ChildEventRegistration2.prototype.hasAnyCallback = function() {
        return !!this.callbackContext;
      };
      return ChildEventRegistration2;
    }();
    function addEventListener(query2, eventType, callback, cancelCallbackOrListenOptions, options2) {
      var cancelCallback;
      if (typeof cancelCallbackOrListenOptions === "object") {
        cancelCallback = void 0;
        options2 = cancelCallbackOrListenOptions;
      }
      if (typeof cancelCallbackOrListenOptions === "function") {
        cancelCallback = cancelCallbackOrListenOptions;
      }
      if (options2 && options2.onlyOnce) {
        var userCallback_1 = callback;
        var onceCallback = function(dataSnapshot, previousChildName) {
          repoRemoveEventCallbackForQuery(query2._repo, query2, container);
          userCallback_1(dataSnapshot, previousChildName);
        };
        onceCallback.userCallback = callback.userCallback;
        onceCallback.context = callback.context;
        callback = onceCallback;
      }
      var callbackContext = new CallbackContext(callback, cancelCallback || void 0);
      var container = eventType === "value" ? new ValueEventRegistration(callbackContext) : new ChildEventRegistration(eventType, callbackContext);
      repoAddEventCallbackForQuery(query2._repo, query2, container);
      return function() {
        return repoRemoveEventCallbackForQuery(query2._repo, query2, container);
      };
    }
    function onValue(query2, callback, cancelCallbackOrListenOptions, options2) {
      return addEventListener(query2, "value", callback, cancelCallbackOrListenOptions, options2);
    }
    function onChildAdded(query2, callback, cancelCallbackOrListenOptions, options2) {
      return addEventListener(query2, "child_added", callback, cancelCallbackOrListenOptions, options2);
    }
    function onChildChanged(query2, callback, cancelCallbackOrListenOptions, options2) {
      return addEventListener(query2, "child_changed", callback, cancelCallbackOrListenOptions, options2);
    }
    function onChildMoved(query2, callback, cancelCallbackOrListenOptions, options2) {
      return addEventListener(query2, "child_moved", callback, cancelCallbackOrListenOptions, options2);
    }
    function onChildRemoved(query2, callback, cancelCallbackOrListenOptions, options2) {
      return addEventListener(query2, "child_removed", callback, cancelCallbackOrListenOptions, options2);
    }
    function off(query2, eventType, callback) {
      var container = null;
      var expCallback = callback ? new CallbackContext(callback) : null;
      if (eventType === "value") {
        container = new ValueEventRegistration(expCallback);
      } else if (eventType) {
        container = new ChildEventRegistration(eventType, expCallback);
      }
      repoRemoveEventCallbackForQuery(query2._repo, query2, container);
    }
    var QueryConstraint = function() {
      function QueryConstraint2() {
      }
      return QueryConstraint2;
    }();
    var QueryEndAtConstraint = function(_super) {
      tslib.__extends(QueryEndAtConstraint2, _super);
      function QueryEndAtConstraint2(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
      }
      QueryEndAtConstraint2.prototype._apply = function(query2) {
        validateFirebaseDataArg("endAt", this._value, query2._path, true);
        var newParams = queryParamsEndAt(query2._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query2._queryParams.hasEnd()) {
          throw new Error("endAt: Starting point was already set (by another call to endAt, endBefore or equalTo).");
        }
        return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
      };
      return QueryEndAtConstraint2;
    }(QueryConstraint);
    function endAt(value, key) {
      validateKey("endAt", "key", key, true);
      return new QueryEndAtConstraint(value, key);
    }
    var QueryEndBeforeConstraint = function(_super) {
      tslib.__extends(QueryEndBeforeConstraint2, _super);
      function QueryEndBeforeConstraint2(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
      }
      QueryEndBeforeConstraint2.prototype._apply = function(query2) {
        validateFirebaseDataArg("endBefore", this._value, query2._path, false);
        var newParams = queryParamsEndBefore(query2._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query2._queryParams.hasEnd()) {
          throw new Error("endBefore: Starting point was already set (by another call to endAt, endBefore or equalTo).");
        }
        return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
      };
      return QueryEndBeforeConstraint2;
    }(QueryConstraint);
    function endBefore(value, key) {
      validateKey("endBefore", "key", key, true);
      return new QueryEndBeforeConstraint(value, key);
    }
    var QueryStartAtConstraint = function(_super) {
      tslib.__extends(QueryStartAtConstraint2, _super);
      function QueryStartAtConstraint2(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
      }
      QueryStartAtConstraint2.prototype._apply = function(query2) {
        validateFirebaseDataArg("startAt", this._value, query2._path, true);
        var newParams = queryParamsStartAt(query2._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query2._queryParams.hasStart()) {
          throw new Error("startAt: Starting point was already set (by another call to startAt, startBefore or equalTo).");
        }
        return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
      };
      return QueryStartAtConstraint2;
    }(QueryConstraint);
    function startAt(value, key) {
      if (value === void 0) {
        value = null;
      }
      validateKey("startAt", "key", key, true);
      return new QueryStartAtConstraint(value, key);
    }
    var QueryStartAfterConstraint = function(_super) {
      tslib.__extends(QueryStartAfterConstraint2, _super);
      function QueryStartAfterConstraint2(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
      }
      QueryStartAfterConstraint2.prototype._apply = function(query2) {
        validateFirebaseDataArg("startAfter", this._value, query2._path, false);
        var newParams = queryParamsStartAfter(query2._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query2._queryParams.hasStart()) {
          throw new Error("startAfter: Starting point was already set (by another call to startAt, startAfter, or equalTo).");
        }
        return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
      };
      return QueryStartAfterConstraint2;
    }(QueryConstraint);
    function startAfter(value, key) {
      validateKey("startAfter", "key", key, true);
      return new QueryStartAfterConstraint(value, key);
    }
    var QueryLimitToFirstConstraint = function(_super) {
      tslib.__extends(QueryLimitToFirstConstraint2, _super);
      function QueryLimitToFirstConstraint2(_limit) {
        var _this = _super.call(this) || this;
        _this._limit = _limit;
        return _this;
      }
      QueryLimitToFirstConstraint2.prototype._apply = function(query2) {
        if (query2._queryParams.hasLimit()) {
          throw new Error("limitToFirst: Limit was already set (by another call to limitToFirst or limitToLast).");
        }
        return new QueryImpl(query2._repo, query2._path, queryParamsLimitToFirst(query2._queryParams, this._limit), query2._orderByCalled);
      };
      return QueryLimitToFirstConstraint2;
    }(QueryConstraint);
    function limitToFirst(limit) {
      if (typeof limit !== "number" || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error("limitToFirst: First argument must be a positive integer.");
      }
      return new QueryLimitToFirstConstraint(limit);
    }
    var QueryLimitToLastConstraint = function(_super) {
      tslib.__extends(QueryLimitToLastConstraint2, _super);
      function QueryLimitToLastConstraint2(_limit) {
        var _this = _super.call(this) || this;
        _this._limit = _limit;
        return _this;
      }
      QueryLimitToLastConstraint2.prototype._apply = function(query2) {
        if (query2._queryParams.hasLimit()) {
          throw new Error("limitToLast: Limit was already set (by another call to limitToFirst or limitToLast).");
        }
        return new QueryImpl(query2._repo, query2._path, queryParamsLimitToLast(query2._queryParams, this._limit), query2._orderByCalled);
      };
      return QueryLimitToLastConstraint2;
    }(QueryConstraint);
    function limitToLast(limit) {
      if (typeof limit !== "number" || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error("limitToLast: First argument must be a positive integer.");
      }
      return new QueryLimitToLastConstraint(limit);
    }
    var QueryOrderByChildConstraint = function(_super) {
      tslib.__extends(QueryOrderByChildConstraint2, _super);
      function QueryOrderByChildConstraint2(_path) {
        var _this = _super.call(this) || this;
        _this._path = _path;
        return _this;
      }
      QueryOrderByChildConstraint2.prototype._apply = function(query2) {
        validateNoPreviousOrderByCall(query2, "orderByChild");
        var parsedPath = new Path(this._path);
        if (pathIsEmpty(parsedPath)) {
          throw new Error("orderByChild: cannot pass in empty path. Use orderByValue() instead.");
        }
        var index2 = new PathIndex(parsedPath);
        var newParams = queryParamsOrderBy(query2._queryParams, index2);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query2._repo, query2._path, newParams, true);
      };
      return QueryOrderByChildConstraint2;
    }(QueryConstraint);
    function orderByChild(path) {
      if (path === "$key") {
        throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
      } else if (path === "$priority") {
        throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');
      } else if (path === "$value") {
        throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');
      }
      validatePathString("orderByChild", "path", path, false);
      return new QueryOrderByChildConstraint(path);
    }
    var QueryOrderByKeyConstraint = function(_super) {
      tslib.__extends(QueryOrderByKeyConstraint2, _super);
      function QueryOrderByKeyConstraint2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      QueryOrderByKeyConstraint2.prototype._apply = function(query2) {
        validateNoPreviousOrderByCall(query2, "orderByKey");
        var newParams = queryParamsOrderBy(query2._queryParams, KEY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query2._repo, query2._path, newParams, true);
      };
      return QueryOrderByKeyConstraint2;
    }(QueryConstraint);
    function orderByKey() {
      return new QueryOrderByKeyConstraint();
    }
    var QueryOrderByPriorityConstraint = function(_super) {
      tslib.__extends(QueryOrderByPriorityConstraint2, _super);
      function QueryOrderByPriorityConstraint2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      QueryOrderByPriorityConstraint2.prototype._apply = function(query2) {
        validateNoPreviousOrderByCall(query2, "orderByPriority");
        var newParams = queryParamsOrderBy(query2._queryParams, PRIORITY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query2._repo, query2._path, newParams, true);
      };
      return QueryOrderByPriorityConstraint2;
    }(QueryConstraint);
    function orderByPriority() {
      return new QueryOrderByPriorityConstraint();
    }
    var QueryOrderByValueConstraint = function(_super) {
      tslib.__extends(QueryOrderByValueConstraint2, _super);
      function QueryOrderByValueConstraint2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      QueryOrderByValueConstraint2.prototype._apply = function(query2) {
        validateNoPreviousOrderByCall(query2, "orderByValue");
        var newParams = queryParamsOrderBy(query2._queryParams, VALUE_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query2._repo, query2._path, newParams, true);
      };
      return QueryOrderByValueConstraint2;
    }(QueryConstraint);
    function orderByValue() {
      return new QueryOrderByValueConstraint();
    }
    var QueryEqualToValueConstraint = function(_super) {
      tslib.__extends(QueryEqualToValueConstraint2, _super);
      function QueryEqualToValueConstraint2(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
      }
      QueryEqualToValueConstraint2.prototype._apply = function(query2) {
        validateFirebaseDataArg("equalTo", this._value, query2._path, false);
        if (query2._queryParams.hasStart()) {
          throw new Error("equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo).");
        }
        if (query2._queryParams.hasEnd()) {
          throw new Error("equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo).");
        }
        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query2));
      };
      return QueryEqualToValueConstraint2;
    }(QueryConstraint);
    function equalTo(value, key) {
      validateKey("equalTo", "key", key, true);
      return new QueryEqualToValueConstraint(value, key);
    }
    function query(query2) {
      var e_1, _a;
      var queryConstraints = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        queryConstraints[_i - 1] = arguments[_i];
      }
      var queryImpl = util.getModularInstance(query2);
      try {
        for (var queryConstraints_1 = tslib.__values(queryConstraints), queryConstraints_1_1 = queryConstraints_1.next(); !queryConstraints_1_1.done; queryConstraints_1_1 = queryConstraints_1.next()) {
          var constraint = queryConstraints_1_1.value;
          queryImpl = constraint._apply(queryImpl);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (queryConstraints_1_1 && !queryConstraints_1_1.done && (_a = queryConstraints_1.return))
            _a.call(queryConstraints_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return queryImpl;
    }
    syncPointSetReferenceConstructor(ReferenceImpl);
    syncTreeSetReferenceConstructor(ReferenceImpl);
    var FIREBASE_DATABASE_EMULATOR_HOST_VAR = "FIREBASE_DATABASE_EMULATOR_HOST";
    var repos = {};
    var useRestClient = false;
    function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {
      repo.repoInfo_ = new RepoInfo(host + ":" + port, false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams);
      if (tokenProvider) {
        repo.authTokenProvider_ = tokenProvider;
      }
    }
    function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {
      var dbUrl = url || app.options.databaseURL;
      if (dbUrl === void 0) {
        if (!app.options.projectId) {
          fatal("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp().");
        }
        log("Using default host for project ", app.options.projectId);
        dbUrl = app.options.projectId + "-default-rtdb.firebaseio.com";
      }
      var parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
      var repoInfo = parsedUrl.repoInfo;
      var isEmulator;
      var dbEmulatorHost = void 0;
      if (typeof process !== "undefined") {
        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
      }
      if (dbEmulatorHost) {
        isEmulator = true;
        dbUrl = "http://" + dbEmulatorHost + "?ns=" + repoInfo.namespace;
        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
        repoInfo = parsedUrl.repoInfo;
      } else {
        isEmulator = !parsedUrl.repoInfo.secure;
      }
      var authTokenProvider = nodeAdmin && isEmulator ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER) : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);
      validateUrl("Invalid Firebase Database URL", parsedUrl);
      if (!pathIsEmpty(parsedUrl.path)) {
        fatal("Database URL must point to the root of a Firebase Database (not including a child path).");
      }
      var repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));
      return new Database$1(repo, app);
    }
    function repoManagerDeleteRepo(repo, appName) {
      var appRepos = repos[appName];
      if (!appRepos || appRepos[repo.key] !== repo) {
        fatal("Database " + appName + "(" + repo.repoInfo_ + ") has already been deleted.");
      }
      repoInterrupt(repo);
      delete appRepos[repo.key];
    }
    function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {
      var appRepos = repos[app.name];
      if (!appRepos) {
        appRepos = {};
        repos[app.name] = appRepos;
      }
      var repo = appRepos[repoInfo.toURLString()];
      if (repo) {
        fatal("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
      }
      repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);
      appRepos[repoInfo.toURLString()] = repo;
      return repo;
    }
    function repoManagerForceRestClient(forceRestClient2) {
      useRestClient = forceRestClient2;
    }
    var Database$1 = function() {
      function Database2(_repoInternal, app) {
        this._repoInternal = _repoInternal;
        this.app = app;
        this["type"] = "database";
        this._instanceStarted = false;
      }
      Object.defineProperty(Database2.prototype, "_repo", {
        get: function() {
          if (!this._instanceStarted) {
            repoStart(this._repoInternal, this.app.options.appId, this.app.options["databaseAuthVariableOverride"]);
            this._instanceStarted = true;
          }
          return this._repoInternal;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Database2.prototype, "_root", {
        get: function() {
          if (!this._rootInternal) {
            this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());
          }
          return this._rootInternal;
        },
        enumerable: false,
        configurable: true
      });
      Database2.prototype._delete = function() {
        if (this._rootInternal !== null) {
          repoManagerDeleteRepo(this._repo, this.app.name);
          this._repoInternal = null;
          this._rootInternal = null;
        }
        return Promise.resolve();
      };
      Database2.prototype._checkNotDeleted = function(apiName) {
        if (this._rootInternal === null) {
          fatal("Cannot call " + apiName + " on a deleted database.");
        }
      };
      return Database2;
    }();
    function connectDatabaseEmulator(db2, host, port, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      db2 = util.getModularInstance(db2);
      db2._checkNotDeleted("useEmulator");
      if (db2._instanceStarted) {
        fatal("Cannot call useEmulator() after instance has already been initialized.");
      }
      var repo = db2._repoInternal;
      var tokenProvider = void 0;
      if (repo.repoInfo_.nodeAdmin) {
        if (options2.mockUserToken) {
          fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".');
        }
        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);
      } else if (options2.mockUserToken) {
        var token = util.createMockUserToken(options2.mockUserToken, db2.app.options.projectId);
        tokenProvider = new EmulatorTokenProvider(token);
      }
      repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);
    }
    function goOffline(db2) {
      db2 = util.getModularInstance(db2);
      db2._checkNotDeleted("goOffline");
      repoInterrupt(db2._repo);
    }
    function goOnline(db2) {
      db2 = util.getModularInstance(db2);
      db2._checkNotDeleted("goOnline");
      repoResume(db2._repo);
    }
    function enableLogging(logger2, persistent) {
      enableLogging$1(logger2, persistent);
    }
    var SERVER_TIMESTAMP = {
      ".sv": "timestamp"
    };
    function serverTimestamp() {
      return SERVER_TIMESTAMP;
    }
    function increment(delta) {
      return {
        ".sv": {
          "increment": delta
        }
      };
    }
    var TransactionResult$1 = function() {
      function TransactionResult2(committed, snapshot) {
        this.committed = committed;
        this.snapshot = snapshot;
      }
      TransactionResult2.prototype.toJSON = function() {
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
      };
      return TransactionResult2;
    }();
    function runTransaction(ref2, transactionUpdate, options2) {
      var _a;
      ref2 = util.getModularInstance(ref2);
      validateWritablePath("Reference.transaction", ref2._path);
      if (ref2.key === ".length" || ref2.key === ".keys") {
        throw "Reference.transaction failed: " + ref2.key + " is a read-only object.";
      }
      var applyLocally = (_a = options2 === null || options2 === void 0 ? void 0 : options2.applyLocally) !== null && _a !== void 0 ? _a : true;
      var deferred = new util.Deferred();
      var promiseComplete = function(error4, committed, node) {
        var dataSnapshot = null;
        if (error4) {
          deferred.reject(error4);
        } else {
          dataSnapshot = new DataSnapshot$1(node, new ReferenceImpl(ref2._repo, ref2._path), PRIORITY_INDEX);
          deferred.resolve(new TransactionResult$1(committed, dataSnapshot));
        }
      };
      var unwatcher = onValue(ref2, function() {
      });
      repoStartTransaction(ref2._repo, ref2._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);
      return deferred.promise;
    }
    var OnDisconnect = function() {
      function OnDisconnect2(_delegate) {
        this._delegate = _delegate;
      }
      OnDisconnect2.prototype.cancel = function(onComplete) {
        util.validateArgCount("OnDisconnect.cancel", 0, 1, arguments.length);
        util.validateCallback("OnDisconnect.cancel", "onComplete", onComplete, true);
        var result = this._delegate.cancel();
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      OnDisconnect2.prototype.remove = function(onComplete) {
        util.validateArgCount("OnDisconnect.remove", 0, 1, arguments.length);
        util.validateCallback("OnDisconnect.remove", "onComplete", onComplete, true);
        var result = this._delegate.remove();
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      OnDisconnect2.prototype.set = function(value, onComplete) {
        util.validateArgCount("OnDisconnect.set", 1, 2, arguments.length);
        util.validateCallback("OnDisconnect.set", "onComplete", onComplete, true);
        var result = this._delegate.set(value);
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      OnDisconnect2.prototype.setWithPriority = function(value, priority, onComplete) {
        util.validateArgCount("OnDisconnect.setWithPriority", 2, 3, arguments.length);
        util.validateCallback("OnDisconnect.setWithPriority", "onComplete", onComplete, true);
        var result = this._delegate.setWithPriority(value, priority);
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      OnDisconnect2.prototype.update = function(objectToMerge, onComplete) {
        util.validateArgCount("OnDisconnect.update", 1, 2, arguments.length);
        if (Array.isArray(objectToMerge)) {
          var newObjectToMerge = {};
          for (var i = 0; i < objectToMerge.length; ++i) {
            newObjectToMerge["" + i] = objectToMerge[i];
          }
          objectToMerge = newObjectToMerge;
          warn("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
        }
        util.validateCallback("OnDisconnect.update", "onComplete", onComplete, true);
        var result = this._delegate.update(objectToMerge);
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      return OnDisconnect2;
    }();
    var TransactionResult = function() {
      function TransactionResult2(committed, snapshot) {
        this.committed = committed;
        this.snapshot = snapshot;
      }
      TransactionResult2.prototype.toJSON = function() {
        util.validateArgCount("TransactionResult.toJSON", 0, 1, arguments.length);
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
      };
      return TransactionResult2;
    }();
    var DataSnapshot = function() {
      function DataSnapshot2(_database, _delegate) {
        this._database = _database;
        this._delegate = _delegate;
      }
      DataSnapshot2.prototype.val = function() {
        util.validateArgCount("DataSnapshot.val", 0, 0, arguments.length);
        return this._delegate.val();
      };
      DataSnapshot2.prototype.exportVal = function() {
        util.validateArgCount("DataSnapshot.exportVal", 0, 0, arguments.length);
        return this._delegate.exportVal();
      };
      DataSnapshot2.prototype.toJSON = function() {
        util.validateArgCount("DataSnapshot.toJSON", 0, 1, arguments.length);
        return this._delegate.toJSON();
      };
      DataSnapshot2.prototype.exists = function() {
        util.validateArgCount("DataSnapshot.exists", 0, 0, arguments.length);
        return this._delegate.exists();
      };
      DataSnapshot2.prototype.child = function(path) {
        util.validateArgCount("DataSnapshot.child", 0, 1, arguments.length);
        path = String(path);
        validatePathString("DataSnapshot.child", "path", path, false);
        return new DataSnapshot2(this._database, this._delegate.child(path));
      };
      DataSnapshot2.prototype.hasChild = function(path) {
        util.validateArgCount("DataSnapshot.hasChild", 1, 1, arguments.length);
        validatePathString("DataSnapshot.hasChild", "path", path, false);
        return this._delegate.hasChild(path);
      };
      DataSnapshot2.prototype.getPriority = function() {
        util.validateArgCount("DataSnapshot.getPriority", 0, 0, arguments.length);
        return this._delegate.priority;
      };
      DataSnapshot2.prototype.forEach = function(action) {
        var _this = this;
        util.validateArgCount("DataSnapshot.forEach", 1, 1, arguments.length);
        util.validateCallback("DataSnapshot.forEach", "action", action, false);
        return this._delegate.forEach(function(expDataSnapshot) {
          return action(new DataSnapshot2(_this._database, expDataSnapshot));
        });
      };
      DataSnapshot2.prototype.hasChildren = function() {
        util.validateArgCount("DataSnapshot.hasChildren", 0, 0, arguments.length);
        return this._delegate.hasChildren();
      };
      Object.defineProperty(DataSnapshot2.prototype, "key", {
        get: function() {
          return this._delegate.key;
        },
        enumerable: false,
        configurable: true
      });
      DataSnapshot2.prototype.numChildren = function() {
        util.validateArgCount("DataSnapshot.numChildren", 0, 0, arguments.length);
        return this._delegate.size;
      };
      DataSnapshot2.prototype.getRef = function() {
        util.validateArgCount("DataSnapshot.ref", 0, 0, arguments.length);
        return new Reference(this._database, this._delegate.ref);
      };
      Object.defineProperty(DataSnapshot2.prototype, "ref", {
        get: function() {
          return this.getRef();
        },
        enumerable: false,
        configurable: true
      });
      return DataSnapshot2;
    }();
    var Query = function() {
      function Query2(database, _delegate) {
        this.database = database;
        this._delegate = _delegate;
      }
      Query2.prototype.on = function(eventType, callback, cancelCallbackOrContext, context) {
        var _this = this;
        var _a;
        util.validateArgCount("Query.on", 2, 4, arguments.length);
        util.validateCallback("Query.on", "callback", callback, false);
        var ret = Query2.getCancelAndContextArgs_("Query.on", cancelCallbackOrContext, context);
        var valueCallback = function(expSnapshot, previousChildName) {
          callback.call(ret.context, new DataSnapshot(_this.database, expSnapshot), previousChildName);
        };
        valueCallback.userCallback = callback;
        valueCallback.context = ret.context;
        var cancelCallback = (_a = ret.cancel) === null || _a === void 0 ? void 0 : _a.bind(ret.context);
        switch (eventType) {
          case "value":
            onValue(this._delegate, valueCallback, cancelCallback);
            return callback;
          case "child_added":
            onChildAdded(this._delegate, valueCallback, cancelCallback);
            return callback;
          case "child_removed":
            onChildRemoved(this._delegate, valueCallback, cancelCallback);
            return callback;
          case "child_changed":
            onChildChanged(this._delegate, valueCallback, cancelCallback);
            return callback;
          case "child_moved":
            onChildMoved(this._delegate, valueCallback, cancelCallback);
            return callback;
          default:
            throw new Error(util.errorPrefix("Query.on", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
        }
      };
      Query2.prototype.off = function(eventType, callback, context) {
        util.validateArgCount("Query.off", 0, 3, arguments.length);
        validateEventType("Query.off", eventType, true);
        util.validateCallback("Query.off", "callback", callback, true);
        util.validateContextObject("Query.off", "context", context, true);
        if (callback) {
          var valueCallback = function() {
          };
          valueCallback.userCallback = callback;
          valueCallback.context = context;
          off(this._delegate, eventType, valueCallback);
        } else {
          off(this._delegate, eventType);
        }
      };
      Query2.prototype.get = function() {
        var _this = this;
        return get(this._delegate).then(function(expSnapshot) {
          return new DataSnapshot(_this.database, expSnapshot);
        });
      };
      Query2.prototype.once = function(eventType, callback, failureCallbackOrContext, context) {
        var _this = this;
        util.validateArgCount("Query.once", 1, 4, arguments.length);
        util.validateCallback("Query.once", "callback", callback, true);
        var ret = Query2.getCancelAndContextArgs_("Query.once", failureCallbackOrContext, context);
        var deferred = new util.Deferred();
        var valueCallback = function(expSnapshot, previousChildName) {
          var result = new DataSnapshot(_this.database, expSnapshot);
          if (callback) {
            callback.call(ret.context, result, previousChildName);
          }
          deferred.resolve(result);
        };
        valueCallback.userCallback = callback;
        valueCallback.context = ret.context;
        var cancelCallback = function(error4) {
          if (ret.cancel) {
            ret.cancel.call(ret.context, error4);
          }
          deferred.reject(error4);
        };
        switch (eventType) {
          case "value":
            onValue(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          case "child_added":
            onChildAdded(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          case "child_removed":
            onChildRemoved(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          case "child_changed":
            onChildChanged(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          case "child_moved":
            onChildMoved(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          default:
            throw new Error(util.errorPrefix("Query.once", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
        }
        return deferred.promise;
      };
      Query2.prototype.limitToFirst = function(limit) {
        util.validateArgCount("Query.limitToFirst", 1, 1, arguments.length);
        return new Query2(this.database, query(this._delegate, limitToFirst(limit)));
      };
      Query2.prototype.limitToLast = function(limit) {
        util.validateArgCount("Query.limitToLast", 1, 1, arguments.length);
        return new Query2(this.database, query(this._delegate, limitToLast(limit)));
      };
      Query2.prototype.orderByChild = function(path) {
        util.validateArgCount("Query.orderByChild", 1, 1, arguments.length);
        return new Query2(this.database, query(this._delegate, orderByChild(path)));
      };
      Query2.prototype.orderByKey = function() {
        util.validateArgCount("Query.orderByKey", 0, 0, arguments.length);
        return new Query2(this.database, query(this._delegate, orderByKey()));
      };
      Query2.prototype.orderByPriority = function() {
        util.validateArgCount("Query.orderByPriority", 0, 0, arguments.length);
        return new Query2(this.database, query(this._delegate, orderByPriority()));
      };
      Query2.prototype.orderByValue = function() {
        util.validateArgCount("Query.orderByValue", 0, 0, arguments.length);
        return new Query2(this.database, query(this._delegate, orderByValue()));
      };
      Query2.prototype.startAt = function(value, name2) {
        if (value === void 0) {
          value = null;
        }
        util.validateArgCount("Query.startAt", 0, 2, arguments.length);
        return new Query2(this.database, query(this._delegate, startAt(value, name2)));
      };
      Query2.prototype.startAfter = function(value, name2) {
        if (value === void 0) {
          value = null;
        }
        util.validateArgCount("Query.startAfter", 0, 2, arguments.length);
        return new Query2(this.database, query(this._delegate, startAfter(value, name2)));
      };
      Query2.prototype.endAt = function(value, name2) {
        if (value === void 0) {
          value = null;
        }
        util.validateArgCount("Query.endAt", 0, 2, arguments.length);
        return new Query2(this.database, query(this._delegate, endAt(value, name2)));
      };
      Query2.prototype.endBefore = function(value, name2) {
        if (value === void 0) {
          value = null;
        }
        util.validateArgCount("Query.endBefore", 0, 2, arguments.length);
        return new Query2(this.database, query(this._delegate, endBefore(value, name2)));
      };
      Query2.prototype.equalTo = function(value, name2) {
        util.validateArgCount("Query.equalTo", 1, 2, arguments.length);
        return new Query2(this.database, query(this._delegate, equalTo(value, name2)));
      };
      Query2.prototype.toString = function() {
        util.validateArgCount("Query.toString", 0, 0, arguments.length);
        return this._delegate.toString();
      };
      Query2.prototype.toJSON = function() {
        util.validateArgCount("Query.toJSON", 0, 1, arguments.length);
        return this._delegate.toJSON();
      };
      Query2.prototype.isEqual = function(other) {
        util.validateArgCount("Query.isEqual", 1, 1, arguments.length);
        if (!(other instanceof Query2)) {
          var error4 = "Query.isEqual failed: First argument must be an instance of firebase.database.Query.";
          throw new Error(error4);
        }
        return this._delegate.isEqual(other._delegate);
      };
      Query2.getCancelAndContextArgs_ = function(fnName, cancelOrContext, context) {
        var ret = { cancel: void 0, context: void 0 };
        if (cancelOrContext && context) {
          ret.cancel = cancelOrContext;
          util.validateCallback(fnName, "cancel", ret.cancel, true);
          ret.context = context;
          util.validateContextObject(fnName, "context", ret.context, true);
        } else if (cancelOrContext) {
          if (typeof cancelOrContext === "object" && cancelOrContext !== null) {
            ret.context = cancelOrContext;
          } else if (typeof cancelOrContext === "function") {
            ret.cancel = cancelOrContext;
          } else {
            throw new Error(util.errorPrefix(fnName, "cancelOrContext") + " must either be a cancel callback or a context object.");
          }
        }
        return ret;
      };
      Object.defineProperty(Query2.prototype, "ref", {
        get: function() {
          return new Reference(this.database, new ReferenceImpl(this._delegate._repo, this._delegate._path));
        },
        enumerable: false,
        configurable: true
      });
      return Query2;
    }();
    var Reference = function(_super) {
      tslib.__extends(Reference2, _super);
      function Reference2(database, _delegate) {
        var _this = _super.call(this, database, new QueryImpl(_delegate._repo, _delegate._path, new QueryParams(), false)) || this;
        _this.database = database;
        _this._delegate = _delegate;
        return _this;
      }
      Reference2.prototype.getKey = function() {
        util.validateArgCount("Reference.key", 0, 0, arguments.length);
        return this._delegate.key;
      };
      Reference2.prototype.child = function(pathString) {
        util.validateArgCount("Reference.child", 1, 1, arguments.length);
        if (typeof pathString === "number") {
          pathString = String(pathString);
        }
        return new Reference2(this.database, child(this._delegate, pathString));
      };
      Reference2.prototype.getParent = function() {
        util.validateArgCount("Reference.parent", 0, 0, arguments.length);
        var parent = this._delegate.parent;
        return parent ? new Reference2(this.database, parent) : null;
      };
      Reference2.prototype.getRoot = function() {
        util.validateArgCount("Reference.root", 0, 0, arguments.length);
        return new Reference2(this.database, this._delegate.root);
      };
      Reference2.prototype.set = function(newVal, onComplete) {
        util.validateArgCount("Reference.set", 1, 2, arguments.length);
        util.validateCallback("Reference.set", "onComplete", onComplete, true);
        var result = set(this._delegate, newVal);
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      Reference2.prototype.update = function(values, onComplete) {
        util.validateArgCount("Reference.update", 1, 2, arguments.length);
        if (Array.isArray(values)) {
          var newObjectToMerge = {};
          for (var i = 0; i < values.length; ++i) {
            newObjectToMerge["" + i] = values[i];
          }
          values = newObjectToMerge;
          warn("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
        }
        validateWritablePath("Reference.update", this._delegate._path);
        util.validateCallback("Reference.update", "onComplete", onComplete, true);
        var result = update(this._delegate, values);
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      Reference2.prototype.setWithPriority = function(newVal, newPriority, onComplete) {
        util.validateArgCount("Reference.setWithPriority", 2, 3, arguments.length);
        util.validateCallback("Reference.setWithPriority", "onComplete", onComplete, true);
        var result = setWithPriority(this._delegate, newVal, newPriority);
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      Reference2.prototype.remove = function(onComplete) {
        util.validateArgCount("Reference.remove", 0, 1, arguments.length);
        util.validateCallback("Reference.remove", "onComplete", onComplete, true);
        var result = remove(this._delegate);
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      Reference2.prototype.transaction = function(transactionUpdate, onComplete, applyLocally) {
        var _this = this;
        util.validateArgCount("Reference.transaction", 1, 3, arguments.length);
        util.validateCallback("Reference.transaction", "transactionUpdate", transactionUpdate, false);
        util.validateCallback("Reference.transaction", "onComplete", onComplete, true);
        validateBoolean("Reference.transaction", "applyLocally", applyLocally, true);
        var result = runTransaction(this._delegate, transactionUpdate, {
          applyLocally
        }).then(function(transactionResult) {
          return new TransactionResult(transactionResult.committed, new DataSnapshot(_this.database, transactionResult.snapshot));
        });
        if (onComplete) {
          result.then(function(transactionResult) {
            return onComplete(null, transactionResult.committed, transactionResult.snapshot);
          }, function(error4) {
            return onComplete(error4, false, null);
          });
        }
        return result;
      };
      Reference2.prototype.setPriority = function(priority, onComplete) {
        util.validateArgCount("Reference.setPriority", 1, 2, arguments.length);
        util.validateCallback("Reference.setPriority", "onComplete", onComplete, true);
        var result = setPriority(this._delegate, priority);
        if (onComplete) {
          result.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        return result;
      };
      Reference2.prototype.push = function(value, onComplete) {
        var _this = this;
        util.validateArgCount("Reference.push", 0, 2, arguments.length);
        util.validateCallback("Reference.push", "onComplete", onComplete, true);
        var expPromise = push(this._delegate, value);
        var promise = expPromise.then(function(expRef) {
          return new Reference2(_this.database, expRef);
        });
        if (onComplete) {
          promise.then(function() {
            return onComplete(null);
          }, function(error4) {
            return onComplete(error4);
          });
        }
        var result = new Reference2(this.database, expPromise);
        result.then = promise.then.bind(promise);
        result.catch = promise.catch.bind(promise, void 0);
        return result;
      };
      Reference2.prototype.onDisconnect = function() {
        validateWritablePath("Reference.onDisconnect", this._delegate._path);
        return new OnDisconnect(new OnDisconnect$1(this._delegate._repo, this._delegate._path));
      };
      Object.defineProperty(Reference2.prototype, "key", {
        get: function() {
          return this.getKey();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Reference2.prototype, "parent", {
        get: function() {
          return this.getParent();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Reference2.prototype, "root", {
        get: function() {
          return this.getRoot();
        },
        enumerable: false,
        configurable: true
      });
      return Reference2;
    }(Query);
    var Database = function() {
      function Database2(_delegate, app) {
        var _this = this;
        this._delegate = _delegate;
        this.app = app;
        this.INTERNAL = {
          delete: function() {
            return _this._delegate._delete();
          }
        };
      }
      Database2.prototype.useEmulator = function(host, port, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        connectDatabaseEmulator(this._delegate, host, port, options2);
      };
      Database2.prototype.ref = function(path) {
        util.validateArgCount("database.ref", 0, 1, arguments.length);
        if (path instanceof Reference) {
          var childRef = refFromURL(this._delegate, path.toString());
          return new Reference(this, childRef);
        } else {
          var childRef = ref(this._delegate, path);
          return new Reference(this, childRef);
        }
      };
      Database2.prototype.refFromURL = function(url) {
        var apiName = "database.refFromURL";
        util.validateArgCount(apiName, 1, 1, arguments.length);
        var childRef = refFromURL(this._delegate, url);
        return new Reference(this, childRef);
      };
      Database2.prototype.goOffline = function() {
        util.validateArgCount("database.goOffline", 0, 0, arguments.length);
        return goOffline(this._delegate);
      };
      Database2.prototype.goOnline = function() {
        util.validateArgCount("database.goOnline", 0, 0, arguments.length);
        return goOnline(this._delegate);
      };
      Database2.ServerValue = {
        TIMESTAMP: serverTimestamp(),
        increment: function(delta) {
          return increment(delta);
        }
      };
      return Database2;
    }();
    var forceLongPolling = function() {
      WebSocketConnection.forceDisallow();
      BrowserPollConnection.forceAllow();
    };
    var forceWebSockets = function() {
      BrowserPollConnection.forceDisallow();
    };
    var isWebSocketsAvailable = function() {
      return WebSocketConnection["isAvailable"]();
    };
    var setSecurityDebugCallback = function(ref2, callback) {
      var connection = ref2._delegate._repo.persistentConnection_;
      connection.securityDebugCallback_ = callback;
    };
    var stats = function(ref2, showDelta) {
      repoStats(ref2._delegate._repo, showDelta);
    };
    var statsIncrementCounter = function(ref2, metric) {
      repoStatsIncrementCounter(ref2._delegate._repo, metric);
    };
    var dataUpdateCount = function(ref2) {
      return ref2._delegate._repo.dataUpdateCount;
    };
    var interceptServerData = function(ref2, callback) {
      return repoInterceptServerData(ref2._delegate._repo, callback);
    };
    function initStandalone$1(_a) {
      var app = _a.app, url = _a.url, version2 = _a.version, customAuthImpl = _a.customAuthImpl, namespace = _a.namespace, _b = _a.nodeAdmin, nodeAdmin = _b === void 0 ? false : _b;
      setSDKVersion(version2);
      var authProvider = new component.Provider("auth-internal", new component.ComponentContainer("database-standalone"));
      authProvider.setComponent(new component.Component("auth-internal", function() {
        return customAuthImpl;
      }, "PRIVATE"));
      return {
        instance: new Database(repoManagerDatabaseFromApp(app, authProvider, void 0, url, nodeAdmin), app),
        namespace
      };
    }
    var INTERNAL = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      forceLongPolling,
      forceWebSockets,
      isWebSocketsAvailable,
      setSecurityDebugCallback,
      stats,
      statsIncrementCounter,
      dataUpdateCount,
      interceptServerData,
      initStandalone: initStandalone$1
    });
    var DataConnection = PersistentConnection;
    PersistentConnection.prototype.simpleListen = function(pathString, onComplete) {
      this.sendRequest("q", { p: pathString }, onComplete);
    };
    PersistentConnection.prototype.echo = function(data, onEcho) {
      this.sendRequest("echo", { d: data }, onEcho);
    };
    var RealTimeConnection = Connection;
    var hijackHash = function(newHash) {
      var oldPut = PersistentConnection.prototype.put;
      PersistentConnection.prototype.put = function(pathString, data, onComplete, hash2) {
        if (hash2 !== void 0) {
          hash2 = newHash();
        }
        oldPut.call(this, pathString, data, onComplete, hash2);
      };
      return function() {
        PersistentConnection.prototype.put = oldPut;
      };
    };
    var ConnectionTarget = RepoInfo;
    var queryIdentifier = function(query2) {
      return query2._delegate._queryIdentifier;
    };
    var forceRestClient = function(forceRestClient2) {
      repoManagerForceRestClient(forceRestClient2);
    };
    var TEST_ACCESS = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      DataConnection,
      RealTimeConnection,
      hijackHash,
      ConnectionTarget,
      queryIdentifier,
      forceRestClient
    });
    setWebSocketImpl(fayeWebsocket.Client);
    var ServerValue = Database.ServerValue;
    function initStandalone(app, url, version2, nodeAdmin) {
      if (nodeAdmin === void 0) {
        nodeAdmin = true;
      }
      util.CONSTANTS.NODE_ADMIN = nodeAdmin;
      return initStandalone$1({
        app,
        url,
        version: version2,
        customAuthImpl: app.INTERNAL,
        namespace: {
          Reference,
          Query,
          Database,
          DataSnapshot,
          enableLogging,
          INTERNAL,
          ServerValue,
          TEST_ACCESS
        },
        nodeAdmin
      });
    }
    function registerDatabase(instance) {
      setSDKVersion(instance.SDK_VERSION);
      var namespace = instance.INTERNAL.registerComponent(new component.Component("database", function(container, _a) {
        var url = _a.instanceIdentifier;
        var app = container.getProvider("app").getImmediate();
        var authProvider = container.getProvider("auth-internal");
        var appCheckProvider = container.getProvider("app-check-internal");
        return new Database(repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url), app);
      }, "PUBLIC").setServiceProps({
        Reference,
        Query,
        Database,
        DataSnapshot,
        enableLogging,
        INTERNAL,
        ServerValue,
        TEST_ACCESS
      }).setMultipleInstances(true));
      instance.registerVersion(name, version, "node");
      if (util.isNodeSdk()) {
        module2.exports = Object.assign({}, namespace, { initStandalone });
      }
    }
    try {
      firebase2 = require_index_node_cjs2().default;
      if (firebase2) {
        registerDatabase(firebase2);
      }
    } catch (err) {
      if (err.code !== "MODULE_NOT_FOUND") {
        throw err;
      }
    }
    var firebase2;
    exports2.DataSnapshot = DataSnapshot;
    exports2.Database = Database;
    exports2.OnDisconnect = OnDisconnect;
    exports2.Query = Query;
    exports2.Reference = Reference;
    exports2.ServerValue = ServerValue;
    exports2.enableLogging = enableLogging;
    exports2.initStandalone = initStandalone;
    exports2.registerDatabase = registerDatabase;
  }
});

// node_modules/@grpc/grpc-js/build/src/constants.js
var require_constants = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/constants.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports2.Propagate = exports2.LogVerbosity = exports2.Status = void 0;
    var Status;
    (function(Status2) {
      Status2[Status2["OK"] = 0] = "OK";
      Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
      Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
      Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
      Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      Status2[Status2["ABORTED"] = 10] = "ABORTED";
      Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
      Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
      Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    })(Status = exports2.Status || (exports2.Status = {}));
    var LogVerbosity;
    (function(LogVerbosity2) {
      LogVerbosity2[LogVerbosity2["DEBUG"] = 0] = "DEBUG";
      LogVerbosity2[LogVerbosity2["INFO"] = 1] = "INFO";
      LogVerbosity2[LogVerbosity2["ERROR"] = 2] = "ERROR";
      LogVerbosity2[LogVerbosity2["NONE"] = 3] = "NONE";
    })(LogVerbosity = exports2.LogVerbosity || (exports2.LogVerbosity = {}));
    var Propagate;
    (function(Propagate2) {
      Propagate2[Propagate2["DEADLINE"] = 1] = "DEADLINE";
      Propagate2[Propagate2["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
      Propagate2[Propagate2["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
      Propagate2[Propagate2["CANCELLATION"] = 8] = "CANCELLATION";
      Propagate2[Propagate2["DEFAULTS"] = 65535] = "DEFAULTS";
    })(Propagate = exports2.Propagate || (exports2.Propagate = {}));
    exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
  }
});

// node_modules/@grpc/grpc-js/build/src/logging.js
var require_logging = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/logging.js"(exports2) {
    init_shims();
    "use strict";
    var _a;
    var _b;
    var _c;
    var _d;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.trace = exports2.log = exports2.setLoggerVerbosity = exports2.setLogger = exports2.getLogger = void 0;
    var constants_1 = require_constants();
    var _logger = console;
    var _logVerbosity = constants_1.LogVerbosity.ERROR;
    var verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : "";
    switch (verbosityString.toUpperCase()) {
      case "DEBUG":
        _logVerbosity = constants_1.LogVerbosity.DEBUG;
        break;
      case "INFO":
        _logVerbosity = constants_1.LogVerbosity.INFO;
        break;
      case "ERROR":
        _logVerbosity = constants_1.LogVerbosity.ERROR;
        break;
      case "NONE":
        _logVerbosity = constants_1.LogVerbosity.NONE;
        break;
      default:
    }
    exports2.getLogger = () => {
      return _logger;
    };
    exports2.setLogger = (logger) => {
      _logger = logger;
    };
    exports2.setLoggerVerbosity = (verbosity) => {
      _logVerbosity = verbosity;
    };
    exports2.log = (severity, ...args) => {
      if (severity >= _logVerbosity && typeof _logger.error === "function") {
        _logger.error(...args);
      }
    };
    var tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : "";
    var enabledTracers = new Set();
    var disabledTracers = new Set();
    for (const tracerName of tracersString.split(",")) {
      if (tracerName.startsWith("-")) {
        disabledTracers.add(tracerName.substring(1));
      } else {
        enabledTracers.add(tracerName);
      }
    }
    var allEnabled = enabledTracers.has("all");
    function trace(severity, tracer, text) {
      if (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer))) {
        exports2.log(severity, new Date().toISOString() + " | " + tracer + " | " + text);
      }
    }
    exports2.trace = trace;
  }
});

// node_modules/@grpc/grpc-js/build/src/metadata.js
var require_metadata = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/metadata.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants();
    var LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
    var LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
    function isLegalKey(key) {
      return LEGAL_KEY_REGEX.test(key);
    }
    function isLegalNonBinaryValue(value) {
      return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
    }
    function isBinaryKey(key) {
      return key.endsWith("-bin");
    }
    function isCustomMetadata(key) {
      return !key.startsWith("grpc-");
    }
    function normalizeKey(key) {
      return key.toLowerCase();
    }
    function validate(key, value) {
      if (!isLegalKey(key)) {
        throw new Error('Metadata key "' + key + '" contains illegal characters');
      }
      if (value !== null && value !== void 0) {
        if (isBinaryKey(key)) {
          if (!(value instanceof Buffer)) {
            throw new Error("keys that end with '-bin' must have Buffer values");
          }
        } else {
          if (value instanceof Buffer) {
            throw new Error("keys that don't end with '-bin' must have String values");
          }
          if (!isLegalNonBinaryValue(value)) {
            throw new Error('Metadata string value "' + value + '" contains illegal characters');
          }
        }
      }
    }
    var Metadata = class {
      constructor(options2) {
        this.internalRepr = new Map();
        if (options2 === void 0) {
          this.options = {};
        } else {
          this.options = options2;
        }
      }
      set(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        this.internalRepr.set(key, [value]);
      }
      add(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        const existingValue = this.internalRepr.get(key);
        if (existingValue === void 0) {
          this.internalRepr.set(key, [value]);
        } else {
          existingValue.push(value);
        }
      }
      remove(key) {
        key = normalizeKey(key);
        validate(key);
        this.internalRepr.delete(key);
      }
      get(key) {
        key = normalizeKey(key);
        validate(key);
        return this.internalRepr.get(key) || [];
      }
      getMap() {
        const result = {};
        this.internalRepr.forEach((values, key) => {
          if (values.length > 0) {
            const v = values[0];
            result[key] = v instanceof Buffer ? v.slice() : v;
          }
        });
        return result;
      }
      clone() {
        const newMetadata = new Metadata(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        this.internalRepr.forEach((value, key) => {
          const clonedValue = value.map((v) => {
            if (v instanceof Buffer) {
              return Buffer.from(v);
            } else {
              return v;
            }
          });
          newInternalRepr.set(key, clonedValue);
        });
        return newMetadata;
      }
      merge(other) {
        other.internalRepr.forEach((values, key) => {
          const mergedValue = (this.internalRepr.get(key) || []).concat(values);
          this.internalRepr.set(key, mergedValue);
        });
      }
      setOptions(options2) {
        this.options = options2;
      }
      getOptions() {
        return this.options;
      }
      toHttp2Headers() {
        const result = {};
        this.internalRepr.forEach((values, key) => {
          result[key] = values.map((value) => {
            if (value instanceof Buffer) {
              return value.toString("base64");
            } else {
              return value;
            }
          });
        });
        return result;
      }
      _getCoreRepresentation() {
        return this.internalRepr;
      }
      static fromHttp2Headers(headers) {
        const result = new Metadata();
        Object.keys(headers).forEach((key) => {
          if (key.charAt(0) === ":") {
            return;
          }
          const values = headers[key];
          try {
            if (isBinaryKey(key)) {
              if (Array.isArray(values)) {
                values.forEach((value) => {
                  result.add(key, Buffer.from(value, "base64"));
                });
              } else if (values !== void 0) {
                if (isCustomMetadata(key)) {
                  values.split(",").forEach((v) => {
                    result.add(key, Buffer.from(v.trim(), "base64"));
                  });
                } else {
                  result.add(key, Buffer.from(values, "base64"));
                }
              }
            } else {
              if (Array.isArray(values)) {
                values.forEach((value) => {
                  result.add(key, value);
                });
              } else if (values !== void 0) {
                result.add(key, values);
              }
            }
          } catch (error3) {
            const message = `Failed to add metadata entry ${key}: ${values}. ${error3.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
            logging_1.log(constants_1.LogVerbosity.ERROR, message);
          }
        });
        return result;
      }
    };
    exports2.Metadata = Metadata;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-credentials.js
var require_call_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-credentials.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallCredentials = void 0;
    var metadata_1 = require_metadata();
    function isCurrentOauth2Client(client) {
      return "getRequestHeaders" in client && typeof client.getRequestHeaders === "function";
    }
    var CallCredentials = class {
      static createFromMetadataGenerator(metadataGenerator) {
        return new SingleCallCredentials(metadataGenerator);
      }
      static createFromGoogleCredential(googleCredentials) {
        return CallCredentials.createFromMetadataGenerator((options2, callback) => {
          let getHeaders;
          if (isCurrentOauth2Client(googleCredentials)) {
            getHeaders = googleCredentials.getRequestHeaders(options2.service_url);
          } else {
            getHeaders = new Promise((resolve2, reject) => {
              googleCredentials.getRequestMetadata(options2.service_url, (err, headers) => {
                if (err) {
                  reject(err);
                  return;
                }
                resolve2(headers);
              });
            });
          }
          getHeaders.then((headers) => {
            const metadata = new metadata_1.Metadata();
            for (const key of Object.keys(headers)) {
              metadata.add(key, headers[key]);
            }
            callback(null, metadata);
          }, (err) => {
            callback(err);
          });
        });
      }
      static createEmpty() {
        return new EmptyCallCredentials();
      }
    };
    exports2.CallCredentials = CallCredentials;
    var ComposedCallCredentials = class extends CallCredentials {
      constructor(creds) {
        super();
        this.creds = creds;
      }
      async generateMetadata(options2) {
        const base = new metadata_1.Metadata();
        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options2)));
        for (const gen of generated) {
          base.merge(gen);
        }
        return base;
      }
      compose(other) {
        return new ComposedCallCredentials(this.creds.concat([other]));
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedCallCredentials) {
          return this.creds.every((value, index2) => value._equals(other.creds[index2]));
        } else {
          return false;
        }
      }
    };
    var SingleCallCredentials = class extends CallCredentials {
      constructor(metadataGenerator) {
        super();
        this.metadataGenerator = metadataGenerator;
      }
      generateMetadata(options2) {
        return new Promise((resolve2, reject) => {
          this.metadataGenerator(options2, (err, metadata) => {
            if (metadata !== void 0) {
              resolve2(metadata);
            } else {
              reject(err);
            }
          });
        });
      }
      compose(other) {
        return new ComposedCallCredentials([this, other]);
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SingleCallCredentials) {
          return this.metadataGenerator === other.metadataGenerator;
        } else {
          return false;
        }
      }
    };
    var EmptyCallCredentials = class extends CallCredentials {
      generateMetadata(options2) {
        return Promise.resolve(new metadata_1.Metadata());
      }
      compose(other) {
        return other;
      }
      _equals(other) {
        return other instanceof EmptyCallCredentials;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/filter-stack.js
var require_filter_stack = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter-stack.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FilterStackFactory = exports2.FilterStack = void 0;
    var FilterStack = class {
      constructor(filters) {
        this.filters = filters;
      }
      sendMetadata(metadata) {
        let result = metadata;
        for (let i = 0; i < this.filters.length; i++) {
          result = this.filters[i].sendMetadata(result);
        }
        return result;
      }
      receiveMetadata(metadata) {
        let result = metadata;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result = this.filters[i].receiveMetadata(result);
        }
        return result;
      }
      sendMessage(message) {
        let result = message;
        for (let i = 0; i < this.filters.length; i++) {
          result = this.filters[i].sendMessage(result);
        }
        return result;
      }
      receiveMessage(message) {
        let result = message;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result = this.filters[i].receiveMessage(result);
        }
        return result;
      }
      receiveTrailers(status) {
        let result = status;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result = this.filters[i].receiveTrailers(result);
        }
        return result;
      }
    };
    exports2.FilterStack = FilterStack;
    var FilterStackFactory = class {
      constructor(factories) {
        this.factories = factories;
      }
      createFilter(callStream) {
        return new FilterStack(this.factories.map((factory) => factory.createFilter(callStream)));
      }
    };
    exports2.FilterStackFactory = FilterStackFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/stream-decoder.js
var require_stream_decoder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/stream-decoder.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamDecoder = void 0;
    var ReadState;
    (function(ReadState2) {
      ReadState2[ReadState2["NO_DATA"] = 0] = "NO_DATA";
      ReadState2[ReadState2["READING_SIZE"] = 1] = "READING_SIZE";
      ReadState2[ReadState2["READING_MESSAGE"] = 2] = "READING_MESSAGE";
    })(ReadState || (ReadState = {}));
    var StreamDecoder = class {
      constructor() {
        this.readState = ReadState.NO_DATA;
        this.readCompressFlag = Buffer.alloc(1);
        this.readPartialSize = Buffer.alloc(4);
        this.readSizeRemaining = 4;
        this.readMessageSize = 0;
        this.readPartialMessage = [];
        this.readMessageRemaining = 0;
      }
      write(data) {
        let readHead = 0;
        let toRead;
        const result = [];
        while (readHead < data.length) {
          switch (this.readState) {
            case ReadState.NO_DATA:
              this.readCompressFlag = data.slice(readHead, readHead + 1);
              readHead += 1;
              this.readState = ReadState.READING_SIZE;
              this.readPartialSize.fill(0);
              this.readSizeRemaining = 4;
              this.readMessageSize = 0;
              this.readMessageRemaining = 0;
              this.readPartialMessage = [];
              break;
            case ReadState.READING_SIZE:
              toRead = Math.min(data.length - readHead, this.readSizeRemaining);
              data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
              this.readSizeRemaining -= toRead;
              readHead += toRead;
              if (this.readSizeRemaining === 0) {
                this.readMessageSize = this.readPartialSize.readUInt32BE(0);
                this.readMessageRemaining = this.readMessageSize;
                if (this.readMessageRemaining > 0) {
                  this.readState = ReadState.READING_MESSAGE;
                } else {
                  const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
                  this.readState = ReadState.NO_DATA;
                  result.push(message);
                }
              }
              break;
            case ReadState.READING_MESSAGE:
              toRead = Math.min(data.length - readHead, this.readMessageRemaining);
              this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
              this.readMessageRemaining -= toRead;
              readHead += toRead;
              if (this.readMessageRemaining === 0) {
                const framedMessageBuffers = [
                  this.readCompressFlag,
                  this.readPartialSize
                ].concat(this.readPartialMessage);
                const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
                this.readState = ReadState.NO_DATA;
                result.push(framedMessage);
              }
              break;
            default:
              throw new Error("Unexpected read state");
          }
        }
        return result;
      }
    };
    exports2.StreamDecoder = StreamDecoder;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-stream.js
var require_call_stream = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-stream.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Http2CallStream = exports2.InterceptingListenerImpl = exports2.isInterceptingListener = void 0;
    var http2 = require("http2");
    var os = require("os");
    var constants_1 = require_constants();
    var filter_stack_1 = require_filter_stack();
    var metadata_1 = require_metadata();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var constants_2 = require_constants();
    var TRACER_NAME = "call_stream";
    var { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL } = http2.constants;
    function getSystemErrorName(errno) {
      for (const [name, num] of Object.entries(os.constants.errno)) {
        if (num === errno) {
          return name;
        }
      }
      return "Unknown system error " + errno;
    }
    function isInterceptingListener(listener) {
      return listener.onReceiveMetadata !== void 0 && listener.onReceiveMetadata.length === 1;
    }
    exports2.isInterceptingListener = isInterceptingListener;
    var InterceptingListenerImpl = class {
      constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.processingMessage = false;
        this.pendingStatus = null;
      }
      onReceiveMetadata(metadata) {
        this.listener.onReceiveMetadata(metadata, (metadata2) => {
          this.nextListener.onReceiveMetadata(metadata2);
        });
      }
      onReceiveMessage(message) {
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, (msg) => {
          this.processingMessage = false;
          this.nextListener.onReceiveMessage(msg);
          if (this.pendingStatus) {
            this.nextListener.onReceiveStatus(this.pendingStatus);
          }
        });
      }
      onReceiveStatus(status) {
        this.listener.onReceiveStatus(status, (processedStatus) => {
          if (this.processingMessage) {
            this.pendingStatus = processedStatus;
          } else {
            this.nextListener.onReceiveStatus(processedStatus);
          }
        });
      }
    };
    exports2.InterceptingListenerImpl = InterceptingListenerImpl;
    var Http2CallStream = class {
      constructor(methodName, channel, options2, filterStackFactory, channelCallCredentials, callNumber) {
        this.methodName = methodName;
        this.channel = channel;
        this.options = options2;
        this.channelCallCredentials = channelCallCredentials;
        this.callNumber = callNumber;
        this.http2Stream = null;
        this.pendingRead = false;
        this.isWriteFilterPending = false;
        this.pendingWrite = null;
        this.pendingWriteCallback = null;
        this.writesClosed = false;
        this.decoder = new stream_decoder_1.StreamDecoder();
        this.isReadFilterPending = false;
        this.canPush = false;
        this.readsClosed = false;
        this.statusOutput = false;
        this.unpushedReadMessages = [];
        this.unfilteredReadMessages = [];
        this.mappedStatusCode = constants_1.Status.UNKNOWN;
        this.finalStatus = null;
        this.subchannel = null;
        this.listener = null;
        this.internalError = null;
        this.filterStack = filterStackFactory.createFilter(this);
        this.credentials = channelCallCredentials;
        this.disconnectListener = () => {
          this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: "Connection dropped",
            metadata: new metadata_1.Metadata()
          });
        };
        if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {
          this.options.parentCall.on("cancelled", () => {
            this.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled by parent call");
          });
        }
      }
      outputStatus() {
        if (!this.statusOutput) {
          this.statusOutput = true;
          const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);
          process.nextTick(() => {
            var _a;
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);
          });
          if (this.subchannel) {
            this.subchannel.callUnref();
            this.subchannel.removeDisconnectListener(this.disconnectListener);
          }
        }
      }
      trace(text) {
        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      endCall(status) {
        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
          this.trace("ended with status: code=" + status.code + ' details="' + status.details + '"');
          this.finalStatus = status;
          this.maybeOutputStatus();
        }
        this.destroyHttp2Stream();
      }
      maybeOutputStatus() {
        if (this.finalStatus !== null) {
          if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {
            this.outputStatus();
          }
        }
      }
      push(message) {
        this.trace("pushing to reader message of length " + (message instanceof Buffer ? message.length : null));
        this.canPush = false;
        process.nextTick(() => {
          var _a;
          if (this.statusOutput) {
            return;
          }
          (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);
          this.maybeOutputStatus();
        });
      }
      handleFilterError(error3) {
        this.cancelWithStatus(constants_1.Status.INTERNAL, error3.message);
      }
      handleFilteredRead(message) {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.maybeOutputStatus();
          return;
        }
        this.isReadFilterPending = false;
        if (this.canPush) {
          this.http2Stream.pause();
          this.push(message);
        } else {
          this.trace("unpushedReadMessages.push message of length " + message.length);
          this.unpushedReadMessages.push(message);
        }
        if (this.unfilteredReadMessages.length > 0) {
          const nextMessage = this.unfilteredReadMessages.shift();
          this.filterReceivedMessage(nextMessage);
        }
      }
      filterReceivedMessage(framedMessage) {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.maybeOutputStatus();
          return;
        }
        this.trace("filterReceivedMessage of length " + framedMessage.length);
        this.isReadFilterPending = true;
        this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));
      }
      tryPush(messageBytes) {
        if (this.isReadFilterPending) {
          this.trace("unfilteredReadMessages.push message of length " + (messageBytes && messageBytes.length));
          this.unfilteredReadMessages.push(messageBytes);
        } else {
          this.filterReceivedMessage(messageBytes);
        }
      }
      handleTrailers(headers) {
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "		" + header + ": " + headers[header] + "\n";
        }
        this.trace("Received server trailers:\n" + headersString);
        let metadata;
        try {
          metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        } catch (e) {
          metadata = new metadata_1.Metadata();
        }
        const metadataMap = metadata.getMap();
        let code = this.mappedStatusCode;
        if (code === constants_1.Status.UNKNOWN && typeof metadataMap["grpc-status"] === "string") {
          const receivedStatus = Number(metadataMap["grpc-status"]);
          if (receivedStatus in constants_1.Status) {
            code = receivedStatus;
            this.trace("received status code " + receivedStatus + " from server");
          }
          metadata.remove("grpc-status");
        }
        let details = "";
        if (typeof metadataMap["grpc-message"] === "string") {
          details = decodeURI(metadataMap["grpc-message"]);
          metadata.remove("grpc-message");
          this.trace('received status details string "' + details + '" from server');
        }
        const status = { code, details, metadata };
        this.endCall(status);
      }
      attachHttp2Stream(stream, subchannel, extraFilterFactory) {
        if (extraFilterFactory !== void 0) {
          this.filterStack = new filter_stack_1.FilterStack([
            this.filterStack,
            extraFilterFactory.createFilter(this)
          ]);
        }
        if (this.finalStatus !== null) {
          stream.close(NGHTTP2_CANCEL);
        } else {
          this.trace("attachHttp2Stream from subchannel " + subchannel.getAddress());
          this.http2Stream = stream;
          this.subchannel = subchannel;
          subchannel.addDisconnectListener(this.disconnectListener);
          subchannel.callRef();
          stream.on("response", (headers, flags) => {
            var _a;
            let headersString = "";
            for (const header of Object.keys(headers)) {
              headersString += "		" + header + ": " + headers[header] + "\n";
            }
            this.trace("Received server headers:\n" + headersString);
            switch (headers[":status"]) {
              case 400:
                this.mappedStatusCode = constants_1.Status.INTERNAL;
                break;
              case 401:
                this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
                break;
              case 403:
                this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
                break;
              case 404:
                this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
                break;
              case 429:
              case 502:
              case 503:
              case 504:
                this.mappedStatusCode = constants_1.Status.UNAVAILABLE;
                break;
              default:
                this.mappedStatusCode = constants_1.Status.UNKNOWN;
            }
            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
              this.handleTrailers(headers);
            } else {
              let metadata;
              try {
                metadata = metadata_1.Metadata.fromHttp2Headers(headers);
              } catch (error3) {
                this.endCall({
                  code: constants_1.Status.UNKNOWN,
                  details: error3.message,
                  metadata: new metadata_1.Metadata()
                });
                return;
              }
              try {
                const finalMetadata = this.filterStack.receiveMetadata(metadata);
                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);
              } catch (error3) {
                this.endCall({
                  code: constants_1.Status.UNKNOWN,
                  details: error3.message,
                  metadata: new metadata_1.Metadata()
                });
              }
            }
          });
          stream.on("trailers", this.handleTrailers.bind(this));
          stream.on("data", (data) => {
            this.trace("receive HTTP/2 data frame of length " + data.length);
            const messages = this.decoder.write(data);
            for (const message of messages) {
              this.trace("parsed message of length " + message.length);
              this.tryPush(message);
            }
          });
          stream.on("end", () => {
            this.readsClosed = true;
            this.maybeOutputStatus();
          });
          stream.on("close", () => {
            process.nextTick(() => {
              var _a;
              this.trace("HTTP/2 stream closed with code " + stream.rstCode);
              if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
                return;
              }
              let code;
              let details = "";
              switch (stream.rstCode) {
                case http2.constants.NGHTTP2_NO_ERROR:
                  if (this.finalStatus !== null) {
                    return;
                  }
                  code = constants_1.Status.INTERNAL;
                  details = `Received RST_STREAM with code ${stream.rstCode}`;
                  break;
                case http2.constants.NGHTTP2_REFUSED_STREAM:
                  code = constants_1.Status.UNAVAILABLE;
                  details = "Stream refused by server";
                  break;
                case http2.constants.NGHTTP2_CANCEL:
                  code = constants_1.Status.CANCELLED;
                  details = "Call cancelled";
                  break;
                case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                  code = constants_1.Status.RESOURCE_EXHAUSTED;
                  details = "Bandwidth exhausted";
                  break;
                case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
                  code = constants_1.Status.PERMISSION_DENIED;
                  details = "Protocol not secure enough";
                  break;
                case http2.constants.NGHTTP2_INTERNAL_ERROR:
                  code = constants_1.Status.INTERNAL;
                  if (this.internalError === null) {
                    details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;
                  } else {
                    if (this.internalError.code === "ECONNRESET") {
                      code = constants_1.Status.UNAVAILABLE;
                      details = this.internalError.message;
                    } else {
                      details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                    }
                  }
                  break;
                default:
                  code = constants_1.Status.INTERNAL;
                  details = `Received RST_STREAM with code ${stream.rstCode}`;
              }
              this.endCall({ code, details, metadata: new metadata_1.Metadata() });
            });
          });
          stream.on("error", (err) => {
            if (err.code !== "ERR_HTTP2_STREAM_ERROR") {
              this.trace("Node error event: message=" + err.message + " code=" + err.code + " errno=" + getSystemErrorName(err.errno) + " syscall=" + err.syscall);
              this.internalError = err;
            }
          });
          if (!this.pendingRead) {
            stream.pause();
          }
          if (this.pendingWrite) {
            if (!this.pendingWriteCallback) {
              throw new Error("Invalid state in write handling code");
            }
            this.trace("sending data chunk of length " + this.pendingWrite.length + " (deferred)");
            stream.write(this.pendingWrite, this.pendingWriteCallback);
          }
          this.maybeCloseWrites();
        }
      }
      start(metadata, listener) {
        this.trace("Sending metadata");
        this.listener = listener;
        this.channel._startCallStream(this, metadata);
      }
      destroyHttp2Stream() {
        var _a;
        if (this.http2Stream !== null && !this.http2Stream.destroyed) {
          let code;
          if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
            code = http2.constants.NGHTTP2_NO_ERROR;
          } else {
            code = http2.constants.NGHTTP2_CANCEL;
          }
          this.trace("close http2 stream with code " + code);
          this.http2Stream.close(code);
        }
      }
      cancelWithStatus(status, details) {
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });
      }
      getDeadline() {
        if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {
          const parentDeadline = this.options.parentCall.getDeadline();
          const selfDeadline = this.options.deadline;
          const parentDeadlineMsecs = parentDeadline instanceof Date ? parentDeadline.getTime() : parentDeadline;
          const selfDeadlineMsecs = selfDeadline instanceof Date ? selfDeadline.getTime() : selfDeadline;
          return Math.min(parentDeadlineMsecs, selfDeadlineMsecs);
        } else {
          return this.options.deadline;
        }
      }
      getCredentials() {
        return this.credentials;
      }
      setCredentials(credentials) {
        this.credentials = this.channelCallCredentials.compose(credentials);
      }
      getStatus() {
        return this.finalStatus;
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
      }
      getMethod() {
        return this.methodName;
      }
      getHost() {
        return this.options.host;
      }
      startRead() {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.readsClosed = true;
          this.maybeOutputStatus();
          return;
        }
        this.canPush = true;
        if (this.http2Stream === null) {
          this.pendingRead = true;
        } else {
          if (this.unpushedReadMessages.length > 0) {
            const nextMessage = this.unpushedReadMessages.shift();
            this.push(nextMessage);
            return;
          }
          this.http2Stream.resume();
        }
      }
      maybeCloseWrites() {
        if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {
          this.trace("calling end() on HTTP/2 stream");
          this.http2Stream.end();
        }
      }
      sendMessageWithContext(context, message) {
        var _a;
        this.trace("write() called with message of length " + message.length);
        const writeObj = {
          message,
          flags: context.flags
        };
        const cb = (_a = context.callback) !== null && _a !== void 0 ? _a : () => {
        };
        this.isWriteFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message2) => {
          this.isWriteFilterPending = false;
          if (this.http2Stream === null) {
            this.trace("deferring writing data chunk of length " + message2.message.length);
            this.pendingWrite = message2.message;
            this.pendingWriteCallback = cb;
          } else {
            this.trace("sending data chunk of length " + message2.message.length);
            this.http2Stream.write(message2.message, cb);
            this.maybeCloseWrites();
          }
        }, this.handleFilterError.bind(this));
      }
      halfClose() {
        this.trace("end() called");
        this.writesClosed = true;
        this.maybeCloseWrites();
      }
    };
    exports2.Http2CallStream = Http2CallStream;
  }
});

// node_modules/@grpc/grpc-js/build/src/tls-helpers.js
var require_tls_helpers = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/tls-helpers.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultRootsData = exports2.CIPHER_SUITES = void 0;
    var fs = require("fs");
    exports2.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
    var DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
    var defaultRootsData = null;
    function getDefaultRootsData() {
      if (DEFAULT_ROOTS_FILE_PATH) {
        if (defaultRootsData === null) {
          defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
        }
        return defaultRootsData;
      }
      return null;
    }
    exports2.getDefaultRootsData = getDefaultRootsData;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-credentials.js
var require_channel_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-credentials.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelCredentials = void 0;
    var tls_1 = require("tls");
    var call_credentials_1 = require_call_credentials();
    var tls_helpers_1 = require_tls_helpers();
    function verifyIsBufferOrNull(obj, friendlyName) {
      if (obj && !(obj instanceof Buffer)) {
        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
      }
    }
    function bufferOrNullEqual(buf1, buf2) {
      if (buf1 === null && buf2 === null) {
        return true;
      } else {
        return buf1 !== null && buf2 !== null && buf1.equals(buf2);
      }
    }
    var ChannelCredentials = class {
      constructor(callCredentials) {
        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
      }
      _getCallCredentials() {
        return this.callCredentials;
      }
      static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
        verifyIsBufferOrNull(rootCerts, "Root certificate");
        verifyIsBufferOrNull(privateKey, "Private key");
        verifyIsBufferOrNull(certChain, "Certificate chain");
        if (privateKey && !certChain) {
          throw new Error("Private key must be given with accompanying certificate chain");
        }
        if (!privateKey && certChain) {
          throw new Error("Certificate chain must be given with accompanying private key");
        }
        return new SecureChannelCredentialsImpl(rootCerts || tls_helpers_1.getDefaultRootsData(), privateKey || null, certChain || null, verifyOptions || {});
      }
      static createInsecure() {
        return new InsecureChannelCredentialsImpl();
      }
    };
    exports2.ChannelCredentials = ChannelCredentials;
    var InsecureChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(callCredentials) {
        super(callCredentials);
      }
      compose(callCredentials) {
        throw new Error("Cannot compose insecure credentials");
      }
      _getConnectionOptions() {
        return null;
      }
      _isSecure() {
        return false;
      }
      _equals(other) {
        return other instanceof InsecureChannelCredentialsImpl;
      }
    };
    var SecureChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(rootCerts, privateKey, certChain, verifyOptions) {
        super();
        this.rootCerts = rootCerts;
        this.privateKey = privateKey;
        this.certChain = certChain;
        this.verifyOptions = verifyOptions;
        const secureContext = tls_1.createSecureContext({
          ca: rootCerts || void 0,
          key: privateKey || void 0,
          cert: certChain || void 0,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
        this.connectionOptions = { secureContext };
        if (verifyOptions && verifyOptions.checkServerIdentity) {
          this.connectionOptions.checkServerIdentity = (host, cert) => {
            return verifyOptions.checkServerIdentity(host, { raw: cert.raw });
          };
        }
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return Object.assign({}, this.connectionOptions);
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SecureChannelCredentialsImpl) {
          if (!bufferOrNullEqual(this.rootCerts, other.rootCerts)) {
            return false;
          }
          if (!bufferOrNullEqual(this.privateKey, other.privateKey)) {
            return false;
          }
          if (!bufferOrNullEqual(this.certChain, other.certChain)) {
            return false;
          }
          return this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;
        } else {
          return false;
        }
      }
    };
    var ComposedChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(channelCredentials, callCreds) {
        super(callCreds);
        this.channelCredentials = channelCredentials;
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return this.channelCredentials._getConnectionOptions();
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedChannelCredentialsImpl) {
          return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);
        } else {
          return false;
        }
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/picker.js
var require_picker = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/picker.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueuePicker = exports2.UnavailablePicker = exports2.PickResultType = void 0;
    var metadata_1 = require_metadata();
    var constants_1 = require_constants();
    var PickResultType;
    (function(PickResultType2) {
      PickResultType2[PickResultType2["COMPLETE"] = 0] = "COMPLETE";
      PickResultType2[PickResultType2["QUEUE"] = 1] = "QUEUE";
      PickResultType2[PickResultType2["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
      PickResultType2[PickResultType2["DROP"] = 3] = "DROP";
    })(PickResultType = exports2.PickResultType || (exports2.PickResultType = {}));
    var UnavailablePicker = class {
      constructor(status) {
        if (status !== void 0) {
          this.status = status;
        } else {
          this.status = {
            code: constants_1.Status.UNAVAILABLE,
            details: "No connection established",
            metadata: new metadata_1.Metadata()
          };
        }
      }
      pick(pickArgs) {
        return {
          pickResultType: PickResultType.TRANSIENT_FAILURE,
          subchannel: null,
          status: this.status,
          extraFilterFactory: null,
          onCallStarted: null
        };
      }
    };
    exports2.UnavailablePicker = UnavailablePicker;
    var QueuePicker = class {
      constructor(loadBalancer) {
        this.loadBalancer = loadBalancer;
        this.calledExitIdle = false;
      }
      pick(pickArgs) {
        if (!this.calledExitIdle) {
          process.nextTick(() => {
            this.loadBalancer.exitIdle();
          });
          this.calledExitIdle = true;
        }
        return {
          pickResultType: PickResultType.QUEUE,
          subchannel: null,
          status: null,
          extraFilterFactory: null,
          onCallStarted: null
        };
      }
    };
    exports2.QueuePicker = QueuePicker;
  }
});

// node_modules/@grpc/grpc-js/build/src/backoff-timeout.js
var require_backoff_timeout = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/backoff-timeout.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BackoffTimeout = void 0;
    var INITIAL_BACKOFF_MS = 1e3;
    var BACKOFF_MULTIPLIER = 1.6;
    var MAX_BACKOFF_MS = 12e4;
    var BACKOFF_JITTER = 0.2;
    function uniformRandom(min, max) {
      return Math.random() * (max - min) + min;
    }
    var BackoffTimeout = class {
      constructor(callback, options2) {
        this.callback = callback;
        this.initialDelay = INITIAL_BACKOFF_MS;
        this.multiplier = BACKOFF_MULTIPLIER;
        this.maxDelay = MAX_BACKOFF_MS;
        this.jitter = BACKOFF_JITTER;
        this.running = false;
        this.hasRef = true;
        if (options2) {
          if (options2.initialDelay) {
            this.initialDelay = options2.initialDelay;
          }
          if (options2.multiplier) {
            this.multiplier = options2.multiplier;
          }
          if (options2.jitter) {
            this.jitter = options2.jitter;
          }
          if (options2.maxDelay) {
            this.maxDelay = options2.maxDelay;
          }
        }
        this.nextDelay = this.initialDelay;
        this.timerId = setTimeout(() => {
        }, 0);
        clearTimeout(this.timerId);
      }
      runOnce() {
        var _a, _b;
        this.running = true;
        this.timerId = setTimeout(() => {
          this.callback();
          this.running = false;
        }, this.nextDelay);
        if (!this.hasRef) {
          (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
        const jitterMagnitude = nextBackoff * this.jitter;
        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
      }
      stop() {
        clearTimeout(this.timerId);
        this.running = false;
      }
      reset() {
        this.nextDelay = this.initialDelay;
      }
      isRunning() {
        return this.running;
      }
      ref() {
        var _a, _b;
        this.hasRef = true;
        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      unref() {
        var _a, _b;
        this.hasRef = false;
        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    };
    exports2.BackoffTimeout = BackoffTimeout;
  }
});

// node_modules/@grpc/grpc-js/build/src/service-config.js
var require_service_config = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/service-config.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractAndSelectServiceConfig = exports2.validateServiceConfig = void 0;
    var os = require("os");
    var load_balancer_1 = require_load_balancer();
    var TIMEOUT_REGEX = /^\d+(\.\d{1,9})?s$/;
    var CLIENT_LANGUAGE_STRING = "node";
    function validateName(obj) {
      if (!("service" in obj) || typeof obj.service !== "string") {
        throw new Error("Invalid method config name: invalid service");
      }
      const result = {
        service: obj.service
      };
      if ("method" in obj) {
        if (typeof obj.method === "string") {
          result.method = obj.method;
        } else {
          throw new Error("Invalid method config name: invalid method");
        }
      }
      return result;
    }
    function validateMethodConfig(obj) {
      const result = {
        name: []
      };
      if (!("name" in obj) || !Array.isArray(obj.name)) {
        throw new Error("Invalid method config: invalid name array");
      }
      for (const name of obj.name) {
        result.name.push(validateName(name));
      }
      if ("waitForReady" in obj) {
        if (typeof obj.waitForReady !== "boolean") {
          throw new Error("Invalid method config: invalid waitForReady");
        }
        result.waitForReady = obj.waitForReady;
      }
      if ("timeout" in obj) {
        if (!(typeof obj.timeout === "string") || !TIMEOUT_REGEX.test(obj.timeout)) {
          throw new Error("Invalid method config: invalid timeout");
        }
        result.timeout = obj.timeout;
      }
      if ("maxRequestBytes" in obj) {
        if (typeof obj.maxRequestBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result.maxRequestBytes = obj.maxRequestBytes;
      }
      if ("maxResponseBytes" in obj) {
        if (typeof obj.maxResponseBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result.maxResponseBytes = obj.maxResponseBytes;
      }
      return result;
    }
    function validateServiceConfig(obj) {
      const result = {
        loadBalancingConfig: [],
        methodConfig: []
      };
      if ("loadBalancingPolicy" in obj) {
        if (typeof obj.loadBalancingPolicy === "string") {
          result.loadBalancingPolicy = obj.loadBalancingPolicy;
        } else {
          throw new Error("Invalid service config: invalid loadBalancingPolicy");
        }
      }
      if ("loadBalancingConfig" in obj) {
        if (Array.isArray(obj.loadBalancingConfig)) {
          for (const config of obj.loadBalancingConfig) {
            result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config));
          }
        } else {
          throw new Error("Invalid service config: invalid loadBalancingConfig");
        }
      }
      if ("methodConfig" in obj) {
        if (Array.isArray(obj.methodConfig)) {
          for (const methodConfig of obj.methodConfig) {
            result.methodConfig.push(validateMethodConfig(methodConfig));
          }
        }
      }
      const seenMethodNames = [];
      for (const methodConfig of result.methodConfig) {
        for (const name of methodConfig.name) {
          for (const seenName of seenMethodNames) {
            if (name.service === seenName.service && name.method === seenName.method) {
              throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
            }
          }
          seenMethodNames.push(name);
        }
      }
      return result;
    }
    exports2.validateServiceConfig = validateServiceConfig;
    function validateCanaryConfig(obj) {
      if (!("serviceConfig" in obj)) {
        throw new Error("Invalid service config choice: missing service config");
      }
      const result = {
        serviceConfig: validateServiceConfig(obj.serviceConfig)
      };
      if ("clientLanguage" in obj) {
        if (Array.isArray(obj.clientLanguage)) {
          result.clientLanguage = [];
          for (const lang of obj.clientLanguage) {
            if (typeof lang === "string") {
              result.clientLanguage.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientLanguage");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientLanguage");
        }
      }
      if ("clientHostname" in obj) {
        if (Array.isArray(obj.clientHostname)) {
          result.clientHostname = [];
          for (const lang of obj.clientHostname) {
            if (typeof lang === "string") {
              result.clientHostname.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientHostname");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientHostname");
        }
      }
      if ("percentage" in obj) {
        if (typeof obj.percentage === "number" && 0 <= obj.percentage && obj.percentage <= 100) {
          result.percentage = obj.percentage;
        } else {
          throw new Error("Invalid service config choice: invalid percentage");
        }
      }
      const allowedFields = [
        "clientLanguage",
        "percentage",
        "clientHostname",
        "serviceConfig"
      ];
      for (const field in obj) {
        if (!allowedFields.includes(field)) {
          throw new Error(`Invalid service config choice: unexpected field ${field}`);
        }
      }
      return result;
    }
    function validateAndSelectCanaryConfig(obj, percentage) {
      if (!Array.isArray(obj)) {
        throw new Error("Invalid service config list");
      }
      for (const config of obj) {
        const validatedConfig = validateCanaryConfig(config);
        if (typeof validatedConfig.percentage === "number" && percentage > validatedConfig.percentage) {
          continue;
        }
        if (Array.isArray(validatedConfig.clientHostname)) {
          let hostnameMatched = false;
          for (const hostname of validatedConfig.clientHostname) {
            if (hostname === os.hostname()) {
              hostnameMatched = true;
            }
          }
          if (!hostnameMatched) {
            continue;
          }
        }
        if (Array.isArray(validatedConfig.clientLanguage)) {
          let languageMatched = false;
          for (const language of validatedConfig.clientLanguage) {
            if (language === CLIENT_LANGUAGE_STRING) {
              languageMatched = true;
            }
          }
          if (!languageMatched) {
            continue;
          }
        }
        return validatedConfig.serviceConfig;
      }
      throw new Error("No matching service config found");
    }
    function extractAndSelectServiceConfig(txtRecord, percentage) {
      for (const record of txtRecord) {
        if (record.length > 0 && record[0].startsWith("grpc_config=")) {
          const recordString = record.join("").substring("grpc_config=".length);
          const recordJson = JSON.parse(recordString);
          return validateAndSelectCanaryConfig(recordJson, percentage);
        }
      }
      return null;
    }
    exports2.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
  }
});

// node_modules/@grpc/grpc-js/build/src/uri-parser.js
var require_uri_parser = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/uri-parser.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uriToString = exports2.splitHostPort = exports2.parseUri = void 0;
    var URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
    function parseUri(uriString) {
      const parsedUri = URI_REGEX.exec(uriString);
      if (parsedUri === null) {
        return null;
      }
      return {
        scheme: parsedUri[1],
        authority: parsedUri[2],
        path: parsedUri[3]
      };
    }
    exports2.parseUri = parseUri;
    var NUMBER_REGEX = /^\d+$/;
    function splitHostPort(path) {
      if (path.startsWith("[")) {
        const hostEnd = path.indexOf("]");
        if (hostEnd === -1) {
          return null;
        }
        const host = path.substring(1, hostEnd);
        if (host.indexOf(":") === -1) {
          return null;
        }
        if (path.length > hostEnd + 1) {
          if (path[hostEnd + 1] === ":") {
            const portString = path.substring(hostEnd + 2);
            if (NUMBER_REGEX.test(portString)) {
              return {
                host,
                port: +portString
              };
            } else {
              return null;
            }
          } else {
            return null;
          }
        } else {
          return {
            host
          };
        }
      } else {
        const splitPath = path.split(":");
        if (splitPath.length === 2) {
          if (NUMBER_REGEX.test(splitPath[1])) {
            return {
              host: splitPath[0],
              port: +splitPath[1]
            };
          } else {
            return null;
          }
        } else {
          return {
            host: path
          };
        }
      }
    }
    exports2.splitHostPort = splitHostPort;
    function uriToString(uri) {
      let result = "";
      if (uri.scheme !== void 0) {
        result += uri.scheme + ":";
      }
      if (uri.authority !== void 0) {
        result += "//" + uri.authority + "/";
      }
      result += uri.path;
      return result;
    }
    exports2.uriToString = uriToString;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-dns.js
var require_resolver_dns = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-dns.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var resolver_1 = require_resolver();
    var dns = require("dns");
    var util = require("util");
    var service_config_1 = require_service_config();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var net_1 = require("net");
    var TRACER_NAME = "dns_resolver";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var DEFAULT_PORT = 443;
    var resolveTxtPromise = util.promisify(dns.resolveTxt);
    var dnsLookupPromise = util.promisify(dns.lookup);
    function mergeArrays(...arrays) {
      const result = [];
      for (let i = 0; i < Math.max.apply(null, arrays.map((array) => array.length)); i++) {
        for (const array of arrays) {
          if (i < array.length) {
            result.push(array[i]);
          }
        }
      }
      return result;
    }
    var DnsResolver = class {
      constructor(target, listener, channelOptions) {
        var _a, _b;
        this.target = target;
        this.listener = listener;
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        trace("Resolver constructed for target " + uri_parser_1.uriToString(target));
        const hostPort = uri_parser_1.splitHostPort(target.path);
        if (hostPort === null) {
          this.ipResult = null;
          this.dnsHostname = null;
          this.port = null;
        } else {
          if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {
            this.ipResult = [
              {
                host: hostPort.host,
                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
              }
            ];
            this.dnsHostname = null;
            this.port = null;
          } else {
            this.ipResult = null;
            this.dnsHostname = hostPort.host;
            this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;
          }
        }
        this.percentage = Math.random() * 100;
        this.defaultResolutionError = {
          code: constants_1.Status.UNAVAILABLE,
          details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,
          metadata: new metadata_1.Metadata()
        };
      }
      startResolution() {
        if (this.ipResult !== null) {
          trace("Returning IP address for target " + uri_parser_1.uriToString(this.target));
          setImmediate(() => {
            this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
          });
          return;
        }
        if (this.dnsHostname === null) {
          setImmediate(() => {
            this.listener.onError({
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,
              metadata: new metadata_1.Metadata()
            });
          });
        } else {
          this.latestLookupResult = null;
          const hostname = this.dnsHostname;
          this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });
          this.pendingLookupPromise.then((addressList) => {
            this.pendingLookupPromise = null;
            const ip4Addresses = addressList.filter((addr) => addr.family === 4);
            const ip6Addresses = addressList.filter((addr) => addr.family === 6);
            this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr) => ({ host: addr.address, port: +this.port }));
            const allAddressesString = "[" + this.latestLookupResult.map((addr) => addr.host + ":" + addr.port).join(",") + "]";
            trace("Resolved addresses for target " + uri_parser_1.uriToString(this.target) + ": " + allAddressesString);
            if (this.latestLookupResult.length === 0) {
              this.listener.onError(this.defaultResolutionError);
              return;
            }
            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
          }, (err) => {
            trace("Resolution error for target " + uri_parser_1.uriToString(this.target) + ": " + err.message);
            this.pendingLookupPromise = null;
            this.listener.onError(this.defaultResolutionError);
          });
          if (this.pendingTxtPromise === null) {
            this.pendingTxtPromise = resolveTxtPromise(hostname);
            this.pendingTxtPromise.then((txtRecord) => {
              this.pendingTxtPromise = null;
              try {
                this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);
              } catch (err) {
                this.latestServiceConfigError = {
                  code: constants_1.Status.UNAVAILABLE,
                  details: "Parsing service config failed",
                  metadata: new metadata_1.Metadata()
                };
              }
              if (this.latestLookupResult !== null) {
                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
              }
            }, (err) => {
            });
          }
        }
      }
      updateResolution() {
        trace("Resolution update requested for target " + uri_parser_1.uriToString(this.target));
        if (this.pendingLookupPromise === null) {
          this.startResolution();
        }
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return target.path;
      }
    };
    function setup() {
      resolver_1.registerResolver("dns", DnsResolver);
      resolver_1.registerDefaultScheme("dns");
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-uds.js
var require_resolver_uds = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-uds.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var resolver_1 = require_resolver();
    var UdsResolver = class {
      constructor(target, listener, channelOptions) {
        this.listener = listener;
        this.addresses = [];
        let path;
        if (target.authority === "") {
          path = "/" + target.path;
        } else {
          path = target.path;
        }
        this.addresses = [{ path }];
      }
      updateResolution() {
        process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return "localhost";
      }
    };
    function setup() {
      resolver_1.registerResolver("unix", UdsResolver);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-ip.js
var require_resolver_ip = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-ip.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var net_1 = require("net");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var resolver_1 = require_resolver();
    var uri_parser_1 = require_uri_parser();
    var logging = require_logging();
    var TRACER_NAME = "ip_resolver";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var IPV4_SCHEME = "ipv4";
    var IPV6_SCHEME = "ipv6";
    var DEFAULT_PORT = 443;
    var IpResolver = class {
      constructor(target, listener, channelOptions) {
        var _a;
        this.target = target;
        this.listener = listener;
        this.addresses = [];
        this.error = null;
        trace("Resolver constructed for target " + uri_parser_1.uriToString(target));
        const addresses = [];
        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
          this.error = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Unrecognized scheme ${target.scheme} in IP resolver`,
            metadata: new metadata_1.Metadata()
          };
          return;
        }
        const pathList = target.path.split(",");
        for (const path of pathList) {
          const hostPort = uri_parser_1.splitHostPort(path);
          if (hostPort === null) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          if (target.scheme === IPV4_SCHEME && !net_1.isIPv4(hostPort.host) || target.scheme === IPV6_SCHEME && !net_1.isIPv6(hostPort.host)) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          addresses.push({
            host: hostPort.host,
            port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
          });
        }
        this.addresses = addresses;
        trace("Parsed " + target.scheme + " address list " + this.addresses);
      }
      updateResolution() {
        process.nextTick(() => {
          if (this.error) {
            this.listener.onError(this.error);
          } else {
            this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});
          }
        });
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return target.path.split(",")[0];
      }
    };
    function setup() {
      resolver_1.registerResolver(IPV4_SCHEME, IpResolver);
      resolver_1.registerResolver(IPV6_SCHEME, IpResolver);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver.js
var require_resolver = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerAll = exports2.mapUriDefaultScheme = exports2.getDefaultAuthority = exports2.createResolver = exports2.registerDefaultScheme = exports2.registerResolver = void 0;
    var resolver_dns = require_resolver_dns();
    var resolver_uds = require_resolver_uds();
    var resolver_ip = require_resolver_ip();
    var uri_parser_1 = require_uri_parser();
    var registeredResolvers = {};
    var defaultScheme = null;
    function registerResolver(scheme, resolverClass) {
      registeredResolvers[scheme] = resolverClass;
    }
    exports2.registerResolver = registerResolver;
    function registerDefaultScheme(scheme) {
      defaultScheme = scheme;
    }
    exports2.registerDefaultScheme = registerDefaultScheme;
    function createResolver(target, listener, options2) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return new registeredResolvers[target.scheme](target, listener, options2);
      } else {
        throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);
      }
    }
    exports2.createResolver = createResolver;
    function getDefaultAuthority(target) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return registeredResolvers[target.scheme].getDefaultAuthority(target);
      } else {
        throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);
      }
    }
    exports2.getDefaultAuthority = getDefaultAuthority;
    function mapUriDefaultScheme(target) {
      if (target.scheme === void 0 || !(target.scheme in registeredResolvers)) {
        if (defaultScheme !== null) {
          return {
            scheme: defaultScheme,
            authority: void 0,
            path: uri_parser_1.uriToString(target)
          };
        } else {
          return null;
        }
      }
      return target;
    }
    exports2.mapUriDefaultScheme = mapUriDefaultScheme;
    function registerAll() {
      resolver_dns.setup();
      resolver_uds.setup();
      resolver_ip.setup();
    }
    exports2.registerAll = registerAll;
  }
});

// node_modules/@grpc/grpc-js/build/src/http_proxy.js
var require_http_proxy = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/http_proxy.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProxiedConnection = exports2.mapProxyName = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants();
    var resolver_1 = require_resolver();
    var http2 = require("http");
    var tls = require("tls");
    var logging = require_logging();
    var subchannel_1 = require_subchannel();
    var uri_parser_1 = require_uri_parser();
    var url_1 = require("url");
    var TRACER_NAME = "proxy";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function getProxyInfo() {
      let proxyEnv = "";
      let envVar = "";
      if (process.env.grpc_proxy) {
        envVar = "grpc_proxy";
        proxyEnv = process.env.grpc_proxy;
      } else if (process.env.https_proxy) {
        envVar = "https_proxy";
        proxyEnv = process.env.https_proxy;
      } else if (process.env.http_proxy) {
        envVar = "http_proxy";
        proxyEnv = process.env.http_proxy;
      } else {
        return {};
      }
      let proxyUrl;
      try {
        proxyUrl = new url_1.URL(proxyEnv);
      } catch (e) {
        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
        return {};
      }
      if (proxyUrl.protocol !== "http:") {
        logging_1.log(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
        return {};
      }
      let userCred = null;
      if (proxyUrl.username) {
        if (proxyUrl.password) {
          logging_1.log(constants_1.LogVerbosity.INFO, "userinfo found in proxy URI");
          userCred = `${proxyUrl.username}:${proxyUrl.password}`;
        } else {
          userCred = proxyUrl.username;
        }
      }
      const hostname = proxyUrl.hostname;
      let port = proxyUrl.port;
      if (port === "") {
        port = "80";
      }
      const result = {
        address: `${hostname}:${port}`
      };
      if (userCred) {
        result.creds = userCred;
      }
      trace("Proxy server " + result.address + " set by environment variable " + envVar);
      return result;
    }
    function getNoProxyHostList() {
      let noProxyStr = process.env.no_grpc_proxy;
      let envVar = "no_grpc_proxy";
      if (!noProxyStr) {
        noProxyStr = process.env.no_proxy;
        envVar = "no_proxy";
      }
      if (noProxyStr) {
        trace("No proxy server list set by environment variable " + envVar);
        return noProxyStr.split(",");
      } else {
        return [];
      }
    }
    function mapProxyName(target, options2) {
      var _a;
      const noProxyResult = {
        target,
        extraOptions: {}
      };
      if (((_a = options2["grpc.enable_http_proxy"]) !== null && _a !== void 0 ? _a : 1) === 0) {
        return noProxyResult;
      }
      const proxyInfo = getProxyInfo();
      if (!proxyInfo.address) {
        return noProxyResult;
      }
      const hostPort = uri_parser_1.splitHostPort(target.path);
      if (!hostPort) {
        return noProxyResult;
      }
      const serverHost = hostPort.host;
      for (const host of getNoProxyHostList()) {
        if (host === serverHost) {
          trace("Not using proxy for target in no_proxy list: " + uri_parser_1.uriToString(target));
          return noProxyResult;
        }
      }
      const extraOptions = {
        "grpc.http_connect_target": uri_parser_1.uriToString(target)
      };
      if (proxyInfo.creds) {
        extraOptions["grpc.http_connect_creds"] = proxyInfo.creds;
      }
      return {
        target: {
          scheme: "dns",
          path: proxyInfo.address
        },
        extraOptions
      };
    }
    exports2.mapProxyName = mapProxyName;
    function getProxiedConnection(address, channelOptions, connectionOptions) {
      if (!("grpc.http_connect_target" in channelOptions)) {
        return Promise.resolve({});
      }
      const realTarget = channelOptions["grpc.http_connect_target"];
      const parsedTarget = uri_parser_1.parseUri(realTarget);
      if (parsedTarget === null) {
        return Promise.resolve({});
      }
      const options2 = {
        method: "CONNECT",
        path: parsedTarget.path
      };
      if (subchannel_1.isTcpSubchannelAddress(address)) {
        options2.host = address.host;
        options2.port = address.port;
      } else {
        options2.socketPath = address.path;
      }
      if ("grpc.http_connect_creds" in channelOptions) {
        options2.headers = {
          "Proxy-Authorization": "Basic " + Buffer.from(channelOptions["grpc.http_connect_creds"]).toString("base64")
        };
      }
      const proxyAddressString = subchannel_1.subchannelAddressToString(address);
      trace("Using proxy " + proxyAddressString + " to connect to " + options2.path);
      return new Promise((resolve2, reject) => {
        const request = http2.request(options2);
        request.once("connect", (res, socket, head) => {
          var _a;
          request.removeAllListeners();
          socket.removeAllListeners();
          if (res.statusCode === 200) {
            trace("Successfully connected to " + options2.path + " through proxy " + proxyAddressString);
            if ("secureContext" in connectionOptions) {
              const targetPath = resolver_1.getDefaultAuthority(parsedTarget);
              const hostPort = uri_parser_1.splitHostPort(targetPath);
              const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;
              const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket }, connectionOptions), () => {
                trace("Successfully established a TLS connection to " + options2.path + " through proxy " + proxyAddressString);
                resolve2({ socket: cts, realTarget: parsedTarget });
              });
              cts.on("error", (error3) => {
                trace("Failed to establish a TLS connection to " + options2.path + " through proxy " + proxyAddressString + " with error " + error3.message);
                reject();
              });
            } else {
              trace("Successfully established a plaintext connection to " + options2.path + " through proxy " + proxyAddressString);
              resolve2({
                socket,
                realTarget: parsedTarget
              });
            }
          } else {
            logging_1.log(constants_1.LogVerbosity.ERROR, "Failed to connect to " + options2.path + " through proxy " + proxyAddressString + " with status " + res.statusCode);
            reject();
          }
        });
        request.once("error", (err) => {
          request.removeAllListeners();
          logging_1.log(constants_1.LogVerbosity.ERROR, "Failed to connect to proxy " + proxyAddressString + " with error " + err.message);
          reject();
        });
        request.end();
      });
    }
    exports2.getProxiedConnection = getProxiedConnection;
  }
});

// node_modules/@grpc/grpc-js/package.json
var require_package = __commonJS({
  "node_modules/@grpc/grpc-js/package.json"(exports2, module2) {
    module2.exports = {
      name: "@grpc/grpc-js",
      version: "1.3.6",
      description: "gRPC Library for Node - pure JS implementation",
      homepage: "https://grpc.io/",
      repository: "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js",
      main: "build/src/index.js",
      engines: {
        node: "^8.13.0 || >=10.10.0"
      },
      keywords: [],
      author: {
        name: "Google Inc."
      },
      types: "build/src/index.d.ts",
      license: "Apache-2.0",
      devDependencies: {
        "@grpc/proto-loader": "^0.5.5",
        "@types/gulp": "^4.0.6",
        "@types/gulp-mocha": "0.0.32",
        "@types/lodash": "^4.14.108",
        "@types/mocha": "^5.2.6",
        "@types/ncp": "^2.0.1",
        "@types/pify": "^3.0.2",
        "@types/yargs": "^15.0.5",
        "clang-format": "^1.0.55",
        execa: "^2.0.3",
        gts: "^2.0.0",
        gulp: "^4.0.2",
        "gulp-mocha": "^6.0.0",
        lodash: "^4.17.4",
        "mocha-jenkins-reporter": "^0.4.1",
        ncp: "^2.0.0",
        pify: "^4.0.1",
        rimraf: "^3.0.2",
        "ts-node": "^8.3.0",
        typescript: "^3.7.2",
        yargs: "^15.4.1"
      },
      contributors: [
        {
          name: "Google Inc."
        }
      ],
      scripts: {
        build: "npm run compile",
        clean: `node -e 'require("rimraf")("./build", () => {})'`,
        compile: "tsc -p .",
        format: 'clang-format -i -style="{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}" src/*.ts test/*.ts',
        lint: "npm run check",
        prepare: "npm run compile",
        test: "gulp test",
        check: "gts check src/**/*.ts",
        fix: "gts fix src/*.ts",
        pretest: "npm run compile",
        posttest: "npm run check"
      },
      dependencies: {
        "@types/node": ">=12.12.47"
      },
      files: [
        "src/**/*.ts",
        "build/src/*.{js,d.ts,js.map}",
        "LICENSE",
        "deps/envoy-api/envoy/api/v2/**/*.proto",
        "deps/envoy-api/envoy/config/**/*.proto",
        "deps/envoy-api/envoy/service/**/*.proto",
        "deps/envoy-api/envoy/type/**/*.proto",
        "deps/udpa/udpa/**/*.proto",
        "deps/googleapis/google/api/*.proto",
        "deps/googleapis/google/rpc/*.proto",
        "deps/protoc-gen-validate/validate/**/*.proto"
      ]
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel.js
var require_subchannel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Subchannel = exports2.subchannelAddressToString = exports2.subchannelAddressEqual = exports2.isTcpSubchannelAddress = void 0;
    var http2 = require("http2");
    var tls_1 = require("tls");
    var channel_1 = require_channel();
    var backoff_timeout_1 = require_backoff_timeout();
    var resolver_1 = require_resolver();
    var logging = require_logging();
    var constants_1 = require_constants();
    var http_proxy_1 = require_http_proxy();
    var net = require("net");
    var uri_parser_1 = require_uri_parser();
    var clientVersion = require_package().version;
    var TRACER_NAME = "subchannel";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function refTrace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, "subchannel_refcount", text);
    }
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var KEEPALIVE_TIMEOUT_MS = 2e4;
    var { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;
    var tooManyPingsData = Buffer.from("too_many_pings", "ascii");
    function isTcpSubchannelAddress(address) {
      return "port" in address;
    }
    exports2.isTcpSubchannelAddress = isTcpSubchannelAddress;
    function subchannelAddressEqual(address1, address2) {
      if (isTcpSubchannelAddress(address1)) {
        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;
      } else {
        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
      }
    }
    exports2.subchannelAddressEqual = subchannelAddressEqual;
    function subchannelAddressToString(address) {
      if (isTcpSubchannelAddress(address)) {
        return address.host + ":" + address.port;
      } else {
        return address.path;
      }
    }
    exports2.subchannelAddressToString = subchannelAddressToString;
    var Subchannel = class {
      constructor(channelTarget, subchannelAddress, options2, credentials) {
        this.channelTarget = channelTarget;
        this.subchannelAddress = subchannelAddress;
        this.options = options2;
        this.credentials = credentials;
        this.connectivityState = channel_1.ConnectivityState.IDLE;
        this.session = null;
        this.continueConnecting = false;
        this.stateListeners = [];
        this.disconnectListeners = [];
        this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;
        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
        this.keepaliveWithoutCalls = false;
        this.callRefcount = 0;
        this.refcount = 0;
        this.userAgent = [
          options2["grpc.primary_user_agent"],
          `grpc-node-js/${clientVersion}`,
          options2["grpc.secondary_user_agent"]
        ].filter((e) => e).join(" ");
        if ("grpc.keepalive_time_ms" in options2) {
          this.keepaliveTimeMs = options2["grpc.keepalive_time_ms"];
        }
        if ("grpc.keepalive_timeout_ms" in options2) {
          this.keepaliveTimeoutMs = options2["grpc.keepalive_timeout_ms"];
        }
        if ("grpc.keepalive_permit_without_calls" in options2) {
          this.keepaliveWithoutCalls = options2["grpc.keepalive_permit_without_calls"] === 1;
        } else {
          this.keepaliveWithoutCalls = false;
        }
        this.keepaliveIntervalId = setTimeout(() => {
        }, 0);
        clearTimeout(this.keepaliveIntervalId);
        this.keepaliveTimeoutId = setTimeout(() => {
        }, 0);
        clearTimeout(this.keepaliveTimeoutId);
        const backoffOptions = {
          initialDelay: options2["grpc.initial_reconnect_backoff_ms"],
          maxDelay: options2["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          this.handleBackoffTimer();
        }, backoffOptions);
        this.subchannelAddressString = subchannelAddressToString(subchannelAddress);
      }
      handleBackoffTimer() {
        if (this.continueConnecting) {
          this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);
        } else {
          this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.IDLE);
        }
      }
      startBackoff() {
        this.backoffTimeout.runOnce();
      }
      stopBackoff() {
        this.backoffTimeout.stop();
        this.backoffTimeout.reset();
      }
      sendPing() {
        var _a, _b;
        logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "Sending ping to " + this.subchannelAddressString);
        this.keepaliveTimeoutId = setTimeout(() => {
          this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
        }, this.keepaliveTimeoutMs);
        (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.session.ping((err, duration, payload) => {
          clearTimeout(this.keepaliveTimeoutId);
        });
      }
      startKeepalivePings() {
        var _a, _b;
        this.keepaliveIntervalId = setInterval(() => {
          this.sendPing();
        }, this.keepaliveTimeMs);
        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      stopKeepalivePings() {
        clearInterval(this.keepaliveIntervalId);
        clearTimeout(this.keepaliveTimeoutId);
      }
      createSession(proxyConnectionResult) {
        var _a, _b, _c;
        if (proxyConnectionResult.realTarget) {
          trace(this.subchannelAddressString + " creating HTTP/2 session through proxy to " + proxyConnectionResult.realTarget);
        } else {
          trace(this.subchannelAddressString + " creating HTTP/2 session");
        }
        const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);
        let connectionOptions = this.credentials._getConnectionOptions() || {};
        connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
        if ("grpc-node.max_session_memory" in this.options) {
          connectionOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
        }
        let addressScheme = "http://";
        if ("secureContext" in connectionOptions) {
          addressScheme = "https://";
          if (this.options["grpc.ssl_target_name_override"]) {
            const sslTargetNameOverride = this.options["grpc.ssl_target_name_override"];
            connectionOptions.checkServerIdentity = (host, cert) => {
              return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
            };
            connectionOptions.servername = sslTargetNameOverride;
          } else {
            const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : "localhost";
            connectionOptions.servername = authorityHostname;
          }
          if (proxyConnectionResult.socket) {
            connectionOptions.createConnection = (authority, option) => {
              return proxyConnectionResult.socket;
            };
          }
        } else {
          connectionOptions.createConnection = (authority, option) => {
            if (proxyConnectionResult.socket) {
              return proxyConnectionResult.socket;
            } else {
              return net.connect(this.subchannelAddress);
            }
          };
        }
        connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);
        const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
        this.session = session;
        session.unref();
        session.once("connect", () => {
          if (this.session === session) {
            this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.READY);
          }
        });
        session.once("close", () => {
          if (this.session === session) {
            trace(this.subchannelAddressString + " connection closed");
            this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);
            this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
          }
        });
        session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
          if (this.session === session) {
            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {
              this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);
              logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);
            }
            trace(this.subchannelAddressString + " connection closed by GOAWAY with code " + errorCode);
            this.transitionToState([channel_1.ConnectivityState.CONNECTING, channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
          }
        });
        session.once("error", (error3) => {
          trace(this.subchannelAddressString + " connection closed with error " + error3.message);
        });
      }
      startConnectingInternal() {
        var _a, _b;
        const connectionOptions = this.credentials._getConnectionOptions() || {};
        if ("secureContext" in connectionOptions) {
          connectionOptions.ALPNProtocols = ["h2"];
          if (this.options["grpc.ssl_target_name_override"]) {
            const sslTargetNameOverride = this.options["grpc.ssl_target_name_override"];
            connectionOptions.checkServerIdentity = (host, cert) => {
              return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
            };
            connectionOptions.servername = sslTargetNameOverride;
          } else {
            if ("grpc.http_connect_target" in this.options) {
              const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options["grpc.http_connect_target"])) !== null && _a !== void 0 ? _a : {
                path: "localhost"
              });
              const hostPort = uri_parser_1.splitHostPort(targetPath);
              connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;
            }
          }
        }
        http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result) => {
          this.createSession(result);
        }, (reason) => {
          this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);
        });
      }
      transitionToState(oldStates, newState) {
        if (oldStates.indexOf(this.connectivityState) === -1) {
          return false;
        }
        trace(this.subchannelAddressString + " " + channel_1.ConnectivityState[this.connectivityState] + " -> " + channel_1.ConnectivityState[newState]);
        const previousState = this.connectivityState;
        this.connectivityState = newState;
        switch (newState) {
          case channel_1.ConnectivityState.READY:
            this.stopBackoff();
            this.session.socket.once("close", () => {
              for (const listener of this.disconnectListeners) {
                listener();
              }
            });
            if (this.keepaliveWithoutCalls) {
              this.startKeepalivePings();
            }
            break;
          case channel_1.ConnectivityState.CONNECTING:
            this.startBackoff();
            this.startConnectingInternal();
            this.continueConnecting = false;
            break;
          case channel_1.ConnectivityState.TRANSIENT_FAILURE:
            if (this.session) {
              this.session.close();
            }
            this.session = null;
            this.stopKeepalivePings();
            if (!this.backoffTimeout.isRunning()) {
              process.nextTick(() => {
                this.handleBackoffTimer();
              });
            }
            break;
          case channel_1.ConnectivityState.IDLE:
            if (this.session) {
              this.session.close();
            }
            this.session = null;
            this.stopKeepalivePings();
            break;
          default:
            throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
        }
        for (const listener of [...this.stateListeners]) {
          listener(this, previousState, newState);
        }
        return true;
      }
      checkBothRefcounts() {
        if (this.callRefcount === 0 && this.refcount === 0) {
          this.transitionToState([
            channel_1.ConnectivityState.CONNECTING,
            channel_1.ConnectivityState.READY
          ], channel_1.ConnectivityState.TRANSIENT_FAILURE);
        }
      }
      callRef() {
        refTrace(this.subchannelAddressString + " callRefcount " + this.callRefcount + " -> " + (this.callRefcount + 1));
        if (this.callRefcount === 0) {
          if (this.session) {
            this.session.ref();
          }
          this.backoffTimeout.ref();
          if (!this.keepaliveWithoutCalls) {
            this.startKeepalivePings();
          }
        }
        this.callRefcount += 1;
      }
      callUnref() {
        refTrace(this.subchannelAddressString + " callRefcount " + this.callRefcount + " -> " + (this.callRefcount - 1));
        this.callRefcount -= 1;
        if (this.callRefcount === 0) {
          if (this.session) {
            this.session.unref();
          }
          this.backoffTimeout.unref();
          if (!this.keepaliveWithoutCalls) {
            this.stopKeepalivePings();
          }
          this.checkBothRefcounts();
        }
      }
      ref() {
        refTrace(this.subchannelAddressString + " refcount " + this.refcount + " -> " + (this.refcount + 1));
        this.refcount += 1;
      }
      unref() {
        refTrace(this.subchannelAddressString + " refcount " + this.refcount + " -> " + (this.refcount - 1));
        this.refcount -= 1;
        this.checkBothRefcounts();
      }
      unrefIfOneRef() {
        if (this.refcount === 1) {
          this.unref();
          return true;
        }
        return false;
      }
      startCallStream(metadata, callStream, extraFilterFactory) {
        const headers = metadata.toHttp2Headers();
        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();
        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
        headers[HTTP2_HEADER_CONTENT_TYPE] = "application/grpc";
        headers[HTTP2_HEADER_METHOD] = "POST";
        headers[HTTP2_HEADER_PATH] = callStream.getMethod();
        headers[HTTP2_HEADER_TE] = "trailers";
        let http2Stream;
        try {
          http2Stream = this.session.request(headers);
        } catch (e) {
          this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.TRANSIENT_FAILURE);
          throw e;
        }
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "		" + header + ": " + headers[header] + "\n";
        }
        logging.trace(constants_1.LogVerbosity.DEBUG, "call_stream", "Starting stream on subchannel " + this.subchannelAddressString + " with headers\n" + headersString);
        callStream.attachHttp2Stream(http2Stream, this, extraFilterFactory);
      }
      startConnecting() {
        if (!this.transitionToState([channel_1.ConnectivityState.IDLE], channel_1.ConnectivityState.CONNECTING)) {
          if (this.connectivityState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.continueConnecting = true;
          }
        }
      }
      getConnectivityState() {
        return this.connectivityState;
      }
      addConnectivityStateListener(listener) {
        this.stateListeners.push(listener);
      }
      removeConnectivityStateListener(listener) {
        const listenerIndex = this.stateListeners.indexOf(listener);
        if (listenerIndex > -1) {
          this.stateListeners.splice(listenerIndex, 1);
        }
      }
      addDisconnectListener(listener) {
        this.disconnectListeners.push(listener);
      }
      removeDisconnectListener(listener) {
        const listenerIndex = this.disconnectListeners.indexOf(listener);
        if (listenerIndex > -1) {
          this.disconnectListeners.splice(listenerIndex, 1);
        }
      }
      resetBackoff() {
        this.backoffTimeout.reset();
        this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);
      }
      getAddress() {
        return this.subchannelAddressString;
      }
    };
    exports2.Subchannel = Subchannel;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js
var require_load_balancer_pick_first = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.PickFirstLoadBalancer = exports2.PickFirstLoadBalancingConfig = void 0;
    var load_balancer_1 = require_load_balancer();
    var channel_1 = require_channel();
    var picker_1 = require_picker();
    var subchannel_1 = require_subchannel();
    var logging = require_logging();
    var constants_1 = require_constants();
    var TRACER_NAME = "pick_first";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "pick_first";
    var CONNECTION_DELAY_INTERVAL_MS = 250;
    var PickFirstLoadBalancingConfig = class {
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      static createFromJson(obj) {
        return new PickFirstLoadBalancingConfig();
      }
    };
    exports2.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
    var PickFirstPicker = class {
      constructor(subchannel) {
        this.subchannel = subchannel;
      }
      pick(pickArgs) {
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: this.subchannel,
          status: null,
          extraFilterFactory: null,
          onCallStarted: null
        };
      }
    };
    var PickFirstLoadBalancer = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.latestAddressList = [];
        this.subchannels = [];
        this.currentState = channel_1.ConnectivityState.IDLE;
        this.currentSubchannelIndex = 0;
        this.currentPick = null;
        this.triedAllSubchannels = false;
        this.subchannelStateCounts = {
          [channel_1.ConnectivityState.CONNECTING]: 0,
          [channel_1.ConnectivityState.IDLE]: 0,
          [channel_1.ConnectivityState.READY]: 0,
          [channel_1.ConnectivityState.SHUTDOWN]: 0,
          [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
          this.subchannelStateCounts[previousState] -= 1;
          this.subchannelStateCounts[newState] += 1;
          if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.startNextSubchannelConnecting();
          }
          if (newState === channel_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            return;
          } else {
            if (this.triedAllSubchannels && this.subchannelStateCounts[channel_1.ConnectivityState.IDLE] === this.subchannels.length) {
              this.resetSubchannelList();
              this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
              return;
            }
            if (this.currentPick === null) {
              if (this.triedAllSubchannels) {
                let newLBState;
                if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
                  newLBState = channel_1.ConnectivityState.CONNECTING;
                } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                  newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;
                } else {
                  newLBState = channel_1.ConnectivityState.IDLE;
                }
                if (newLBState !== this.currentState) {
                  if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                    this.updateState(newLBState, new picker_1.UnavailablePicker());
                  } else {
                    this.updateState(newLBState, new picker_1.QueuePicker(this));
                  }
                }
              } else {
                this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
              }
            }
          }
        };
        this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {
          if (newState !== channel_1.ConnectivityState.READY) {
            this.currentPick = null;
            subchannel.unref();
            subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);
            if (this.subchannels.length > 0) {
              if (this.triedAllSubchannels) {
                let newLBState;
                if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
                  newLBState = channel_1.ConnectivityState.CONNECTING;
                } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                  newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;
                } else {
                  newLBState = channel_1.ConnectivityState.IDLE;
                }
                if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                  this.updateState(newLBState, new picker_1.UnavailablePicker());
                } else {
                  this.updateState(newLBState, new picker_1.QueuePicker(this));
                }
              } else {
                this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
              }
            } else {
              this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
            }
          }
        };
        this.connectionDelayTimeout = setTimeout(() => {
        }, 0);
        clearTimeout(this.connectionDelayTimeout);
      }
      startNextSubchannelConnecting() {
        if (this.triedAllSubchannels) {
          return;
        }
        for (const [index2, subchannel] of this.subchannels.entries()) {
          if (index2 > this.currentSubchannelIndex) {
            const subchannelState = subchannel.getConnectivityState();
            if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {
              this.startConnecting(index2);
              return;
            }
          }
        }
        this.triedAllSubchannels = true;
      }
      startConnecting(subchannelIndex) {
        clearTimeout(this.connectionDelayTimeout);
        this.currentSubchannelIndex = subchannelIndex;
        if (this.subchannels[subchannelIndex].getConnectivityState() === channel_1.ConnectivityState.IDLE) {
          trace("Start connecting to subchannel with address " + this.subchannels[subchannelIndex].getAddress());
          process.nextTick(() => {
            this.subchannels[subchannelIndex].startConnecting();
          });
        }
        this.connectionDelayTimeout = setTimeout(() => {
          this.startNextSubchannelConnecting();
        }, CONNECTION_DELAY_INTERVAL_MS);
      }
      pickSubchannel(subchannel) {
        trace("Pick subchannel with address " + subchannel.getAddress());
        if (this.currentPick !== null) {
          this.currentPick.unref();
          this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
        }
        this.currentPick = subchannel;
        this.updateState(channel_1.ConnectivityState.READY, new PickFirstPicker(subchannel));
        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);
        subchannel.ref();
        this.resetSubchannelList();
        clearTimeout(this.connectionDelayTimeout);
      }
      updateState(newState, picker) {
        trace(channel_1.ConnectivityState[this.currentState] + " -> " + channel_1.ConnectivityState[newState]);
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const subchannel of this.subchannels) {
          subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          subchannel.unref();
        }
        this.currentSubchannelIndex = 0;
        this.subchannelStateCounts = {
          [channel_1.ConnectivityState.CONNECTING]: 0,
          [channel_1.ConnectivityState.IDLE]: 0,
          [channel_1.ConnectivityState.READY]: 0,
          [channel_1.ConnectivityState.SHUTDOWN]: 0,
          [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannels = [];
        this.triedAllSubchannels = false;
      }
      connectToAddressList() {
        this.resetSubchannelList();
        trace("Connect to address list " + this.latestAddressList.map((address) => subchannel_1.subchannelAddressToString(address)));
        this.subchannels = this.latestAddressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
          subchannel.ref();
        }
        for (const subchannel of this.subchannels) {
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
          this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;
          if (subchannel.getConnectivityState() === channel_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            this.resetSubchannelList();
            return;
          }
        }
        for (const [index2, subchannel] of this.subchannels.entries()) {
          const subchannelState = subchannel.getConnectivityState();
          if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {
            this.startConnecting(index2);
            if (this.currentPick === null) {
              this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
            }
            return;
          }
        }
        if (this.currentPick === null) {
          this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        }
      }
      updateAddressList(addressList, lbConfig) {
        if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index2) => addressList[index2] === value)) {
          this.latestAddressList = addressList;
          this.connectToAddressList();
        }
      }
      exitIdle() {
        for (const subchannel of this.subchannels) {
          subchannel.startConnecting();
        }
        if (this.currentState === channel_1.ConnectivityState.IDLE) {
          if (this.latestAddressList.length > 0) {
            this.connectToAddressList();
          }
        }
        if (this.currentState === channel_1.ConnectivityState.IDLE || this.triedAllSubchannels) {
          this.channelControlHelper.requestReresolution();
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
        if (this.currentPick !== null) {
          this.currentPick.unref();
          this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.PickFirstLoadBalancer = PickFirstLoadBalancer;
    function setup() {
      load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js
var require_load_balancer_round_robin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.RoundRobinLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var channel_1 = require_channel();
    var picker_1 = require_picker();
    var subchannel_1 = require_subchannel();
    var logging = require_logging();
    var constants_1 = require_constants();
    var TRACER_NAME = "round_robin";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "round_robin";
    var RoundRobinLoadBalancingConfig = class {
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      static createFromJson(obj) {
        return new RoundRobinLoadBalancingConfig();
      }
    };
    var RoundRobinPicker = class {
      constructor(subchannelList, nextIndex = 0) {
        this.subchannelList = subchannelList;
        this.nextIndex = nextIndex;
      }
      pick(pickArgs) {
        const pickedSubchannel = this.subchannelList[this.nextIndex];
        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: pickedSubchannel,
          status: null,
          extraFilterFactory: null,
          onCallStarted: null
        };
      }
      peekNextSubchannel() {
        return this.subchannelList[this.nextIndex];
      }
    };
    var RoundRobinLoadBalancer = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.subchannels = [];
        this.currentState = channel_1.ConnectivityState.IDLE;
        this.currentReadyPicker = null;
        this.subchannelStateCounts = {
          [channel_1.ConnectivityState.CONNECTING]: 0,
          [channel_1.ConnectivityState.IDLE]: 0,
          [channel_1.ConnectivityState.READY]: 0,
          [channel_1.ConnectivityState.SHUTDOWN]: 0,
          [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
          this.subchannelStateCounts[previousState] -= 1;
          this.subchannelStateCounts[newState] += 1;
          this.calculateAndUpdateState();
          if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE || newState === channel_1.ConnectivityState.IDLE) {
            this.channelControlHelper.requestReresolution();
            subchannel.startConnecting();
          }
        };
      }
      calculateAndUpdateState() {
        if (this.subchannelStateCounts[channel_1.ConnectivityState.READY] > 0) {
          const readySubchannels = this.subchannels.filter((subchannel) => subchannel.getConnectivityState() === channel_1.ConnectivityState.READY);
          let index2 = 0;
          if (this.currentReadyPicker !== null) {
            index2 = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());
            if (index2 < 0) {
              index2 = 0;
            }
          }
          this.updateState(channel_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index2));
        } else if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
          this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
          this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        } else {
          this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        }
      }
      updateState(newState, picker) {
        trace(channel_1.ConnectivityState[this.currentState] + " -> " + channel_1.ConnectivityState[newState]);
        if (newState === channel_1.ConnectivityState.READY) {
          this.currentReadyPicker = picker;
        } else {
          this.currentReadyPicker = null;
        }
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const subchannel of this.subchannels) {
          subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          subchannel.unref();
        }
        this.subchannelStateCounts = {
          [channel_1.ConnectivityState.CONNECTING]: 0,
          [channel_1.ConnectivityState.IDLE]: 0,
          [channel_1.ConnectivityState.READY]: 0,
          [channel_1.ConnectivityState.SHUTDOWN]: 0,
          [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannels = [];
      }
      updateAddressList(addressList, lbConfig) {
        this.resetSubchannelList();
        trace("Connect to address list " + addressList.map((address) => subchannel_1.subchannelAddressToString(address)));
        this.subchannels = addressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
          subchannel.ref();
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
          const subchannelState = subchannel.getConnectivityState();
          this.subchannelStateCounts[subchannelState] += 1;
          if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
            subchannel.startConnecting();
          }
        }
        this.calculateAndUpdateState();
      }
      exitIdle() {
        for (const subchannel of this.subchannels) {
          subchannel.startConnecting();
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
    function setup() {
      load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer.js
var require_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerAll = exports2.validateLoadBalancingConfig = exports2.getFirstUsableConfig = exports2.isLoadBalancerNameRegistered = exports2.createLoadBalancer = exports2.registerLoadBalancerType = void 0;
    var load_balancer_pick_first = require_load_balancer_pick_first();
    var load_balancer_round_robin = require_load_balancer_round_robin();
    var registeredLoadBalancerTypes = {};
    function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
      registeredLoadBalancerTypes[typeName] = {
        LoadBalancer: loadBalancerType,
        LoadBalancingConfig: loadBalancingConfigType
      };
    }
    exports2.registerLoadBalancerType = registerLoadBalancerType;
    function createLoadBalancer(config, channelControlHelper) {
      const typeName = config.getLoadBalancerName();
      if (typeName in registeredLoadBalancerTypes) {
        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);
      } else {
        return null;
      }
    }
    exports2.createLoadBalancer = createLoadBalancer;
    function isLoadBalancerNameRegistered(typeName) {
      return typeName in registeredLoadBalancerTypes;
    }
    exports2.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
    function getFirstUsableConfig(configs, defaultPickFirst = false) {
      for (const config of configs) {
        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {
          return config;
        }
      }
      if (defaultPickFirst) {
        return new load_balancer_pick_first.PickFirstLoadBalancingConfig();
      } else {
        return null;
      }
    }
    exports2.getFirstUsableConfig = getFirstUsableConfig;
    function validateLoadBalancingConfig(obj) {
      if (!(obj !== null && typeof obj === "object")) {
        throw new Error("Load balancing config must be an object");
      }
      const keys = Object.keys(obj);
      if (keys.length !== 1) {
        throw new Error("Provided load balancing config has multiple conflicting entries");
      }
      const typeName = keys[0];
      if (typeName in registeredLoadBalancerTypes) {
        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);
      } else {
        throw new Error(`Unrecognized load balancing config name ${typeName}`);
      }
    }
    exports2.validateLoadBalancingConfig = validateLoadBalancingConfig;
    function registerAll() {
      load_balancer_pick_first.setup();
      load_balancer_round_robin.setup();
    }
    exports2.registerAll = registerAll;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js
var require_load_balancer_child_handler = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChildLoadBalancerHandler = void 0;
    var load_balancer_1 = require_load_balancer();
    var channel_1 = require_channel();
    var TYPE_NAME = "child_load_balancer_helper";
    var ChildLoadBalancerHandler = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.currentChild = null;
        this.pendingChild = null;
        this.ChildPolicyHelper = class {
          constructor(parent) {
            this.parent = parent;
            this.child = null;
          }
          createSubchannel(subchannelAddress, subchannelArgs) {
            return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
          }
          updateState(connectivityState, picker) {
            var _a;
            if (this.calledByPendingChild()) {
              if (connectivityState !== channel_1.ConnectivityState.READY) {
                return;
              }
              (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();
              this.parent.currentChild = this.parent.pendingChild;
              this.parent.pendingChild = null;
            } else if (!this.calledByCurrentChild()) {
              return;
            }
            this.parent.channelControlHelper.updateState(connectivityState, picker);
          }
          requestReresolution() {
            var _a;
            const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;
            if (this.child === latestChild) {
              this.parent.channelControlHelper.requestReresolution();
            }
          }
          setChild(newChild) {
            this.child = newChild;
          }
          calledByPendingChild() {
            return this.child === this.parent.pendingChild;
          }
          calledByCurrentChild() {
            return this.child === this.parent.currentChild;
          }
        };
      }
      updateAddressList(addressList, lbConfig, attributes) {
        let childToUpdate;
        if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {
          const newHelper = new this.ChildPolicyHelper(this);
          const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);
          newHelper.setChild(newChild);
          if (this.currentChild === null) {
            this.currentChild = newChild;
            childToUpdate = this.currentChild;
          } else {
            if (this.pendingChild) {
              this.pendingChild.destroy();
            }
            this.pendingChild = newChild;
            childToUpdate = this.pendingChild;
          }
        } else {
          if (this.pendingChild === null) {
            childToUpdate = this.currentChild;
          } else {
            childToUpdate = this.pendingChild;
          }
        }
        childToUpdate.updateAddressList(addressList, lbConfig, attributes);
      }
      exitIdle() {
        if (this.currentChild) {
          this.currentChild.resetBackoff();
          if (this.pendingChild) {
            this.pendingChild.resetBackoff();
          }
        }
      }
      resetBackoff() {
        if (this.currentChild) {
          this.currentChild.resetBackoff();
          if (this.pendingChild) {
            this.pendingChild.resetBackoff();
          }
        }
      }
      destroy() {
        if (this.currentChild) {
          this.currentChild.destroy();
          this.currentChild = null;
        }
        if (this.pendingChild) {
          this.pendingChild.destroy();
          this.pendingChild = null;
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js
var require_resolving_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResolvingLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var service_config_1 = require_service_config();
    var channel_1 = require_channel();
    var resolver_1 = require_resolver();
    var picker_1 = require_picker();
    var backoff_timeout_1 = require_backoff_timeout();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var TRACER_NAME = "resolving_load_balancer";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function getDefaultConfigSelector(serviceConfig) {
      return function defaultConfigSelector(methodName, metadata) {
        var _a, _b;
        const splitName = methodName.split("/").filter((x) => x.length > 0);
        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : "";
        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : "";
        if (serviceConfig && serviceConfig.methodConfig) {
          for (const methodConfig of serviceConfig.methodConfig) {
            for (const name of methodConfig.name) {
              if (name.service === service && (name.method === void 0 || name.method === method)) {
                return {
                  methodConfig,
                  pickInformation: {},
                  status: constants_1.Status.OK
                };
              }
            }
          }
        }
        return {
          methodConfig: { name: [] },
          pickInformation: {},
          status: constants_1.Status.OK
        };
      };
    }
    var ResolvingLoadBalancer = class {
      constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {
        this.target = target;
        this.channelControlHelper = channelControlHelper;
        this.channelOptions = channelOptions;
        this.onSuccessfulResolution = onSuccessfulResolution;
        this.onFailedResolution = onFailedResolution;
        this.latestChildState = channel_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        this.currentState = channel_1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
        if (channelOptions["grpc.service_config"]) {
          this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions["grpc.service_config"]));
        } else {
          this.defaultServiceConfig = {
            loadBalancingConfig: [],
            methodConfig: []
          };
        }
        this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
          createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
          requestReresolution: () => {
            if (this.backoffTimeout.isRunning()) {
              this.continueResolving = true;
            } else {
              this.updateResolution();
            }
          },
          updateState: (newState, picker) => {
            this.latestChildState = newState;
            this.latestChildPicker = picker;
            this.updateState(newState, picker);
          }
        });
        this.innerResolver = resolver_1.createResolver(target, {
          onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {
            var _a;
            let workingServiceConfig = null;
            if (serviceConfig === null) {
              if (serviceConfigError === null) {
                this.previousServiceConfig = null;
                workingServiceConfig = this.defaultServiceConfig;
              } else {
                if (this.previousServiceConfig === null) {
                  this.handleResolutionFailure(serviceConfigError);
                } else {
                  workingServiceConfig = this.previousServiceConfig;
                }
              }
            } else {
              workingServiceConfig = serviceConfig;
              this.previousServiceConfig = serviceConfig;
            }
            const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];
            const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);
            if (loadBalancingConfig === null) {
              this.handleResolutionFailure({
                code: constants_1.Status.UNAVAILABLE,
                details: "All load balancer options in service config are not compatible",
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);
            const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;
            this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));
          },
          onError: (error3) => {
            this.handleResolutionFailure(error3);
          }
        }, channelOptions);
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.updateResolution();
            this.continueResolving = false;
          } else {
            this.updateState(this.latestChildState, this.latestChildPicker);
          }
        });
        this.backoffTimeout.unref();
      }
      updateResolution() {
        this.innerResolver.updateResolution();
        if (this.currentState === channel_1.ConnectivityState.IDLE) {
          this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
      }
      updateState(connectivityState, picker) {
        trace(uri_parser_1.uriToString(this.target) + " " + channel_1.ConnectivityState[this.currentState] + " -> " + channel_1.ConnectivityState[connectivityState]);
        if (connectivityState === channel_1.ConnectivityState.IDLE) {
          picker = new picker_1.QueuePicker(this);
        }
        this.currentState = connectivityState;
        this.channelControlHelper.updateState(connectivityState, picker);
      }
      handleResolutionFailure(error3) {
        if (this.latestChildState === channel_1.ConnectivityState.IDLE) {
          this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error3));
          this.onFailedResolution(error3);
        }
        this.backoffTimeout.runOnce();
      }
      exitIdle() {
        this.childLoadBalancer.exitIdle();
        if (this.currentState === channel_1.ConnectivityState.IDLE) {
          if (this.backoffTimeout.isRunning()) {
            this.continueResolving = true;
          } else {
            this.updateResolution();
          }
          this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
      }
      updateAddressList(addressList, lbConfig) {
        throw new Error("updateAddressList not supported on ResolvingLoadBalancer");
      }
      resetBackoff() {
        this.backoffTimeout.reset();
        this.childLoadBalancer.resetBackoff();
      }
      destroy() {
        this.childLoadBalancer.destroy();
        this.innerResolver.destroy();
        this.updateState(channel_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());
      }
      getTypeName() {
        return "resolving_load_balancer";
      }
    };
    exports2.ResolvingLoadBalancer = ResolvingLoadBalancer;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-options.js
var require_channel_options = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-options.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.channelOptionsEqual = exports2.recognizedOptions = void 0;
    exports2.recognizedOptions = {
      "grpc.ssl_target_name_override": true,
      "grpc.primary_user_agent": true,
      "grpc.secondary_user_agent": true,
      "grpc.default_authority": true,
      "grpc.keepalive_time_ms": true,
      "grpc.keepalive_timeout_ms": true,
      "grpc.keepalive_permit_without_calls": true,
      "grpc.service_config": true,
      "grpc.max_concurrent_streams": true,
      "grpc.initial_reconnect_backoff_ms": true,
      "grpc.max_reconnect_backoff_ms": true,
      "grpc.use_local_subchannel_pool": true,
      "grpc.max_send_message_length": true,
      "grpc.max_receive_message_length": true,
      "grpc.enable_http_proxy": true,
      "grpc-node.max_session_memory": true
    };
    function channelOptionsEqual(options1, options2) {
      const keys1 = Object.keys(options1).sort();
      const keys2 = Object.keys(options2).sort();
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (let i = 0; i < keys1.length; i += 1) {
        if (keys1[i] !== keys2[i]) {
          return false;
        }
        if (options1[keys1[i]] !== options2[keys2[i]]) {
          return false;
        }
      }
      return true;
    }
    exports2.channelOptionsEqual = channelOptionsEqual;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-pool.js
var require_subchannel_pool = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-pool.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSubchannelPool = exports2.SubchannelPool = void 0;
    var channel_options_1 = require_channel_options();
    var subchannel_1 = require_subchannel();
    var uri_parser_1 = require_uri_parser();
    var REF_CHECK_INTERVAL = 1e4;
    var SubchannelPool = class {
      constructor(global2) {
        this.global = global2;
        this.pool = Object.create(null);
        this.cleanupTimer = null;
      }
      unrefUnusedSubchannels() {
        let allSubchannelsUnrefed = true;
        for (const channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());
          if (refedSubchannels.length > 0) {
            allSubchannelsUnrefed = false;
          }
          this.pool[channelTarget] = refedSubchannels;
        }
        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
          clearInterval(this.cleanupTimer);
          this.cleanupTimer = null;
        }
      }
      ensureCleanupTask() {
        var _a, _b;
        if (this.global && this.cleanupTimer === null) {
          this.cleanupTimer = setInterval(() => {
            this.unrefUnusedSubchannels();
          }, REF_CHECK_INTERVAL);
          (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
        this.ensureCleanupTask();
        const channelTarget = uri_parser_1.uriToString(channelTargetUri);
        if (channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          for (const subchannelObj of subchannelObjArray) {
            if (subchannel_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {
              return subchannelObj.subchannel;
            }
          }
        }
        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);
        if (!(channelTarget in this.pool)) {
          this.pool[channelTarget] = [];
        }
        this.pool[channelTarget].push({
          subchannelAddress: subchannelTarget,
          channelArguments,
          channelCredentials,
          subchannel
        });
        if (this.global) {
          subchannel.ref();
        }
        return subchannel;
      }
    };
    exports2.SubchannelPool = SubchannelPool;
    var globalSubchannelPool = new SubchannelPool(true);
    function getSubchannelPool(global2) {
      if (global2) {
        return globalSubchannelPool;
      } else {
        return new SubchannelPool(false);
      }
    }
    exports2.getSubchannelPool = getSubchannelPool;
  }
});

// node_modules/@grpc/grpc-js/build/src/filter.js
var require_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseFilter = void 0;
    var BaseFilter = class {
      async sendMetadata(metadata) {
        return metadata;
      }
      receiveMetadata(metadata) {
        return metadata;
      }
      async sendMessage(message) {
        return message;
      }
      async receiveMessage(message) {
        return message;
      }
      receiveTrailers(status) {
        return status;
      }
    };
    exports2.BaseFilter = BaseFilter;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js
var require_call_credentials_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallCredentialsFilterFactory = exports2.CallCredentialsFilter = void 0;
    var filter_1 = require_filter();
    var constants_1 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var CallCredentialsFilter = class extends filter_1.BaseFilter {
      constructor(channel, stream) {
        var _a, _b;
        super();
        this.channel = channel;
        this.stream = stream;
        this.channel = channel;
        this.stream = stream;
        const splitPath = stream.getMethod().split("/");
        let serviceName = "";
        if (splitPath.length >= 2) {
          serviceName = splitPath[1];
        }
        const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : "localhost";
        this.serviceUrl = `https://${hostname}/${serviceName}`;
      }
      async sendMetadata(metadata) {
        const credentials = this.stream.getCredentials();
        const credsMetadata = credentials.generateMetadata({
          service_url: this.serviceUrl
        });
        const resultMetadata = await metadata;
        try {
          resultMetadata.merge(await credsMetadata);
        } catch (error3) {
          this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error3.message}`);
          return Promise.reject("Failed to retrieve auth metadata");
        }
        if (resultMetadata.get("authorization").length > 1) {
          this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '"authorization" metadata cannot have multiple values');
          return Promise.reject('"authorization" metadata cannot have multiple values');
        }
        return resultMetadata;
      }
    };
    exports2.CallCredentialsFilter = CallCredentialsFilter;
    var CallCredentialsFilterFactory = class {
      constructor(channel) {
        this.channel = channel;
        this.channel = channel;
      }
      createFilter(callStream) {
        return new CallCredentialsFilter(this.channel, callStream);
      }
    };
    exports2.CallCredentialsFilterFactory = CallCredentialsFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/deadline-filter.js
var require_deadline_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/deadline-filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeadlineFilterFactory = exports2.DeadlineFilter = void 0;
    var constants_1 = require_constants();
    var filter_1 = require_filter();
    var units = [
      ["m", 1],
      ["S", 1e3],
      ["M", 60 * 1e3],
      ["H", 60 * 60 * 1e3]
    ];
    function getDeadline(deadline) {
      const now = new Date().getTime();
      const timeoutMs = Math.max(deadline - now, 0);
      for (const [unit, factor] of units) {
        const amount = timeoutMs / factor;
        if (amount < 1e8) {
          return String(Math.ceil(amount)) + unit;
        }
      }
      throw new Error("Deadline is too far in the future");
    }
    var DeadlineFilter = class extends filter_1.BaseFilter {
      constructor(channel, callStream) {
        var _a, _b;
        super();
        this.channel = channel;
        this.callStream = callStream;
        this.timer = null;
        const callDeadline = callStream.getDeadline();
        if (callDeadline instanceof Date) {
          this.deadline = callDeadline.getTime();
        } else {
          this.deadline = callDeadline;
        }
        const now = new Date().getTime();
        let timeout = this.deadline - now;
        if (timeout <= 0) {
          process.nextTick(() => {
            callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
          });
        } else if (this.deadline !== Infinity) {
          this.timer = setTimeout(() => {
            callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
          }, timeout);
          (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      async sendMetadata(metadata) {
        if (this.deadline === Infinity) {
          return metadata;
        }
        const finalMetadata = await metadata;
        const timeoutString = getDeadline(this.deadline);
        finalMetadata.set("grpc-timeout", timeoutString);
        return finalMetadata;
      }
      receiveTrailers(status) {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        return status;
      }
    };
    exports2.DeadlineFilter = DeadlineFilter;
    var DeadlineFilterFactory = class {
      constructor(channel) {
        this.channel = channel;
      }
      createFilter(callStream) {
        return new DeadlineFilter(this.channel, callStream);
      }
    };
    exports2.DeadlineFilterFactory = DeadlineFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-filter.js
var require_compression_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompressionFilterFactory = exports2.CompressionFilter = void 0;
    var zlib2 = require("zlib");
    var filter_1 = require_filter();
    var CompressionHandler = class {
      async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
          messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
          messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
      }
    };
    var IdentityHandler = class extends CompressionHandler {
      async compressMessage(message) {
        return message;
      }
      async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
      }
      decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
      }
    };
    var DeflateHandler = class extends CompressionHandler {
      compressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.deflate(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.inflate(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
    };
    var GzipHandler = class extends CompressionHandler {
      compressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.gzip(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.unzip(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
    };
    var UnknownHandler = class extends CompressionHandler {
      constructor(compressionName) {
        super();
        this.compressionName = compressionName;
      }
      compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
      }
      decompressMessage(message) {
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
      }
    };
    function getCompressionHandler(compressionName) {
      switch (compressionName) {
        case "identity":
          return new IdentityHandler();
        case "deflate":
          return new DeflateHandler();
        case "gzip":
          return new GzipHandler();
        default:
          return new UnknownHandler(compressionName);
      }
    }
    var CompressionFilter = class extends filter_1.BaseFilter {
      constructor() {
        super(...arguments);
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
      }
      async sendMetadata(metadata) {
        const headers = await metadata;
        headers.set("grpc-accept-encoding", "identity,deflate,gzip");
        headers.set("accept-encoding", "identity");
        return headers;
      }
      receiveMetadata(metadata) {
        const receiveEncoding = metadata.get("grpc-encoding");
        if (receiveEncoding.length > 0) {
          const encoding = receiveEncoding[0];
          if (typeof encoding === "string") {
            this.receiveCompression = getCompressionHandler(encoding);
          }
        }
        metadata.remove("grpc-encoding");
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      async sendMessage(message) {
        const resolvedMessage = await message;
        const compress = resolvedMessage.flags === void 0 ? false : (resolvedMessage.flags & 2) === 0;
        return {
          message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
          flags: resolvedMessage.flags
        };
      }
      async receiveMessage(message) {
        return this.receiveCompression.readMessage(await message);
      }
    };
    exports2.CompressionFilter = CompressionFilter;
    var CompressionFilterFactory = class {
      constructor(channel) {
        this.channel = channel;
      }
      createFilter(callStream) {
        return new CompressionFilter();
      }
    };
    exports2.CompressionFilterFactory = CompressionFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js
var require_max_message_size_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaxMessageSizeFilterFactory = exports2.MaxMessageSizeFilter = void 0;
    var filter_1 = require_filter();
    var constants_1 = require_constants();
    var MaxMessageSizeFilter = class extends filter_1.BaseFilter {
      constructor(options2, callStream) {
        super();
        this.options = options2;
        this.callStream = callStream;
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        if ("grpc.max_send_message_length" in options2) {
          this.maxSendMessageSize = options2["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options2) {
          this.maxReceiveMessageSize = options2["grpc.max_receive_message_length"];
        }
      }
      async sendMessage(message) {
        if (this.maxSendMessageSize === -1) {
          return message;
        } else {
          const concreteMessage = await message;
          if (concreteMessage.message.length > this.maxSendMessageSize) {
            this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);
            return Promise.reject("Message too large");
          } else {
            return concreteMessage;
          }
        }
      }
      async receiveMessage(message) {
        if (this.maxReceiveMessageSize === -1) {
          return message;
        } else {
          const concreteMessage = await message;
          if (concreteMessage.length > this.maxReceiveMessageSize) {
            this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);
            return Promise.reject("Message too large");
          } else {
            return concreteMessage;
          }
        }
      }
    };
    exports2.MaxMessageSizeFilter = MaxMessageSizeFilter;
    var MaxMessageSizeFilterFactory = class {
      constructor(options2) {
        this.options = options2;
      }
      createFilter(callStream) {
        return new MaxMessageSizeFilter(this.options, callStream);
      }
    };
    exports2.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel.js
var require_channel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelImplementation = exports2.ConnectivityState = void 0;
    var call_stream_1 = require_call_stream();
    var channel_credentials_1 = require_channel_credentials();
    var resolving_load_balancer_1 = require_resolving_load_balancer();
    var subchannel_pool_1 = require_subchannel_pool();
    var picker_1 = require_picker();
    var constants_1 = require_constants();
    var filter_stack_1 = require_filter_stack();
    var call_credentials_filter_1 = require_call_credentials_filter();
    var deadline_filter_1 = require_deadline_filter();
    var compression_filter_1 = require_compression_filter();
    var resolver_1 = require_resolver();
    var logging_1 = require_logging();
    var max_message_size_filter_1 = require_max_message_size_filter();
    var http_proxy_1 = require_http_proxy();
    var uri_parser_1 = require_uri_parser();
    var ConnectivityState;
    (function(ConnectivityState2) {
      ConnectivityState2[ConnectivityState2["IDLE"] = 0] = "IDLE";
      ConnectivityState2[ConnectivityState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectivityState2[ConnectivityState2["READY"] = 2] = "READY";
      ConnectivityState2[ConnectivityState2["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
      ConnectivityState2[ConnectivityState2["SHUTDOWN"] = 4] = "SHUTDOWN";
    })(ConnectivityState = exports2.ConnectivityState || (exports2.ConnectivityState = {}));
    var MAX_TIMEOUT_TIME = 2147483647;
    var nextCallNumber = 0;
    function getNewCallNumber() {
      const callNumber = nextCallNumber;
      nextCallNumber += 1;
      if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {
        nextCallNumber = 0;
      }
      return callNumber;
    }
    var ChannelImplementation = class {
      constructor(target, credentials, options2) {
        var _a, _b, _c;
        this.credentials = credentials;
        this.options = options2;
        this.connectivityState = ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        this.configSelectionQueue = [];
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        this.configSelector = null;
        if (typeof target !== "string") {
          throw new TypeError("Channel target must be a string");
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
          throw new TypeError("Channel credentials must be a ChannelCredentials object");
        }
        if (options2) {
          if (typeof options2 !== "object" || !Object.values(options2).every((value) => typeof value === "string" || typeof value === "number" || typeof value === "undefined")) {
            throw new TypeError("Channel options must be an object with string or number values");
          }
        }
        const originalTargetUri = uri_parser_1.parseUri(target);
        if (originalTargetUri === null) {
          throw new Error(`Could not parse target name "${target}"`);
        }
        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);
        if (defaultSchemeMapResult === null) {
          throw new Error(`Could not find a default scheme for target name "${target}"`);
        }
        this.callRefTimer = setInterval(() => {
        }, MAX_TIMEOUT_TIME);
        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (this.options["grpc.default_authority"]) {
          this.defaultAuthority = this.options["grpc.default_authority"];
        } else {
          this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);
        }
        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options2);
        this.target = proxyMapResult.target;
        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options2["grpc.use_local_subchannel_pool"]) !== null && _c !== void 0 ? _c : 0) === 0);
        const channelControlHelper = {
          createSubchannel: (subchannelAddress, subchannelArgs) => {
            return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);
          },
          updateState: (connectivityState, picker) => {
            this.currentPicker = picker;
            const queueCopy = this.pickQueue.slice();
            this.pickQueue = [];
            this.callRefTimerUnref();
            for (const { callStream, callMetadata, callConfig } of queueCopy) {
              this.tryPick(callStream, callMetadata, callConfig);
            }
            this.updateState(connectivityState);
          },
          requestReresolution: () => {
            throw new Error("Resolving load balancer should never call requestReresolution");
          }
        };
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options2, (configSelector) => {
          this.configSelector = configSelector;
          process.nextTick(() => {
            const localQueue = this.configSelectionQueue;
            this.configSelectionQueue = [];
            this.callRefTimerUnref();
            for (const { callStream, callMetadata } of localQueue) {
              this.tryGetConfig(callStream, callMetadata);
            }
            this.configSelectionQueue = [];
          });
        }, (status) => {
          if (this.configSelectionQueue.length > 0) {
            logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", "Name resolution failed for target " + uri_parser_1.uriToString(this.target) + " with calls queued for config selection");
          }
          const localQueue = this.configSelectionQueue;
          this.configSelectionQueue = [];
          this.callRefTimerUnref();
          for (const { callStream, callMetadata } of localQueue) {
            if (callMetadata.getOptions().waitForReady) {
              this.callRefTimerRef();
              this.configSelectionQueue.push({ callStream, callMetadata });
            } else {
              callStream.cancelWithStatus(status.code, status.details);
            }
          }
        });
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
          new call_credentials_filter_1.CallCredentialsFilterFactory(this),
          new deadline_filter_1.DeadlineFilterFactory(this),
          new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),
          new compression_filter_1.CompressionFilterFactory(this)
        ]);
      }
      callRefTimerRef() {
        var _a, _b, _c, _d;
        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {
          logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", "callRefTimer.ref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
      }
      callRefTimerUnref() {
        var _a, _b;
        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
          logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", "callRefTimer.unref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      pushPick(callStream, callMetadata, callConfig) {
        this.pickQueue.push({ callStream, callMetadata, callConfig });
        this.callRefTimerRef();
      }
      tryPick(callStream, callMetadata, callConfig) {
        var _a, _b, _c;
        const pickResult = this.currentPicker.pick({ metadata: callMetadata, extraPickInfo: callConfig.pickInformation });
        logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", "Pick result: " + picker_1.PickResultType[pickResult.pickResultType] + " subchannel: " + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + " status: " + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + " " + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));
        switch (pickResult.pickResultType) {
          case picker_1.PickResultType.COMPLETE:
            if (pickResult.subchannel === null) {
              callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Request dropped by load balancing policy");
            } else {
              if (pickResult.subchannel.getConnectivityState() !== ConnectivityState.READY) {
                logging_1.log(constants_1.LogVerbosity.ERROR, "Error: COMPLETE pick result subchannel " + pickResult.subchannel.getAddress() + " has state " + ConnectivityState[pickResult.subchannel.getConnectivityState()]);
                this.pushPick(callStream, callMetadata, callConfig);
                break;
              }
              callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then((finalMetadata) => {
                var _a2, _b2, _c2;
                const subchannelState = pickResult.subchannel.getConnectivityState();
                if (subchannelState === ConnectivityState.READY) {
                  try {
                    pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a2 = pickResult.extraFilterFactory) !== null && _a2 !== void 0 ? _a2 : void 0);
                    (_b2 = callConfig.onCommitted) === null || _b2 === void 0 ? void 0 : _b2.call(callConfig);
                    (_c2 = pickResult.onCallStarted) === null || _c2 === void 0 ? void 0 : _c2.call(pickResult);
                  } catch (error3) {
                    if (error3.code === "ERR_HTTP2_GOAWAY_SESSION") {
                      logging_1.trace(constants_1.LogVerbosity.INFO, "channel", "Failed to start call on picked subchannel " + pickResult.subchannel.getAddress() + " with error " + error3.message + ". Retrying pick");
                      this.tryPick(callStream, callMetadata, callConfig);
                    } else {
                      logging_1.trace(constants_1.LogVerbosity.INFO, "channel", "Failed to start call on picked subchanel " + pickResult.subchannel.getAddress() + " with error " + error3.message + ". Ending call");
                      callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error3.message}`);
                    }
                  }
                } else {
                  logging_1.trace(constants_1.LogVerbosity.INFO, "channel", "Picked subchannel " + pickResult.subchannel.getAddress() + " has state " + ConnectivityState[subchannelState] + " after metadata filters. Retrying pick");
                  this.tryPick(callStream, callMetadata, callConfig);
                }
              }, (error3) => {
                callStream.cancelWithStatus(typeof error3.code === "number" ? error3.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error3.message}`);
              });
            }
            break;
          case picker_1.PickResultType.QUEUE:
            this.pushPick(callStream, callMetadata, callConfig);
            break;
          case picker_1.PickResultType.TRANSIENT_FAILURE:
            if (callMetadata.getOptions().waitForReady) {
              this.pushPick(callStream, callMetadata, callConfig);
            } else {
              callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
            }
            break;
          case picker_1.PickResultType.DROP:
            callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
            break;
          default:
            throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);
        }
      }
      removeConnectivityStateWatcher(watcherObject) {
        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
        if (watcherIndex >= 0) {
          this.connectivityStateWatchers.splice(watcherIndex, 1);
        }
      }
      updateState(newState) {
        logging_1.trace(constants_1.LogVerbosity.DEBUG, "connectivity_state", uri_parser_1.uriToString(this.target) + " " + ConnectivityState[this.connectivityState] + " -> " + ConnectivityState[newState]);
        this.connectivityState = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) {
          if (newState !== watcherObject.currentState) {
            if (watcherObject.timer) {
              clearTimeout(watcherObject.timer);
            }
            this.removeConnectivityStateWatcher(watcherObject);
            watcherObject.callback();
          }
        }
      }
      tryGetConfig(stream, metadata) {
        if (this.configSelector === null) {
          this.resolvingLoadBalancer.exitIdle();
          this.configSelectionQueue.push({
            callStream: stream,
            callMetadata: metadata
          });
          this.callRefTimerRef();
        } else {
          const callConfig = this.configSelector(stream.getMethod(), metadata);
          if (callConfig.status === constants_1.Status.OK) {
            this.tryPick(stream, metadata, callConfig);
          } else {
            stream.cancelWithStatus(callConfig.status, "Failed to route call to method " + stream.getMethod());
          }
        }
      }
      _startCallStream(stream, metadata) {
        this.tryGetConfig(stream, metadata.clone());
      }
      close() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(ConnectivityState.SHUTDOWN);
        clearInterval(this.callRefTimer);
        this.subchannelPool.unrefUnusedSubchannels();
      }
      getTarget() {
        return uri_parser_1.uriToString(this.target);
      }
      getConnectivityState(tryToConnect) {
        const connectivityState = this.connectivityState;
        if (tryToConnect) {
          this.resolvingLoadBalancer.exitIdle();
        }
        return connectivityState;
      }
      watchConnectivityState(currentState, deadline, callback) {
        if (this.connectivityState === ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        let timer = null;
        if (deadline !== Infinity) {
          const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
          const now = new Date();
          if (deadline === -Infinity || deadlineDate <= now) {
            process.nextTick(callback, new Error("Deadline passed without connectivity state change"));
            return;
          }
          timer = setTimeout(() => {
            this.removeConnectivityStateWatcher(watcherObject);
            callback(new Error("Deadline passed without connectivity state change"));
          }, deadlineDate.getTime() - now.getTime());
        }
        const watcherObject = {
          currentState,
          callback,
          timer
        };
        this.connectivityStateWatchers.push(watcherObject);
      }
      createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== "string") {
          throw new TypeError("Channel#createCall: method must be a string");
        }
        if (!(typeof deadline === "number" || deadline instanceof Date)) {
          throw new TypeError("Channel#createCall: deadline must be a number or Date");
        }
        if (this.connectivityState === ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        const callNumber = getNewCallNumber();
        logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", uri_parser_1.uriToString(this.target) + " createCall [" + callNumber + '] method="' + method + '", deadline=' + deadline);
        const finalOptions = {
          deadline,
          flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
          host: host !== null && host !== void 0 ? host : this.defaultAuthority,
          parentCall
        };
        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);
        return stream;
      }
    };
    exports2.ChannelImplementation = ChannelImplementation;
  }
});

// node_modules/@grpc/grpc-js/build/src/call.js
var require_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientDuplexStreamImpl = exports2.ClientWritableStreamImpl = exports2.ClientReadableStreamImpl = exports2.ClientUnaryCallImpl = exports2.callErrorFromStatus = void 0;
    var events_1 = require("events");
    var stream_1 = require("stream");
    var constants_1 = require_constants();
    function callErrorFromStatus(status) {
      const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
      return Object.assign(new Error(message), status);
    }
    exports2.callErrorFromStatus = callErrorFromStatus;
    var ClientUnaryCallImpl = class extends events_1.EventEmitter {
      constructor() {
        super();
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
    };
    exports2.ClientUnaryCallImpl = ClientUnaryCallImpl;
    var ClientReadableStreamImpl = class extends stream_1.Readable {
      constructor(deserialize) {
        super({ objectMode: true });
        this.deserialize = deserialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
      }
    };
    exports2.ClientReadableStreamImpl = ClientReadableStreamImpl;
    var ClientWritableStreamImpl = class extends stream_1.Writable {
      constructor(serialize) {
        super({ objectMode: true });
        this.serialize = serialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _write(chunk, encoding, cb) {
        var _a;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
      }
    };
    exports2.ClientWritableStreamImpl = ClientWritableStreamImpl;
    var ClientDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(serialize, deserialize) {
        super({ objectMode: true });
        this.serialize = serialize;
        this.deserialize = deserialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
      }
      _write(chunk, encoding, cb) {
        var _a;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
      }
    };
    exports2.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/client-interceptors.js
var require_client_interceptors = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client-interceptors.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInterceptingCall = exports2.InterceptingCall = exports2.RequesterBuilder = exports2.ListenerBuilder = exports2.InterceptorConfigurationError = void 0;
    var metadata_1 = require_metadata();
    var call_stream_1 = require_call_stream();
    var constants_1 = require_constants();
    var InterceptorConfigurationError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InterceptorConfigurationError";
        Error.captureStackTrace(this, InterceptorConfigurationError);
      }
    };
    exports2.InterceptorConfigurationError = InterceptorConfigurationError;
    var ListenerBuilder = class {
      constructor() {
        this.metadata = void 0;
        this.message = void 0;
        this.status = void 0;
      }
      withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
      }
      withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
      }
      withOnReceiveStatus(onReceiveStatus) {
        this.status = onReceiveStatus;
        return this;
      }
      build() {
        return {
          onReceiveMetadata: this.metadata,
          onReceiveMessage: this.message,
          onReceiveStatus: this.status
        };
      }
    };
    exports2.ListenerBuilder = ListenerBuilder;
    var RequesterBuilder = class {
      constructor() {
        this.start = void 0;
        this.message = void 0;
        this.halfClose = void 0;
        this.cancel = void 0;
      }
      withStart(start) {
        this.start = start;
        return this;
      }
      withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
      }
      withHalfClose(halfClose) {
        this.halfClose = halfClose;
        return this;
      }
      withCancel(cancel) {
        this.cancel = cancel;
        return this;
      }
      build() {
        return {
          start: this.start,
          sendMessage: this.message,
          halfClose: this.halfClose,
          cancel: this.cancel
        };
      }
    };
    exports2.RequesterBuilder = RequesterBuilder;
    var defaultListener = {
      onReceiveMetadata: (metadata, next) => {
        next(metadata);
      },
      onReceiveMessage: (message, next) => {
        next(message);
      },
      onReceiveStatus: (status, next) => {
        next(status);
      }
    };
    var defaultRequester = {
      start: (metadata, listener, next) => {
        next(metadata, listener);
      },
      sendMessage: (message, next) => {
        next(message);
      },
      halfClose: (next) => {
        next();
      },
      cancel: (next) => {
        next();
      }
    };
    var InterceptingCall = class {
      constructor(nextCall, requester) {
        var _a, _b, _c, _d;
        this.nextCall = nextCall;
        this.processingMessage = false;
        this.pendingHalfClose = false;
        if (requester) {
          this.requester = {
            start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,
            sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,
            halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,
            cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel
          };
        } else {
          this.requester = defaultRequester;
        }
      }
      cancelWithStatus(status, details) {
        this.requester.cancel(() => {
          this.nextCall.cancelWithStatus(status, details);
        });
      }
      getPeer() {
        return this.nextCall.getPeer();
      }
      start(metadata, interceptingListener) {
        var _a, _b, _c, _d, _e, _f;
        const fullInterceptingListener = {
          onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata2) => {
          },
          onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message) => {
          },
          onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status) => {
          }
        };
        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
          var _a2, _b2, _c2;
          let finalInterceptingListener;
          if (call_stream_1.isInterceptingListener(listener)) {
            finalInterceptingListener = listener;
          } else {
            const fullListener = {
              onReceiveMetadata: (_a2 = listener.onReceiveMetadata) !== null && _a2 !== void 0 ? _a2 : defaultListener.onReceiveMetadata,
              onReceiveMessage: (_b2 = listener.onReceiveMessage) !== null && _b2 !== void 0 ? _b2 : defaultListener.onReceiveMessage,
              onReceiveStatus: (_c2 = listener.onReceiveStatus) !== null && _c2 !== void 0 ? _c2 : defaultListener.onReceiveStatus
            };
            finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
          }
          this.nextCall.start(md, finalInterceptingListener);
        });
      }
      sendMessageWithContext(context, message) {
        this.processingMessage = true;
        this.requester.sendMessage(message, (finalMessage) => {
          this.processingMessage = false;
          this.nextCall.sendMessageWithContext(context, finalMessage);
          if (this.pendingHalfClose) {
            this.nextCall.halfClose();
          }
        });
      }
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      startRead() {
        this.nextCall.startRead();
      }
      halfClose() {
        this.requester.halfClose(() => {
          if (this.processingMessage) {
            this.pendingHalfClose = true;
          } else {
            this.nextCall.halfClose();
          }
        });
      }
      setCredentials(credentials) {
        this.nextCall.setCredentials(credentials);
      }
    };
    exports2.InterceptingCall = InterceptingCall;
    function getCall(channel, path, options2) {
      var _a, _b;
      const deadline = (_a = options2.deadline) !== null && _a !== void 0 ? _a : Infinity;
      const host = options2.host;
      const parent = (_b = options2.parent) !== null && _b !== void 0 ? _b : null;
      const propagateFlags = options2.propagate_flags;
      const credentials = options2.credentials;
      const call = channel.createCall(path, deadline, host, parent, propagateFlags);
      if (credentials) {
        call.setCredentials(credentials);
      }
      return call;
    }
    var BaseInterceptingCall = class {
      constructor(call, methodDefinition) {
        this.call = call;
        this.methodDefinition = methodDefinition;
      }
      cancelWithStatus(status, details) {
        this.call.cancelWithStatus(status, details);
      }
      getPeer() {
        return this.call.getPeer();
      }
      setCredentials(credentials) {
        this.call.setCredentials(credentials);
      }
      sendMessageWithContext(context, message) {
        let serialized;
        try {
          serialized = this.methodDefinition.requestSerialize(message);
        } catch (e) {
          this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);
          return;
        }
        this.call.sendMessageWithContext(context, serialized);
      }
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      start(metadata, interceptingListener) {
        let readError = null;
        this.call.start(metadata, {
          onReceiveMetadata: (metadata2) => {
            var _a;
            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata2);
          },
          onReceiveMessage: (message) => {
            var _a;
            let deserialized;
            try {
              deserialized = this.methodDefinition.responseDeserialize(message);
            } catch (e) {
              readError = {
                code: constants_1.Status.INTERNAL,
                details: `Response message parsing error: ${e.message}`,
                metadata: new metadata_1.Metadata()
              };
              this.call.cancelWithStatus(readError.code, readError.details);
              return;
            }
            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);
          },
          onReceiveStatus: (status) => {
            var _a, _b;
            if (readError) {
              (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);
            } else {
              (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);
            }
          }
        });
      }
      startRead() {
        this.call.startRead();
      }
      halfClose() {
        this.call.halfClose();
      }
    };
    var BaseUnaryInterceptingCall = class extends BaseInterceptingCall {
      constructor(call, methodDefinition) {
        super(call, methodDefinition);
      }
      start(metadata, listener) {
        var _a, _b;
        let receivedMessage = false;
        const wrapperListener = {
          onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata2) => {
          },
          onReceiveMessage: (message) => {
            var _a2;
            receivedMessage = true;
            (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, message);
          },
          onReceiveStatus: (status) => {
            var _a2, _b2;
            if (!receivedMessage) {
              (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, null);
            }
            (_b2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b2 === void 0 ? void 0 : _b2.call(listener, status);
          }
        };
        super.start(metadata, wrapperListener);
        this.call.startRead();
      }
    };
    var BaseStreamingInterceptingCall = class extends BaseInterceptingCall {
    };
    function getBottomInterceptingCall(channel, options2, methodDefinition) {
      const call = getCall(channel, methodDefinition.path, options2);
      if (methodDefinition.responseStream) {
        return new BaseStreamingInterceptingCall(call, methodDefinition);
      } else {
        return new BaseUnaryInterceptingCall(call, methodDefinition);
      }
    }
    function getInterceptingCall(interceptorArgs, methodDefinition, options2, channel) {
      if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
      }
      if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as call options. Only one of these is allowed.");
      }
      let interceptors = [];
      if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {
        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      } else {
        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      }
      const interceptorOptions = Object.assign({}, options2, {
        method_definition: methodDefinition
      });
      const getCall2 = interceptors.reduceRight((nextCall, nextInterceptor) => {
        return (currentOptions) => nextInterceptor(currentOptions, nextCall);
      }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
      return getCall2(interceptorOptions);
    }
    exports2.getInterceptingCall = getInterceptingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/client.js
var require_client3 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var call_1 = require_call();
    var channel_1 = require_channel();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var client_interceptors_1 = require_client_interceptors();
    var CHANNEL_SYMBOL = Symbol();
    var INTERCEPTOR_SYMBOL = Symbol();
    var INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
    var CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
    function isFunction(arg) {
      return typeof arg === "function";
    }
    var Client = class {
      constructor(address, credentials, options2 = {}) {
        var _a, _b;
        options2 = Object.assign({}, options2);
        this[INTERCEPTOR_SYMBOL] = (_a = options2.interceptors) !== null && _a !== void 0 ? _a : [];
        delete options2.interceptors;
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options2.interceptor_providers) !== null && _b !== void 0 ? _b : [];
        delete options2.interceptor_providers;
        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
          throw new Error("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
        }
        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options2.callInvocationTransformer;
        delete options2.callInvocationTransformer;
        if (options2.channelOverride) {
          this[CHANNEL_SYMBOL] = options2.channelOverride;
        } else if (options2.channelFactoryOverride) {
          const channelFactoryOverride = options2.channelFactoryOverride;
          delete options2.channelFactoryOverride;
          this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options2);
        } else {
          this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options2);
        }
      }
      close() {
        this[CHANNEL_SYMBOL].close();
      }
      getChannel() {
        return this[CHANNEL_SYMBOL];
      }
      waitForReady(deadline, callback) {
        const checkState = (err) => {
          if (err) {
            callback(new Error("Failed to connect before the deadline"));
            return;
          }
          let newState;
          try {
            newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
          } catch (e) {
            callback(new Error("The channel has been closed"));
            return;
          }
          if (newState === channel_1.ConnectivityState.READY) {
            callback();
          } else {
            try {
              this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
            } catch (e) {
              callback(new Error("The channel has been closed"));
            }
          }
        };
        setImmediate(checkState);
      }
      checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (isFunction(arg1)) {
          return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
        } else if (isFunction(arg2)) {
          if (arg1 instanceof metadata_1.Metadata) {
            return { metadata: arg1, options: {}, callback: arg2 };
          } else {
            return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
          }
        } else {
          if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {
            throw new Error("Incorrect arguments passed");
          }
          return { metadata: arg1, options: arg2, callback: arg3 };
        }
      }
      makeUnaryRequest(method, serialize, deserialize, argument, metadata, options2, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options2, callback);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientUnaryCallImpl(),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let responseMessage = null;
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              callProperties.callback(null, responseMessage);
            } else {
              callProperties.callback(call_1.callErrorFromStatus(status));
            }
            emitter.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
      }
      makeClientStreamRequest(method, serialize, deserialize, metadata, options2, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options2, callback);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientWritableStreamImpl(serialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let responseMessage = null;
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              callProperties.callback(null, responseMessage);
            } else {
              callProperties.callback(call_1.callErrorFromStatus(status));
            }
            emitter.emit("status", status);
          }
        });
        return emitter;
      }
      checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options2;
        if (arg1 instanceof metadata_1.Metadata) {
          metadata = arg1;
          if (arg2) {
            options2 = arg2;
          } else {
            options2 = {};
          }
        } else {
          if (arg1) {
            options2 = arg1;
          } else {
            options2 = {};
          }
          metadata = new metadata_1.Metadata();
        }
        return { metadata, options: options2 };
      }
      makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options2) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options2);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientReadableStreamImpl(deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              stream.emit("error", call_1.callErrorFromStatus(status));
            }
            stream.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return stream;
      }
      makeBidiStreamRequest(method, serialize, deserialize, metadata, options2) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options2);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              stream.emit("error", call_1.callErrorFromStatus(status));
            }
            stream.emit("status", status);
          }
        });
        return stream;
      }
    };
    exports2.Client = Client;
  }
});

// node_modules/@grpc/grpc-js/build/src/make-client.js
var require_make_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/make-client.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadPackageDefinition = exports2.makeClientConstructor = void 0;
    var client_1 = require_client3();
    var requesterFuncs = {
      unary: client_1.Client.prototype.makeUnaryRequest,
      server_stream: client_1.Client.prototype.makeServerStreamRequest,
      client_stream: client_1.Client.prototype.makeClientStreamRequest,
      bidi: client_1.Client.prototype.makeBidiStreamRequest
    };
    function isPrototypePolluted(key) {
      return ["__proto__", "prototype", "constructor"].includes(key);
    }
    function makeClientConstructor(methods, serviceName, classOptions) {
      if (!classOptions) {
        classOptions = {};
      }
      class ServiceClientImpl extends client_1.Client {
      }
      Object.keys(methods).forEach((name) => {
        if (isPrototypePolluted(name)) {
          return;
        }
        const attrs = methods[name];
        let methodType;
        if (typeof name === "string" && name.charAt(0) === "$") {
          throw new Error("Method names cannot start with $");
        }
        if (attrs.requestStream) {
          if (attrs.responseStream) {
            methodType = "bidi";
          } else {
            methodType = "client_stream";
          }
        } else {
          if (attrs.responseStream) {
            methodType = "server_stream";
          } else {
            methodType = "unary";
          }
        }
        const serialize = attrs.requestSerialize;
        const deserialize = attrs.responseDeserialize;
        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
        ServiceClientImpl.prototype[name] = methodFunc;
        Object.assign(ServiceClientImpl.prototype[name], attrs);
        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
          ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];
        }
      });
      ServiceClientImpl.service = methods;
      return ServiceClientImpl;
    }
    exports2.makeClientConstructor = makeClientConstructor;
    function partial(fn, path, serialize, deserialize) {
      return function(...args) {
        return fn.call(this, path, serialize, deserialize, ...args);
      };
    }
    function isProtobufTypeDefinition(obj) {
      return "format" in obj;
    }
    function loadPackageDefinition(packageDef) {
      const result = {};
      for (const serviceFqn in packageDef) {
        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
          const service = packageDef[serviceFqn];
          const nameComponents = serviceFqn.split(".");
          if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
            continue;
          }
          const serviceName = nameComponents[nameComponents.length - 1];
          let current = result;
          for (const packageName of nameComponents.slice(0, -1)) {
            if (!current[packageName]) {
              current[packageName] = {};
            }
            current = current[packageName];
          }
          if (isProtobufTypeDefinition(service)) {
            current[serviceName] = service;
          } else {
            current[serviceName] = makeClientConstructor(service, serviceName, {});
          }
        }
      }
      return result;
    }
    exports2.loadPackageDefinition = loadPackageDefinition;
  }
});

// node_modules/@grpc/grpc-js/build/src/server-call.js
var require_server_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-call.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Http2ServerCallStream = exports2.ServerDuplexStreamImpl = exports2.ServerWritableStreamImpl = exports2.ServerReadableStreamImpl = exports2.ServerUnaryCallImpl = void 0;
    var events_1 = require("events");
    var http2 = require("http2");
    var stream_1 = require("stream");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var TRACER_NAME = "server_call";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var GRPC_ACCEPT_ENCODING_HEADER = "grpc-accept-encoding";
    var GRPC_ENCODING_HEADER = "grpc-encoding";
    var GRPC_MESSAGE_HEADER = "grpc-message";
    var GRPC_STATUS_HEADER = "grpc-status";
    var GRPC_TIMEOUT_HEADER = "grpc-timeout";
    var DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
    var deadlineUnitsToMs = {
      H: 36e5,
      M: 6e4,
      S: 1e3,
      m: 1,
      u: 1e-3,
      n: 1e-6
    };
    var defaultResponseHeaders = {
      [GRPC_ACCEPT_ENCODING_HEADER]: "identity",
      [GRPC_ENCODING_HEADER]: "identity",
      [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
      [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto"
    };
    var defaultResponseOptions = {
      waitForTrailers: true
    };
    var ServerUnaryCallImpl = class extends events_1.EventEmitter {
      constructor(call, metadata, request) {
        super();
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
    };
    exports2.ServerUnaryCallImpl = ServerUnaryCallImpl;
    var ServerReadableStreamImpl = class extends stream_1.Readable {
      constructor(call, metadata, deserialize) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this);
      }
      _read(size) {
        if (!this.call.consumeUnpushedMessages(this)) {
          return;
        }
        this.call.resume();
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
    };
    exports2.ServerReadableStreamImpl = ServerReadableStreamImpl;
    var ServerWritableStreamImpl = class extends stream_1.Writable {
      constructor(call, metadata, serialize, request) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.request = request;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.on("error", (err) => {
          this.call.sendError(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      _write(chunk, encoding, callback) {
        try {
          const response = this.call.serializeMessage(chunk);
          if (!this.call.write(response)) {
            this.call.once("drain", callback);
            return;
          }
        } catch (err) {
          err.code = constants_1.Status.INTERNAL;
          this.emit("error", err);
        }
        callback();
      }
      _final(callback) {
        this.call.sendStatus({
          code: constants_1.Status.OK,
          details: "OK",
          metadata: this.trailingMetadata
        });
        callback(null);
      }
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        super.end();
      }
    };
    exports2.ServerWritableStreamImpl = ServerWritableStreamImpl;
    var ServerDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(call, metadata, serialize, deserialize) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this);
        this.on("error", (err) => {
          this.call.sendError(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        super.end();
      }
    };
    exports2.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
    ServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;
    ServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;
    ServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;
    ServerDuplexStreamImpl.prototype.end = ServerWritableStreamImpl.prototype.end;
    var Http2ServerCallStream = class extends events_1.EventEmitter {
      constructor(stream, handler2, options2) {
        super();
        this.stream = stream;
        this.handler = handler2;
        this.options = options2;
        this.cancelled = false;
        this.deadlineTimer = setTimeout(() => {
        }, 0);
        this.deadline = Infinity;
        this.wantTrailers = false;
        this.metadataSent = false;
        this.canPush = false;
        this.isPushPending = false;
        this.bufferedMessages = [];
        this.messagesToPush = [];
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.stream.once("error", (err) => {
        });
        this.stream.once("close", () => {
          var _a;
          trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " stream closed with rstCode " + this.stream.rstCode);
          this.cancelled = true;
          this.emit("cancelled", "cancelled");
        });
        this.stream.on("drain", () => {
          this.emit("drain");
        });
        if ("grpc.max_send_message_length" in options2) {
          this.maxSendMessageSize = options2["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options2) {
          this.maxReceiveMessageSize = options2["grpc.max_receive_message_length"];
        }
        clearTimeout(this.deadlineTimer);
      }
      checkCancelled() {
        if (this.stream.destroyed) {
          this.cancelled = true;
        }
        return this.cancelled;
      }
      sendMetadata(customMetadata) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.metadataSent) {
          return;
        }
        this.metadataSent = true;
        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;
        const headers = Object.assign({}, defaultResponseHeaders, custom);
        this.stream.respond(headers, defaultResponseOptions);
      }
      receiveMetadata(headers) {
        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
        if (timeoutHeader.length > 0) {
          const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);
          if (match === null) {
            const err = new Error("Invalid deadline");
            err.code = constants_1.Status.OUT_OF_RANGE;
            this.sendError(err);
            return;
          }
          const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;
          const now = new Date();
          this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
          this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);
          metadata.remove(GRPC_TIMEOUT_HEADER);
        }
        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
        metadata.remove(http2.constants.HTTP2_HEADER_TE);
        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
        metadata.remove("grpc-encoding");
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      receiveUnaryMessage() {
        return new Promise((resolve2, reject) => {
          const stream = this.stream;
          const chunks = [];
          let totalLength = 0;
          stream.on("data", (data) => {
            chunks.push(data);
            totalLength += data.byteLength;
          });
          stream.once("end", async () => {
            try {
              const requestBytes = Buffer.concat(chunks, totalLength);
              if (this.maxReceiveMessageSize !== -1 && requestBytes.length > this.maxReceiveMessageSize) {
                this.sendError({
                  code: constants_1.Status.RESOURCE_EXHAUSTED,
                  details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`
                });
                resolve2();
              }
              resolve2(this.deserializeMessage(requestBytes));
            } catch (err) {
              err.code = constants_1.Status.INTERNAL;
              this.sendError(err);
              resolve2();
            }
          });
        });
      }
      serializeMessage(value) {
        const messageBuffer = this.handler.serialize(value);
        const byteLength = messageBuffer.byteLength;
        const output = Buffer.allocUnsafe(byteLength + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(byteLength, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      deserializeMessage(bytes) {
        const receivedMessage = bytes.slice(5);
        return this.handler.deserialize(receivedMessage);
      }
      async sendUnaryMessage(err, value, metadata, flags) {
        if (this.checkCancelled()) {
          return;
        }
        if (!metadata) {
          metadata = new metadata_1.Metadata();
        }
        if (err) {
          if (!Object.prototype.hasOwnProperty.call(err, "metadata")) {
            err.metadata = metadata;
          }
          this.sendError(err);
          return;
        }
        try {
          const response = this.serializeMessage(value);
          this.write(response);
          this.sendStatus({ code: constants_1.Status.OK, details: "OK", metadata });
        } catch (err2) {
          err2.code = constants_1.Status.INTERNAL;
          this.sendError(err2);
        }
      }
      sendStatus(statusObj) {
        var _a;
        if (this.checkCancelled()) {
          return;
        }
        trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " ended with status code: " + constants_1.Status[statusObj.code] + " details: " + statusObj.details);
        clearTimeout(this.deadlineTimer);
        if (!this.wantTrailers) {
          this.wantTrailers = true;
          this.stream.once("wantTrailers", () => {
            const trailersToSend = Object.assign({
              [GRPC_STATUS_HEADER]: statusObj.code,
              [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)
            }, statusObj.metadata.toHttp2Headers());
            this.stream.sendTrailers(trailersToSend);
          });
          this.sendMetadata();
          this.stream.end();
        }
      }
      sendError(error3) {
        if (this.checkCancelled()) {
          return;
        }
        const status = {
          code: constants_1.Status.UNKNOWN,
          details: "message" in error3 ? error3.message : "Unknown Error",
          metadata: "metadata" in error3 && error3.metadata !== void 0 ? error3.metadata : new metadata_1.Metadata()
        };
        if ("code" in error3 && typeof error3.code === "number" && Number.isInteger(error3.code)) {
          status.code = error3.code;
          if ("details" in error3 && typeof error3.details === "string") {
            status.details = error3.details;
          }
        }
        this.sendStatus(status);
      }
      write(chunk) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {
          this.sendError({
            code: constants_1.Status.RESOURCE_EXHAUSTED,
            details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`
          });
          return;
        }
        this.sendMetadata();
        return this.stream.write(chunk);
      }
      resume() {
        this.stream.resume();
      }
      setupSurfaceCall(call) {
        this.once("cancelled", (reason) => {
          call.cancelled = true;
          call.emit("cancelled", reason);
        });
      }
      setupReadable(readable) {
        const decoder = new stream_decoder_1.StreamDecoder();
        this.stream.on("data", async (data) => {
          const messages = decoder.write(data);
          for (const message of messages) {
            if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {
              this.sendError({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`
              });
              return;
            }
            this.pushOrBufferMessage(readable, message);
          }
        });
        this.stream.once("end", () => {
          this.pushOrBufferMessage(readable, null);
        });
      }
      consumeUnpushedMessages(readable) {
        this.canPush = true;
        while (this.messagesToPush.length > 0) {
          const nextMessage = this.messagesToPush.shift();
          const canPush = readable.push(nextMessage);
          if (nextMessage === null || canPush === false) {
            this.canPush = false;
            break;
          }
        }
        return this.canPush;
      }
      pushOrBufferMessage(readable, messageBytes) {
        if (this.isPushPending) {
          this.bufferedMessages.push(messageBytes);
        } else {
          this.pushMessage(readable, messageBytes);
        }
      }
      async pushMessage(readable, messageBytes) {
        if (messageBytes === null) {
          if (this.canPush) {
            readable.push(null);
          } else {
            this.messagesToPush.push(null);
          }
          return;
        }
        this.isPushPending = true;
        try {
          const deserialized = await this.deserializeMessage(messageBytes);
          if (this.canPush) {
            if (!readable.push(deserialized)) {
              this.canPush = false;
              this.stream.pause();
            }
          } else {
            this.messagesToPush.push(deserialized);
          }
        } catch (error3) {
          this.bufferedMessages.length = 0;
          if (!("code" in error3 && typeof error3.code === "number" && Number.isInteger(error3.code) && error3.code >= constants_1.Status.OK && error3.code <= constants_1.Status.UNAUTHENTICATED)) {
            error3.code = constants_1.Status.INTERNAL;
          }
          readable.emit("error", error3);
        }
        this.isPushPending = false;
        if (this.bufferedMessages.length > 0) {
          this.pushMessage(readable, this.bufferedMessages.shift());
        }
      }
      getPeer() {
        const socket = this.stream.session.socket;
        if (socket.remoteAddress) {
          if (socket.remotePort) {
            return `${socket.remoteAddress}:${socket.remotePort}`;
          } else {
            return socket.remoteAddress;
          }
        } else {
          return "unknown";
        }
      }
      getDeadline() {
        return this.deadline;
      }
    };
    exports2.Http2ServerCallStream = Http2ServerCallStream;
    function handleExpiredDeadline(call) {
      const err = new Error("Deadline exceeded");
      err.code = constants_1.Status.DEADLINE_EXCEEDED;
      call.sendError(err);
      call.cancelled = true;
      call.emit("cancelled", "deadline");
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/server.js
var require_server2 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Server = void 0;
    var http2 = require("http2");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var server_call_1 = require_server_call();
    var resolver_1 = require_resolver();
    var logging = require_logging();
    var subchannel_1 = require_subchannel();
    var uri_parser_1 = require_uri_parser();
    var TRACER_NAME = "server";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function noop3() {
    }
    function getUnimplementedStatusResponse(methodName) {
      return {
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method ${methodName}`,
        metadata: new metadata_1.Metadata()
      };
    }
    function getDefaultHandler(handlerType, methodName) {
      const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
      switch (handlerType) {
        case "unary":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "clientStream":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "serverStream":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        case "bidi":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        default:
          throw new Error(`Invalid handlerType ${handlerType}`);
      }
    }
    var Server = class {
      constructor(options2) {
        this.http2ServerList = [];
        this.handlers = new Map();
        this.sessions = new Set();
        this.started = false;
        this.options = options2 !== null && options2 !== void 0 ? options2 : {};
      }
      addProtoService() {
        throw new Error("Not implemented. Use addService() instead");
      }
      addService(service, implementation) {
        if (service === null || typeof service !== "object" || implementation === null || typeof implementation !== "object") {
          throw new Error("addService() requires two objects as arguments");
        }
        const serviceKeys = Object.keys(service);
        if (serviceKeys.length === 0) {
          throw new Error("Cannot add an empty service to a server");
        }
        serviceKeys.forEach((name) => {
          const attrs = service[name];
          let methodType;
          if (attrs.requestStream) {
            if (attrs.responseStream) {
              methodType = "bidi";
            } else {
              methodType = "clientStream";
            }
          } else {
            if (attrs.responseStream) {
              methodType = "serverStream";
            } else {
              methodType = "unary";
            }
          }
          let implFn = implementation[name];
          let impl;
          if (implFn === void 0 && typeof attrs.originalName === "string") {
            implFn = implementation[attrs.originalName];
          }
          if (implFn !== void 0) {
            impl = implFn.bind(implementation);
          } else {
            impl = getDefaultHandler(methodType, name);
          }
          const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
          if (success === false) {
            throw new Error(`Method handler for ${attrs.path} already provided.`);
          }
        });
      }
      removeService(service) {
        if (service === null || typeof service !== "object") {
          throw new Error("removeService() requires object as argument");
        }
        const serviceKeys = Object.keys(service);
        serviceKeys.forEach((name) => {
          const attrs = service[name];
          this.unregister(attrs.path);
        });
      }
      bind(port, creds) {
        throw new Error("Not implemented. Use bindAsync() instead");
      }
      bindAsync(port, creds, callback) {
        if (this.started === true) {
          throw new Error("server is already started");
        }
        if (typeof port !== "string") {
          throw new TypeError("port must be a string");
        }
        if (creds === null || typeof creds !== "object") {
          throw new TypeError("creds must be an object");
        }
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        const initialPortUri = uri_parser_1.parseUri(port);
        if (initialPortUri === null) {
          throw new Error(`Could not parse port "${port}"`);
        }
        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);
        if (portUri === null) {
          throw new Error(`Could not get a default scheme for port "${port}"`);
        }
        const serverOptions = {
          maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER
        };
        if ("grpc-node.max_session_memory" in this.options) {
          serverOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
        }
        if ("grpc.max_concurrent_streams" in this.options) {
          serverOptions.settings = {
            maxConcurrentStreams: this.options["grpc.max_concurrent_streams"]
          };
        }
        const setupServer = () => {
          let http2Server;
          if (creds._isSecure()) {
            const secureServerOptions = Object.assign(serverOptions, creds._getSettings());
            http2Server = http2.createSecureServer(secureServerOptions);
          } else {
            http2Server = http2.createServer(serverOptions);
          }
          http2Server.setTimeout(0, noop3);
          this._setupHandlers(http2Server);
          return http2Server;
        };
        const bindSpecificPort = (addressList, portNum, previousCount) => {
          if (addressList.length === 0) {
            return Promise.resolve({ port: portNum, count: previousCount });
          }
          return Promise.all(addressList.map((address) => {
            trace("Attempting to bind " + subchannel_1.subchannelAddressToString(address));
            let addr;
            if (subchannel_1.isTcpSubchannelAddress(address)) {
              addr = {
                host: address.host,
                port: portNum
              };
            } else {
              addr = address;
            }
            const http2Server = setupServer();
            return new Promise((resolve2, reject) => {
              function onError(err) {
                resolve2(err);
              }
              http2Server.once("error", onError);
              http2Server.listen(addr, () => {
                trace("Successfully bound " + subchannel_1.subchannelAddressToString(address));
                this.http2ServerList.push(http2Server);
                const boundAddress = http2Server.address();
                if (typeof boundAddress === "string") {
                  resolve2(portNum);
                } else {
                  resolve2(boundAddress.port);
                }
                http2Server.removeListener("error", onError);
              });
            });
          })).then((results) => {
            let count = 0;
            for (const result of results) {
              if (typeof result === "number") {
                count += 1;
                if (result !== portNum) {
                  throw new Error("Invalid state: multiple port numbers added from single address");
                }
              }
            }
            return {
              port: portNum,
              count: count + previousCount
            };
          });
        };
        const bindWildcardPort = (addressList) => {
          if (addressList.length === 0) {
            return Promise.resolve({ port: 0, count: 0 });
          }
          const address = addressList[0];
          const http2Server = setupServer();
          return new Promise((resolve2, reject) => {
            function onError(err) {
              resolve2(bindWildcardPort(addressList.slice(1)));
            }
            http2Server.once("error", onError);
            http2Server.listen(address, () => {
              this.http2ServerList.push(http2Server);
              resolve2(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));
              http2Server.removeListener("error", onError);
            });
          });
        };
        const resolverListener = {
          onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {
            resolverListener.onSuccessfulResolution = () => {
            };
            if (addressList.length === 0) {
              callback(new Error(`No addresses resolved for port ${port}`), 0);
              return;
            }
            let bindResultPromise;
            if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {
              if (addressList[0].port === 0) {
                bindResultPromise = bindWildcardPort(addressList);
              } else {
                bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);
              }
            } else {
              bindResultPromise = bindSpecificPort(addressList, 1, 0);
            }
            bindResultPromise.then((bindResult) => {
              if (bindResult.count === 0) {
                const errorString = `No address added out of total ${addressList.length} resolved`;
                logging.log(constants_1.LogVerbosity.ERROR, errorString);
                callback(new Error(errorString), 0);
              } else {
                if (bindResult.count < addressList.length) {
                  logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
                }
                callback(null, bindResult.port);
              }
            }, (error3) => {
              const errorString = `No address added out of total ${addressList.length} resolved`;
              logging.log(constants_1.LogVerbosity.ERROR, errorString);
              callback(new Error(errorString), 0);
            });
          },
          onError: (error3) => {
            callback(new Error(error3.details), 0);
          }
        };
        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);
        resolver.updateResolution();
      }
      forceShutdown() {
        for (const http2Server of this.http2ServerList) {
          if (http2Server.listening) {
            http2Server.close();
          }
        }
        this.started = false;
        this.sessions.forEach((session) => {
          session.destroy(http2.constants.NGHTTP2_CANCEL);
        });
        this.sessions.clear();
      }
      register(name, handler2, serialize, deserialize, type) {
        if (this.handlers.has(name)) {
          return false;
        }
        this.handlers.set(name, {
          func: handler2,
          serialize,
          deserialize,
          type,
          path: name
        });
        return true;
      }
      unregister(name) {
        return this.handlers.delete(name);
      }
      start() {
        if (this.http2ServerList.length === 0 || this.http2ServerList.every((http2Server) => http2Server.listening !== true)) {
          throw new Error("server must be bound in order to start");
        }
        if (this.started === true) {
          throw new Error("server is already started");
        }
        this.started = true;
      }
      tryShutdown(callback) {
        let pendingChecks = 0;
        function maybeCallback() {
          pendingChecks--;
          if (pendingChecks === 0) {
            callback();
          }
        }
        this.started = false;
        for (const http2Server of this.http2ServerList) {
          if (http2Server.listening) {
            pendingChecks++;
            http2Server.close(maybeCallback);
          }
        }
        this.sessions.forEach((session) => {
          if (!session.closed) {
            pendingChecks += 1;
            session.close(maybeCallback);
          }
        });
        if (pendingChecks === 0) {
          callback();
        }
      }
      addHttp2Port() {
        throw new Error("Not yet implemented");
      }
      _setupHandlers(http2Server) {
        if (http2Server === null) {
          return;
        }
        http2Server.on("stream", (stream, headers) => {
          const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
          if (typeof contentType !== "string" || !contentType.startsWith("application/grpc")) {
            stream.respond({
              [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE
            }, { endStream: true });
            return;
          }
          try {
            const path = headers[http2.constants.HTTP2_HEADER_PATH];
            const serverAddress = http2Server.address();
            let serverAddressString = "null";
            if (serverAddress) {
              if (typeof serverAddress === "string") {
                serverAddressString = serverAddress;
              } else {
                serverAddressString = serverAddress.address + ":" + serverAddress.port;
              }
            }
            trace("Received call to method " + path + " at address " + serverAddressString);
            const handler2 = this.handlers.get(path);
            if (handler2 === void 0) {
              trace("No handler registered for method " + path + ". Sending UNIMPLEMENTED status.");
              throw getUnimplementedStatusResponse(path);
            }
            const call = new server_call_1.Http2ServerCallStream(stream, handler2, this.options);
            const metadata = call.receiveMetadata(headers);
            switch (handler2.type) {
              case "unary":
                handleUnary(call, handler2, metadata);
                break;
              case "clientStream":
                handleClientStreaming(call, handler2, metadata);
                break;
              case "serverStream":
                handleServerStreaming(call, handler2, metadata);
                break;
              case "bidi":
                handleBidiStreaming(call, handler2, metadata);
                break;
              default:
                throw new Error(`Unknown handler type: ${handler2.type}`);
            }
          } catch (err) {
            const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);
            if (err.code === void 0) {
              err.code = constants_1.Status.INTERNAL;
            }
            call.sendError(err);
          }
        });
        http2Server.on("session", (session) => {
          if (!this.started) {
            session.destroy();
            return;
          }
          this.sessions.add(session);
          session.on("close", () => {
            this.sessions.delete(session);
          });
        });
      }
    };
    exports2.Server = Server;
    async function handleUnary(call, handler2, metadata) {
      const request = await call.receiveUnaryMessage();
      if (request === void 0 || call.cancelled) {
        return;
      }
      const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);
      handler2.func(emitter, (err, value, trailer, flags) => {
        call.sendUnaryMessage(err, value, trailer, flags);
      });
    }
    function handleClientStreaming(call, handler2, metadata) {
      const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler2.deserialize);
      function respond2(err, value, trailer, flags) {
        stream.destroy();
        call.sendUnaryMessage(err, value, trailer, flags);
      }
      if (call.cancelled) {
        return;
      }
      stream.on("error", respond2);
      handler2.func(stream, respond2);
    }
    async function handleServerStreaming(call, handler2, metadata) {
      const request = await call.receiveUnaryMessage();
      if (request === void 0 || call.cancelled) {
        return;
      }
      const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler2.serialize, request);
      handler2.func(stream);
    }
    function handleBidiStreaming(call, handler2, metadata) {
      const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler2.serialize, handler2.deserialize);
      if (call.cancelled) {
        return;
      }
      handler2.func(stream);
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/server-credentials.js
var require_server_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-credentials.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerCredentials = void 0;
    var tls_helpers_1 = require_tls_helpers();
    var ServerCredentials = class {
      static createInsecure() {
        return new InsecureServerCredentials();
      }
      static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
          throw new TypeError("rootCerts must be null or a Buffer");
        }
        if (!Array.isArray(keyCertPairs)) {
          throw new TypeError("keyCertPairs must be an array");
        }
        if (typeof checkClientCertificate !== "boolean") {
          throw new TypeError("checkClientCertificate must be a boolean");
        }
        const cert = [];
        const key = [];
        for (let i = 0; i < keyCertPairs.length; i++) {
          const pair = keyCertPairs[i];
          if (pair === null || typeof pair !== "object") {
            throw new TypeError(`keyCertPair[${i}] must be an object`);
          }
          if (!Buffer.isBuffer(pair.private_key)) {
            throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
          }
          if (!Buffer.isBuffer(pair.cert_chain)) {
            throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
          }
          cert.push(pair.cert_chain);
          key.push(pair.private_key);
        }
        return new SecureServerCredentials({
          ca: rootCerts || tls_helpers_1.getDefaultRootsData() || void 0,
          cert,
          key,
          requestCert: checkClientCertificate,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
      }
    };
    exports2.ServerCredentials = ServerCredentials;
    var InsecureServerCredentials = class extends ServerCredentials {
      _isSecure() {
        return false;
      }
      _getSettings() {
        return null;
      }
    };
    var SecureServerCredentials = class extends ServerCredentials {
      constructor(options2) {
        super();
        this.options = options2;
      }
      _isSecure() {
        return true;
      }
      _getSettings() {
        return this.options;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/status-builder.js
var require_status_builder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/status-builder.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StatusBuilder = void 0;
    var StatusBuilder = class {
      constructor() {
        this.code = null;
        this.details = null;
        this.metadata = null;
      }
      withCode(code) {
        this.code = code;
        return this;
      }
      withDetails(details) {
        this.details = details;
        return this;
      }
      withMetadata(metadata) {
        this.metadata = metadata;
        return this;
      }
      build() {
        const status = {};
        if (this.code !== null) {
          status.code = this.code;
        }
        if (this.details !== null) {
          status.details = this.details;
        }
        if (this.metadata !== null) {
          status.metadata = this.metadata;
        }
        return status;
      }
    };
    exports2.StatusBuilder = StatusBuilder;
  }
});

// node_modules/@grpc/grpc-js/build/src/experimental.js
var require_experimental = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/experimental.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var logging_1 = require_logging();
    Object.defineProperty(exports2, "trace", { enumerable: true, get: function() {
      return logging_1.trace;
    } });
    var resolver_1 = require_resolver();
    Object.defineProperty(exports2, "registerResolver", { enumerable: true, get: function() {
      return resolver_1.registerResolver;
    } });
    var uri_parser_1 = require_uri_parser();
    Object.defineProperty(exports2, "uriToString", { enumerable: true, get: function() {
      return uri_parser_1.uriToString;
    } });
    var backoff_timeout_1 = require_backoff_timeout();
    Object.defineProperty(exports2, "BackoffTimeout", { enumerable: true, get: function() {
      return backoff_timeout_1.BackoffTimeout;
    } });
    var load_balancer_1 = require_load_balancer();
    Object.defineProperty(exports2, "registerLoadBalancerType", { enumerable: true, get: function() {
      return load_balancer_1.registerLoadBalancerType;
    } });
    Object.defineProperty(exports2, "getFirstUsableConfig", { enumerable: true, get: function() {
      return load_balancer_1.getFirstUsableConfig;
    } });
    Object.defineProperty(exports2, "validateLoadBalancingConfig", { enumerable: true, get: function() {
      return load_balancer_1.validateLoadBalancingConfig;
    } });
    var subchannel_1 = require_subchannel();
    Object.defineProperty(exports2, "subchannelAddressToString", { enumerable: true, get: function() {
      return subchannel_1.subchannelAddressToString;
    } });
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    Object.defineProperty(exports2, "ChildLoadBalancerHandler", { enumerable: true, get: function() {
      return load_balancer_child_handler_1.ChildLoadBalancerHandler;
    } });
    var picker_1 = require_picker();
    Object.defineProperty(exports2, "UnavailablePicker", { enumerable: true, get: function() {
      return picker_1.UnavailablePicker;
    } });
    Object.defineProperty(exports2, "QueuePicker", { enumerable: true, get: function() {
      return picker_1.QueuePicker;
    } });
    Object.defineProperty(exports2, "PickResultType", { enumerable: true, get: function() {
      return picker_1.PickResultType;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "BaseFilter", { enumerable: true, get: function() {
      return filter_1.BaseFilter;
    } });
    var filter_stack_1 = require_filter_stack();
    Object.defineProperty(exports2, "FilterStackFactory", { enumerable: true, get: function() {
      return filter_stack_1.FilterStackFactory;
    } });
  }
});

// node_modules/@grpc/grpc-js/build/src/index.js
var require_src = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/index.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.experimental = exports2.StatusBuilder = exports2.getClientChannel = exports2.ServerCredentials = exports2.Server = exports2.setLogVerbosity = exports2.setLogger = exports2.load = exports2.loadObject = exports2.CallCredentials = exports2.ChannelCredentials = exports2.waitForClientReady = exports2.closeClient = exports2.Channel = exports2.makeGenericClientConstructor = exports2.makeClientConstructor = exports2.loadPackageDefinition = exports2.Client = exports2.propagate = exports2.connectivityState = exports2.status = exports2.logVerbosity = exports2.Metadata = exports2.credentials = void 0;
    var call_credentials_1 = require_call_credentials();
    Object.defineProperty(exports2, "CallCredentials", { enumerable: true, get: function() {
      return call_credentials_1.CallCredentials;
    } });
    var channel_1 = require_channel();
    Object.defineProperty(exports2, "connectivityState", { enumerable: true, get: function() {
      return channel_1.ConnectivityState;
    } });
    Object.defineProperty(exports2, "Channel", { enumerable: true, get: function() {
      return channel_1.ChannelImplementation;
    } });
    var channel_credentials_1 = require_channel_credentials();
    Object.defineProperty(exports2, "ChannelCredentials", { enumerable: true, get: function() {
      return channel_credentials_1.ChannelCredentials;
    } });
    var client_1 = require_client3();
    Object.defineProperty(exports2, "Client", { enumerable: true, get: function() {
      return client_1.Client;
    } });
    var constants_1 = require_constants();
    Object.defineProperty(exports2, "logVerbosity", { enumerable: true, get: function() {
      return constants_1.LogVerbosity;
    } });
    Object.defineProperty(exports2, "status", { enumerable: true, get: function() {
      return constants_1.Status;
    } });
    Object.defineProperty(exports2, "propagate", { enumerable: true, get: function() {
      return constants_1.Propagate;
    } });
    var logging = require_logging();
    var make_client_1 = require_make_client();
    Object.defineProperty(exports2, "loadPackageDefinition", { enumerable: true, get: function() {
      return make_client_1.loadPackageDefinition;
    } });
    Object.defineProperty(exports2, "makeClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    Object.defineProperty(exports2, "makeGenericClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    var metadata_1 = require_metadata();
    Object.defineProperty(exports2, "Metadata", { enumerable: true, get: function() {
      return metadata_1.Metadata;
    } });
    var server_1 = require_server2();
    Object.defineProperty(exports2, "Server", { enumerable: true, get: function() {
      return server_1.Server;
    } });
    var server_credentials_1 = require_server_credentials();
    Object.defineProperty(exports2, "ServerCredentials", { enumerable: true, get: function() {
      return server_credentials_1.ServerCredentials;
    } });
    var status_builder_1 = require_status_builder();
    Object.defineProperty(exports2, "StatusBuilder", { enumerable: true, get: function() {
      return status_builder_1.StatusBuilder;
    } });
    exports2.credentials = {
      combineChannelCredentials: (channelCredentials, ...callCredentials) => {
        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
      },
      combineCallCredentials: (first, ...additional) => {
        return additional.reduce((acc, other) => acc.compose(other), first);
      },
      createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
      createSsl: channel_credentials_1.ChannelCredentials.createSsl,
      createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
      createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
      createEmpty: call_credentials_1.CallCredentials.createEmpty
    };
    exports2.closeClient = (client) => client.close();
    exports2.waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
    exports2.loadObject = (value, options2) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports2.load = (filename, format2, options2) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports2.setLogger = (logger) => {
      logging.setLogger(logger);
    };
    exports2.setLogVerbosity = (verbosity) => {
      logging.setLoggerVerbosity(verbosity);
    };
    exports2.getClientChannel = (client) => {
      return client_1.Client.prototype.getChannel.call(client);
    };
    var client_interceptors_1 = require_client_interceptors();
    Object.defineProperty(exports2, "ListenerBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.ListenerBuilder;
    } });
    Object.defineProperty(exports2, "RequesterBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.RequesterBuilder;
    } });
    Object.defineProperty(exports2, "InterceptingCall", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptingCall;
    } });
    Object.defineProperty(exports2, "InterceptorConfigurationError", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptorConfigurationError;
    } });
    var experimental = require_experimental();
    exports2.experimental = experimental;
    var resolver = require_resolver();
    var load_balancer = require_load_balancer();
    (() => {
      resolver.registerAll();
      load_balancer.registerAll();
    })();
  }
});

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.camelcase/index.js"(exports2, module2) {
    init_shims();
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start, end) {
      var index2 = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index2 < length) {
        result[index2] = array[index2 + start];
      }
      return result;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    var camelCase = createCompounder(function(result, word, index2) {
      word = word.toLowerCase();
      return result + (index2 ? capitalize(word) : word);
    });
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = camelCase;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
      while (index2 < arguments.length)
        params[offset++] = arguments[index2++];
      return new Promise(function executor(resolve2, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve2.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    init_shims();
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    init_shims();
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits((charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0, (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0);
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    init_shims();
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src2[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop3() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop3, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop3, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop3, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : "toNumber";
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response === null) {
            self2.end(true);
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        });
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    init_shims();
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    init_shims();
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value));
            case "i":
              return String(Math.floor(value));
            case "j":
              return JSON.stringify(value);
            case "s":
              return String(value);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = fetch2;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch2(filename, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      } else if (!options2)
        options2 = {};
      if (!callback)
        return asPromise(fetch2, this, filename, options2);
      if (!options2.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
          return err && typeof XMLHttpRequest !== "undefined" ? fetch2.xhr(filename, options2, callback) : err ? callback(err) : callback(null, options2.binary ? contents : contents.toString("utf8"));
        });
      return fetch2.xhr(filename, options2, callback);
    }
    fetch2.xhr = function fetch_xhr(filename, options2, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options2.binary) {
          var buffer = xhr.response;
          if (!buffer) {
            buffer = [];
            for (var i = 0; i < xhr.responseText.length; ++i)
              buffer.push(xhr.responseText.charCodeAt(i) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
      };
      if (options2.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    init_shims();
    "use strict";
    var path = exports2;
    var isAbsolute = path.isAbsolute = function isAbsolute2(path2) {
      return /^(?:\/|\w+:)/.test(path2);
    };
    var normalize2 = path.normalize = function normalize3(path2) {
      path2 = path2.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      var parts = path2.split("/"), absolute2 = isAbsolute(path2), prefix = "";
      if (absolute2)
        prefix = parts.shift() + "/";
      for (var i = 0; i < parts.length; ) {
        if (parts[i] === "..") {
          if (i > 0 && parts[i - 1] !== "..")
            parts.splice(--i, 2);
          else if (absolute2)
            parts.splice(i, 1);
          else
            ++i;
        } else if (parts[i] === ".")
          parts.splice(i, 1);
        else
          ++i;
      }
      return prefix + parts.join("/");
    };
    path.resolve = function resolve2(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize2(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize2(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize2(originPath + "/" + includePath) : includePath;
    };
  }
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    init_shims();
    "use strict";
    var types2 = exports2;
    var util = require_util();
    var s2 = [
      "double",
      "float",
      "int32",
      "uint32",
      "sint32",
      "fixed32",
      "sfixed32",
      "int64",
      "uint64",
      "sint64",
      "fixed64",
      "sfixed64",
      "bool",
      "string",
      "bytes"
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length)
        o[s2[i + offset]] = values[i++];
      return o;
    }
    types2.basic = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2,
      2
    ]);
    types2.defaults = bake([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      false,
      "",
      util.emptyArray,
      null
    ]);
    types2.long = bake([
      0,
      0,
      0,
      1,
      1
    ], 7);
    types2.mapKey = bake([
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2
    ], 2);
    types2.packed = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types2 = require_types();
    var util = require_util();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = function fromJSON(name, json) {
      return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    };
    function Field(name, id, type, rule, extend, options2, comment) {
      if (util.isObject(rule)) {
        comment = extend;
        options2 = rule;
        rule = extend = void 0;
      } else if (util.isObject(extend)) {
        comment = options2;
        options2 = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name, options2);
      if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util.Long ? types2.long[type] !== void 0 : false;
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    Object.defineProperty(Field.prototype, "packed", {
      get: function() {
        if (this._packed === null)
          this._packed = this.getOption("packed") !== false;
        return this._packed;
      }
    });
    Field.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (name === "packed")
        this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
    };
    Field.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types2.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
          util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
          util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map)
        this.defaultValue = util.emptyObject;
      else if (this.repeated)
        this.defaultValue = util.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field._configure = function configure(Type_) {
      Type = Type_;
    };
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util = require_util();
    function OneOf(name, fieldNames, options2, comment) {
      if (!Array.isArray(fieldNames)) {
        options2 = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name, options2);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON(name, json) {
      return new OneOf(name, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
          if (!oneof.fieldsArray[i].parent)
            oneof.parent.add(oneof.fieldsArray[i]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      var index2 = this.fieldsArray.indexOf(field);
      if (index2 < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index2, 1);
      index2 = this.oneof.indexOf(field.name);
      if (index2 > -1)
        this.oneof.splice(index2, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent) {
      ReflectionObject.prototype.onAdd.call(this, parent);
      var self2 = this;
      for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent) {
      for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent);
    };
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index2 = 0;
      while (index2 < arguments.length)
        fieldNames[index2] = arguments[index2++];
      return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util.oneOfGetter(fieldNames),
          set: util.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field = require_field();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var Service;
    var Enum;
    Namespace.fromJSON = function fromJSON(name, json) {
      return new Namespace(name, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
      return obj;
    }
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = function isReservedId(reserved2, id) {
      if (reserved2) {
        for (var i = 0; i < reserved2.length; ++i)
          if (typeof reserved2[i] !== "string" && reserved2[i][0] <= id && reserved2[i][1] > id)
            return true;
      }
      return false;
    };
    Namespace.isReservedName = function isReservedName(reserved2, name) {
      if (reserved2) {
        for (var i = 0; i < reserved2.length; ++i)
          if (reserved2[i] === name)
            return true;
      }
      return false;
    };
    function Namespace(name, options2) {
      ReflectionObject.call(this, name, options2);
      this.nested = void 0;
      this._nestedArray = null;
    }
    function clearCache(namespace) {
      namespace._nestedArray = null;
      return namespace;
    }
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
      }
    });
    Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
      return util.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
          nested = nestedJson[names[i]];
          ns.add((nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));
        }
      }
      return this;
    };
    Namespace.prototype.get = function get(name) {
      return this.nested && this.nested[name] || null;
    };
    Namespace.prototype.getEnum = function getEnum(name) {
      if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
      throw Error("no such enum: " + name);
    };
    Namespace.prototype.add = function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace || object instanceof OneOf))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i = 0; i < nested.length; ++i)
              object.add(nested[i]);
            this.remove(prev);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace.prototype.remove = function remove(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace.prototype.define = function define2(path, json) {
      if (util.isString(path))
        path = path.split(".");
      else if (!Array.isArray(path))
        throw TypeError("illegal path");
      if (path && path.length && path[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace.prototype.resolveAll = function resolveAll() {
      var nested = this.nestedArray, i = 0;
      while (i < nested.length)
        if (nested[i] instanceof Namespace)
          nested[i++].resolveAll();
        else
          nested[i++].resolve();
      return this.resolve();
    };
    Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util.isString(path) && path.length) {
        if (path === ".")
          return this.root;
        path = path.split(".");
      } else if (!path.length)
        return this;
      if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);
      var found = this.get(path[0]);
      if (found) {
        if (path.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
            return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
          return found;
      } else
        for (var i = 0; i < this.nestedArray.length; ++i)
          if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
            return found;
      if (this.parent === null || parentAlreadyChecked)
        return null;
      return this.parent.lookup(path, filterTypes);
    };
    Namespace.prototype.lookupType = function lookupType(path) {
      var found = this.lookup(path, [Type]);
      if (!found)
        throw Error("no such type: " + path);
      return found;
    };
    Namespace.prototype.lookupEnum = function lookupEnum(path) {
      var found = this.lookup(path, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
      var found = this.lookup(path, [Type, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupService = function lookupService(path) {
      var found = this.lookup(path, [Service]);
      if (!found)
        throw Error("no such Service '" + path + "' in " + this);
      return found;
    };
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types2 = require_types();
    var util = require_util();
    function MapField(name, id, keyType, type, options2, comment) {
      Field.call(this, name, id, type, void 0, void 0, options2, comment);
      if (!util.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON(name, json) {
      return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      if (types2.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util = require_util();
    function Method(name, type, requestType, responseType, requestStream, responseStream, options2, comment, parsedOptions) {
      if (util.isObject(requestStream)) {
        options2 = requestStream;
        requestStream = responseStream = void 0;
      } else if (util.isObject(responseStream)) {
        options2 = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util.isString(type)))
        throw TypeError("type must be a string");
      if (!util.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name, options2);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON(name, json) {
      return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "type",
        this.type !== "rpc" && this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Service;
    var Namespace = require_namespace();
    ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util = require_util();
    var rpc = require_rpc();
    function Service(name, options2) {
      Namespace.call(this, name, options2);
      this.methods = {};
      this._methodsArray = null;
    }
    Service.fromJSON = function fromJSON(name, json) {
      var service = new Service(name, json.options);
      if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
          service.add(Method.fromJSON(names[i], json.methods[names[i]]));
      if (json.nested)
        service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    };
    Service.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service.prototype.get = function get(name) {
      return this.methods[name] || Namespace.prototype.get.call(this, name);
    };
    Service.prototype.resolveAll = function resolveAll() {
      var methods = this.methodsArray;
      for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
      return Namespace.prototype.resolve.call(this);
    };
    Service.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Service.prototype.remove = function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i = 0, method; i < this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// node_modules/protobufjs/src/message.js
var require_message2 = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Message;
    var util = require_minimal();
    function Message(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          this[keys[i]] = properties[keys[i]];
    }
    Message.create = function create(properties) {
      return this.$type.create(properties);
    };
    Message.encode = function encode(message, writer) {
      return this.$type.encode(message, writer);
    };
    Message.encodeDelimited = function encodeDelimited(message, writer) {
      return this.$type.encodeDelimited(message, writer);
    };
    Message.decode = function decode(reader) {
      return this.$type.decode(reader);
    };
    Message.decodeDelimited = function decodeDelimited(reader) {
      return this.$type.decodeDelimited(reader);
    };
    Message.verify = function verify(message) {
      return this.$type.verify(message);
    };
    Message.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message.toObject = function toObject(message, options2) {
      return this.$type.toObject(message, options2);
    };
    Message.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util.toJSONOptions);
    };
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types2 = require_types();
    var util = require_util();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group)
        gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i = 0;
      for (; i < mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
        gen("case %i:", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types2.defaults[field.keyType] !== void 0)
            gen("k=%j", types2.defaults[field.keyType]);
          else
            gen("k=null");
          if (types2.defaults[type] !== void 0)
            gen("value=%j", types2.defaults[type]);
          else
            gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types2.basic[type] === void 0)
            gen("value=types[%i].decode(r,r.uint32())", i);
          else
            gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types2.long[field.keyType] !== void 0)
            gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else
            gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types2.packed[type] !== void 0)
            gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types2.basic[type] === void 0)
            gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
          else
            gen("%s.push(r.%s())", ref, type);
        } else if (types2.basic[type] === void 0)
          gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else
          gen("%s=r.%s()", ref, type);
        gen("break");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required)
          gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util = require_util();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)
            gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length)
        gen("var p={}");
      for (var i = 0; i < mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
        if (field.optional)
          gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1)
              gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i, ref);
        }
        if (field.optional)
          gen("}");
      }
      return gen("return null");
    }
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    init_shims();
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util = require_util();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (field.repeated && values[keys[i]] === field.typeDefault)
              gen("default:");
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else
          gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length)
        return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), prop = util.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i, prop + "[ks[i]]")("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i, prop + "[i]")("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum))
            gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(gen, field, i, prop);
          if (!(field.resolvedType instanceof Enum))
            gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum)
          gen("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else
          gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      if (!fields.length)
        return util.codegen()("return {}");
      var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i)
          gen("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i)
          gen("d%s={}", util.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field = normalFields[i], prop = util.safeProp(field.name);
          if (field.resolvedType instanceof Enum)
            gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long)
            gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else
            gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field = fields[i], index2 = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(gen, field, index2, prop + "[ks2[j]]")("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(gen, field, index2, prop + "[j]")("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(gen, field, index2, prop);
          if (field.partOf)
            gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    init_shims();
    "use strict";
    var wrappers = exports2;
    var Message = require_message2();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].substr(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message, options2) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";
        if (options2 && options2.json && message.type_url && message.value) {
          name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
          prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type)
            message = type.decode(message.value);
        }
        if (!(message instanceof this.ctor) && message instanceof Message) {
          var object = message.$type.toObject(message, options2);
          var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.substr(1) : message.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name = prefix + messageName;
          object["@type"] = name;
          return object;
        }
        return this.toObject(message, options2);
      }
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Type;
    var Namespace = require_namespace();
    ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service = require_service2();
    var Message = require_message2();
    var Reader = require_reader();
    var Writer = require_writer();
    var util = require_util();
    var encoder = require_encoder();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type(name, options2) {
      Namespace.call(this, name, options2);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type.prototype, {
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
            var field = this.fields[names[i]], id = field.id;
            if (this._fieldsById[id])
              throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }
      },
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
      },
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
      },
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util.merge(ctor, Message, true);
          this._ctor = ctor;
          var i = 0;
          for (; i < this.fieldsArray.length; ++i)
            this._fieldsArray[i].resolve();
          var ctorProperties = {};
          for (i = 0; i < this.oneofsArray.length; ++i)
            ctorProperties[this._oneofsArray[i].resolve().name] = {
              get: util.oneOfGetter(this._oneofsArray[i].oneof),
              set: util.oneOfSetter(this._oneofsArray[i].oneof)
            };
          if (i)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type.generateConstructor = function generateConstructor(mtype) {
      var gen = util.codegen(["p"], mtype.name);
      for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map)
          gen("this%s={}", util.safeProp(field.name));
        else if (field.repeated)
          gen("this%s=[]", util.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type.fromJSON = function fromJSON(name, json) {
      var type = new Type(name, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names = Object.keys(json.fields), i = 0;
      for (; i < names.length; ++i)
        type.add((typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));
      if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
          type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
      if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
          var nested = json.nested[names[i]];
          type.add((nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      return type;
    };
    Type.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type.prototype.resolveAll = function resolveAll() {
      var fields = this.fieldsArray, i = 0;
      while (i < fields.length)
        fields[i++].resolve();
      var oneofs = this.oneofsArray;
      i = 0;
      while (i < oneofs.length)
        oneofs[i++].resolve();
      return Namespace.prototype.resolveAll.call(this);
    };
    Type.prototype.get = function get(name) {
      return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
    };
    Type.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? this._fieldsById[object.id] : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Type.prototype.remove = function remove(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Type.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Type.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
    Type.prototype.create = function create(properties) {
      return new this.ctor(properties);
    };
    Type.prototype.setup = function setup() {
      var fullName = this.fullName, types2 = [];
      for (var i = 0; i < this.fieldsArray.length; ++i)
        types2.push(this._fieldsArray[i].resolve().resolvedType);
      this.encode = encoder(this)({
        Writer,
        types: types2,
        util
      });
      this.decode = decoder(this)({
        Reader,
        types: types2,
        util
      });
      this.verify = verifier(this)({
        types: types2,
        util
      });
      this.fromObject = converter.fromObject(this)({
        types: types2,
        util
      });
      this.toObject = converter.toObject(this)({
        types: types2,
        util
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type.prototype.encode = function encode_setup(message, writer) {
      return this.setup().encode(message, writer);
    };
    Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
    };
    Type.prototype.decode = function decode_setup(reader, length) {
      return this.setup().decode(reader, length);
    };
    Type.prototype.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof Reader))
        reader = Reader.create(reader);
      return this.decode(reader, reader.uint32());
    };
    Type.prototype.verify = function verify_setup(message) {
      return this.setup().verify(message);
    };
    Type.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type.prototype.toObject = function toObject(message, options2) {
      return this.setup().toObject(message, options2);
    };
    Type.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util.decorateType(target, typeName);
      };
    };
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Root2;
    var Namespace = require_namespace();
    ((Root2.prototype = Object.create(Namespace.prototype)).constructor = Root2).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var parse;
    var common;
    function Root2(options2) {
      Namespace.call(this, "", options2);
      this.deferred = [];
      this.files = [];
    }
    Root2.fromJSON = function fromJSON(json, root) {
      if (!root)
        root = new Root2();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested);
    };
    Root2.prototype.resolvePath = util.path.resolve;
    Root2.prototype.fetch = util.fetch;
    function SYNC() {
    }
    Root2.prototype.load = function load2(filename, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = void 0;
      }
      var self2 = this;
      if (!callback)
        return util.asPromise(load2, self2, filename, options2);
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback)
          return;
        var cb = callback;
        callback = null;
        if (sync)
          throw err;
        cb(err, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common)
            return altname;
        }
        return null;
      }
      function process2(filename2, source) {
        try {
          if (util.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse.filename = filename2;
            var parsed = parse(source, self2, options2), resolved2, i2 = 0;
            if (parsed.imports) {
              for (; i2 < parsed.imports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                  fetch2(resolved2);
            }
            if (parsed.weakImports) {
              for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                  fetch2(resolved2, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued)
          finish(null, self2);
      }
      function fetch2(filename2, weak) {
        if (self2.files.indexOf(filename2) > -1)
          return;
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync)
            process2(filename2, common[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak)
              finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback)
              return;
            if (err) {
              if (!weak)
                finish(err);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util.isString(filename))
        filename = [filename];
      for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self2.resolvePath("", filename[i]))
          fetch2(resolved);
      if (sync)
        return self2;
      if (!queued)
        finish(null, self2);
      return void 0;
    };
    Root2.prototype.loadSync = function loadSync(filename, options2) {
      if (!util.isNode)
        throw Error("not supported");
      return this.load(filename, options2, SYNC);
    };
    Root2.prototype.resolveAll = function resolveAll() {
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root2.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0 && !object.extensionField) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type)
          for (var i = 0; i < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i]))
              this.deferred.splice(i, 1);
            else
              ++i;
        for (var j = 0; j < object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
    };
    Root2.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0) {
          if (object.extensionField) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index2 = this.deferred.indexOf(object);
            if (index2 > -1)
              this.deferred.splice(index2, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i = 0; i < object.nestedArray.length; ++i)
          this._handleRemove(object._nestedArray[i]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
    };
    Root2._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse = parse_;
      common = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    init_shims();
    "use strict";
    var util = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util.codegen = require_codegen();
    util.fetch = require_fetch();
    util.path = require_path();
    util.fs = util.inquire("fs");
    util.toArray = function toArray(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index2 = 0;
        while (index2 < keys.length)
          array[index2] = object[keys[index2++]];
        return array;
      }
      return [];
    };
    util.toObject = function toObject(array) {
      var object = {}, index2 = 0;
      while (index2 < array.length) {
        var key = array[index2++], val = array[index2++];
        if (val !== void 0)
          object[key] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util.isReserved = function isReserved(name) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
    };
    util.safeProp = function safeProp2(prop) {
      if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util.compareFieldsById = function compareFieldsById(a, b) {
      return a.id - b.id;
    };
    util.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type)
        Type = require_type();
      var type = new Type(typeName || ctor.name);
      util.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util.setProperty = function setProperty(dst, path, value) {
      function setProp(dst2, path2, value2) {
        var part = path2.shift();
        if (path2.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path2, value2);
        } else {
          var prevValue = dst2[part];
          if (prevValue)
            value2 = [].concat(prevValue).concat(value2);
          dst2[part] = value2;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path)
        throw TypeError("path must be specified");
      path = path.split(".");
      return setProp(dst, path, value);
    };
    Object.defineProperty(util, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util = require_util();
    var Root2;
    function ReflectionObject(name, options2) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (options2 && !util.isObject(options2))
        throw TypeError("options must be an object");
      this.options = options2;
      this.parsedOptions = null;
      this.name = name;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      fullName: {
        get: function() {
          var path = [this.name], ptr = this.parent;
          while (ptr) {
            path.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent) {
      if (this.parent && this.parent !== parent)
        this.parent.remove(this);
      this.parent = parent;
      this.resolved = false;
      var root = parent.root;
      if (root instanceof Root2)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent) {
      var root = parent.root;
      if (root instanceof Root2)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root2)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype.getOption = function getOption(name) {
      if (this.options)
        return this.options[name];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name] === void 0)
        (this.options || (this.options = {}))[name] = value;
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name);
        });
        if (opt) {
          var newValue = opt[name];
          util.setProperty(newValue, propName, value);
        } else {
          opt = {};
          opt[name] = util.setProperty({}, propName, value);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options2, ifNotSet) {
      if (options2)
        for (var keys = Object.keys(options2), i = 0; i < keys.length; ++i)
          this.setOption(keys[i], options2[keys[i]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject._configure = function(Root_) {
      Root2 = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util = require_util();
    function Enum(name, values, options2, comment, comments) {
      ReflectionObject.call(this, name, options2);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
          if (typeof values[keys[i]] === "number")
            this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
      }
    }
    Enum.fromJSON = function fromJSON(name, json) {
      var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name, id, comment) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (!util.isInteger(id))
        throw TypeError("id must be an integer");
      if (this.values[name] !== void 0)
        throw Error("duplicate name '" + name + "' in " + this);
      if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
      } else
        this.valuesById[this.values[name] = id] = name;
      this.comments[name] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove(name) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      var val = this.values[name];
      if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name];
      delete this.comments[name];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Enum.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = encoder;
    var Enum = require_enum();
    var types2 = require_types();
    var util = require_util();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    function encoder(mtype) {
      var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i, ref;
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), index2 = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types2.basic[type];
        ref = "m" + util.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types2.mapKey[field.keyType], field.keyType);
          if (wireType === void 0)
            gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index2, ref);
          else
            gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types2.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0)
              genTypePartial(gen, field, index2, ref + "[i]");
            else
              gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional)
            gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index2, ref);
          else
            gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    init_shims();
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load2(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load2;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message2();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types();
    protobuf.util = require_util();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape2(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    tokenize.unescape = unescape2;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length = source.length, line = 1, commentType = null, commentText = null, commentLine = 0, commentLineEmpty = false, commentIsLeading = false;
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
          throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape2(match[1]);
      }
      function charAt(pos) {
        return source.charAt(pos);
      }
      function setComment(start, end, isLeading) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        commentIsLeading = isLeading;
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start - lookback, c;
        do {
          if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
            commentLineEmpty = true;
            break;
          }
        } while (c === " " || c === "	");
        var lines = source.substring(start, end).split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
          lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        commentText = lines.join("\n").trim();
      }
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
      }
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      function next() {
        if (stack.length > 0)
          return stack.shift();
        if (stringDelim)
          return readString();
        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length)
            return null;
          repeat = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length)
              return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start, offset - 1, isLeadingComment);
                }
                ++line;
                repeat = true;
              } else {
                start = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length) {
                      break;
                    }
                    offset++;
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start, offset, isLeadingComment);
                }
                line++;
                repeat = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start = offset + 1;
              isDoc = alternateCommentMode || charAt(start) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length) {
                  throw illegal("comment");
                }
                prev = curr;
                curr = charAt(offset);
              } while (prev !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start, offset - 2, isLeadingComment);
              }
              repeat = true;
            } else {
              return "/";
            }
          }
        } while (repeat);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
          while (end < length && !delimRe.test(charAt(end)))
            ++end;
        var token = source.substring(offset, offset = end);
        if (token === '"' || token === "'")
          stringDelim = token;
        return token;
      }
      function push(token) {
        stack.push(token);
      }
      function peek() {
        if (!stack.length) {
          var token = next();
          if (token === null)
            return null;
          push(token);
        }
        return stack[0];
      }
      function skip(expected, optional) {
        var actual = peek(), equals = actual === expected;
        if (equals) {
          next();
          return true;
        }
        if (!optional)
          throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === void 0) {
          if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
            ret = commentIsLeading ? commentText : null;
          }
        } else {
          if (commentLine < trailingLine) {
            peek();
          }
          if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
            ret = commentIsLeading ? null : commentText;
          }
        }
        return ret;
      }
      return Object.defineProperty({
        next,
        peek,
        push,
        skip,
        cmnt
      }, "line", {
        get: function() {
          return line;
        }
      });
    }
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS({
  "node_modules/protobufjs/src/parse.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = parse;
    parse.filename = null;
    parse.defaults = { keepCase: false };
    var tokenize = require_tokenize();
    var Root2 = require_root();
    var Type = require_type();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service = require_service2();
    var Method = require_method();
    var types2 = require_types();
    var util = require_util();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function parse(source, root, options2) {
      if (!(root instanceof Root2)) {
        options2 = root;
        root = new Root2();
      }
      if (!options2)
        options2 = parse.defaults;
      var preferTrailingComment = options2.preferTrailingComment || false;
      var tn = tokenize(source, options2.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
      var ptr = root;
      var applyCase = options2.keepCase ? function(name) {
        return name;
      } : util.camelCase;
      function illegal(token2, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
          parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      function readString() {
        var values = [], token2;
        do {
          if ((token2 = next()) !== '"' && token2 !== "'")
            throw illegal(token2);
          values.push(next());
          skip(token2);
          token2 = peek();
        } while (token2 === '"' || token2 === "'");
        return values.join("");
      }
      function readValue(acceptTypeRef) {
        var token2 = next();
        switch (token2) {
          case "'":
          case '"':
            push(token2);
            return readString();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(token2, true);
        } catch (e) {
          if (acceptTypeRef && typeRefRe.test(token2))
            return token2;
          throw illegal(token2, "value");
        }
      }
      function readRanges(target, acceptStrings) {
        var token2, start;
        do {
          if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'"))
            target.push(readString());
          else
            target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
        } while (skip(",", true));
        skip(";");
      }
      function parseNumber(token2, insideTryCatch) {
        var sign = 1;
        if (token2.charAt(0) === "-") {
          sign = -1;
          token2 = token2.substring(1);
        }
        switch (token2) {
          case "inf":
          case "INF":
          case "Inf":
            return sign * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token2))
          return sign * parseInt(token2, 10);
        if (base16Re.test(token2))
          return sign * parseInt(token2, 16);
        if (base8Re.test(token2))
          return sign * parseInt(token2, 8);
        if (numberRe.test(token2))
          return sign * parseFloat(token2);
        throw illegal(token2, "number", insideTryCatch);
      }
      function parseId(token2, acceptNegative) {
        switch (token2) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token2.charAt(0) === "-")
          throw illegal(token2, "id");
        if (base10NegRe.test(token2))
          return parseInt(token2, 10);
        if (base16NegRe.test(token2))
          return parseInt(token2, 16);
        if (base8NegRe.test(token2))
          return parseInt(token2, 8);
        throw illegal(token2, "id");
      }
      function parsePackage() {
        if (pkg !== void 0)
          throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg))
          throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip(";");
      }
      function parseImport() {
        var token2 = peek();
        var whichImports;
        switch (token2) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token2 = readString();
        skip(";");
        whichImports.push(token2);
      }
      function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";
        if (!isProto3 && syntax !== "proto2")
          throw illegal(syntax, "syntax");
        skip(";");
      }
      function parseCommon(parent, token2) {
        switch (token2) {
          case "option":
            parseOption(parent, token2);
            skip(";");
            return true;
          case "message":
            parseType(parent, token2);
            return true;
          case "enum":
            parseEnum(parent, token2);
            return true;
          case "service":
            parseService(parent, token2);
            return true;
          case "extend":
            parseExtension(parent, token2);
            return true;
        }
        return false;
      }
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse.filename;
        }
        if (skip("{", true)) {
          var token2;
          while ((token2 = next()) !== "}")
            fnIf(token2);
          skip(";", true);
        } else {
          if (fnElse)
            fnElse();
          skip(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
            obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      function parseType(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "type name");
        var type = new Type(token2);
        ifBlock(type, function parseType_block(token3) {
          if (parseCommon(type, token3))
            return;
          switch (token3) {
            case "map":
              parseMapField(type, token3);
              break;
            case "required":
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token3);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(type, "optional");
              break;
          }
        });
        parent.add(type);
      }
      function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent, rule);
          return;
        }
        if (!typeRefRe.test(type))
          throw illegal(type, "type");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        name = applyCase(name);
        skip("=");
        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseField_line() {
          parseInlineOptions(field);
        });
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent.add(oneof);
        } else {
          parent.add(field);
        }
        if (!isProto3 && field.repeated && (types2.packed[type] !== void 0 || types2.basic[type] === void 0))
          field.setOption("packed", false, true);
      }
      function parseGroup(parent, rule) {
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        var fieldName = util.lcFirst(name);
        if (name === fieldName)
          name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token2) {
          switch (token2) {
            case "option":
              parseOption(type, token2);
              skip(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token2);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            default:
              throw illegal(token2);
          }
        });
        parent.add(type).add(field);
      }
      function parseMapField(parent) {
        skip("<");
        var keyType = next();
        if (types2.mapKey[keyType] === void 0)
          throw illegal(keyType, "type");
        skip(",");
        var valueType = next();
        if (!typeRefRe.test(valueType))
          throw illegal(valueType, "type");
        skip(">");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseMapField_line() {
          parseInlineOptions(field);
        });
        parent.add(field);
      }
      function parseOneOf(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var oneof = new OneOf(applyCase(token2));
        ifBlock(oneof, function parseOneOf_block(token3) {
          if (token3 === "option") {
            parseOption(oneof, token3);
            skip(";");
          } else {
            push(token3);
            parseField(oneof, "optional");
          }
        });
        parent.add(oneof);
      }
      function parseEnum(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var enm = new Enum(token2);
        ifBlock(enm, function parseEnum_block(token3) {
          switch (token3) {
            case "option":
              parseOption(enm, token3);
              skip(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;
            default:
              parseEnumValue(enm, token3);
          }
        });
        parent.add(enm);
      }
      function parseEnumValue(parent, token2) {
        if (!nameRe.test(token2))
          throw illegal(token2, "name");
        skip("=");
        var value = parseId(next(), true), dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token3) {
          if (token3 === "option") {
            parseOption(dummy, token3);
            skip(";");
          } else
            throw illegal(token3);
        }, function parseEnumValue_line() {
          parseInlineOptions(dummy);
        });
        parent.add(token2, value, dummy.comment);
      }
      function parseOption(parent, token2) {
        var isCustom = skip("(", true);
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name = token2;
        var option = name;
        var propName;
        if (isCustom) {
          skip(")");
          name = "(" + name + ")";
          option = name;
          token2 = peek();
          if (fqTypeRefRe.test(token2)) {
            propName = token2.substr(1);
            name += token2;
            next();
          }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
      }
      function parseOptionValue(parent, name) {
        if (skip("{", true)) {
          var result = {};
          while (!skip("}", true)) {
            if (!nameRe.test(token = next()))
              throw illegal(token, "name");
            var value;
            var propName = token;
            if (peek() === "{")
              value = parseOptionValue(parent, name + "." + token);
            else {
              skip(":");
              if (peek() === "{")
                value = parseOptionValue(parent, name + "." + token);
              else {
                value = readValue(true);
                setOption(parent, name + "." + token, value);
              }
            }
            var prevValue = result[propName];
            if (prevValue)
              value = [].concat(prevValue).concat(value);
            result[propName] = value;
            skip(",", true);
          }
          return result;
        }
        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
      }
      function setOption(parent, name, value) {
        if (parent.setOption)
          parent.setOption(name, value);
      }
      function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
          parent.setParsedOption(name, value, propName);
      }
      function parseInlineOptions(parent) {
        if (skip("[", true)) {
          do {
            parseOption(parent, "option");
          } while (skip(",", true));
          skip("]");
        }
        return parent;
      }
      function parseService(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "service name");
        var service = new Service(token2);
        ifBlock(service, function parseService_block(token3) {
          if (parseCommon(service, token3))
            return;
          if (token3 === "rpc")
            parseMethod(service, token3);
          else
            throw illegal(token3);
        });
        parent.add(service);
      }
      function parseMethod(parent, token2) {
        var commentText = cmnt();
        var type = token2;
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name = token2, requestType, requestStream, responseType, responseStream;
        skip("(");
        if (skip("stream", true))
          requestStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        requestType = token2;
        skip(")");
        skip("returns");
        skip("(");
        if (skip("stream", true))
          responseStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        responseType = token2;
        skip(")");
        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token3) {
          if (token3 === "option") {
            parseOption(method, token3);
            skip(";");
          } else
            throw illegal(token3);
        });
        parent.add(method);
      }
      function parseExtension(parent, token2) {
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "reference");
        var reference = token2;
        ifBlock(null, function parseExtension_block(token3) {
          switch (token3) {
            case "required":
            case "repeated":
              parseField(parent, token3, reference);
              break;
            case "optional":
              if (isProto3) {
                parseField(parent, "proto3_optional", reference);
              } else {
                parseField(parent, "optional", reference);
              }
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(parent, "optional", reference);
              break;
          }
        });
      }
      var token;
      while ((token = next()) !== null) {
        switch (token) {
          case "package":
            if (!head)
              throw illegal(token);
            parsePackage();
            break;
          case "import":
            if (!head)
              throw illegal(token);
            parseImport();
            break;
          case "syntax":
            if (!head)
              throw illegal(token);
            parseSyntax();
            break;
          case "option":
            parseOption(ptr, token);
            skip(";");
            break;
          default:
            if (parseCommon(ptr, token)) {
              head = false;
              continue;
            }
            throw illegal(token);
        }
      }
      parse.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        syntax,
        root
      };
    }
  }
});

// node_modules/protobufjs/src/common.js
var require_common = __commonJS({
  "node_modules/protobufjs/src/common.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = common;
    var commonRe = /\/|\./;
    function common(name, json) {
      if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
      }
      common[name] = json;
    }
    common("any", {
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common("duration", {
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common("timestamp", {
      Timestamp: timeType
    });
    common("empty", {
      Empty: {
        fields: {}
      }
    });
    common("struct", {
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common("wrappers", {
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common("field_mask", {
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common.get = function get(file) {
      return common[file] || null;
    };
  }
});

// node_modules/protobufjs/src/index.js
var require_src2 = __commonJS({
  "node_modules/protobufjs/src/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse();
    protobuf.common = require_common();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS({
  "node_modules/protobufjs/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = require_src2();
  }
});

// node_modules/protobufjs/google/protobuf/descriptor.json
var require_descriptor = __commonJS({
  "node_modules/protobufjs/google/protobuf/descriptor.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                FileDescriptorSet: {
                  fields: {
                    file: {
                      rule: "repeated",
                      type: "FileDescriptorProto",
                      id: 1
                    }
                  }
                },
                FileDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    package: {
                      type: "string",
                      id: 2
                    },
                    dependency: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    publicDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 10,
                      options: {
                        packed: false
                      }
                    },
                    weakDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 11,
                      options: {
                        packed: false
                      }
                    },
                    messageType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 4
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 5
                    },
                    service: {
                      rule: "repeated",
                      type: "ServiceDescriptorProto",
                      id: 6
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 7
                    },
                    options: {
                      type: "FileOptions",
                      id: 8
                    },
                    sourceCodeInfo: {
                      type: "SourceCodeInfo",
                      id: 9
                    },
                    syntax: {
                      type: "string",
                      id: 12
                    }
                  }
                },
                DescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    field: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 2
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 6
                    },
                    nestedType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 3
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 4
                    },
                    extensionRange: {
                      rule: "repeated",
                      type: "ExtensionRange",
                      id: 5
                    },
                    oneofDecl: {
                      rule: "repeated",
                      type: "OneofDescriptorProto",
                      id: 8
                    },
                    options: {
                      type: "MessageOptions",
                      id: 7
                    },
                    reservedRange: {
                      rule: "repeated",
                      type: "ReservedRange",
                      id: 9
                    },
                    reservedName: {
                      rule: "repeated",
                      type: "string",
                      id: 10
                    }
                  },
                  nested: {
                    ExtensionRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    },
                    ReservedRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    }
                  }
                },
                FieldDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    label: {
                      type: "Label",
                      id: 4
                    },
                    type: {
                      type: "Type",
                      id: 5
                    },
                    typeName: {
                      type: "string",
                      id: 6
                    },
                    extendee: {
                      type: "string",
                      id: 2
                    },
                    defaultValue: {
                      type: "string",
                      id: 7
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    options: {
                      type: "FieldOptions",
                      id: 8
                    }
                  },
                  nested: {
                    Type: {
                      values: {
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Label: {
                      values: {
                        LABEL_OPTIONAL: 1,
                        LABEL_REQUIRED: 2,
                        LABEL_REPEATED: 3
                      }
                    }
                  }
                },
                OneofDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    options: {
                      type: "OneofOptions",
                      id: 2
                    }
                  }
                },
                EnumDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      rule: "repeated",
                      type: "EnumValueDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "EnumOptions",
                      id: 3
                    }
                  }
                },
                EnumValueDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      type: "EnumValueOptions",
                      id: 3
                    }
                  }
                },
                ServiceDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    method: {
                      rule: "repeated",
                      type: "MethodDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "ServiceOptions",
                      id: 3
                    }
                  }
                },
                MethodDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    inputType: {
                      type: "string",
                      id: 2
                    },
                    outputType: {
                      type: "string",
                      id: 3
                    },
                    options: {
                      type: "MethodOptions",
                      id: 4
                    },
                    clientStreaming: {
                      type: "bool",
                      id: 5
                    },
                    serverStreaming: {
                      type: "bool",
                      id: 6
                    }
                  }
                },
                FileOptions: {
                  fields: {
                    javaPackage: {
                      type: "string",
                      id: 1
                    },
                    javaOuterClassname: {
                      type: "string",
                      id: 8
                    },
                    javaMultipleFiles: {
                      type: "bool",
                      id: 10
                    },
                    javaGenerateEqualsAndHash: {
                      type: "bool",
                      id: 20,
                      options: {
                        deprecated: true
                      }
                    },
                    javaStringCheckUtf8: {
                      type: "bool",
                      id: 27
                    },
                    optimizeFor: {
                      type: "OptimizeMode",
                      id: 9,
                      options: {
                        default: "SPEED"
                      }
                    },
                    goPackage: {
                      type: "string",
                      id: 11
                    },
                    ccGenericServices: {
                      type: "bool",
                      id: 16
                    },
                    javaGenericServices: {
                      type: "bool",
                      id: 17
                    },
                    pyGenericServices: {
                      type: "bool",
                      id: 18
                    },
                    deprecated: {
                      type: "bool",
                      id: 23
                    },
                    ccEnableArenas: {
                      type: "bool",
                      id: 31
                    },
                    objcClassPrefix: {
                      type: "string",
                      id: 36
                    },
                    csharpNamespace: {
                      type: "string",
                      id: 37
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      38,
                      38
                    ]
                  ],
                  nested: {
                    OptimizeMode: {
                      values: {
                        SPEED: 1,
                        CODE_SIZE: 2,
                        LITE_RUNTIME: 3
                      }
                    }
                  }
                },
                MessageOptions: {
                  fields: {
                    messageSetWireFormat: {
                      type: "bool",
                      id: 1
                    },
                    noStandardDescriptorAccessor: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    mapEntry: {
                      type: "bool",
                      id: 7
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      8,
                      8
                    ]
                  ]
                },
                FieldOptions: {
                  fields: {
                    ctype: {
                      type: "CType",
                      id: 1,
                      options: {
                        default: "STRING"
                      }
                    },
                    packed: {
                      type: "bool",
                      id: 2
                    },
                    jstype: {
                      type: "JSType",
                      id: 6,
                      options: {
                        default: "JS_NORMAL"
                      }
                    },
                    lazy: {
                      type: "bool",
                      id: 5
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    weak: {
                      type: "bool",
                      id: 10
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      4,
                      4
                    ]
                  ],
                  nested: {
                    CType: {
                      values: {
                        STRING: 0,
                        CORD: 1,
                        STRING_PIECE: 2
                      }
                    },
                    JSType: {
                      values: {
                        JS_NORMAL: 0,
                        JS_STRING: 1,
                        JS_NUMBER: 2
                      }
                    }
                  }
                },
                OneofOptions: {
                  fields: {
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumOptions: {
                  fields: {
                    allowAlias: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumValueOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 1
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                ServiceOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                MethodOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                UninterpretedOption: {
                  fields: {
                    name: {
                      rule: "repeated",
                      type: "NamePart",
                      id: 2
                    },
                    identifierValue: {
                      type: "string",
                      id: 3
                    },
                    positiveIntValue: {
                      type: "uint64",
                      id: 4
                    },
                    negativeIntValue: {
                      type: "int64",
                      id: 5
                    },
                    doubleValue: {
                      type: "double",
                      id: 6
                    },
                    stringValue: {
                      type: "bytes",
                      id: 7
                    },
                    aggregateValue: {
                      type: "string",
                      id: 8
                    }
                  },
                  nested: {
                    NamePart: {
                      fields: {
                        namePart: {
                          rule: "required",
                          type: "string",
                          id: 1
                        },
                        isExtension: {
                          rule: "required",
                          type: "bool",
                          id: 2
                        }
                      }
                    }
                  }
                },
                SourceCodeInfo: {
                  fields: {
                    location: {
                      rule: "repeated",
                      type: "Location",
                      id: 1
                    }
                  },
                  nested: {
                    Location: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        span: {
                          rule: "repeated",
                          type: "int32",
                          id: 2
                        },
                        leadingComments: {
                          type: "string",
                          id: 3
                        },
                        trailingComments: {
                          type: "string",
                          id: 4
                        },
                        leadingDetachedComments: {
                          rule: "repeated",
                          type: "string",
                          id: 6
                        }
                      }
                    }
                  }
                },
                GeneratedCodeInfo: {
                  fields: {
                    annotation: {
                      rule: "repeated",
                      type: "Annotation",
                      id: 1
                    }
                  },
                  nested: {
                    Annotation: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        sourceFile: {
                          type: "string",
                          id: 2
                        },
                        begin: {
                          type: "int32",
                          id: 3
                        },
                        end: {
                          type: "int32",
                          id: 4
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/ext/descriptor/index.js
var require_descriptor2 = __commonJS({
  "node_modules/protobufjs/ext/descriptor/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var $protobuf = require_protobufjs();
    module2.exports = exports2 = $protobuf.descriptor = $protobuf.Root.fromJSON(require_descriptor()).lookup(".google.protobuf");
    var Namespace = $protobuf.Namespace;
    var Root2 = $protobuf.Root;
    var Enum = $protobuf.Enum;
    var Type = $protobuf.Type;
    var Field = $protobuf.Field;
    var MapField = $protobuf.MapField;
    var OneOf = $protobuf.OneOf;
    var Service = $protobuf.Service;
    var Method = $protobuf.Method;
    Root2.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.FileDescriptorSet.decode(descriptor);
      var root = new Root2();
      if (descriptor.file) {
        var fileDescriptor, filePackage;
        for (var j = 0, i; j < descriptor.file.length; ++j) {
          filePackage = root;
          if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
            filePackage = root.define(fileDescriptor["package"]);
          if (fileDescriptor.name && fileDescriptor.name.length)
            root.files.push(filePackage.filename = fileDescriptor.name);
          if (fileDescriptor.messageType)
            for (i = 0; i < fileDescriptor.messageType.length; ++i)
              filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));
          if (fileDescriptor.enumType)
            for (i = 0; i < fileDescriptor.enumType.length; ++i)
              filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));
          if (fileDescriptor.extension)
            for (i = 0; i < fileDescriptor.extension.length; ++i)
              filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));
          if (fileDescriptor.service)
            for (i = 0; i < fileDescriptor.service.length; ++i)
              filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));
          var opts = fromDescriptorOptions(fileDescriptor.options, exports2.FileOptions);
          if (opts) {
            var ks = Object.keys(opts);
            for (i = 0; i < ks.length; ++i)
              filePackage.setOption(ks[i], opts[ks[i]]);
          }
        }
      }
      return root;
    };
    Root2.prototype.toDescriptor = function toDescriptor(syntax) {
      var set = exports2.FileDescriptorSet.create();
      Root_toDescriptorRecursive(this, set.file, syntax);
      return set;
    };
    function Root_toDescriptorRecursive(ns, files, syntax) {
      var file = exports2.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto" });
      if (syntax)
        file.syntax = syntax;
      if (!(ns instanceof Root2))
        file["package"] = ns.fullName.substring(1);
      for (var i = 0, nested; i < ns.nestedArray.length; ++i)
        if ((nested = ns._nestedArray[i]) instanceof Type)
          file.messageType.push(nested.toDescriptor(syntax));
        else if (nested instanceof Enum)
          file.enumType.push(nested.toDescriptor());
        else if (nested instanceof Field)
          file.extension.push(nested.toDescriptor(syntax));
        else if (nested instanceof Service)
          file.service.push(nested.toDescriptor());
        else if (nested instanceof Namespace)
          Root_toDescriptorRecursive(nested, files, syntax);
      file.options = toDescriptorOptions(ns.options, exports2.FileOptions);
      if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
        files.push(file);
    }
    var unnamedMessageIndex = 0;
    Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.DescriptorProto.decode(descriptor);
      var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports2.MessageOptions)), i;
      if (descriptor.oneofDecl)
        for (i = 0; i < descriptor.oneofDecl.length; ++i)
          type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
      if (descriptor.field)
        for (i = 0; i < descriptor.field.length; ++i) {
          var field = Field.fromDescriptor(descriptor.field[i], syntax);
          type.add(field);
          if (descriptor.field[i].hasOwnProperty("oneofIndex"))
            type.oneofsArray[descriptor.field[i].oneofIndex].add(field);
        }
      if (descriptor.extension)
        for (i = 0; i < descriptor.extension.length; ++i)
          type.add(Field.fromDescriptor(descriptor.extension[i], syntax));
      if (descriptor.nestedType)
        for (i = 0; i < descriptor.nestedType.length; ++i) {
          type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));
          if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)
            type.setOption("map_entry", true);
        }
      if (descriptor.enumType)
        for (i = 0; i < descriptor.enumType.length; ++i)
          type.add(Enum.fromDescriptor(descriptor.enumType[i]));
      if (descriptor.extensionRange && descriptor.extensionRange.length) {
        type.extensions = [];
        for (i = 0; i < descriptor.extensionRange.length; ++i)
          type.extensions.push([descriptor.extensionRange[i].start, descriptor.extensionRange[i].end]);
      }
      if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
        type.reserved = [];
        if (descriptor.reservedRange)
          for (i = 0; i < descriptor.reservedRange.length; ++i)
            type.reserved.push([descriptor.reservedRange[i].start, descriptor.reservedRange[i].end]);
        if (descriptor.reservedName)
          for (i = 0; i < descriptor.reservedName.length; ++i)
            type.reserved.push(descriptor.reservedName[i]);
      }
      return type;
    };
    Type.prototype.toDescriptor = function toDescriptor(syntax) {
      var descriptor = exports2.DescriptorProto.create({ name: this.name }), i;
      for (i = 0; i < this.fieldsArray.length; ++i) {
        var fieldDescriptor;
        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));
        if (this._fieldsArray[i] instanceof MapField) {
          var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType), valueTypeName = valueType === 11 || valueType === 14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : void 0;
          descriptor.nestedType.push(exports2.DescriptorProto.create({
            name: fieldDescriptor.typeName,
            field: [
              exports2.FieldDescriptorProto.create({ name: "key", number: 1, label: 1, type: keyType }),
              exports2.FieldDescriptorProto.create({ name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName })
            ],
            options: exports2.MessageOptions.create({ mapEntry: true })
          }));
        }
      }
      for (i = 0; i < this.oneofsArray.length; ++i)
        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
      for (i = 0; i < this.nestedArray.length; ++i) {
        if (this._nestedArray[i] instanceof Field)
          descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));
        else if (this._nestedArray[i] instanceof Type)
          descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));
        else if (this._nestedArray[i] instanceof Enum)
          descriptor.enumType.push(this._nestedArray[i].toDescriptor());
      }
      if (this.extensions)
        for (i = 0; i < this.extensions.length; ++i)
          descriptor.extensionRange.push(exports2.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));
      if (this.reserved)
        for (i = 0; i < this.reserved.length; ++i)
          if (typeof this.reserved[i] === "string")
            descriptor.reservedName.push(this.reserved[i]);
          else
            descriptor.reservedRange.push(exports2.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));
      descriptor.options = toDescriptorOptions(this.options, exports2.MessageOptions);
      return descriptor;
    };
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.DescriptorProto.decode(descriptor);
      if (typeof descriptor.number !== "number")
        throw Error("missing field id");
      var fieldType;
      if (descriptor.typeName && descriptor.typeName.length)
        fieldType = descriptor.typeName;
      else
        fieldType = fromDescriptorType(descriptor.type);
      var fieldRule;
      switch (descriptor.label) {
        case 1:
          fieldRule = void 0;
          break;
        case 2:
          fieldRule = "required";
          break;
        case 3:
          fieldRule = "repeated";
          break;
        default:
          throw Error("illegal label: " + descriptor.label);
      }
      var extendee = descriptor.extendee;
      if (descriptor.extendee !== void 0) {
        extendee = extendee.length ? extendee : void 0;
      }
      var field = new Field(descriptor.name.length ? descriptor.name : "field" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);
      field.options = fromDescriptorOptions(descriptor.options, exports2.FieldOptions);
      if (descriptor.defaultValue && descriptor.defaultValue.length) {
        var defaultValue = descriptor.defaultValue;
        switch (defaultValue) {
          case "true":
          case "TRUE":
            defaultValue = true;
            break;
          case "false":
          case "FALSE":
            defaultValue = false;
            break;
          default:
            var match = numberRe.exec(defaultValue);
            if (match)
              defaultValue = parseInt(defaultValue);
            break;
        }
        field.setOption("default", defaultValue);
      }
      if (packableDescriptorType(descriptor.type)) {
        if (syntax === "proto3") {
          if (descriptor.options && !descriptor.options.packed)
            field.setOption("packed", false);
        } else if (!(descriptor.options && descriptor.options.packed))
          field.setOption("packed", false);
      }
      return field;
    };
    Field.prototype.toDescriptor = function toDescriptor(syntax) {
      var descriptor = exports2.FieldDescriptorProto.create({ name: this.name, number: this.id });
      if (this.map) {
        descriptor.type = 11;
        descriptor.typeName = $protobuf.util.ucFirst(this.name);
        descriptor.label = 3;
      } else {
        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
          case 10:
          case 11:
          case 14:
            descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
            break;
        }
        switch (this.rule) {
          case "repeated":
            descriptor.label = 3;
            break;
          case "required":
            descriptor.label = 2;
            break;
          default:
            descriptor.label = 1;
            break;
        }
      }
      descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;
      if (this.partOf) {
        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
          throw Error("missing oneof");
      }
      if (this.options) {
        descriptor.options = toDescriptorOptions(this.options, exports2.FieldOptions);
        if (this.options["default"] != null)
          descriptor.defaultValue = String(this.options["default"]);
      }
      if (syntax === "proto3") {
        if (!this.packed)
          (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = false;
      } else if (this.packed)
        (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = true;
      return descriptor;
    };
    var unnamedEnumIndex = 0;
    Enum.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.EnumDescriptorProto.decode(descriptor);
      var values = {};
      if (descriptor.value)
        for (var i = 0; i < descriptor.value.length; ++i) {
          var name = descriptor.value[i].name, value = descriptor.value[i].number || 0;
          values[name && name.length ? name : "NAME" + value] = value;
        }
      return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports2.EnumOptions));
    };
    Enum.prototype.toDescriptor = function toDescriptor() {
      var values = [];
      for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)
        values.push(exports2.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));
      return exports2.EnumDescriptorProto.create({
        name: this.name,
        value: values,
        options: toDescriptorOptions(this.options, exports2.EnumOptions)
      });
    };
    var unnamedOneofIndex = 0;
    OneOf.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.OneofDescriptorProto.decode(descriptor);
      return new OneOf(descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++);
    };
    OneOf.prototype.toDescriptor = function toDescriptor() {
      return exports2.OneofDescriptorProto.create({
        name: this.name
      });
    };
    var unnamedServiceIndex = 0;
    Service.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.ServiceDescriptorProto.decode(descriptor);
      var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports2.ServiceOptions));
      if (descriptor.method)
        for (var i = 0; i < descriptor.method.length; ++i)
          service.add(Method.fromDescriptor(descriptor.method[i]));
      return service;
    };
    Service.prototype.toDescriptor = function toDescriptor() {
      var methods = [];
      for (var i = 0; i < this.methodsArray.length; ++i)
        methods.push(this._methodsArray[i].toDescriptor());
      return exports2.ServiceDescriptorProto.create({
        name: this.name,
        method: methods,
        options: toDescriptorOptions(this.options, exports2.ServiceOptions)
      });
    };
    var unnamedMethodIndex = 0;
    Method.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.MethodDescriptorProto.decode(descriptor);
      return new Method(descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++, "rpc", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports2.MethodOptions));
    };
    Method.prototype.toDescriptor = function toDescriptor() {
      return exports2.MethodDescriptorProto.create({
        name: this.name,
        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
        clientStreaming: this.requestStream,
        serverStreaming: this.responseStream,
        options: toDescriptorOptions(this.options, exports2.MethodOptions)
      });
    };
    function fromDescriptorType(type) {
      switch (type) {
        case 1:
          return "double";
        case 2:
          return "float";
        case 3:
          return "int64";
        case 4:
          return "uint64";
        case 5:
          return "int32";
        case 6:
          return "fixed64";
        case 7:
          return "fixed32";
        case 8:
          return "bool";
        case 9:
          return "string";
        case 12:
          return "bytes";
        case 13:
          return "uint32";
        case 15:
          return "sfixed32";
        case 16:
          return "sfixed64";
        case 17:
          return "sint32";
        case 18:
          return "sint64";
      }
      throw Error("illegal type: " + type);
    }
    function packableDescriptorType(type) {
      switch (type) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
          return true;
      }
      return false;
    }
    function toDescriptorType(type, resolvedType) {
      switch (type) {
        case "double":
          return 1;
        case "float":
          return 2;
        case "int64":
          return 3;
        case "uint64":
          return 4;
        case "int32":
          return 5;
        case "fixed64":
          return 6;
        case "fixed32":
          return 7;
        case "bool":
          return 8;
        case "string":
          return 9;
        case "bytes":
          return 12;
        case "uint32":
          return 13;
        case "sfixed32":
          return 15;
        case "sfixed64":
          return 16;
        case "sint32":
          return 17;
        case "sint64":
          return 18;
      }
      if (resolvedType instanceof Enum)
        return 14;
      if (resolvedType instanceof Type)
        return resolvedType.group ? 10 : 11;
      throw Error("illegal type: " + type);
    }
    function fromDescriptorOptions(options2, type) {
      if (!options2)
        return void 0;
      var out = [];
      for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)
        if ((key = (field = type._fieldsArray[i]).name) !== "uninterpretedOption") {
          if (options2.hasOwnProperty(key)) {
            val = options2[key];
            if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== void 0)
              val = field.resolvedType.valuesById[val];
            out.push(underScore(key), val);
          }
        }
      return out.length ? $protobuf.util.toObject(out) : void 0;
    }
    function toDescriptorOptions(options2, type) {
      if (!options2)
        return void 0;
      var out = [];
      for (var i = 0, ks = Object.keys(options2), key, val; i < ks.length; ++i) {
        val = options2[key = ks[i]];
        if (key === "default")
          continue;
        var field = type.fields[key];
        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))
          continue;
        out.push(key, val);
      }
      return out.length ? type.fromObject($protobuf.util.toObject(out)) : void 0;
    }
    function shortname(from, to) {
      var fromPath = from.fullName.split("."), toPath = to.fullName.split("."), i = 0, j = 0, k = toPath.length - 1;
      if (!(from instanceof Root2) && to instanceof Namespace)
        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
          var other = to.lookup(fromPath[i++], true);
          if (other !== null && other !== to)
            break;
          ++j;
        }
      else
        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j)
          ;
      return toPath.slice(j).join(".");
    }
    function underScore(str) {
      return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {
        return "_" + $1.toLowerCase();
      });
    }
  }
});

// node_modules/protobufjs/google/protobuf/api.json
var require_api2 = __commonJS({
  "node_modules/protobufjs/google/protobuf/api.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Api: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    methods: {
                      rule: "repeated",
                      type: "Method",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    version: {
                      type: "string",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    mixins: {
                      rule: "repeated",
                      type: "Mixin",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Method: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    requestTypeUrl: {
                      type: "string",
                      id: 2
                    },
                    requestStreaming: {
                      type: "bool",
                      id: 3
                    },
                    responseTypeUrl: {
                      type: "string",
                      id: 4
                    },
                    responseStreaming: {
                      type: "bool",
                      id: 5
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Mixin: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    root: {
                      type: "string",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/source_context.json
var require_source_context = __commonJS({
  "node_modules/protobufjs/google/protobuf/source_context.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/type.json
var require_type2 = __commonJS({
  "node_modules/protobufjs/google/protobuf/type.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Type: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    fields: {
                      rule: "repeated",
                      type: "Field",
                      id: 2
                    },
                    oneofs: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    syntax: {
                      type: "Syntax",
                      id: 6
                    }
                  }
                },
                Field: {
                  fields: {
                    kind: {
                      type: "Kind",
                      id: 1
                    },
                    cardinality: {
                      type: "Cardinality",
                      id: 2
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    name: {
                      type: "string",
                      id: 4
                    },
                    typeUrl: {
                      type: "string",
                      id: 6
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 7
                    },
                    packed: {
                      type: "bool",
                      id: 8
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    defaultValue: {
                      type: "string",
                      id: 11
                    }
                  },
                  nested: {
                    Kind: {
                      values: {
                        TYPE_UNKNOWN: 0,
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Cardinality: {
                      values: {
                        CARDINALITY_UNKNOWN: 0,
                        CARDINALITY_OPTIONAL: 1,
                        CARDINALITY_REQUIRED: 2,
                        CARDINALITY_REPEATED: 3
                      }
                    }
                  }
                },
                Enum: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    enumvalue: {
                      rule: "repeated",
                      type: "EnumValue",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 4
                    },
                    syntax: {
                      type: "Syntax",
                      id: 5
                    }
                  }
                },
                EnumValue: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                },
                Any: {
                  fields: {
                    type_url: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "bytes",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/@grpc/proto-loader/build/src/util.js
var require_util2 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/util.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs = require("fs");
    var path = require("path");
    var Protobuf = require_protobufjs();
    function addIncludePathResolver(root, includePaths) {
      const originalResolvePath = root.resolvePath;
      root.resolvePath = (origin, target) => {
        if (path.isAbsolute(target)) {
          return target;
        }
        for (const directory of includePaths) {
          const fullPath = path.join(directory, target);
          try {
            fs.accessSync(fullPath, fs.constants.R_OK);
            return fullPath;
          } catch (err) {
            continue;
          }
        }
        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
        return originalResolvePath(origin, target);
      };
    }
    async function loadProtosWithOptions(filename, options2) {
      const root = new Protobuf.Root();
      options2 = options2 || {};
      if (!!options2.includeDirs) {
        if (!Array.isArray(options2.includeDirs)) {
          return Promise.reject(new Error("The includeDirs option must be an array"));
        }
        addIncludePathResolver(root, options2.includeDirs);
      }
      const loadedRoot = await root.load(filename, options2);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports2.loadProtosWithOptions = loadProtosWithOptions;
    function loadProtosWithOptionsSync(filename, options2) {
      const root = new Protobuf.Root();
      options2 = options2 || {};
      if (!!options2.includeDirs) {
        if (!Array.isArray(options2.includeDirs)) {
          throw new Error("The includeDirs option must be an array");
        }
        addIncludePathResolver(root, options2.includeDirs);
      }
      const loadedRoot = root.loadSync(filename, options2);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports2.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
    function addCommonProtos() {
      const apiDescriptor = require_api2();
      const descriptorDescriptor = require_descriptor();
      const sourceContextDescriptor = require_source_context();
      const typeDescriptor = require_type2();
      Protobuf.common("api", apiDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("descriptor", descriptorDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("source_context", sourceContextDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("type", typeDescriptor.nested.google.nested.protobuf.nested);
    }
    exports2.addCommonProtos = addCommonProtos;
  }
});

// node_modules/@grpc/proto-loader/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/index.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var camelCase = require_lodash();
    var Protobuf = require_protobufjs();
    var descriptor = require_descriptor2();
    var util_1 = require_util2();
    function isAnyExtension(obj) {
      return "@type" in obj && typeof obj["@type"] === "string";
    }
    exports2.isAnyExtension = isAnyExtension;
    var descriptorOptions = {
      longs: String,
      enums: String,
      bytes: String,
      defaults: true,
      oneofs: true,
      json: true
    };
    function joinName(baseName, name) {
      if (baseName === "") {
        return name;
      } else {
        return baseName + "." + name;
      }
    }
    function isHandledReflectionObject(obj) {
      return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;
    }
    function isNamespaceBase(obj) {
      return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
    }
    function getAllHandledReflectionObjects(obj, parentName) {
      const objName = joinName(parentName, obj.name);
      if (isHandledReflectionObject(obj)) {
        return [[objName, obj]];
      } else {
        if (isNamespaceBase(obj) && typeof obj.nested !== "undefined") {
          return Object.keys(obj.nested).map((name) => {
            return getAllHandledReflectionObjects(obj.nested[name], objName);
          }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
        }
      }
      return [];
    }
    function createDeserializer(cls, options2) {
      return function deserialize(argBuf) {
        return cls.toObject(cls.decode(argBuf), options2);
      };
    }
    function createSerializer(cls) {
      return function serialize(arg) {
        const message = cls.fromObject(arg);
        return cls.encode(message).finish();
      };
    }
    function createMethodDefinition(method, serviceName, options2, fileDescriptors) {
      const requestType = method.resolvedRequestType;
      const responseType = method.resolvedResponseType;
      return {
        path: "/" + serviceName + "/" + method.name,
        requestStream: !!method.requestStream,
        responseStream: !!method.responseStream,
        requestSerialize: createSerializer(requestType),
        requestDeserialize: createDeserializer(requestType, options2),
        responseSerialize: createSerializer(responseType),
        responseDeserialize: createDeserializer(responseType, options2),
        originalName: camelCase(method.name),
        requestType: createMessageDefinition(requestType, fileDescriptors),
        responseType: createMessageDefinition(responseType, fileDescriptors)
      };
    }
    function createServiceDefinition(service, name, options2, fileDescriptors) {
      const def = {};
      for (const method of service.methodsArray) {
        def[method.name] = createMethodDefinition(method, name, options2, fileDescriptors);
      }
      return def;
    }
    function createMessageDefinition(message, fileDescriptors) {
      const messageDescriptor = message.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 DescriptorProto",
        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createEnumDefinition(enumType, fileDescriptors) {
      const enumDescriptor = enumType.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 EnumDescriptorProto",
        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createDefinition(obj, name, options2, fileDescriptors) {
      if (obj instanceof Protobuf.Service) {
        return createServiceDefinition(obj, name, options2, fileDescriptors);
      } else if (obj instanceof Protobuf.Type) {
        return createMessageDefinition(obj, fileDescriptors);
      } else if (obj instanceof Protobuf.Enum) {
        return createEnumDefinition(obj, fileDescriptors);
      } else {
        throw new Error("Type mismatch in reflection object handling");
      }
    }
    function createPackageDefinition(root, options2) {
      const def = {};
      root.resolveAll();
      const descriptorList = root.toDescriptor("proto3").file;
      const bufferList = descriptorList.map((value) => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
      for (const [name, obj] of getAllHandledReflectionObjects(root, "")) {
        def[name] = createDefinition(obj, name, options2, bufferList);
      }
      return def;
    }
    function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options2) {
      options2 = options2 || {};
      const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
      root.resolveAll();
      return createPackageDefinition(root, options2);
    }
    function load2(filename, options2) {
      return util_1.loadProtosWithOptions(filename, options2).then((loadedRoot) => {
        return createPackageDefinition(loadedRoot, options2);
      });
    }
    exports2.load = load2;
    function loadSync(filename, options2) {
      const loadedRoot = util_1.loadProtosWithOptionsSync(filename, options2);
      return createPackageDefinition(loadedRoot, options2);
    }
    exports2.loadSync = loadSync;
    function fromJSON(json, options2) {
      options2 = options2 || {};
      const loadedRoot = Protobuf.Root.fromJSON(json);
      loadedRoot.resolveAll();
      return createPackageDefinition(loadedRoot, options2);
    }
    exports2.fromJSON = fromJSON;
    function loadFileDescriptorSetFromBuffer(descriptorSet, options2) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options2);
    }
    exports2.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
    function loadFileDescriptorSetFromObject(descriptorSet, options2) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options2);
    }
    exports2.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
    util_1.addCommonProtos();
  }
});

// node_modules/@firebase/firestore/dist/node-cjs/database-c96156d6-f0f0e10d.js
var require_database_c96156d6_f0f0e10d = __commonJS({
  "node_modules/@firebase/firestore/dist/node-cjs/database-c96156d6-f0f0e10d.js"(exports2) {
    init_shims();
    "use strict";
    var tslib = require_tslib();
    var util = require_index_node_cjs();
    var logger = require_index_cjs2();
    var util$1 = require("util");
    var crypto = require("crypto");
    var grpcJs = require_src();
    var package_json = require_package();
    var path = require("path");
    var protoLoader = require_src3();
    var version = "8.8.1";
    var SDK_VERSION = version;
    var ListenSequence = function() {
      function ListenSequence2(previousValue, sequenceNumberSyncer) {
        var _this = this;
        this.previousValue = previousValue;
        if (sequenceNumberSyncer) {
          sequenceNumberSyncer.sequenceNumberHandler = function(sequenceNumber) {
            return _this.setPreviousValue(sequenceNumber);
          };
          this.writeNewSequenceNumber = function(sequenceNumber) {
            return sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);
          };
        }
      }
      ListenSequence2.prototype.setPreviousValue = function(externalPreviousValue) {
        this.previousValue = Math.max(externalPreviousValue, this.previousValue);
        return this.previousValue;
      };
      ListenSequence2.prototype.next = function() {
        var nextValue = ++this.previousValue;
        if (this.writeNewSequenceNumber) {
          this.writeNewSequenceNumber(nextValue);
        }
        return nextValue;
      };
      return ListenSequence2;
    }();
    ListenSequence.INVALID = -1;
    function formatJSON(value) {
      return util$1.inspect(value, { depth: 100 });
    }
    var logClient = new logger.Logger("@firebase/firestore");
    function getLogLevel() {
      return logClient.logLevel;
    }
    function setLogLevel$1(logLevel) {
      logClient.setLogLevel(logLevel);
    }
    function logDebug(msg) {
      var obj = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        obj[_i - 1] = arguments[_i];
      }
      if (logClient.logLevel <= logger.LogLevel.DEBUG) {
        var args = obj.map(argToString);
        logClient.debug.apply(logClient, tslib.__spreadArray(["Firestore (" + SDK_VERSION + "): " + msg], args));
      }
    }
    function logError(msg) {
      var obj = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        obj[_i - 1] = arguments[_i];
      }
      if (logClient.logLevel <= logger.LogLevel.ERROR) {
        var args = obj.map(argToString);
        logClient.error.apply(logClient, tslib.__spreadArray(["Firestore (" + SDK_VERSION + "): " + msg], args));
      }
    }
    function logWarn(msg) {
      var obj = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        obj[_i - 1] = arguments[_i];
      }
      if (logClient.logLevel <= logger.LogLevel.WARN) {
        var args = obj.map(argToString);
        logClient.warn.apply(logClient, tslib.__spreadArray(["Firestore (" + SDK_VERSION + "): " + msg], args));
      }
    }
    function argToString(obj) {
      if (typeof obj === "string") {
        return obj;
      } else {
        try {
          return formatJSON(obj);
        } catch (e) {
          return obj;
        }
      }
    }
    function fail(failure) {
      if (failure === void 0) {
        failure = "Unexpected state";
      }
      var message = "FIRESTORE (" + SDK_VERSION + ") INTERNAL ASSERTION FAILED: " + failure;
      logError(message);
      throw new Error(message);
    }
    function hardAssert(assertion, message) {
      if (!assertion) {
        fail();
      }
    }
    function debugCast(obj, constructor) {
      return obj;
    }
    var Code = {
      OK: "ok",
      CANCELLED: "cancelled",
      UNKNOWN: "unknown",
      INVALID_ARGUMENT: "invalid-argument",
      DEADLINE_EXCEEDED: "deadline-exceeded",
      NOT_FOUND: "not-found",
      ALREADY_EXISTS: "already-exists",
      PERMISSION_DENIED: "permission-denied",
      UNAUTHENTICATED: "unauthenticated",
      RESOURCE_EXHAUSTED: "resource-exhausted",
      FAILED_PRECONDITION: "failed-precondition",
      ABORTED: "aborted",
      OUT_OF_RANGE: "out-of-range",
      UNIMPLEMENTED: "unimplemented",
      INTERNAL: "internal",
      UNAVAILABLE: "unavailable",
      DATA_LOSS: "data-loss"
    };
    var FirestoreError = function(_super) {
      tslib.__extends(FirestoreError2, _super);
      function FirestoreError2(code, message) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.message = message;
        _this.name = "FirebaseError";
        _this.toString = function() {
          return _this.name + ": [code=" + _this.code + "]: " + _this.message;
        };
        return _this;
      }
      return FirestoreError2;
    }(Error);
    var DOCUMENT_KEY_NAME = "__name__";
    var BasePath = function() {
      function BasePath2(segments, offset, length) {
        if (offset === void 0) {
          offset = 0;
        } else if (offset > segments.length) {
          fail();
        }
        if (length === void 0) {
          length = segments.length - offset;
        } else if (length > segments.length - offset) {
          fail();
        }
        this.segments = segments;
        this.offset = offset;
        this.len = length;
      }
      Object.defineProperty(BasePath2.prototype, "length", {
        get: function() {
          return this.len;
        },
        enumerable: false,
        configurable: true
      });
      BasePath2.prototype.isEqual = function(other) {
        return BasePath2.comparator(this, other) === 0;
      };
      BasePath2.prototype.child = function(nameOrPath) {
        var segments = this.segments.slice(this.offset, this.limit());
        if (nameOrPath instanceof BasePath2) {
          nameOrPath.forEach(function(segment) {
            segments.push(segment);
          });
        } else {
          segments.push(nameOrPath);
        }
        return this.construct(segments);
      };
      BasePath2.prototype.limit = function() {
        return this.offset + this.length;
      };
      BasePath2.prototype.popFirst = function(size) {
        size = size === void 0 ? 1 : size;
        return this.construct(this.segments, this.offset + size, this.length - size);
      };
      BasePath2.prototype.popLast = function() {
        return this.construct(this.segments, this.offset, this.length - 1);
      };
      BasePath2.prototype.firstSegment = function() {
        return this.segments[this.offset];
      };
      BasePath2.prototype.lastSegment = function() {
        return this.get(this.length - 1);
      };
      BasePath2.prototype.get = function(index2) {
        return this.segments[this.offset + index2];
      };
      BasePath2.prototype.isEmpty = function() {
        return this.length === 0;
      };
      BasePath2.prototype.isPrefixOf = function(other) {
        if (other.length < this.length) {
          return false;
        }
        for (var i = 0; i < this.length; i++) {
          if (this.get(i) !== other.get(i)) {
            return false;
          }
        }
        return true;
      };
      BasePath2.prototype.isImmediateParentOf = function(potentialChild) {
        if (this.length + 1 !== potentialChild.length) {
          return false;
        }
        for (var i = 0; i < this.length; i++) {
          if (this.get(i) !== potentialChild.get(i)) {
            return false;
          }
        }
        return true;
      };
      BasePath2.prototype.forEach = function(fn) {
        for (var i = this.offset, end = this.limit(); i < end; i++) {
          fn(this.segments[i]);
        }
      };
      BasePath2.prototype.toArray = function() {
        return this.segments.slice(this.offset, this.limit());
      };
      BasePath2.comparator = function(p1, p2) {
        var len = Math.min(p1.length, p2.length);
        for (var i = 0; i < len; i++) {
          var left = p1.get(i);
          var right = p2.get(i);
          if (left < right) {
            return -1;
          }
          if (left > right) {
            return 1;
          }
        }
        if (p1.length < p2.length) {
          return -1;
        }
        if (p1.length > p2.length) {
          return 1;
        }
        return 0;
      };
      return BasePath2;
    }();
    var ResourcePath = function(_super) {
      tslib.__extends(ResourcePath2, _super);
      function ResourcePath2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ResourcePath2.prototype.construct = function(segments, offset, length) {
        return new ResourcePath2(segments, offset, length);
      };
      ResourcePath2.prototype.canonicalString = function() {
        return this.toArray().join("/");
      };
      ResourcePath2.prototype.toString = function() {
        return this.canonicalString();
      };
      ResourcePath2.fromString = function() {
        var pathComponents = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          pathComponents[_i] = arguments[_i];
        }
        var segments = [];
        for (var _d = 0, pathComponents_1 = pathComponents; _d < pathComponents_1.length; _d++) {
          var path2 = pathComponents_1[_d];
          if (path2.indexOf("//") >= 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid segment (" + path2 + "). Paths must not contain // in them.");
          }
          segments.push.apply(segments, path2.split("/").filter(function(segment) {
            return segment.length > 0;
          }));
        }
        return new ResourcePath2(segments);
      };
      ResourcePath2.emptyPath = function() {
        return new ResourcePath2([]);
      };
      return ResourcePath2;
    }(BasePath);
    var identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
    var FieldPath$1 = function(_super) {
      tslib.__extends(FieldPath$12, _super);
      function FieldPath$12() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FieldPath$12.prototype.construct = function(segments, offset, length) {
        return new FieldPath$12(segments, offset, length);
      };
      FieldPath$12.isValidIdentifier = function(segment) {
        return identifierRegExp.test(segment);
      };
      FieldPath$12.prototype.canonicalString = function() {
        return this.toArray().map(function(str) {
          str = str.replace(/\\/g, "\\\\").replace(/`/g, "\\`");
          if (!FieldPath$12.isValidIdentifier(str)) {
            str = "`" + str + "`";
          }
          return str;
        }).join(".");
      };
      FieldPath$12.prototype.toString = function() {
        return this.canonicalString();
      };
      FieldPath$12.prototype.isKeyField = function() {
        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;
      };
      FieldPath$12.keyField = function() {
        return new FieldPath$12([DOCUMENT_KEY_NAME]);
      };
      FieldPath$12.fromServerFormat = function(path2) {
        var segments = [];
        var current = "";
        var i = 0;
        var addCurrentSegment = function() {
          if (current.length === 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path2 + "). Paths must not be empty, begin with '.', end with '.', or contain '..'");
          }
          segments.push(current);
          current = "";
        };
        var inBackticks = false;
        while (i < path2.length) {
          var c = path2[i];
          if (c === "\\") {
            if (i + 1 === path2.length) {
              throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has trailing escape character: " + path2);
            }
            var next = path2[i + 1];
            if (!(next === "\\" || next === "." || next === "`")) {
              throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has invalid escape sequence: " + path2);
            }
            current += next;
            i += 2;
          } else if (c === "`") {
            inBackticks = !inBackticks;
            i++;
          } else if (c === "." && !inBackticks) {
            addCurrentSegment();
            i++;
          } else {
            current += c;
            i++;
          }
        }
        addCurrentSegment();
        if (inBackticks) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Unterminated ` in path: " + path2);
        }
        return new FieldPath$12(segments);
      };
      FieldPath$12.emptyPath = function() {
        return new FieldPath$12([]);
      };
      return FieldPath$12;
    }(BasePath);
    var escapeChar = "";
    var encodedSeparatorChar = "";
    var encodedNul = "";
    var encodedEscape = "";
    function encodeResourcePath(path2) {
      var result = "";
      for (var i = 0; i < path2.length; i++) {
        if (result.length > 0) {
          result = encodeSeparator(result);
        }
        result = encodeSegment(path2.get(i), result);
      }
      return encodeSeparator(result);
    }
    function encodeSegment(segment, resultBuf) {
      var result = resultBuf;
      var length = segment.length;
      for (var i = 0; i < length; i++) {
        var c = segment.charAt(i);
        switch (c) {
          case "\0":
            result += escapeChar + encodedNul;
            break;
          case escapeChar:
            result += escapeChar + encodedEscape;
            break;
          default:
            result += c;
        }
      }
      return result;
    }
    function encodeSeparator(result) {
      return result + escapeChar + encodedSeparatorChar;
    }
    function decodeResourcePath(path2) {
      var length = path2.length;
      hardAssert(length >= 2);
      if (length === 2) {
        hardAssert(path2.charAt(0) === escapeChar && path2.charAt(1) === encodedSeparatorChar);
        return ResourcePath.emptyPath();
      }
      var lastReasonableEscapeIndex = length - 2;
      var segments = [];
      var segmentBuilder = "";
      for (var start = 0; start < length; ) {
        var end = path2.indexOf(escapeChar, start);
        if (end < 0 || end > lastReasonableEscapeIndex) {
          fail();
        }
        var next = path2.charAt(end + 1);
        switch (next) {
          case encodedSeparatorChar:
            var currentPiece = path2.substring(start, end);
            var segment = void 0;
            if (segmentBuilder.length === 0) {
              segment = currentPiece;
            } else {
              segmentBuilder += currentPiece;
              segment = segmentBuilder;
              segmentBuilder = "";
            }
            segments.push(segment);
            break;
          case encodedNul:
            segmentBuilder += path2.substring(start, end);
            segmentBuilder += "\0";
            break;
          case encodedEscape:
            segmentBuilder += path2.substring(start, end + 1);
            break;
          default:
            fail();
        }
        start = end + 2;
      }
      return new ResourcePath(segments);
    }
    var SCHEMA_VERSION = 11;
    var DbTimestamp = function() {
      function DbTimestamp2(seconds, nanoseconds) {
        this.seconds = seconds;
        this.nanoseconds = nanoseconds;
      }
      return DbTimestamp2;
    }();
    var DbPrimaryClient = function() {
      function DbPrimaryClient2(ownerId, allowTabSynchronization, leaseTimestampMs) {
        this.ownerId = ownerId;
        this.allowTabSynchronization = allowTabSynchronization;
        this.leaseTimestampMs = leaseTimestampMs;
      }
      return DbPrimaryClient2;
    }();
    DbPrimaryClient.store = "owner";
    DbPrimaryClient.key = "owner";
    var DbMutationQueue = function() {
      function DbMutationQueue2(userId, lastAcknowledgedBatchId, lastStreamToken) {
        this.userId = userId;
        this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;
        this.lastStreamToken = lastStreamToken;
      }
      return DbMutationQueue2;
    }();
    DbMutationQueue.store = "mutationQueues";
    DbMutationQueue.keyPath = "userId";
    var DbMutationBatch = function() {
      function DbMutationBatch2(userId, batchId, localWriteTimeMs, baseMutations, mutations) {
        this.userId = userId;
        this.batchId = batchId;
        this.localWriteTimeMs = localWriteTimeMs;
        this.baseMutations = baseMutations;
        this.mutations = mutations;
      }
      return DbMutationBatch2;
    }();
    DbMutationBatch.store = "mutations";
    DbMutationBatch.keyPath = "batchId";
    DbMutationBatch.userMutationsIndex = "userMutationsIndex";
    DbMutationBatch.userMutationsKeyPath = ["userId", "batchId"];
    var DbDocumentMutation = function() {
      function DbDocumentMutation2() {
      }
      DbDocumentMutation2.prefixForUser = function(userId) {
        return [userId];
      };
      DbDocumentMutation2.prefixForPath = function(userId, path2) {
        return [userId, encodeResourcePath(path2)];
      };
      DbDocumentMutation2.key = function(userId, path2, batchId) {
        return [userId, encodeResourcePath(path2), batchId];
      };
      return DbDocumentMutation2;
    }();
    DbDocumentMutation.store = "documentMutations";
    DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();
    var DbNoDocument = function() {
      function DbNoDocument2(path2, readTime) {
        this.path = path2;
        this.readTime = readTime;
      }
      return DbNoDocument2;
    }();
    var DbUnknownDocument = function() {
      function DbUnknownDocument2(path2, version2) {
        this.path = path2;
        this.version = version2;
      }
      return DbUnknownDocument2;
    }();
    var DbRemoteDocument = function() {
      function DbRemoteDocument2(unknownDocument, noDocument, document2, hasCommittedMutations, readTime, parentPath) {
        this.unknownDocument = unknownDocument;
        this.noDocument = noDocument;
        this.document = document2;
        this.hasCommittedMutations = hasCommittedMutations;
        this.readTime = readTime;
        this.parentPath = parentPath;
      }
      return DbRemoteDocument2;
    }();
    DbRemoteDocument.store = "remoteDocuments";
    DbRemoteDocument.readTimeIndex = "readTimeIndex";
    DbRemoteDocument.readTimeIndexPath = "readTime";
    DbRemoteDocument.collectionReadTimeIndex = "collectionReadTimeIndex";
    DbRemoteDocument.collectionReadTimeIndexPath = ["parentPath", "readTime"];
    var DbRemoteDocumentGlobal = function() {
      function DbRemoteDocumentGlobal2(byteSize) {
        this.byteSize = byteSize;
      }
      return DbRemoteDocumentGlobal2;
    }();
    DbRemoteDocumentGlobal.store = "remoteDocumentGlobal";
    DbRemoteDocumentGlobal.key = "remoteDocumentGlobalKey";
    var DbTarget = function() {
      function DbTarget2(targetId, canonicalId2, readTime, resumeToken, lastListenSequenceNumber, lastLimboFreeSnapshotVersion, query2) {
        this.targetId = targetId;
        this.canonicalId = canonicalId2;
        this.readTime = readTime;
        this.resumeToken = resumeToken;
        this.lastListenSequenceNumber = lastListenSequenceNumber;
        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;
        this.query = query2;
      }
      return DbTarget2;
    }();
    DbTarget.store = "targets";
    DbTarget.keyPath = "targetId";
    DbTarget.queryTargetsIndexName = "queryTargetsIndex";
    DbTarget.queryTargetsKeyPath = ["canonicalId", "targetId"];
    var DbTargetDocument = function() {
      function DbTargetDocument2(targetId, path2, sequenceNumber) {
        this.targetId = targetId;
        this.path = path2;
        this.sequenceNumber = sequenceNumber;
      }
      return DbTargetDocument2;
    }();
    DbTargetDocument.store = "targetDocuments";
    DbTargetDocument.keyPath = ["targetId", "path"];
    DbTargetDocument.documentTargetsIndex = "documentTargetsIndex";
    DbTargetDocument.documentTargetsKeyPath = ["path", "targetId"];
    var DbTargetGlobal = function() {
      function DbTargetGlobal2(highestTargetId, highestListenSequenceNumber, lastRemoteSnapshotVersion, targetCount) {
        this.highestTargetId = highestTargetId;
        this.highestListenSequenceNumber = highestListenSequenceNumber;
        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
        this.targetCount = targetCount;
      }
      return DbTargetGlobal2;
    }();
    DbTargetGlobal.key = "targetGlobalKey";
    DbTargetGlobal.store = "targetGlobal";
    var DbCollectionParent = function() {
      function DbCollectionParent2(collectionId, parent) {
        this.collectionId = collectionId;
        this.parent = parent;
      }
      return DbCollectionParent2;
    }();
    DbCollectionParent.store = "collectionParents";
    DbCollectionParent.keyPath = ["collectionId", "parent"];
    var DbClientMetadata = function() {
      function DbClientMetadata2(clientId, updateTimeMs, networkEnabled, inForeground) {
        this.clientId = clientId;
        this.updateTimeMs = updateTimeMs;
        this.networkEnabled = networkEnabled;
        this.inForeground = inForeground;
      }
      return DbClientMetadata2;
    }();
    DbClientMetadata.store = "clientMetadata";
    DbClientMetadata.keyPath = "clientId";
    var DbBundle = function() {
      function DbBundle2(bundleId, createTime, version2) {
        this.bundleId = bundleId;
        this.createTime = createTime;
        this.version = version2;
      }
      return DbBundle2;
    }();
    DbBundle.store = "bundles";
    DbBundle.keyPath = "bundleId";
    var DbNamedQuery = function() {
      function DbNamedQuery2(name, readTime, bundledQuery) {
        this.name = name;
        this.readTime = readTime;
        this.bundledQuery = bundledQuery;
      }
      return DbNamedQuery2;
    }();
    DbNamedQuery.store = "namedQueries";
    DbNamedQuery.keyPath = "name";
    var V1_STORES = [
      DbMutationQueue.store,
      DbMutationBatch.store,
      DbDocumentMutation.store,
      DbRemoteDocument.store,
      DbTarget.store,
      DbPrimaryClient.store,
      DbTargetGlobal.store,
      DbTargetDocument.store
    ];
    var V3_STORES = V1_STORES;
    var V4_STORES = tslib.__spreadArray(tslib.__spreadArray([], V3_STORES), [DbClientMetadata.store]);
    var V6_STORES = tslib.__spreadArray(tslib.__spreadArray([], V4_STORES), [DbRemoteDocumentGlobal.store]);
    var V8_STORES = tslib.__spreadArray(tslib.__spreadArray([], V6_STORES), [DbCollectionParent.store]);
    var V11_STORES = tslib.__spreadArray(tslib.__spreadArray([], V8_STORES), [DbBundle.store, DbNamedQuery.store]);
    var ALL_STORES = V11_STORES;
    var PRIMARY_LEASE_LOST_ERROR_MSG = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
    var PersistenceTransaction = function() {
      function PersistenceTransaction2() {
        this.onCommittedListeners = [];
      }
      PersistenceTransaction2.prototype.addOnCommittedListener = function(listener) {
        this.onCommittedListeners.push(listener);
      };
      PersistenceTransaction2.prototype.raiseOnCommittedEvent = function() {
        this.onCommittedListeners.forEach(function(listener) {
          return listener();
        });
      };
      return PersistenceTransaction2;
    }();
    var Deferred = function() {
      function Deferred2() {
        var _this = this;
        this.promise = new Promise(function(resolve2, reject) {
          _this.resolve = resolve2;
          _this.reject = reject;
        });
      }
      return Deferred2;
    }();
    var PersistencePromise = function() {
      function PersistencePromise2(callback) {
        var _this = this;
        this.nextCallback = null;
        this.catchCallback = null;
        this.result = void 0;
        this.error = void 0;
        this.isDone = false;
        this.callbackAttached = false;
        callback(function(value) {
          _this.isDone = true;
          _this.result = value;
          if (_this.nextCallback) {
            _this.nextCallback(value);
          }
        }, function(error3) {
          _this.isDone = true;
          _this.error = error3;
          if (_this.catchCallback) {
            _this.catchCallback(error3);
          }
        });
      }
      PersistencePromise2.prototype.catch = function(fn) {
        return this.next(void 0, fn);
      };
      PersistencePromise2.prototype.next = function(nextFn, catchFn) {
        var _this = this;
        if (this.callbackAttached) {
          fail();
        }
        this.callbackAttached = true;
        if (this.isDone) {
          if (!this.error) {
            return this.wrapSuccess(nextFn, this.result);
          } else {
            return this.wrapFailure(catchFn, this.error);
          }
        } else {
          return new PersistencePromise2(function(resolve2, reject) {
            _this.nextCallback = function(value) {
              _this.wrapSuccess(nextFn, value).next(resolve2, reject);
            };
            _this.catchCallback = function(error3) {
              _this.wrapFailure(catchFn, error3).next(resolve2, reject);
            };
          });
        }
      };
      PersistencePromise2.prototype.toPromise = function() {
        var _this = this;
        return new Promise(function(resolve2, reject) {
          _this.next(resolve2, reject);
        });
      };
      PersistencePromise2.prototype.wrapUserFunction = function(fn) {
        try {
          var result = fn();
          if (result instanceof PersistencePromise2) {
            return result;
          } else {
            return PersistencePromise2.resolve(result);
          }
        } catch (e) {
          return PersistencePromise2.reject(e);
        }
      };
      PersistencePromise2.prototype.wrapSuccess = function(nextFn, value) {
        if (nextFn) {
          return this.wrapUserFunction(function() {
            return nextFn(value);
          });
        } else {
          return PersistencePromise2.resolve(value);
        }
      };
      PersistencePromise2.prototype.wrapFailure = function(catchFn, error3) {
        if (catchFn) {
          return this.wrapUserFunction(function() {
            return catchFn(error3);
          });
        } else {
          return PersistencePromise2.reject(error3);
        }
      };
      PersistencePromise2.resolve = function(result) {
        return new PersistencePromise2(function(resolve2, reject) {
          resolve2(result);
        });
      };
      PersistencePromise2.reject = function(error3) {
        return new PersistencePromise2(function(resolve2, reject) {
          reject(error3);
        });
      };
      PersistencePromise2.waitFor = function(all) {
        return new PersistencePromise2(function(resolve2, reject) {
          var expectedCount = 0;
          var resolvedCount = 0;
          var done = false;
          all.forEach(function(element) {
            ++expectedCount;
            element.next(function() {
              ++resolvedCount;
              if (done && resolvedCount === expectedCount) {
                resolve2();
              }
            }, function(err) {
              return reject(err);
            });
          });
          done = true;
          if (resolvedCount === expectedCount) {
            resolve2();
          }
        });
      };
      PersistencePromise2.or = function(predicates) {
        var p = PersistencePromise2.resolve(false);
        var _loop_1 = function(predicate2) {
          p = p.next(function(isTrue) {
            if (isTrue) {
              return PersistencePromise2.resolve(isTrue);
            } else {
              return predicate2();
            }
          });
        };
        for (var _i = 0, predicates_1 = predicates; _i < predicates_1.length; _i++) {
          var predicate = predicates_1[_i];
          _loop_1(predicate);
        }
        return p;
      };
      PersistencePromise2.forEach = function(collection2, f) {
        var _this = this;
        var promises = [];
        collection2.forEach(function(r, s2) {
          promises.push(f.call(_this, r, s2));
        });
        return this.waitFor(promises);
      };
      return PersistencePromise2;
    }();
    var LOG_TAG$g = "SimpleDb";
    var TRANSACTION_RETRY_COUNT = 3;
    var SimpleDbTransaction = function() {
      function SimpleDbTransaction2(action, transaction) {
        var _this = this;
        this.action = action;
        this.transaction = transaction;
        this.aborted = false;
        this.completionDeferred = new Deferred();
        this.transaction.oncomplete = function() {
          _this.completionDeferred.resolve();
        };
        this.transaction.onabort = function() {
          if (transaction.error) {
            _this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));
          } else {
            _this.completionDeferred.resolve();
          }
        };
        this.transaction.onerror = function(event) {
          var error3 = checkForAndReportiOSError(event.target.error);
          _this.completionDeferred.reject(new IndexedDbTransactionError(action, error3));
        };
      }
      SimpleDbTransaction2.open = function(db2, action, mode, objectStoreNames) {
        try {
          return new SimpleDbTransaction2(action, db2.transaction(objectStoreNames, mode));
        } catch (e) {
          throw new IndexedDbTransactionError(action, e);
        }
      };
      Object.defineProperty(SimpleDbTransaction2.prototype, "completionPromise", {
        get: function() {
          return this.completionDeferred.promise;
        },
        enumerable: false,
        configurable: true
      });
      SimpleDbTransaction2.prototype.abort = function(error3) {
        if (error3) {
          this.completionDeferred.reject(error3);
        }
        if (!this.aborted) {
          logDebug(LOG_TAG$g, "Aborting transaction:", error3 ? error3.message : "Client-initiated abort");
          this.aborted = true;
          this.transaction.abort();
        }
      };
      SimpleDbTransaction2.prototype.store = function(storeName) {
        var store = this.transaction.objectStore(storeName);
        return new SimpleDbStore(store);
      };
      return SimpleDbTransaction2;
    }();
    var SimpleDb = function() {
      function SimpleDb2(name, version2, schemaConverter) {
        this.name = name;
        this.version = version2;
        this.schemaConverter = schemaConverter;
        var iOSVersion = SimpleDb2.getIOSVersion(util.getUA());
        if (iOSVersion === 12.2) {
          logError("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
        }
      }
      SimpleDb2.delete = function(name) {
        logDebug(LOG_TAG$g, "Removing database:", name);
        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();
      };
      SimpleDb2.isAvailable = function() {
        if (typeof indexedDB === "undefined") {
          return false;
        }
        if (SimpleDb2.isMockPersistence()) {
          return true;
        }
        var ua = util.getUA();
        var iOSVersion = SimpleDb2.getIOSVersion(ua);
        var isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;
        var androidVersion = SimpleDb2.getAndroidVersion(ua);
        var isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;
        if (ua.indexOf("MSIE ") > 0 || ua.indexOf("Trident/") > 0 || ua.indexOf("Edge/") > 0 || isUnsupportedIOS || isUnsupportedAndroid) {
          return false;
        } else {
          return true;
        }
      };
      SimpleDb2.isMockPersistence = function() {
        var _a;
        return typeof process !== "undefined" && ((_a = process.env) === null || _a === void 0 ? void 0 : _a.USE_MOCK_PERSISTENCE) === "YES";
      };
      SimpleDb2.getStore = function(txn, store) {
        return txn.store(store);
      };
      SimpleDb2.getIOSVersion = function(ua) {
        var iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\d_]+)/i);
        var version2 = iOSVersionRegex ? iOSVersionRegex[1].split("_").slice(0, 2).join(".") : "-1";
        return Number(version2);
      };
      SimpleDb2.getAndroidVersion = function(ua) {
        var androidVersionRegex = ua.match(/Android ([\d.]+)/i);
        var version2 = androidVersionRegex ? androidVersionRegex[1].split(".").slice(0, 2).join(".") : "-1";
        return Number(version2);
      };
      SimpleDb2.prototype.ensureDb = function(action) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var _d;
          var _this = this;
          return tslib.__generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                if (!!this.db)
                  return [3, 2];
                logDebug(LOG_TAG$g, "Opening database:", this.name);
                _d = this;
                return [4, new Promise(function(resolve2, reject) {
                  var request = indexedDB.open(_this.name, _this.version);
                  request.onsuccess = function(event) {
                    var db2 = event.target.result;
                    resolve2(db2);
                  };
                  request.onblocked = function() {
                    reject(new IndexedDbTransactionError(action, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
                  };
                  request.onerror = function(event) {
                    var error3 = event.target.error;
                    if (error3.name === "VersionError") {
                      reject(new FirestoreError(Code.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh."));
                    } else {
                      reject(new IndexedDbTransactionError(action, error3));
                    }
                  };
                  request.onupgradeneeded = function(event) {
                    logDebug(LOG_TAG$g, 'Database "' + _this.name + '" requires upgrade from version:', event.oldVersion);
                    var db2 = event.target.result;
                    _this.schemaConverter.createOrUpgrade(db2, request.transaction, event.oldVersion, _this.version).next(function() {
                      logDebug(LOG_TAG$g, "Database upgrade to version " + _this.version + " complete");
                    });
                  };
                })];
              case 1:
                _d.db = _e.sent();
                _e.label = 2;
              case 2:
                if (this.versionchangelistener) {
                  this.db.onversionchange = function(event) {
                    return _this.versionchangelistener(event);
                  };
                }
                return [2, this.db];
            }
          });
        });
      };
      SimpleDb2.prototype.setVersionChangeListener = function(versionChangeListener) {
        this.versionchangelistener = versionChangeListener;
        if (this.db) {
          this.db.onversionchange = function(event) {
            return versionChangeListener(event);
          };
        }
      };
      SimpleDb2.prototype.runTransaction = function(action, mode, objectStores, transactionFn) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var readonly, attemptNumber, _loop_2, this_1, state_1;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                readonly = mode === "readonly";
                attemptNumber = 0;
                _loop_2 = function() {
                  var transaction_1, transactionFnResult, error_1, retryable;
                  return tslib.__generator(this, function(_e) {
                    switch (_e.label) {
                      case 0:
                        ++attemptNumber;
                        _e.label = 1;
                      case 1:
                        _e.trys.push([1, 4, , 5]);
                        return [4, this_1.ensureDb(action)];
                      case 2:
                        this_1.db = _e.sent();
                        transaction_1 = SimpleDbTransaction.open(this_1.db, action, readonly ? "readonly" : "readwrite", objectStores);
                        transactionFnResult = transactionFn(transaction_1).catch(function(error3) {
                          transaction_1.abort(error3);
                          return PersistencePromise.reject(error3);
                        }).toPromise();
                        transactionFnResult.catch(function() {
                        });
                        return [4, transaction_1.completionPromise];
                      case 3:
                        _e.sent();
                        return [2, { value: transactionFnResult }];
                      case 4:
                        error_1 = _e.sent();
                        retryable = error_1.name !== "FirebaseError" && attemptNumber < TRANSACTION_RETRY_COUNT;
                        logDebug(LOG_TAG$g, "Transaction failed with error:", error_1.message, "Retrying:", retryable);
                        this_1.close();
                        if (!retryable) {
                          return [2, { value: Promise.reject(error_1) }];
                        }
                        return [3, 5];
                      case 5:
                        return [2];
                    }
                  });
                };
                this_1 = this;
                _d.label = 1;
              case 1:
                return [5, _loop_2()];
              case 2:
                state_1 = _d.sent();
                if (typeof state_1 === "object")
                  return [2, state_1.value];
                return [3, 1];
              case 3:
                return [2];
            }
          });
        });
      };
      SimpleDb2.prototype.close = function() {
        if (this.db) {
          this.db.close();
        }
        this.db = void 0;
      };
      return SimpleDb2;
    }();
    var IterationController = function() {
      function IterationController2(dbCursor) {
        this.dbCursor = dbCursor;
        this.shouldStop = false;
        this.nextKey = null;
      }
      Object.defineProperty(IterationController2.prototype, "isDone", {
        get: function() {
          return this.shouldStop;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(IterationController2.prototype, "skipToKey", {
        get: function() {
          return this.nextKey;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(IterationController2.prototype, "cursor", {
        set: function(value) {
          this.dbCursor = value;
        },
        enumerable: false,
        configurable: true
      });
      IterationController2.prototype.done = function() {
        this.shouldStop = true;
      };
      IterationController2.prototype.skip = function(key) {
        this.nextKey = key;
      };
      IterationController2.prototype.delete = function() {
        return wrapRequest(this.dbCursor.delete());
      };
      return IterationController2;
    }();
    var IndexedDbTransactionError = function(_super) {
      tslib.__extends(IndexedDbTransactionError2, _super);
      function IndexedDbTransactionError2(actionName, cause) {
        var _this = _super.call(this, Code.UNAVAILABLE, "IndexedDB transaction '" + actionName + "' failed: " + cause) || this;
        _this.name = "IndexedDbTransactionError";
        return _this;
      }
      return IndexedDbTransactionError2;
    }(FirestoreError);
    function isIndexedDbTransactionError(e) {
      return e.name === "IndexedDbTransactionError";
    }
    var SimpleDbStore = function() {
      function SimpleDbStore2(store) {
        this.store = store;
      }
      SimpleDbStore2.prototype.put = function(keyOrValue, value) {
        var request;
        if (value !== void 0) {
          logDebug(LOG_TAG$g, "PUT", this.store.name, keyOrValue, value);
          request = this.store.put(value, keyOrValue);
        } else {
          logDebug(LOG_TAG$g, "PUT", this.store.name, "<auto-key>", keyOrValue);
          request = this.store.put(keyOrValue);
        }
        return wrapRequest(request);
      };
      SimpleDbStore2.prototype.add = function(value) {
        logDebug(LOG_TAG$g, "ADD", this.store.name, value, value);
        var request = this.store.add(value);
        return wrapRequest(request);
      };
      SimpleDbStore2.prototype.get = function(key) {
        var _this = this;
        var request = this.store.get(key);
        return wrapRequest(request).next(function(result) {
          if (result === void 0) {
            result = null;
          }
          logDebug(LOG_TAG$g, "GET", _this.store.name, key, result);
          return result;
        });
      };
      SimpleDbStore2.prototype.delete = function(key) {
        logDebug(LOG_TAG$g, "DELETE", this.store.name, key);
        var request = this.store.delete(key);
        return wrapRequest(request);
      };
      SimpleDbStore2.prototype.count = function() {
        logDebug(LOG_TAG$g, "COUNT", this.store.name);
        var request = this.store.count();
        return wrapRequest(request);
      };
      SimpleDbStore2.prototype.loadAll = function(indexOrRange, range) {
        var cursor = this.cursor(this.options(indexOrRange, range));
        var results = [];
        return this.iterateCursor(cursor, function(key, value) {
          results.push(value);
        }).next(function() {
          return results;
        });
      };
      SimpleDbStore2.prototype.deleteAll = function(indexOrRange, range) {
        logDebug(LOG_TAG$g, "DELETE ALL", this.store.name);
        var options2 = this.options(indexOrRange, range);
        options2.keysOnly = false;
        var cursor = this.cursor(options2);
        return this.iterateCursor(cursor, function(key, value, control) {
          return control.delete();
        });
      };
      SimpleDbStore2.prototype.iterate = function(optionsOrCallback, callback) {
        var options2;
        if (!callback) {
          options2 = {};
          callback = optionsOrCallback;
        } else {
          options2 = optionsOrCallback;
        }
        var cursor = this.cursor(options2);
        return this.iterateCursor(cursor, callback);
      };
      SimpleDbStore2.prototype.iterateSerial = function(callback) {
        var cursorRequest = this.cursor({});
        return new PersistencePromise(function(resolve2, reject) {
          cursorRequest.onerror = function(event) {
            var error3 = checkForAndReportiOSError(event.target.error);
            reject(error3);
          };
          cursorRequest.onsuccess = function(event) {
            var cursor = event.target.result;
            if (!cursor) {
              resolve2();
              return;
            }
            callback(cursor.primaryKey, cursor.value).next(function(shouldContinue) {
              if (shouldContinue) {
                cursor.continue();
              } else {
                resolve2();
              }
            });
          };
        });
      };
      SimpleDbStore2.prototype.iterateCursor = function(cursorRequest, fn) {
        var results = [];
        return new PersistencePromise(function(resolve2, reject) {
          cursorRequest.onerror = function(event) {
            reject(event.target.error);
          };
          cursorRequest.onsuccess = function(event) {
            var cursor = event.target.result;
            if (!cursor) {
              resolve2();
              return;
            }
            var controller = new IterationController(cursor);
            var userResult = fn(cursor.primaryKey, cursor.value, controller);
            if (userResult instanceof PersistencePromise) {
              var userPromise = userResult.catch(function(err) {
                controller.done();
                return PersistencePromise.reject(err);
              });
              results.push(userPromise);
            }
            if (controller.isDone) {
              resolve2();
            } else if (controller.skipToKey === null) {
              cursor.continue();
            } else {
              cursor.continue(controller.skipToKey);
            }
          };
        }).next(function() {
          return PersistencePromise.waitFor(results);
        });
      };
      SimpleDbStore2.prototype.options = function(indexOrRange, range) {
        var indexName = void 0;
        if (indexOrRange !== void 0) {
          if (typeof indexOrRange === "string") {
            indexName = indexOrRange;
          } else {
            range = indexOrRange;
          }
        }
        return { index: indexName, range };
      };
      SimpleDbStore2.prototype.cursor = function(options2) {
        var direction = "next";
        if (options2.reverse) {
          direction = "prev";
        }
        if (options2.index) {
          var index2 = this.store.index(options2.index);
          if (options2.keysOnly) {
            return index2.openKeyCursor(options2.range, direction);
          } else {
            return index2.openCursor(options2.range, direction);
          }
        } else {
          return this.store.openCursor(options2.range, direction);
        }
      };
      return SimpleDbStore2;
    }();
    function wrapRequest(request) {
      return new PersistencePromise(function(resolve2, reject) {
        request.onsuccess = function(event) {
          var result = event.target.result;
          resolve2(result);
        };
        request.onerror = function(event) {
          var error3 = checkForAndReportiOSError(event.target.error);
          reject(error3);
        };
      });
    }
    var reportedIOSError = false;
    function checkForAndReportiOSError(error3) {
      var iOSVersion = SimpleDb.getIOSVersion(util.getUA());
      if (iOSVersion >= 12.2 && iOSVersion < 13) {
        var IOS_ERROR = "An internal error was encountered in the Indexed Database server";
        if (error3.message.indexOf(IOS_ERROR) >= 0) {
          var newError_1 = new FirestoreError("internal", "IOS_INDEXEDDB_BUG1: IndexedDb has thrown '" + IOS_ERROR + "'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
          if (!reportedIOSError) {
            reportedIOSError = true;
            setTimeout(function() {
              throw newError_1;
            }, 0);
          }
          return newError_1;
        }
      }
      return error3;
    }
    var IndexedDbTransaction = function(_super) {
      tslib.__extends(IndexedDbTransaction2, _super);
      function IndexedDbTransaction2(simpleDbTransaction, currentSequenceNumber) {
        var _this = _super.call(this) || this;
        _this.simpleDbTransaction = simpleDbTransaction;
        _this.currentSequenceNumber = currentSequenceNumber;
        return _this;
      }
      return IndexedDbTransaction2;
    }(PersistenceTransaction);
    function getStore(txn, store) {
      var indexedDbTransaction = debugCast(txn);
      return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);
    }
    function randomBytes2(nBytes) {
      return crypto.randomBytes(nBytes);
    }
    var AutoId = function() {
      function AutoId2() {
      }
      AutoId2.newId = function() {
        var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        var maxMultiple = Math.floor(256 / chars2.length) * chars2.length;
        var autoId = "";
        var targetLength = 20;
        while (autoId.length < targetLength) {
          var bytes = randomBytes2(40);
          for (var i = 0; i < bytes.length; ++i) {
            if (autoId.length < targetLength && bytes[i] < maxMultiple) {
              autoId += chars2.charAt(bytes[i] % chars2.length);
            }
          }
        }
        return autoId;
      };
      return AutoId2;
    }();
    function primitiveComparator(left, right) {
      if (left < right) {
        return -1;
      }
      if (left > right) {
        return 1;
      }
      return 0;
    }
    function arrayEquals(left, right, comparator) {
      if (left.length !== right.length) {
        return false;
      }
      return left.every(function(value, index2) {
        return comparator(value, right[index2]);
      });
    }
    function immediateSuccessor(s2) {
      return s2 + "\0";
    }
    var MIN_SECONDS = -62135596800;
    var MS_TO_NANOS = 1e6;
    var Timestamp = function() {
      function Timestamp2(seconds, nanoseconds) {
        this.seconds = seconds;
        this.nanoseconds = nanoseconds;
        if (nanoseconds < 0) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
        }
        if (nanoseconds >= 1e9) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
        }
        if (seconds < MIN_SECONDS) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
        }
        if (seconds >= 253402300800) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
        }
      }
      Timestamp2.now = function() {
        return Timestamp2.fromMillis(Date.now());
      };
      Timestamp2.fromDate = function(date) {
        return Timestamp2.fromMillis(date.getTime());
      };
      Timestamp2.fromMillis = function(milliseconds) {
        var seconds = Math.floor(milliseconds / 1e3);
        var nanos = Math.floor((milliseconds - seconds * 1e3) * MS_TO_NANOS);
        return new Timestamp2(seconds, nanos);
      };
      Timestamp2.prototype.toDate = function() {
        return new Date(this.toMillis());
      };
      Timestamp2.prototype.toMillis = function() {
        return this.seconds * 1e3 + this.nanoseconds / MS_TO_NANOS;
      };
      Timestamp2.prototype._compareTo = function(other) {
        if (this.seconds === other.seconds) {
          return primitiveComparator(this.nanoseconds, other.nanoseconds);
        }
        return primitiveComparator(this.seconds, other.seconds);
      };
      Timestamp2.prototype.isEqual = function(other) {
        return other.seconds === this.seconds && other.nanoseconds === this.nanoseconds;
      };
      Timestamp2.prototype.toString = function() {
        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
      };
      Timestamp2.prototype.toJSON = function() {
        return { seconds: this.seconds, nanoseconds: this.nanoseconds };
      };
      Timestamp2.prototype.valueOf = function() {
        var adjustedSeconds = this.seconds - MIN_SECONDS;
        var formattedSeconds = String(adjustedSeconds).padStart(12, "0");
        var formattedNanoseconds = String(this.nanoseconds).padStart(9, "0");
        return formattedSeconds + "." + formattedNanoseconds;
      };
      return Timestamp2;
    }();
    var SnapshotVersion = function() {
      function SnapshotVersion2(timestamp) {
        this.timestamp = timestamp;
      }
      SnapshotVersion2.fromTimestamp = function(value) {
        return new SnapshotVersion2(value);
      };
      SnapshotVersion2.min = function() {
        return new SnapshotVersion2(new Timestamp(0, 0));
      };
      SnapshotVersion2.prototype.compareTo = function(other) {
        return this.timestamp._compareTo(other.timestamp);
      };
      SnapshotVersion2.prototype.isEqual = function(other) {
        return this.timestamp.isEqual(other.timestamp);
      };
      SnapshotVersion2.prototype.toMicroseconds = function() {
        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1e3;
      };
      SnapshotVersion2.prototype.toString = function() {
        return "SnapshotVersion(" + this.timestamp.toString() + ")";
      };
      SnapshotVersion2.prototype.toTimestamp = function() {
        return this.timestamp;
      };
      return SnapshotVersion2;
    }();
    function objectSize(obj) {
      var count = 0;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          count++;
        }
      }
      return count;
    }
    function forEach(obj, fn) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn(key, obj[key]);
        }
      }
    }
    function isEmpty(obj) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          return false;
        }
      }
      return true;
    }
    var FieldMask = function() {
      function FieldMask2(fields) {
        this.fields = fields;
        fields.sort(FieldPath$1.comparator);
      }
      FieldMask2.prototype.covers = function(fieldPath) {
        for (var _i = 0, _d = this.fields; _i < _d.length; _i++) {
          var fieldMaskPath = _d[_i];
          if (fieldMaskPath.isPrefixOf(fieldPath)) {
            return true;
          }
        }
        return false;
      };
      FieldMask2.prototype.isEqual = function(other) {
        return arrayEquals(this.fields, other.fields, function(l, r) {
          return l.isEqual(r);
        });
      };
      return FieldMask2;
    }();
    function decodeBase64(encoded) {
      if (/[^-A-Za-z0-9+/=]/.test(encoded)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Not a valid Base64 string: " + encoded);
      }
      return new Buffer(encoded, "base64").toString("binary");
    }
    function encodeBase64(raw) {
      return new Buffer(raw, "binary").toString("base64");
    }
    var ByteString = function() {
      function ByteString2(binaryString) {
        this.binaryString = binaryString;
      }
      ByteString2.fromBase64String = function(base64) {
        var binaryString = decodeBase64(base64);
        return new ByteString2(binaryString);
      };
      ByteString2.fromUint8Array = function(array) {
        var binaryString = binaryStringFromUint8Array(array);
        return new ByteString2(binaryString);
      };
      ByteString2.prototype.toBase64 = function() {
        return encodeBase64(this.binaryString);
      };
      ByteString2.prototype.toUint8Array = function() {
        return uint8ArrayFromBinaryString(this.binaryString);
      };
      ByteString2.prototype.approximateByteSize = function() {
        return this.binaryString.length * 2;
      };
      ByteString2.prototype.compareTo = function(other) {
        return primitiveComparator(this.binaryString, other.binaryString);
      };
      ByteString2.prototype.isEqual = function(other) {
        return this.binaryString === other.binaryString;
      };
      return ByteString2;
    }();
    ByteString.EMPTY_BYTE_STRING = new ByteString("");
    function binaryStringFromUint8Array(array) {
      var binaryString = "";
      for (var i = 0; i < array.length; ++i) {
        binaryString += String.fromCharCode(array[i]);
      }
      return binaryString;
    }
    function uint8ArrayFromBinaryString(binaryString) {
      var buffer = new Uint8Array(binaryString.length);
      for (var i = 0; i < binaryString.length; i++) {
        buffer[i] = binaryString.charCodeAt(i);
      }
      return buffer;
    }
    var ISO_TIMESTAMP_REG_EXP = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
    function normalizeTimestamp(date) {
      hardAssert(!!date);
      if (typeof date === "string") {
        var nanos = 0;
        var fraction = ISO_TIMESTAMP_REG_EXP.exec(date);
        hardAssert(!!fraction);
        if (fraction[1]) {
          var nanoStr = fraction[1];
          nanoStr = (nanoStr + "000000000").substr(0, 9);
          nanos = Number(nanoStr);
        }
        var parsedDate = new Date(date);
        var seconds = Math.floor(parsedDate.getTime() / 1e3);
        return { seconds, nanos };
      } else {
        var seconds = normalizeNumber(date.seconds);
        var nanos = normalizeNumber(date.nanos);
        return { seconds, nanos };
      }
    }
    function normalizeNumber(value) {
      if (typeof value === "number") {
        return value;
      } else if (typeof value === "string") {
        return Number(value);
      } else {
        return 0;
      }
    }
    function normalizeByteString(blob) {
      if (typeof blob === "string") {
        return ByteString.fromBase64String(blob);
      } else {
        return ByteString.fromUint8Array(blob);
      }
    }
    var SERVER_TIMESTAMP_SENTINEL = "server_timestamp";
    var TYPE_KEY = "__type__";
    var PREVIOUS_VALUE_KEY = "__previous_value__";
    var LOCAL_WRITE_TIME_KEY = "__local_write_time__";
    function isServerTimestamp(value) {
      var _a, _b;
      var type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;
      return type === SERVER_TIMESTAMP_SENTINEL;
    }
    function serverTimestamp(localWriteTime, previousValue) {
      var _d;
      var mapValue = {
        fields: (_d = {}, _d[TYPE_KEY] = {
          stringValue: SERVER_TIMESTAMP_SENTINEL
        }, _d[LOCAL_WRITE_TIME_KEY] = {
          timestampValue: {
            seconds: localWriteTime.seconds,
            nanos: localWriteTime.nanoseconds
          }
        }, _d)
      };
      if (previousValue) {
        mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;
      }
      return { mapValue };
    }
    function getPreviousValue(value) {
      var previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];
      if (isServerTimestamp(previousValue)) {
        return getPreviousValue(previousValue);
      }
      return previousValue;
    }
    function getLocalWriteTime(value) {
      var localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);
      return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);
    }
    var BATCHID_UNKNOWN = -1;
    function isNullOrUndefined(value) {
      return value === null || value === void 0;
    }
    function isNegativeZero(value) {
      return value === 0 && 1 / value === 1 / -0;
    }
    function isSafeInteger(value) {
      return typeof value === "number" && Number.isInteger(value) && !isNegativeZero(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER;
    }
    var DocumentKey = function() {
      function DocumentKey2(path2) {
        this.path = path2;
      }
      DocumentKey2.fromPath = function(path2) {
        return new DocumentKey2(ResourcePath.fromString(path2));
      };
      DocumentKey2.fromName = function(name) {
        return new DocumentKey2(ResourcePath.fromString(name).popFirst(5));
      };
      DocumentKey2.prototype.hasCollectionId = function(collectionId) {
        return this.path.length >= 2 && this.path.get(this.path.length - 2) === collectionId;
      };
      DocumentKey2.prototype.isEqual = function(other) {
        return other !== null && ResourcePath.comparator(this.path, other.path) === 0;
      };
      DocumentKey2.prototype.toString = function() {
        return this.path.toString();
      };
      DocumentKey2.comparator = function(k1, k2) {
        return ResourcePath.comparator(k1.path, k2.path);
      };
      DocumentKey2.isDocumentKey = function(path2) {
        return path2.length % 2 === 0;
      };
      DocumentKey2.fromSegments = function(segments) {
        return new DocumentKey2(new ResourcePath(segments.slice()));
      };
      return DocumentKey2;
    }();
    function typeOrder(value) {
      if ("nullValue" in value) {
        return 0;
      } else if ("booleanValue" in value) {
        return 1;
      } else if ("integerValue" in value || "doubleValue" in value) {
        return 2;
      } else if ("timestampValue" in value) {
        return 3;
      } else if ("stringValue" in value) {
        return 5;
      } else if ("bytesValue" in value) {
        return 6;
      } else if ("referenceValue" in value) {
        return 7;
      } else if ("geoPointValue" in value) {
        return 8;
      } else if ("arrayValue" in value) {
        return 9;
      } else if ("mapValue" in value) {
        if (isServerTimestamp(value)) {
          return 4;
        }
        return 10;
      } else {
        return fail();
      }
    }
    function valueEquals(left, right) {
      var leftType = typeOrder(left);
      var rightType = typeOrder(right);
      if (leftType !== rightType) {
        return false;
      }
      switch (leftType) {
        case 0:
          return true;
        case 1:
          return left.booleanValue === right.booleanValue;
        case 4:
          return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));
        case 3:
          return timestampEquals(left, right);
        case 5:
          return left.stringValue === right.stringValue;
        case 6:
          return blobEquals(left, right);
        case 7:
          return left.referenceValue === right.referenceValue;
        case 8:
          return geoPointEquals(left, right);
        case 2:
          return numberEquals(left, right);
        case 9:
          return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);
        case 10:
          return objectEquals(left, right);
        default:
          return fail();
      }
    }
    function timestampEquals(left, right) {
      if (typeof left.timestampValue === "string" && typeof right.timestampValue === "string" && left.timestampValue.length === right.timestampValue.length) {
        return left.timestampValue === right.timestampValue;
      }
      var leftTimestamp = normalizeTimestamp(left.timestampValue);
      var rightTimestamp = normalizeTimestamp(right.timestampValue);
      return leftTimestamp.seconds === rightTimestamp.seconds && leftTimestamp.nanos === rightTimestamp.nanos;
    }
    function geoPointEquals(left, right) {
      return normalizeNumber(left.geoPointValue.latitude) === normalizeNumber(right.geoPointValue.latitude) && normalizeNumber(left.geoPointValue.longitude) === normalizeNumber(right.geoPointValue.longitude);
    }
    function blobEquals(left, right) {
      return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));
    }
    function numberEquals(left, right) {
      if ("integerValue" in left && "integerValue" in right) {
        return normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue);
      } else if ("doubleValue" in left && "doubleValue" in right) {
        var n1 = normalizeNumber(left.doubleValue);
        var n2 = normalizeNumber(right.doubleValue);
        if (n1 === n2) {
          return isNegativeZero(n1) === isNegativeZero(n2);
        } else {
          return isNaN(n1) && isNaN(n2);
        }
      }
      return false;
    }
    function objectEquals(left, right) {
      var leftMap = left.mapValue.fields || {};
      var rightMap = right.mapValue.fields || {};
      if (objectSize(leftMap) !== objectSize(rightMap)) {
        return false;
      }
      for (var key in leftMap) {
        if (leftMap.hasOwnProperty(key)) {
          if (rightMap[key] === void 0 || !valueEquals(leftMap[key], rightMap[key])) {
            return false;
          }
        }
      }
      return true;
    }
    function arrayValueContains(haystack, needle) {
      return (haystack.values || []).find(function(v) {
        return valueEquals(v, needle);
      }) !== void 0;
    }
    function valueCompare(left, right) {
      var leftType = typeOrder(left);
      var rightType = typeOrder(right);
      if (leftType !== rightType) {
        return primitiveComparator(leftType, rightType);
      }
      switch (leftType) {
        case 0:
          return 0;
        case 1:
          return primitiveComparator(left.booleanValue, right.booleanValue);
        case 2:
          return compareNumbers(left, right);
        case 3:
          return compareTimestamps(left.timestampValue, right.timestampValue);
        case 4:
          return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));
        case 5:
          return primitiveComparator(left.stringValue, right.stringValue);
        case 6:
          return compareBlobs(left.bytesValue, right.bytesValue);
        case 7:
          return compareReferences(left.referenceValue, right.referenceValue);
        case 8:
          return compareGeoPoints(left.geoPointValue, right.geoPointValue);
        case 9:
          return compareArrays(left.arrayValue, right.arrayValue);
        case 10:
          return compareMaps(left.mapValue, right.mapValue);
        default:
          throw fail();
      }
    }
    function compareNumbers(left, right) {
      var leftNumber = normalizeNumber(left.integerValue || left.doubleValue);
      var rightNumber = normalizeNumber(right.integerValue || right.doubleValue);
      if (leftNumber < rightNumber) {
        return -1;
      } else if (leftNumber > rightNumber) {
        return 1;
      } else if (leftNumber === rightNumber) {
        return 0;
      } else {
        if (isNaN(leftNumber)) {
          return isNaN(rightNumber) ? 0 : -1;
        } else {
          return 1;
        }
      }
    }
    function compareTimestamps(left, right) {
      if (typeof left === "string" && typeof right === "string" && left.length === right.length) {
        return primitiveComparator(left, right);
      }
      var leftTimestamp = normalizeTimestamp(left);
      var rightTimestamp = normalizeTimestamp(right);
      var comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);
      if (comparison !== 0) {
        return comparison;
      }
      return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);
    }
    function compareReferences(leftPath, rightPath) {
      var leftSegments = leftPath.split("/");
      var rightSegments = rightPath.split("/");
      for (var i = 0; i < leftSegments.length && i < rightSegments.length; i++) {
        var comparison = primitiveComparator(leftSegments[i], rightSegments[i]);
        if (comparison !== 0) {
          return comparison;
        }
      }
      return primitiveComparator(leftSegments.length, rightSegments.length);
    }
    function compareGeoPoints(left, right) {
      var comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));
      if (comparison !== 0) {
        return comparison;
      }
      return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));
    }
    function compareBlobs(left, right) {
      var leftBytes = normalizeByteString(left);
      var rightBytes = normalizeByteString(right);
      return leftBytes.compareTo(rightBytes);
    }
    function compareArrays(left, right) {
      var leftArray = left.values || [];
      var rightArray = right.values || [];
      for (var i = 0; i < leftArray.length && i < rightArray.length; ++i) {
        var compare = valueCompare(leftArray[i], rightArray[i]);
        if (compare) {
          return compare;
        }
      }
      return primitiveComparator(leftArray.length, rightArray.length);
    }
    function compareMaps(left, right) {
      var leftMap = left.fields || {};
      var leftKeys = Object.keys(leftMap);
      var rightMap = right.fields || {};
      var rightKeys = Object.keys(rightMap);
      leftKeys.sort();
      rightKeys.sort();
      for (var i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {
        var keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);
        if (keyCompare !== 0) {
          return keyCompare;
        }
        var compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);
        if (compare !== 0) {
          return compare;
        }
      }
      return primitiveComparator(leftKeys.length, rightKeys.length);
    }
    function canonicalId(value) {
      return canonifyValue(value);
    }
    function canonifyValue(value) {
      if ("nullValue" in value) {
        return "null";
      } else if ("booleanValue" in value) {
        return "" + value.booleanValue;
      } else if ("integerValue" in value) {
        return "" + value.integerValue;
      } else if ("doubleValue" in value) {
        return "" + value.doubleValue;
      } else if ("timestampValue" in value) {
        return canonifyTimestamp(value.timestampValue);
      } else if ("stringValue" in value) {
        return value.stringValue;
      } else if ("bytesValue" in value) {
        return canonifyByteString(value.bytesValue);
      } else if ("referenceValue" in value) {
        return canonifyReference(value.referenceValue);
      } else if ("geoPointValue" in value) {
        return canonifyGeoPoint(value.geoPointValue);
      } else if ("arrayValue" in value) {
        return canonifyArray(value.arrayValue);
      } else if ("mapValue" in value) {
        return canonifyMap(value.mapValue);
      } else {
        return fail();
      }
    }
    function canonifyByteString(byteString) {
      return normalizeByteString(byteString).toBase64();
    }
    function canonifyTimestamp(timestamp) {
      var normalizedTimestamp = normalizeTimestamp(timestamp);
      return "time(" + normalizedTimestamp.seconds + "," + normalizedTimestamp.nanos + ")";
    }
    function canonifyGeoPoint(geoPoint) {
      return "geo(" + geoPoint.latitude + "," + geoPoint.longitude + ")";
    }
    function canonifyReference(referenceValue) {
      return DocumentKey.fromName(referenceValue).toString();
    }
    function canonifyMap(mapValue) {
      var sortedKeys = Object.keys(mapValue.fields || {}).sort();
      var result = "{";
      var first = true;
      for (var _i = 0, sortedKeys_1 = sortedKeys; _i < sortedKeys_1.length; _i++) {
        var key = sortedKeys_1[_i];
        if (!first) {
          result += ",";
        } else {
          first = false;
        }
        result += key + ":" + canonifyValue(mapValue.fields[key]);
      }
      return result + "}";
    }
    function canonifyArray(arrayValue) {
      var result = "[";
      var first = true;
      for (var _i = 0, _d = arrayValue.values || []; _i < _d.length; _i++) {
        var value = _d[_i];
        if (!first) {
          result += ",";
        } else {
          first = false;
        }
        result += canonifyValue(value);
      }
      return result + "]";
    }
    function refValue(databaseId, key) {
      return {
        referenceValue: "projects/" + databaseId.projectId + "/databases/" + databaseId.database + "/documents/" + key.path.canonicalString()
      };
    }
    function isInteger(value) {
      return !!value && "integerValue" in value;
    }
    function isDouble(value) {
      return !!value && "doubleValue" in value;
    }
    function isNumber(value) {
      return isInteger(value) || isDouble(value);
    }
    function isArray(value) {
      return !!value && "arrayValue" in value;
    }
    function isNullValue(value) {
      return !!value && "nullValue" in value;
    }
    function isNanValue(value) {
      return !!value && "doubleValue" in value && isNaN(Number(value.doubleValue));
    }
    function isMapValue(value) {
      return !!value && "mapValue" in value;
    }
    function deepClone(source) {
      if (source.geoPointValue) {
        return { geoPointValue: Object.assign({}, source.geoPointValue) };
      } else if (source.timestampValue && typeof source.timestampValue === "object") {
        return { timestampValue: Object.assign({}, source.timestampValue) };
      } else if (source.mapValue) {
        var target_1 = { mapValue: { fields: {} } };
        forEach(source.mapValue.fields, function(key, val) {
          return target_1.mapValue.fields[key] = deepClone(val);
        });
        return target_1;
      } else if (source.arrayValue) {
        var target = { arrayValue: { values: [] } };
        for (var i = 0; i < (source.arrayValue.values || []).length; ++i) {
          target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);
        }
        return target;
      } else {
        return Object.assign({}, source);
      }
    }
    var ObjectValue = function() {
      function ObjectValue2(value) {
        this.value = value;
      }
      ObjectValue2.empty = function() {
        return new ObjectValue2({ mapValue: {} });
      };
      ObjectValue2.prototype.field = function(path2) {
        if (path2.isEmpty()) {
          return this.value;
        } else {
          var currentLevel = this.value;
          for (var i = 0; i < path2.length - 1; ++i) {
            currentLevel = (currentLevel.mapValue.fields || {})[path2.get(i)];
            if (!isMapValue(currentLevel)) {
              return null;
            }
          }
          currentLevel = (currentLevel.mapValue.fields || {})[path2.lastSegment()];
          return currentLevel || null;
        }
      };
      ObjectValue2.prototype.set = function(path2, value) {
        var fieldsMap = this.getFieldsMap(path2.popLast());
        fieldsMap[path2.lastSegment()] = deepClone(value);
      };
      ObjectValue2.prototype.setAll = function(data) {
        var _this = this;
        var parent = FieldPath$1.emptyPath();
        var upserts = {};
        var deletes = [];
        data.forEach(function(value, path2) {
          if (!parent.isImmediateParentOf(path2)) {
            var fieldsMap_1 = _this.getFieldsMap(parent);
            _this.applyChanges(fieldsMap_1, upserts, deletes);
            upserts = {};
            deletes = [];
            parent = path2.popLast();
          }
          if (value) {
            upserts[path2.lastSegment()] = deepClone(value);
          } else {
            deletes.push(path2.lastSegment());
          }
        });
        var fieldsMap = this.getFieldsMap(parent);
        this.applyChanges(fieldsMap, upserts, deletes);
      };
      ObjectValue2.prototype.delete = function(path2) {
        var nestedValue = this.field(path2.popLast());
        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {
          delete nestedValue.mapValue.fields[path2.lastSegment()];
        }
      };
      ObjectValue2.prototype.isEqual = function(other) {
        return valueEquals(this.value, other.value);
      };
      ObjectValue2.prototype.getFieldsMap = function(path2) {
        var current = this.value;
        if (!current.mapValue.fields) {
          current.mapValue = { fields: {} };
        }
        for (var i = 0; i < path2.length; ++i) {
          var next = current.mapValue.fields[path2.get(i)];
          if (!isMapValue(next) || !next.mapValue.fields) {
            next = { mapValue: { fields: {} } };
            current.mapValue.fields[path2.get(i)] = next;
          }
          current = next;
        }
        return current.mapValue.fields;
      };
      ObjectValue2.prototype.applyChanges = function(fieldsMap, inserts, deletes) {
        forEach(inserts, function(key, val) {
          return fieldsMap[key] = val;
        });
        for (var _i = 0, deletes_1 = deletes; _i < deletes_1.length; _i++) {
          var field = deletes_1[_i];
          delete fieldsMap[field];
        }
      };
      ObjectValue2.prototype.clone = function() {
        return new ObjectValue2(deepClone(this.value));
      };
      return ObjectValue2;
    }();
    function extractFieldMask(value) {
      var fields = [];
      forEach(value.fields, function(key, value2) {
        var currentPath = new FieldPath$1([key]);
        if (isMapValue(value2)) {
          var nestedMask = extractFieldMask(value2.mapValue);
          var nestedFields = nestedMask.fields;
          if (nestedFields.length === 0) {
            fields.push(currentPath);
          } else {
            for (var _i = 0, nestedFields_1 = nestedFields; _i < nestedFields_1.length; _i++) {
              var nestedPath = nestedFields_1[_i];
              fields.push(currentPath.child(nestedPath));
            }
          }
        } else {
          fields.push(currentPath);
        }
      });
      return new FieldMask(fields);
    }
    var MutableDocument = function() {
      function MutableDocument2(key, documentType, version2, data, documentState) {
        this.key = key;
        this.documentType = documentType;
        this.version = version2;
        this.data = data;
        this.documentState = documentState;
      }
      MutableDocument2.newInvalidDocument = function(documentKey) {
        return new MutableDocument2(documentKey, 0, SnapshotVersion.min(), ObjectValue.empty(), 0);
      };
      MutableDocument2.newFoundDocument = function(documentKey, version2, value) {
        return new MutableDocument2(documentKey, 1, version2, value, 0);
      };
      MutableDocument2.newNoDocument = function(documentKey, version2) {
        return new MutableDocument2(documentKey, 2, version2, ObjectValue.empty(), 0);
      };
      MutableDocument2.newUnknownDocument = function(documentKey, version2) {
        return new MutableDocument2(documentKey, 3, version2, ObjectValue.empty(), 2);
      };
      MutableDocument2.prototype.convertToFoundDocument = function(version2, value) {
        this.version = version2;
        this.documentType = 1;
        this.data = value;
        this.documentState = 0;
        return this;
      };
      MutableDocument2.prototype.convertToNoDocument = function(version2) {
        this.version = version2;
        this.documentType = 2;
        this.data = ObjectValue.empty();
        this.documentState = 0;
        return this;
      };
      MutableDocument2.prototype.convertToUnknownDocument = function(version2) {
        this.version = version2;
        this.documentType = 3;
        this.data = ObjectValue.empty();
        this.documentState = 2;
        return this;
      };
      MutableDocument2.prototype.setHasCommittedMutations = function() {
        this.documentState = 2;
        return this;
      };
      MutableDocument2.prototype.setHasLocalMutations = function() {
        this.documentState = 1;
        return this;
      };
      Object.defineProperty(MutableDocument2.prototype, "hasLocalMutations", {
        get: function() {
          return this.documentState === 1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MutableDocument2.prototype, "hasCommittedMutations", {
        get: function() {
          return this.documentState === 2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MutableDocument2.prototype, "hasPendingWrites", {
        get: function() {
          return this.hasLocalMutations || this.hasCommittedMutations;
        },
        enumerable: false,
        configurable: true
      });
      MutableDocument2.prototype.isValidDocument = function() {
        return this.documentType !== 0;
      };
      MutableDocument2.prototype.isFoundDocument = function() {
        return this.documentType === 1;
      };
      MutableDocument2.prototype.isNoDocument = function() {
        return this.documentType === 2;
      };
      MutableDocument2.prototype.isUnknownDocument = function() {
        return this.documentType === 3;
      };
      MutableDocument2.prototype.isEqual = function(other) {
        return other instanceof MutableDocument2 && this.key.isEqual(other.key) && this.version.isEqual(other.version) && this.documentType === other.documentType && this.documentState === other.documentState && this.data.isEqual(other.data);
      };
      MutableDocument2.prototype.clone = function() {
        return new MutableDocument2(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
      };
      MutableDocument2.prototype.toString = function() {
        return "Document(" + this.key + ", " + this.version + ", " + JSON.stringify(this.data.value) + ", " + ("{documentType: " + this.documentType + "}), ") + ("{documentState: " + this.documentState + "})");
      };
      return MutableDocument2;
    }();
    function compareDocumentsByField(field, d1, d2) {
      var v1 = d1.data.field(field);
      var v2 = d2.data.field(field);
      if (v1 !== null && v2 !== null) {
        return valueCompare(v1, v2);
      } else {
        return fail();
      }
    }
    var TargetImpl = function() {
      function TargetImpl2(path2, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2) {
        if (collectionGroup2 === void 0) {
          collectionGroup2 = null;
        }
        if (orderBy2 === void 0) {
          orderBy2 = [];
        }
        if (filters === void 0) {
          filters = [];
        }
        if (limit2 === void 0) {
          limit2 = null;
        }
        if (startAt2 === void 0) {
          startAt2 = null;
        }
        if (endAt2 === void 0) {
          endAt2 = null;
        }
        this.path = path2;
        this.collectionGroup = collectionGroup2;
        this.orderBy = orderBy2;
        this.filters = filters;
        this.limit = limit2;
        this.startAt = startAt2;
        this.endAt = endAt2;
        this.memoizedCanonicalId = null;
      }
      return TargetImpl2;
    }();
    function newTarget(path2, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2) {
      if (collectionGroup2 === void 0) {
        collectionGroup2 = null;
      }
      if (orderBy2 === void 0) {
        orderBy2 = [];
      }
      if (filters === void 0) {
        filters = [];
      }
      if (limit2 === void 0) {
        limit2 = null;
      }
      if (startAt2 === void 0) {
        startAt2 = null;
      }
      if (endAt2 === void 0) {
        endAt2 = null;
      }
      return new TargetImpl(path2, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2);
    }
    function canonifyTarget(target) {
      var targetImpl = debugCast(target);
      if (targetImpl.memoizedCanonicalId === null) {
        var canonicalId_1 = targetImpl.path.canonicalString();
        if (targetImpl.collectionGroup !== null) {
          canonicalId_1 += "|cg:" + targetImpl.collectionGroup;
        }
        canonicalId_1 += "|f:";
        canonicalId_1 += targetImpl.filters.map(function(f) {
          return canonifyFilter(f);
        }).join(",");
        canonicalId_1 += "|ob:";
        canonicalId_1 += targetImpl.orderBy.map(function(o) {
          return canonifyOrderBy(o);
        }).join(",");
        if (!isNullOrUndefined(targetImpl.limit)) {
          canonicalId_1 += "|l:";
          canonicalId_1 += targetImpl.limit;
        }
        if (targetImpl.startAt) {
          canonicalId_1 += "|lb:";
          canonicalId_1 += canonifyBound(targetImpl.startAt);
        }
        if (targetImpl.endAt) {
          canonicalId_1 += "|ub:";
          canonicalId_1 += canonifyBound(targetImpl.endAt);
        }
        targetImpl.memoizedCanonicalId = canonicalId_1;
      }
      return targetImpl.memoizedCanonicalId;
    }
    function stringifyTarget(target) {
      var str = target.path.canonicalString();
      if (target.collectionGroup !== null) {
        str += " collectionGroup=" + target.collectionGroup;
      }
      if (target.filters.length > 0) {
        str += ", filters: [" + target.filters.map(function(f) {
          return stringifyFilter(f);
        }).join(", ") + "]";
      }
      if (!isNullOrUndefined(target.limit)) {
        str += ", limit: " + target.limit;
      }
      if (target.orderBy.length > 0) {
        str += ", orderBy: [" + target.orderBy.map(function(o) {
          return stringifyOrderBy(o);
        }).join(", ") + "]";
      }
      if (target.startAt) {
        str += ", startAt: " + canonifyBound(target.startAt);
      }
      if (target.endAt) {
        str += ", endAt: " + canonifyBound(target.endAt);
      }
      return "Target(" + str + ")";
    }
    function targetEquals(left, right) {
      if (left.limit !== right.limit) {
        return false;
      }
      if (left.orderBy.length !== right.orderBy.length) {
        return false;
      }
      for (var i = 0; i < left.orderBy.length; i++) {
        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {
          return false;
        }
      }
      if (left.filters.length !== right.filters.length) {
        return false;
      }
      for (var i = 0; i < left.filters.length; i++) {
        if (!filterEquals(left.filters[i], right.filters[i])) {
          return false;
        }
      }
      if (left.collectionGroup !== right.collectionGroup) {
        return false;
      }
      if (!left.path.isEqual(right.path)) {
        return false;
      }
      if (!boundEquals(left.startAt, right.startAt)) {
        return false;
      }
      return boundEquals(left.endAt, right.endAt);
    }
    function isDocumentTarget(target) {
      return DocumentKey.isDocumentKey(target.path) && target.collectionGroup === null && target.filters.length === 0;
    }
    var Filter = function() {
      function Filter2() {
      }
      return Filter2;
    }();
    var FieldFilter = function(_super) {
      tslib.__extends(FieldFilter2, _super);
      function FieldFilter2(field, op, value) {
        var _this = _super.call(this) || this;
        _this.field = field;
        _this.op = op;
        _this.value = value;
        return _this;
      }
      FieldFilter2.create = function(field, op, value) {
        if (field.isKeyField()) {
          if (op === "in" || op === "not-in") {
            return this.createKeyFieldInFilter(field, op, value);
          } else {
            return new KeyFieldFilter(field, op, value);
          }
        } else if (op === "array-contains") {
          return new ArrayContainsFilter(field, value);
        } else if (op === "in") {
          return new InFilter(field, value);
        } else if (op === "not-in") {
          return new NotInFilter(field, value);
        } else if (op === "array-contains-any") {
          return new ArrayContainsAnyFilter(field, value);
        } else {
          return new FieldFilter2(field, op, value);
        }
      };
      FieldFilter2.createKeyFieldInFilter = function(field, op, value) {
        return op === "in" ? new KeyFieldInFilter(field, value) : new KeyFieldNotInFilter(field, value);
      };
      FieldFilter2.prototype.matches = function(doc2) {
        var other = doc2.data.field(this.field);
        if (this.op === "!=") {
          return other !== null && this.matchesComparison(valueCompare(other, this.value));
        }
        return other !== null && typeOrder(this.value) === typeOrder(other) && this.matchesComparison(valueCompare(other, this.value));
      };
      FieldFilter2.prototype.matchesComparison = function(comparison) {
        switch (this.op) {
          case "<":
            return comparison < 0;
          case "<=":
            return comparison <= 0;
          case "==":
            return comparison === 0;
          case "!=":
            return comparison !== 0;
          case ">":
            return comparison > 0;
          case ">=":
            return comparison >= 0;
          default:
            return fail();
        }
      };
      FieldFilter2.prototype.isInequality = function() {
        return [
          "<",
          "<=",
          ">",
          ">=",
          "!=",
          "not-in"
        ].indexOf(this.op) >= 0;
      };
      return FieldFilter2;
    }(Filter);
    function canonifyFilter(filter) {
      return filter.field.canonicalString() + filter.op.toString() + canonicalId(filter.value);
    }
    function filterEquals(f1, f2) {
      return f1.op === f2.op && f1.field.isEqual(f2.field) && valueEquals(f1.value, f2.value);
    }
    function stringifyFilter(filter) {
      return filter.field.canonicalString() + " " + filter.op + " " + canonicalId(filter.value);
    }
    var KeyFieldFilter = function(_super) {
      tslib.__extends(KeyFieldFilter2, _super);
      function KeyFieldFilter2(field, op, value) {
        var _this = _super.call(this, field, op, value) || this;
        _this.key = DocumentKey.fromName(value.referenceValue);
        return _this;
      }
      KeyFieldFilter2.prototype.matches = function(doc2) {
        var comparison = DocumentKey.comparator(doc2.key, this.key);
        return this.matchesComparison(comparison);
      };
      return KeyFieldFilter2;
    }(FieldFilter);
    var KeyFieldInFilter = function(_super) {
      tslib.__extends(KeyFieldInFilter2, _super);
      function KeyFieldInFilter2(field, value) {
        var _this = _super.call(this, field, "in", value) || this;
        _this.keys = extractDocumentKeysFromArrayValue("in", value);
        return _this;
      }
      KeyFieldInFilter2.prototype.matches = function(doc2) {
        return this.keys.some(function(key) {
          return key.isEqual(doc2.key);
        });
      };
      return KeyFieldInFilter2;
    }(FieldFilter);
    var KeyFieldNotInFilter = function(_super) {
      tslib.__extends(KeyFieldNotInFilter2, _super);
      function KeyFieldNotInFilter2(field, value) {
        var _this = _super.call(this, field, "not-in", value) || this;
        _this.keys = extractDocumentKeysFromArrayValue("not-in", value);
        return _this;
      }
      KeyFieldNotInFilter2.prototype.matches = function(doc2) {
        return !this.keys.some(function(key) {
          return key.isEqual(doc2.key);
        });
      };
      return KeyFieldNotInFilter2;
    }(FieldFilter);
    function extractDocumentKeysFromArrayValue(op, value) {
      var _a;
      return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(function(v) {
        return DocumentKey.fromName(v.referenceValue);
      });
    }
    var ArrayContainsFilter = function(_super) {
      tslib.__extends(ArrayContainsFilter2, _super);
      function ArrayContainsFilter2(field, value) {
        return _super.call(this, field, "array-contains", value) || this;
      }
      ArrayContainsFilter2.prototype.matches = function(doc2) {
        var other = doc2.data.field(this.field);
        return isArray(other) && arrayValueContains(other.arrayValue, this.value);
      };
      return ArrayContainsFilter2;
    }(FieldFilter);
    var InFilter = function(_super) {
      tslib.__extends(InFilter2, _super);
      function InFilter2(field, value) {
        return _super.call(this, field, "in", value) || this;
      }
      InFilter2.prototype.matches = function(doc2) {
        var other = doc2.data.field(this.field);
        return other !== null && arrayValueContains(this.value.arrayValue, other);
      };
      return InFilter2;
    }(FieldFilter);
    var NotInFilter = function(_super) {
      tslib.__extends(NotInFilter2, _super);
      function NotInFilter2(field, value) {
        return _super.call(this, field, "not-in", value) || this;
      }
      NotInFilter2.prototype.matches = function(doc2) {
        if (arrayValueContains(this.value.arrayValue, { nullValue: "NULL_VALUE" })) {
          return false;
        }
        var other = doc2.data.field(this.field);
        return other !== null && !arrayValueContains(this.value.arrayValue, other);
      };
      return NotInFilter2;
    }(FieldFilter);
    var ArrayContainsAnyFilter = function(_super) {
      tslib.__extends(ArrayContainsAnyFilter2, _super);
      function ArrayContainsAnyFilter2(field, value) {
        return _super.call(this, field, "array-contains-any", value) || this;
      }
      ArrayContainsAnyFilter2.prototype.matches = function(doc2) {
        var _this = this;
        var other = doc2.data.field(this.field);
        if (!isArray(other) || !other.arrayValue.values) {
          return false;
        }
        return other.arrayValue.values.some(function(val) {
          return arrayValueContains(_this.value.arrayValue, val);
        });
      };
      return ArrayContainsAnyFilter2;
    }(FieldFilter);
    var Bound = function() {
      function Bound2(position, before) {
        this.position = position;
        this.before = before;
      }
      return Bound2;
    }();
    function canonifyBound(bound) {
      return (bound.before ? "b" : "a") + ":" + bound.position.map(function(p) {
        return canonicalId(p);
      }).join(",");
    }
    var OrderBy = function() {
      function OrderBy2(field, dir) {
        if (dir === void 0) {
          dir = "asc";
        }
        this.field = field;
        this.dir = dir;
      }
      return OrderBy2;
    }();
    function canonifyOrderBy(orderBy2) {
      return orderBy2.field.canonicalString() + orderBy2.dir;
    }
    function stringifyOrderBy(orderBy2) {
      return orderBy2.field.canonicalString() + " (" + orderBy2.dir + ")";
    }
    function orderByEquals(left, right) {
      return left.dir === right.dir && left.field.isEqual(right.field);
    }
    function sortsBeforeDocument(bound, orderBy2, doc2) {
      var comparison = 0;
      for (var i = 0; i < bound.position.length; i++) {
        var orderByComponent = orderBy2[i];
        var component = bound.position[i];
        if (orderByComponent.field.isKeyField()) {
          comparison = DocumentKey.comparator(DocumentKey.fromName(component.referenceValue), doc2.key);
        } else {
          var docValue = doc2.data.field(orderByComponent.field);
          comparison = valueCompare(component, docValue);
        }
        if (orderByComponent.dir === "desc") {
          comparison = comparison * -1;
        }
        if (comparison !== 0) {
          break;
        }
      }
      return bound.before ? comparison <= 0 : comparison < 0;
    }
    function boundEquals(left, right) {
      if (left === null) {
        return right === null;
      } else if (right === null) {
        return false;
      }
      if (left.before !== right.before || left.position.length !== right.position.length) {
        return false;
      }
      for (var i = 0; i < left.position.length; i++) {
        var leftPosition = left.position[i];
        var rightPosition = right.position[i];
        if (!valueEquals(leftPosition, rightPosition)) {
          return false;
        }
      }
      return true;
    }
    var QueryImpl = function() {
      function QueryImpl2(path2, collectionGroup2, explicitOrderBy, filters, limit2, limitType, startAt2, endAt2) {
        if (collectionGroup2 === void 0) {
          collectionGroup2 = null;
        }
        if (explicitOrderBy === void 0) {
          explicitOrderBy = [];
        }
        if (filters === void 0) {
          filters = [];
        }
        if (limit2 === void 0) {
          limit2 = null;
        }
        if (limitType === void 0) {
          limitType = "F";
        }
        if (startAt2 === void 0) {
          startAt2 = null;
        }
        if (endAt2 === void 0) {
          endAt2 = null;
        }
        this.path = path2;
        this.collectionGroup = collectionGroup2;
        this.explicitOrderBy = explicitOrderBy;
        this.filters = filters;
        this.limit = limit2;
        this.limitType = limitType;
        this.startAt = startAt2;
        this.endAt = endAt2;
        this.memoizedOrderBy = null;
        this.memoizedTarget = null;
        if (this.startAt)
          ;
        if (this.endAt)
          ;
      }
      return QueryImpl2;
    }();
    function newQuery(path2, collectionGroup2, explicitOrderBy, filters, limit2, limitType, startAt2, endAt2) {
      return new QueryImpl(path2, collectionGroup2, explicitOrderBy, filters, limit2, limitType, startAt2, endAt2);
    }
    function newQueryForPath(path2) {
      return new QueryImpl(path2);
    }
    function asCollectionQueryAtPath(query2, path2) {
      return new QueryImpl(path2, null, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, query2.endAt);
    }
    function matchesAllDocuments(query2) {
      return query2.filters.length === 0 && query2.limit === null && query2.startAt == null && query2.endAt == null && (query2.explicitOrderBy.length === 0 || query2.explicitOrderBy.length === 1 && query2.explicitOrderBy[0].field.isKeyField());
    }
    function hasLimitToFirst(query2) {
      return !isNullOrUndefined(query2.limit) && query2.limitType === "F";
    }
    function hasLimitToLast(query2) {
      return !isNullOrUndefined(query2.limit) && query2.limitType === "L";
    }
    function getFirstOrderByField(query2) {
      return query2.explicitOrderBy.length > 0 ? query2.explicitOrderBy[0].field : null;
    }
    function getInequalityFilterField(query2) {
      for (var _i = 0, _d = query2.filters; _i < _d.length; _i++) {
        var filter = _d[_i];
        if (filter.isInequality()) {
          return filter.field;
        }
      }
      return null;
    }
    function findFilterOperator(query2, operators) {
      for (var _i = 0, _d = query2.filters; _i < _d.length; _i++) {
        var filter = _d[_i];
        if (operators.indexOf(filter.op) >= 0) {
          return filter.op;
        }
      }
      return null;
    }
    function newQueryForCollectionGroup(collectionId) {
      return new QueryImpl(ResourcePath.emptyPath(), collectionId);
    }
    function isDocumentQuery$1(query2) {
      return DocumentKey.isDocumentKey(query2.path) && query2.collectionGroup === null && query2.filters.length === 0;
    }
    function isCollectionGroupQuery(query2) {
      return query2.collectionGroup !== null;
    }
    function queryOrderBy(query2) {
      var queryImpl = debugCast(query2);
      if (queryImpl.memoizedOrderBy === null) {
        queryImpl.memoizedOrderBy = [];
        var inequalityField = getInequalityFilterField(queryImpl);
        var firstOrderByField = getFirstOrderByField(queryImpl);
        if (inequalityField !== null && firstOrderByField === null) {
          if (!inequalityField.isKeyField()) {
            queryImpl.memoizedOrderBy.push(new OrderBy(inequalityField));
          }
          queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), "asc"));
        } else {
          var foundKeyOrdering = false;
          for (var _i = 0, _d = queryImpl.explicitOrderBy; _i < _d.length; _i++) {
            var orderBy_1 = _d[_i];
            queryImpl.memoizedOrderBy.push(orderBy_1);
            if (orderBy_1.field.isKeyField()) {
              foundKeyOrdering = true;
            }
          }
          if (!foundKeyOrdering) {
            var lastDirection = queryImpl.explicitOrderBy.length > 0 ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir : "asc";
            queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));
          }
        }
      }
      return queryImpl.memoizedOrderBy;
    }
    function queryToTarget(query2) {
      var queryImpl = debugCast(query2);
      if (!queryImpl.memoizedTarget) {
        if (queryImpl.limitType === "F") {
          queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, queryOrderBy(queryImpl), queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);
        } else {
          var orderBys = [];
          for (var _i = 0, _d = queryOrderBy(queryImpl); _i < _d.length; _i++) {
            var orderBy_2 = _d[_i];
            var dir = orderBy_2.dir === "desc" ? "asc" : "desc";
            orderBys.push(new OrderBy(orderBy_2.field, dir));
          }
          var startAt_1 = queryImpl.endAt ? new Bound(queryImpl.endAt.position, !queryImpl.endAt.before) : null;
          var endAt_1 = queryImpl.startAt ? new Bound(queryImpl.startAt.position, !queryImpl.startAt.before) : null;
          queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt_1, endAt_1);
        }
      }
      return queryImpl.memoizedTarget;
    }
    function queryWithAddedFilter(query2, filter) {
      var newFilters = query2.filters.concat([filter]);
      return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), newFilters, query2.limit, query2.limitType, query2.startAt, query2.endAt);
    }
    function queryWithAddedOrderBy(query2, orderBy2) {
      var newOrderBy = query2.explicitOrderBy.concat([orderBy2]);
      return new QueryImpl(query2.path, query2.collectionGroup, newOrderBy, query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, query2.endAt);
    }
    function queryWithLimit(query2, limit2, limitType) {
      return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), limit2, limitType, query2.startAt, query2.endAt);
    }
    function queryWithStartAt(query2, bound) {
      return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, bound, query2.endAt);
    }
    function queryWithEndAt(query2, bound) {
      return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, bound);
    }
    function queryEquals(left, right) {
      return targetEquals(queryToTarget(left), queryToTarget(right)) && left.limitType === right.limitType;
    }
    function canonifyQuery(query2) {
      return canonifyTarget(queryToTarget(query2)) + "|lt:" + query2.limitType;
    }
    function stringifyQuery(query2) {
      return "Query(target=" + stringifyTarget(queryToTarget(query2)) + "; limitType=" + query2.limitType + ")";
    }
    function queryMatches(query2, doc2) {
      return doc2.isFoundDocument() && queryMatchesPathAndCollectionGroup(query2, doc2) && queryMatchesOrderBy(query2, doc2) && queryMatchesFilters(query2, doc2) && queryMatchesBounds(query2, doc2);
    }
    function queryMatchesPathAndCollectionGroup(query2, doc2) {
      var docPath = doc2.key.path;
      if (query2.collectionGroup !== null) {
        return doc2.key.hasCollectionId(query2.collectionGroup) && query2.path.isPrefixOf(docPath);
      } else if (DocumentKey.isDocumentKey(query2.path)) {
        return query2.path.isEqual(docPath);
      } else {
        return query2.path.isImmediateParentOf(docPath);
      }
    }
    function queryMatchesOrderBy(query2, doc2) {
      for (var _i = 0, _d = query2.explicitOrderBy; _i < _d.length; _i++) {
        var orderBy_3 = _d[_i];
        if (!orderBy_3.field.isKeyField() && doc2.data.field(orderBy_3.field) === null) {
          return false;
        }
      }
      return true;
    }
    function queryMatchesFilters(query2, doc2) {
      for (var _i = 0, _d = query2.filters; _i < _d.length; _i++) {
        var filter = _d[_i];
        if (!filter.matches(doc2)) {
          return false;
        }
      }
      return true;
    }
    function queryMatchesBounds(query2, doc2) {
      if (query2.startAt && !sortsBeforeDocument(query2.startAt, queryOrderBy(query2), doc2)) {
        return false;
      }
      if (query2.endAt && sortsBeforeDocument(query2.endAt, queryOrderBy(query2), doc2)) {
        return false;
      }
      return true;
    }
    function newQueryComparator(query2) {
      return function(d1, d2) {
        var comparedOnKeyField = false;
        for (var _i = 0, _d = queryOrderBy(query2); _i < _d.length; _i++) {
          var orderBy_4 = _d[_i];
          var comp = compareDocs(orderBy_4, d1, d2);
          if (comp !== 0) {
            return comp;
          }
          comparedOnKeyField = comparedOnKeyField || orderBy_4.field.isKeyField();
        }
        return 0;
      };
    }
    function compareDocs(orderBy2, d1, d2) {
      var comparison = orderBy2.field.isKeyField() ? DocumentKey.comparator(d1.key, d2.key) : compareDocumentsByField(orderBy2.field, d1, d2);
      switch (orderBy2.dir) {
        case "asc":
          return comparison;
        case "desc":
          return -1 * comparison;
        default:
          return fail();
      }
    }
    var SortedMap = function() {
      function SortedMap2(comparator, root) {
        this.comparator = comparator;
        this.root = root ? root : LLRBNode.EMPTY;
      }
      SortedMap2.prototype.insert = function(key, value) {
        return new SortedMap2(this.comparator, this.root.insert(key, value, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
      };
      SortedMap2.prototype.remove = function(key) {
        return new SortedMap2(this.comparator, this.root.remove(key, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
      };
      SortedMap2.prototype.get = function(key) {
        var node = this.root;
        while (!node.isEmpty()) {
          var cmp = this.comparator(key, node.key);
          if (cmp === 0) {
            return node.value;
          } else if (cmp < 0) {
            node = node.left;
          } else if (cmp > 0) {
            node = node.right;
          }
        }
        return null;
      };
      SortedMap2.prototype.indexOf = function(key) {
        var prunedNodes = 0;
        var node = this.root;
        while (!node.isEmpty()) {
          var cmp = this.comparator(key, node.key);
          if (cmp === 0) {
            return prunedNodes + node.left.size;
          } else if (cmp < 0) {
            node = node.left;
          } else {
            prunedNodes += node.left.size + 1;
            node = node.right;
          }
        }
        return -1;
      };
      SortedMap2.prototype.isEmpty = function() {
        return this.root.isEmpty();
      };
      Object.defineProperty(SortedMap2.prototype, "size", {
        get: function() {
          return this.root.size;
        },
        enumerable: false,
        configurable: true
      });
      SortedMap2.prototype.minKey = function() {
        return this.root.minKey();
      };
      SortedMap2.prototype.maxKey = function() {
        return this.root.maxKey();
      };
      SortedMap2.prototype.inorderTraversal = function(action) {
        return this.root.inorderTraversal(action);
      };
      SortedMap2.prototype.forEach = function(fn) {
        this.inorderTraversal(function(k, v) {
          fn(k, v);
          return false;
        });
      };
      SortedMap2.prototype.toString = function() {
        var descriptions = [];
        this.inorderTraversal(function(k, v) {
          descriptions.push(k + ":" + v);
          return false;
        });
        return "{" + descriptions.join(", ") + "}";
      };
      SortedMap2.prototype.reverseTraversal = function(action) {
        return this.root.reverseTraversal(action);
      };
      SortedMap2.prototype.getIterator = function() {
        return new SortedMapIterator(this.root, null, this.comparator, false);
      };
      SortedMap2.prototype.getIteratorFrom = function(key) {
        return new SortedMapIterator(this.root, key, this.comparator, false);
      };
      SortedMap2.prototype.getReverseIterator = function() {
        return new SortedMapIterator(this.root, null, this.comparator, true);
      };
      SortedMap2.prototype.getReverseIteratorFrom = function(key) {
        return new SortedMapIterator(this.root, key, this.comparator, true);
      };
      return SortedMap2;
    }();
    var SortedMapIterator = function() {
      function SortedMapIterator2(node, startKey, comparator, isReverse) {
        this.isReverse = isReverse;
        this.nodeStack = [];
        var cmp = 1;
        while (!node.isEmpty()) {
          cmp = startKey ? comparator(node.key, startKey) : 1;
          if (isReverse) {
            cmp *= -1;
          }
          if (cmp < 0) {
            if (this.isReverse) {
              node = node.left;
            } else {
              node = node.right;
            }
          } else if (cmp === 0) {
            this.nodeStack.push(node);
            break;
          } else {
            this.nodeStack.push(node);
            if (this.isReverse) {
              node = node.right;
            } else {
              node = node.left;
            }
          }
        }
      }
      SortedMapIterator2.prototype.getNext = function() {
        var node = this.nodeStack.pop();
        var result = { key: node.key, value: node.value };
        if (this.isReverse) {
          node = node.left;
          while (!node.isEmpty()) {
            this.nodeStack.push(node);
            node = node.right;
          }
        } else {
          node = node.right;
          while (!node.isEmpty()) {
            this.nodeStack.push(node);
            node = node.left;
          }
        }
        return result;
      };
      SortedMapIterator2.prototype.hasNext = function() {
        return this.nodeStack.length > 0;
      };
      SortedMapIterator2.prototype.peek = function() {
        if (this.nodeStack.length === 0) {
          return null;
        }
        var node = this.nodeStack[this.nodeStack.length - 1];
        return { key: node.key, value: node.value };
      };
      return SortedMapIterator2;
    }();
    var LLRBNode = function() {
      function LLRBNode2(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode2.RED;
        this.left = left != null ? left : LLRBNode2.EMPTY;
        this.right = right != null ? right : LLRBNode2.EMPTY;
        this.size = this.left.size + 1 + this.right.size;
      }
      LLRBNode2.prototype.copy = function(key, value, color, left, right) {
        return new LLRBNode2(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
      };
      LLRBNode2.prototype.isEmpty = function() {
        return false;
      };
      LLRBNode2.prototype.inorderTraversal = function(action) {
        return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);
      };
      LLRBNode2.prototype.reverseTraversal = function(action) {
        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
      };
      LLRBNode2.prototype.min = function() {
        if (this.left.isEmpty()) {
          return this;
        } else {
          return this.left.min();
        }
      };
      LLRBNode2.prototype.minKey = function() {
        return this.min().key;
      };
      LLRBNode2.prototype.maxKey = function() {
        if (this.right.isEmpty()) {
          return this.key;
        } else {
          return this.right.maxKey();
        }
      };
      LLRBNode2.prototype.insert = function(key, value, comparator) {
        var n = this;
        var cmp = comparator(key, n.key);
        if (cmp < 0) {
          n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        } else if (cmp === 0) {
          n = n.copy(null, value, null, null, null);
        } else {
          n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp();
      };
      LLRBNode2.prototype.removeMin = function() {
        if (this.left.isEmpty()) {
          return LLRBNode2.EMPTY;
        }
        var n = this;
        if (!n.left.isRed() && !n.left.left.isRed()) {
          n = n.moveRedLeft();
        }
        n = n.copy(null, null, null, n.left.removeMin(), null);
        return n.fixUp();
      };
      LLRBNode2.prototype.remove = function(key, comparator) {
        var smallest;
        var n = this;
        if (comparator(key, n.key) < 0) {
          if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {
            n = n.moveRedLeft();
          }
          n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        } else {
          if (n.left.isRed()) {
            n = n.rotateRight();
          }
          if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {
            n = n.moveRedRight();
          }
          if (comparator(key, n.key) === 0) {
            if (n.right.isEmpty()) {
              return LLRBNode2.EMPTY;
            } else {
              smallest = n.right.min();
              n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());
            }
          }
          n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp();
      };
      LLRBNode2.prototype.isRed = function() {
        return this.color;
      };
      LLRBNode2.prototype.fixUp = function() {
        var n = this;
        if (n.right.isRed() && !n.left.isRed()) {
          n = n.rotateLeft();
        }
        if (n.left.isRed() && n.left.left.isRed()) {
          n = n.rotateRight();
        }
        if (n.left.isRed() && n.right.isRed()) {
          n = n.colorFlip();
        }
        return n;
      };
      LLRBNode2.prototype.moveRedLeft = function() {
        var n = this.colorFlip();
        if (n.right.left.isRed()) {
          n = n.copy(null, null, null, null, n.right.rotateRight());
          n = n.rotateLeft();
          n = n.colorFlip();
        }
        return n;
      };
      LLRBNode2.prototype.moveRedRight = function() {
        var n = this.colorFlip();
        if (n.left.left.isRed()) {
          n = n.rotateRight();
          n = n.colorFlip();
        }
        return n;
      };
      LLRBNode2.prototype.rotateLeft = function() {
        var nl = this.copy(null, null, LLRBNode2.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
      };
      LLRBNode2.prototype.rotateRight = function() {
        var nr = this.copy(null, null, LLRBNode2.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
      };
      LLRBNode2.prototype.colorFlip = function() {
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
      };
      LLRBNode2.prototype.checkMaxDepth = function() {
        var blackDepth = this.check();
        if (Math.pow(2, blackDepth) <= this.size + 1) {
          return true;
        } else {
          return false;
        }
      };
      LLRBNode2.prototype.check = function() {
        if (this.isRed() && this.left.isRed()) {
          throw fail();
        }
        if (this.right.isRed()) {
          throw fail();
        }
        var blackDepth = this.left.check();
        if (blackDepth !== this.right.check()) {
          throw fail();
        } else {
          return blackDepth + (this.isRed() ? 0 : 1);
        }
      };
      return LLRBNode2;
    }();
    LLRBNode.EMPTY = null;
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    var LLRBEmptyNode = function() {
      function LLRBEmptyNode2() {
        this.size = 0;
      }
      Object.defineProperty(LLRBEmptyNode2.prototype, "key", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LLRBEmptyNode2.prototype, "value", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LLRBEmptyNode2.prototype, "color", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LLRBEmptyNode2.prototype, "left", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LLRBEmptyNode2.prototype, "right", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      LLRBEmptyNode2.prototype.copy = function(key, value, color, left, right) {
        return this;
      };
      LLRBEmptyNode2.prototype.insert = function(key, value, comparator) {
        return new LLRBNode(key, value);
      };
      LLRBEmptyNode2.prototype.remove = function(key, comparator) {
        return this;
      };
      LLRBEmptyNode2.prototype.isEmpty = function() {
        return true;
      };
      LLRBEmptyNode2.prototype.inorderTraversal = function(action) {
        return false;
      };
      LLRBEmptyNode2.prototype.reverseTraversal = function(action) {
        return false;
      };
      LLRBEmptyNode2.prototype.minKey = function() {
        return null;
      };
      LLRBEmptyNode2.prototype.maxKey = function() {
        return null;
      };
      LLRBEmptyNode2.prototype.isRed = function() {
        return false;
      };
      LLRBEmptyNode2.prototype.checkMaxDepth = function() {
        return true;
      };
      LLRBEmptyNode2.prototype.check = function() {
        return 0;
      };
      return LLRBEmptyNode2;
    }();
    LLRBNode.EMPTY = new LLRBEmptyNode();
    var SortedSet = function() {
      function SortedSet2(comparator) {
        this.comparator = comparator;
        this.data = new SortedMap(this.comparator);
      }
      SortedSet2.prototype.has = function(elem) {
        return this.data.get(elem) !== null;
      };
      SortedSet2.prototype.first = function() {
        return this.data.minKey();
      };
      SortedSet2.prototype.last = function() {
        return this.data.maxKey();
      };
      Object.defineProperty(SortedSet2.prototype, "size", {
        get: function() {
          return this.data.size;
        },
        enumerable: false,
        configurable: true
      });
      SortedSet2.prototype.indexOf = function(elem) {
        return this.data.indexOf(elem);
      };
      SortedSet2.prototype.forEach = function(cb) {
        this.data.inorderTraversal(function(k, v) {
          cb(k);
          return false;
        });
      };
      SortedSet2.prototype.forEachInRange = function(range, cb) {
        var iter = this.data.getIteratorFrom(range[0]);
        while (iter.hasNext()) {
          var elem = iter.getNext();
          if (this.comparator(elem.key, range[1]) >= 0) {
            return;
          }
          cb(elem.key);
        }
      };
      SortedSet2.prototype.forEachWhile = function(cb, start) {
        var iter;
        if (start !== void 0) {
          iter = this.data.getIteratorFrom(start);
        } else {
          iter = this.data.getIterator();
        }
        while (iter.hasNext()) {
          var elem = iter.getNext();
          var result = cb(elem.key);
          if (!result) {
            return;
          }
        }
      };
      SortedSet2.prototype.firstAfterOrEqual = function(elem) {
        var iter = this.data.getIteratorFrom(elem);
        return iter.hasNext() ? iter.getNext().key : null;
      };
      SortedSet2.prototype.getIterator = function() {
        return new SortedSetIterator(this.data.getIterator());
      };
      SortedSet2.prototype.getIteratorFrom = function(key) {
        return new SortedSetIterator(this.data.getIteratorFrom(key));
      };
      SortedSet2.prototype.add = function(elem) {
        return this.copy(this.data.remove(elem).insert(elem, true));
      };
      SortedSet2.prototype.delete = function(elem) {
        if (!this.has(elem)) {
          return this;
        }
        return this.copy(this.data.remove(elem));
      };
      SortedSet2.prototype.isEmpty = function() {
        return this.data.isEmpty();
      };
      SortedSet2.prototype.unionWith = function(other) {
        var result = this;
        if (result.size < other.size) {
          result = other;
          other = this;
        }
        other.forEach(function(elem) {
          result = result.add(elem);
        });
        return result;
      };
      SortedSet2.prototype.isEqual = function(other) {
        if (!(other instanceof SortedSet2)) {
          return false;
        }
        if (this.size !== other.size) {
          return false;
        }
        var thisIt = this.data.getIterator();
        var otherIt = other.data.getIterator();
        while (thisIt.hasNext()) {
          var thisElem = thisIt.getNext().key;
          var otherElem = otherIt.getNext().key;
          if (this.comparator(thisElem, otherElem) !== 0) {
            return false;
          }
        }
        return true;
      };
      SortedSet2.prototype.toArray = function() {
        var res = [];
        this.forEach(function(targetId) {
          res.push(targetId);
        });
        return res;
      };
      SortedSet2.prototype.toString = function() {
        var result = [];
        this.forEach(function(elem) {
          return result.push(elem);
        });
        return "SortedSet(" + result.toString() + ")";
      };
      SortedSet2.prototype.copy = function(data) {
        var result = new SortedSet2(this.comparator);
        result.data = data;
        return result;
      };
      return SortedSet2;
    }();
    var SortedSetIterator = function() {
      function SortedSetIterator2(iter) {
        this.iter = iter;
      }
      SortedSetIterator2.prototype.getNext = function() {
        return this.iter.getNext().key;
      };
      SortedSetIterator2.prototype.hasNext = function() {
        return this.iter.hasNext();
      };
      return SortedSetIterator2;
    }();
    var EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
    function mutableDocumentMap() {
      return EMPTY_MUTABLE_DOCUMENT_MAP;
    }
    var EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
    function documentMap() {
      return EMPTY_DOCUMENT_MAP;
    }
    var EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);
    function documentVersionMap() {
      return EMPTY_DOCUMENT_VERSION_MAP;
    }
    var EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);
    function documentKeySet() {
      var keys = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
      }
      var set = EMPTY_DOCUMENT_KEY_SET;
      for (var _d = 0, keys_1 = keys; _d < keys_1.length; _d++) {
        var key = keys_1[_d];
        set = set.add(key);
      }
      return set;
    }
    var EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);
    function targetIdSet() {
      return EMPTY_TARGET_ID_SET;
    }
    function toDouble(serializer, value) {
      if (serializer.useProto3Json) {
        if (isNaN(value)) {
          return { doubleValue: "NaN" };
        } else if (value === Infinity) {
          return { doubleValue: "Infinity" };
        } else if (value === -Infinity) {
          return { doubleValue: "-Infinity" };
        }
      }
      return { doubleValue: isNegativeZero(value) ? "-0" : value };
    }
    function toInteger(value) {
      return { integerValue: "" + value };
    }
    function toNumber(serializer, value) {
      return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);
    }
    var TransformOperation = function() {
      function TransformOperation2() {
        this._ = void 0;
      }
      return TransformOperation2;
    }();
    function applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {
      if (transform instanceof ServerTimestampTransform) {
        return serverTimestamp(localWriteTime, previousValue);
      } else if (transform instanceof ArrayUnionTransformOperation) {
        return applyArrayUnionTransformOperation(transform, previousValue);
      } else if (transform instanceof ArrayRemoveTransformOperation) {
        return applyArrayRemoveTransformOperation(transform, previousValue);
      } else {
        return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);
      }
    }
    function applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {
      if (transform instanceof ArrayUnionTransformOperation) {
        return applyArrayUnionTransformOperation(transform, previousValue);
      } else if (transform instanceof ArrayRemoveTransformOperation) {
        return applyArrayRemoveTransformOperation(transform, previousValue);
      }
      return transformResult;
    }
    function computeTransformOperationBaseValue(transform, previousValue) {
      if (transform instanceof NumericIncrementTransformOperation) {
        return isNumber(previousValue) ? previousValue : { integerValue: 0 };
      }
      return null;
    }
    function transformOperationEquals(left, right) {
      if (left instanceof ArrayUnionTransformOperation && right instanceof ArrayUnionTransformOperation) {
        return arrayEquals(left.elements, right.elements, valueEquals);
      } else if (left instanceof ArrayRemoveTransformOperation && right instanceof ArrayRemoveTransformOperation) {
        return arrayEquals(left.elements, right.elements, valueEquals);
      } else if (left instanceof NumericIncrementTransformOperation && right instanceof NumericIncrementTransformOperation) {
        return valueEquals(left.operand, right.operand);
      }
      return left instanceof ServerTimestampTransform && right instanceof ServerTimestampTransform;
    }
    var ServerTimestampTransform = function(_super) {
      tslib.__extends(ServerTimestampTransform2, _super);
      function ServerTimestampTransform2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return ServerTimestampTransform2;
    }(TransformOperation);
    var ArrayUnionTransformOperation = function(_super) {
      tslib.__extends(ArrayUnionTransformOperation2, _super);
      function ArrayUnionTransformOperation2(elements) {
        var _this = _super.call(this) || this;
        _this.elements = elements;
        return _this;
      }
      return ArrayUnionTransformOperation2;
    }(TransformOperation);
    function applyArrayUnionTransformOperation(transform, previousValue) {
      var values = coercedFieldValuesArray(previousValue);
      var _loop_3 = function(toUnion2) {
        if (!values.some(function(element) {
          return valueEquals(element, toUnion2);
        })) {
          values.push(toUnion2);
        }
      };
      for (var _i = 0, _d = transform.elements; _i < _d.length; _i++) {
        var toUnion = _d[_i];
        _loop_3(toUnion);
      }
      return { arrayValue: { values } };
    }
    var ArrayRemoveTransformOperation = function(_super) {
      tslib.__extends(ArrayRemoveTransformOperation2, _super);
      function ArrayRemoveTransformOperation2(elements) {
        var _this = _super.call(this) || this;
        _this.elements = elements;
        return _this;
      }
      return ArrayRemoveTransformOperation2;
    }(TransformOperation);
    function applyArrayRemoveTransformOperation(transform, previousValue) {
      var values = coercedFieldValuesArray(previousValue);
      var _loop_4 = function(toRemove2) {
        values = values.filter(function(element) {
          return !valueEquals(element, toRemove2);
        });
      };
      for (var _i = 0, _d = transform.elements; _i < _d.length; _i++) {
        var toRemove = _d[_i];
        _loop_4(toRemove);
      }
      return { arrayValue: { values } };
    }
    var NumericIncrementTransformOperation = function(_super) {
      tslib.__extends(NumericIncrementTransformOperation2, _super);
      function NumericIncrementTransformOperation2(serializer, operand) {
        var _this = _super.call(this) || this;
        _this.serializer = serializer;
        _this.operand = operand;
        return _this;
      }
      return NumericIncrementTransformOperation2;
    }(TransformOperation);
    function applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {
      var baseValue = computeTransformOperationBaseValue(transform, previousValue);
      var sum = asNumber(baseValue) + asNumber(transform.operand);
      if (isInteger(baseValue) && isInteger(transform.operand)) {
        return toInteger(sum);
      } else {
        return toDouble(transform.serializer, sum);
      }
    }
    function asNumber(value) {
      return normalizeNumber(value.integerValue || value.doubleValue);
    }
    function coercedFieldValuesArray(value) {
      return isArray(value) && value.arrayValue.values ? value.arrayValue.values.slice() : [];
    }
    var FieldTransform = function() {
      function FieldTransform2(field, transform) {
        this.field = field;
        this.transform = transform;
      }
      return FieldTransform2;
    }();
    function fieldTransformEquals(left, right) {
      return left.field.isEqual(right.field) && transformOperationEquals(left.transform, right.transform);
    }
    function fieldTransformsAreEqual(left, right) {
      if (left === void 0 && right === void 0) {
        return true;
      }
      if (left && right) {
        return arrayEquals(left, right, function(l, r) {
          return fieldTransformEquals(l, r);
        });
      }
      return false;
    }
    var MutationResult = function() {
      function MutationResult2(version2, transformResults) {
        this.version = version2;
        this.transformResults = transformResults;
      }
      return MutationResult2;
    }();
    var Precondition = function() {
      function Precondition2(updateTime, exists) {
        this.updateTime = updateTime;
        this.exists = exists;
      }
      Precondition2.none = function() {
        return new Precondition2();
      };
      Precondition2.exists = function(exists) {
        return new Precondition2(void 0, exists);
      };
      Precondition2.updateTime = function(version2) {
        return new Precondition2(version2);
      };
      Object.defineProperty(Precondition2.prototype, "isNone", {
        get: function() {
          return this.updateTime === void 0 && this.exists === void 0;
        },
        enumerable: false,
        configurable: true
      });
      Precondition2.prototype.isEqual = function(other) {
        return this.exists === other.exists && (this.updateTime ? !!other.updateTime && this.updateTime.isEqual(other.updateTime) : !other.updateTime);
      };
      return Precondition2;
    }();
    function preconditionIsValidForDocument(precondition, document2) {
      if (precondition.updateTime !== void 0) {
        return document2.isFoundDocument() && document2.version.isEqual(precondition.updateTime);
      } else if (precondition.exists !== void 0) {
        return precondition.exists === document2.isFoundDocument();
      } else {
        return true;
      }
    }
    var Mutation = function() {
      function Mutation2() {
      }
      return Mutation2;
    }();
    function applyMutationToRemoteDocument(mutation, document2, mutationResult) {
      if (mutation instanceof SetMutation) {
        applySetMutationToRemoteDocument(mutation, document2, mutationResult);
      } else if (mutation instanceof PatchMutation) {
        applyPatchMutationToRemoteDocument(mutation, document2, mutationResult);
      } else {
        applyDeleteMutationToRemoteDocument(mutation, document2, mutationResult);
      }
    }
    function applyMutationToLocalView(mutation, document2, localWriteTime) {
      if (mutation instanceof SetMutation) {
        applySetMutationToLocalView(mutation, document2, localWriteTime);
      } else if (mutation instanceof PatchMutation) {
        applyPatchMutationToLocalView(mutation, document2, localWriteTime);
      } else {
        applyDeleteMutationToLocalView(mutation, document2);
      }
    }
    function extractMutationBaseValue(mutation, document2) {
      var baseObject = null;
      for (var _i = 0, _d = mutation.fieldTransforms; _i < _d.length; _i++) {
        var fieldTransform = _d[_i];
        var existingValue = document2.data.field(fieldTransform.field);
        var coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);
        if (coercedValue != null) {
          if (baseObject == null) {
            baseObject = ObjectValue.empty();
          }
          baseObject.set(fieldTransform.field, coercedValue);
        }
      }
      return baseObject ? baseObject : null;
    }
    function mutationEquals(left, right) {
      if (left.type !== right.type) {
        return false;
      }
      if (!left.key.isEqual(right.key)) {
        return false;
      }
      if (!left.precondition.isEqual(right.precondition)) {
        return false;
      }
      if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {
        return false;
      }
      if (left.type === 0) {
        return left.value.isEqual(right.value);
      }
      if (left.type === 1) {
        return left.data.isEqual(right.data) && left.fieldMask.isEqual(right.fieldMask);
      }
      return true;
    }
    function getPostMutationVersion(document2) {
      return document2.isFoundDocument() ? document2.version : SnapshotVersion.min();
    }
    var SetMutation = function(_super) {
      tslib.__extends(SetMutation2, _super);
      function SetMutation2(key, value, precondition, fieldTransforms) {
        if (fieldTransforms === void 0) {
          fieldTransforms = [];
        }
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.value = value;
        _this.precondition = precondition;
        _this.fieldTransforms = fieldTransforms;
        _this.type = 0;
        return _this;
      }
      return SetMutation2;
    }(Mutation);
    function applySetMutationToRemoteDocument(mutation, document2, mutationResult) {
      var newData = mutation.value.clone();
      var transformResults = serverTransformResults(mutation.fieldTransforms, document2, mutationResult.transformResults);
      newData.setAll(transformResults);
      document2.convertToFoundDocument(mutationResult.version, newData).setHasCommittedMutations();
    }
    function applySetMutationToLocalView(mutation, document2, localWriteTime) {
      if (!preconditionIsValidForDocument(mutation.precondition, document2)) {
        return;
      }
      var newData = mutation.value.clone();
      var transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document2);
      newData.setAll(transformResults);
      document2.convertToFoundDocument(getPostMutationVersion(document2), newData).setHasLocalMutations();
    }
    var PatchMutation = function(_super) {
      tslib.__extends(PatchMutation2, _super);
      function PatchMutation2(key, data, fieldMask, precondition, fieldTransforms) {
        if (fieldTransforms === void 0) {
          fieldTransforms = [];
        }
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.data = data;
        _this.fieldMask = fieldMask;
        _this.precondition = precondition;
        _this.fieldTransforms = fieldTransforms;
        _this.type = 1;
        return _this;
      }
      return PatchMutation2;
    }(Mutation);
    function applyPatchMutationToRemoteDocument(mutation, document2, mutationResult) {
      if (!preconditionIsValidForDocument(mutation.precondition, document2)) {
        document2.convertToUnknownDocument(mutationResult.version);
        return;
      }
      var transformResults = serverTransformResults(mutation.fieldTransforms, document2, mutationResult.transformResults);
      var newData = document2.data;
      newData.setAll(getPatch(mutation));
      newData.setAll(transformResults);
      document2.convertToFoundDocument(mutationResult.version, newData).setHasCommittedMutations();
    }
    function applyPatchMutationToLocalView(mutation, document2, localWriteTime) {
      if (!preconditionIsValidForDocument(mutation.precondition, document2)) {
        return;
      }
      var transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document2);
      var newData = document2.data;
      newData.setAll(getPatch(mutation));
      newData.setAll(transformResults);
      document2.convertToFoundDocument(getPostMutationVersion(document2), newData).setHasLocalMutations();
    }
    function getPatch(mutation) {
      var result = new Map();
      mutation.fieldMask.fields.forEach(function(fieldPath) {
        if (!fieldPath.isEmpty()) {
          var newValue = mutation.data.field(fieldPath);
          result.set(fieldPath, newValue);
        }
      });
      return result;
    }
    function serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults2) {
      var transformResults = new Map();
      hardAssert(fieldTransforms.length === serverTransformResults2.length);
      for (var i = 0; i < serverTransformResults2.length; i++) {
        var fieldTransform = fieldTransforms[i];
        var transform = fieldTransform.transform;
        var previousValue = mutableDocument.data.field(fieldTransform.field);
        transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults2[i]));
      }
      return transformResults;
    }
    function localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {
      var transformResults = new Map();
      for (var _i = 0, fieldTransforms_1 = fieldTransforms; _i < fieldTransforms_1.length; _i++) {
        var fieldTransform = fieldTransforms_1[_i];
        var transform = fieldTransform.transform;
        var previousValue = mutableDocument.data.field(fieldTransform.field);
        transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));
      }
      return transformResults;
    }
    var DeleteMutation = function(_super) {
      tslib.__extends(DeleteMutation2, _super);
      function DeleteMutation2(key, precondition) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.precondition = precondition;
        _this.type = 2;
        _this.fieldTransforms = [];
        return _this;
      }
      return DeleteMutation2;
    }(Mutation);
    function applyDeleteMutationToRemoteDocument(mutation, document2, mutationResult) {
      document2.convertToNoDocument(mutationResult.version).setHasCommittedMutations();
    }
    function applyDeleteMutationToLocalView(mutation, document2) {
      if (preconditionIsValidForDocument(mutation.precondition, document2)) {
        document2.convertToNoDocument(SnapshotVersion.min());
      }
    }
    var VerifyMutation = function(_super) {
      tslib.__extends(VerifyMutation2, _super);
      function VerifyMutation2(key, precondition) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.precondition = precondition;
        _this.type = 3;
        _this.fieldTransforms = [];
        return _this;
      }
      return VerifyMutation2;
    }(Mutation);
    var MutationBatch = function() {
      function MutationBatch2(batchId, localWriteTime, baseMutations, mutations) {
        this.batchId = batchId;
        this.localWriteTime = localWriteTime;
        this.baseMutations = baseMutations;
        this.mutations = mutations;
      }
      MutationBatch2.prototype.applyToRemoteDocument = function(document2, batchResult) {
        var mutationResults = batchResult.mutationResults;
        for (var i = 0; i < this.mutations.length; i++) {
          var mutation = this.mutations[i];
          if (mutation.key.isEqual(document2.key)) {
            var mutationResult = mutationResults[i];
            applyMutationToRemoteDocument(mutation, document2, mutationResult);
          }
        }
      };
      MutationBatch2.prototype.applyToLocalView = function(document2) {
        for (var _i = 0, _d = this.baseMutations; _i < _d.length; _i++) {
          var mutation = _d[_i];
          if (mutation.key.isEqual(document2.key)) {
            applyMutationToLocalView(mutation, document2, this.localWriteTime);
          }
        }
        for (var _e = 0, _f = this.mutations; _e < _f.length; _e++) {
          var mutation = _f[_e];
          if (mutation.key.isEqual(document2.key)) {
            applyMutationToLocalView(mutation, document2, this.localWriteTime);
          }
        }
      };
      MutationBatch2.prototype.applyToLocalDocumentSet = function(documentMap2) {
        var _this = this;
        this.mutations.forEach(function(m) {
          var document2 = documentMap2.get(m.key);
          var mutableDocument = document2;
          _this.applyToLocalView(mutableDocument);
          if (!document2.isValidDocument()) {
            mutableDocument.convertToNoDocument(SnapshotVersion.min());
          }
        });
      };
      MutationBatch2.prototype.keys = function() {
        return this.mutations.reduce(function(keys, m) {
          return keys.add(m.key);
        }, documentKeySet());
      };
      MutationBatch2.prototype.isEqual = function(other) {
        return this.batchId === other.batchId && arrayEquals(this.mutations, other.mutations, function(l, r) {
          return mutationEquals(l, r);
        }) && arrayEquals(this.baseMutations, other.baseMutations, function(l, r) {
          return mutationEquals(l, r);
        });
      };
      return MutationBatch2;
    }();
    var MutationBatchResult = function() {
      function MutationBatchResult2(batch, commitVersion, mutationResults, docVersions) {
        this.batch = batch;
        this.commitVersion = commitVersion;
        this.mutationResults = mutationResults;
        this.docVersions = docVersions;
      }
      MutationBatchResult2.from = function(batch, commitVersion, results) {
        hardAssert(batch.mutations.length === results.length);
        var versionMap = documentVersionMap();
        var mutations = batch.mutations;
        for (var i = 0; i < mutations.length; i++) {
          versionMap = versionMap.insert(mutations[i].key, results[i].version);
        }
        return new MutationBatchResult2(batch, commitVersion, results, versionMap);
      };
      return MutationBatchResult2;
    }();
    var ExistenceFilter = function() {
      function ExistenceFilter2(count) {
        this.count = count;
      }
      return ExistenceFilter2;
    }();
    var RpcCode;
    (function(RpcCode2) {
      RpcCode2[RpcCode2["OK"] = 0] = "OK";
      RpcCode2[RpcCode2["CANCELLED"] = 1] = "CANCELLED";
      RpcCode2[RpcCode2["UNKNOWN"] = 2] = "UNKNOWN";
      RpcCode2[RpcCode2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      RpcCode2[RpcCode2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      RpcCode2[RpcCode2["NOT_FOUND"] = 5] = "NOT_FOUND";
      RpcCode2[RpcCode2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      RpcCode2[RpcCode2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      RpcCode2[RpcCode2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
      RpcCode2[RpcCode2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      RpcCode2[RpcCode2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      RpcCode2[RpcCode2["ABORTED"] = 10] = "ABORTED";
      RpcCode2[RpcCode2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      RpcCode2[RpcCode2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      RpcCode2[RpcCode2["INTERNAL"] = 13] = "INTERNAL";
      RpcCode2[RpcCode2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      RpcCode2[RpcCode2["DATA_LOSS"] = 15] = "DATA_LOSS";
    })(RpcCode || (RpcCode = {}));
    function isPermanentError(code) {
      switch (code) {
        case Code.OK:
          return fail();
        case Code.CANCELLED:
        case Code.UNKNOWN:
        case Code.DEADLINE_EXCEEDED:
        case Code.RESOURCE_EXHAUSTED:
        case Code.INTERNAL:
        case Code.UNAVAILABLE:
        case Code.UNAUTHENTICATED:
          return false;
        case Code.INVALID_ARGUMENT:
        case Code.NOT_FOUND:
        case Code.ALREADY_EXISTS:
        case Code.PERMISSION_DENIED:
        case Code.FAILED_PRECONDITION:
        case Code.ABORTED:
        case Code.OUT_OF_RANGE:
        case Code.UNIMPLEMENTED:
        case Code.DATA_LOSS:
          return true;
        default:
          return fail();
      }
    }
    function isPermanentWriteError(code) {
      return isPermanentError(code) && code !== Code.ABORTED;
    }
    function mapCodeFromRpcCode(code) {
      if (code === void 0) {
        logError("GRPC error has no .code");
        return Code.UNKNOWN;
      }
      switch (code) {
        case RpcCode.OK:
          return Code.OK;
        case RpcCode.CANCELLED:
          return Code.CANCELLED;
        case RpcCode.UNKNOWN:
          return Code.UNKNOWN;
        case RpcCode.DEADLINE_EXCEEDED:
          return Code.DEADLINE_EXCEEDED;
        case RpcCode.RESOURCE_EXHAUSTED:
          return Code.RESOURCE_EXHAUSTED;
        case RpcCode.INTERNAL:
          return Code.INTERNAL;
        case RpcCode.UNAVAILABLE:
          return Code.UNAVAILABLE;
        case RpcCode.UNAUTHENTICATED:
          return Code.UNAUTHENTICATED;
        case RpcCode.INVALID_ARGUMENT:
          return Code.INVALID_ARGUMENT;
        case RpcCode.NOT_FOUND:
          return Code.NOT_FOUND;
        case RpcCode.ALREADY_EXISTS:
          return Code.ALREADY_EXISTS;
        case RpcCode.PERMISSION_DENIED:
          return Code.PERMISSION_DENIED;
        case RpcCode.FAILED_PRECONDITION:
          return Code.FAILED_PRECONDITION;
        case RpcCode.ABORTED:
          return Code.ABORTED;
        case RpcCode.OUT_OF_RANGE:
          return Code.OUT_OF_RANGE;
        case RpcCode.UNIMPLEMENTED:
          return Code.UNIMPLEMENTED;
        case RpcCode.DATA_LOSS:
          return Code.DATA_LOSS;
        default:
          return fail();
      }
    }
    var RemoteEvent = function() {
      function RemoteEvent2(snapshotVersion, targetChanges, targetMismatches, documentUpdates, resolvedLimboDocuments) {
        this.snapshotVersion = snapshotVersion;
        this.targetChanges = targetChanges;
        this.targetMismatches = targetMismatches;
        this.documentUpdates = documentUpdates;
        this.resolvedLimboDocuments = resolvedLimboDocuments;
      }
      RemoteEvent2.createSynthesizedRemoteEventForCurrentChange = function(targetId, current) {
        var targetChanges = new Map();
        targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current));
        return new RemoteEvent2(SnapshotVersion.min(), targetChanges, targetIdSet(), mutableDocumentMap(), documentKeySet());
      };
      return RemoteEvent2;
    }();
    var TargetChange = function() {
      function TargetChange2(resumeToken, current, addedDocuments, modifiedDocuments, removedDocuments) {
        this.resumeToken = resumeToken;
        this.current = current;
        this.addedDocuments = addedDocuments;
        this.modifiedDocuments = modifiedDocuments;
        this.removedDocuments = removedDocuments;
      }
      TargetChange2.createSynthesizedTargetChangeForCurrentChange = function(targetId, current) {
        return new TargetChange2(ByteString.EMPTY_BYTE_STRING, current, documentKeySet(), documentKeySet(), documentKeySet());
      };
      return TargetChange2;
    }();
    var DocumentWatchChange = function() {
      function DocumentWatchChange2(updatedTargetIds, removedTargetIds, key, newDoc) {
        this.updatedTargetIds = updatedTargetIds;
        this.removedTargetIds = removedTargetIds;
        this.key = key;
        this.newDoc = newDoc;
      }
      return DocumentWatchChange2;
    }();
    var ExistenceFilterChange = function() {
      function ExistenceFilterChange2(targetId, existenceFilter) {
        this.targetId = targetId;
        this.existenceFilter = existenceFilter;
      }
      return ExistenceFilterChange2;
    }();
    var WatchTargetChange = function() {
      function WatchTargetChange2(state, targetIds, resumeToken, cause) {
        if (resumeToken === void 0) {
          resumeToken = ByteString.EMPTY_BYTE_STRING;
        }
        if (cause === void 0) {
          cause = null;
        }
        this.state = state;
        this.targetIds = targetIds;
        this.resumeToken = resumeToken;
        this.cause = cause;
      }
      return WatchTargetChange2;
    }();
    var TargetState = function() {
      function TargetState2() {
        this.pendingResponses = 0;
        this.documentChanges = snapshotChangesMap();
        this._resumeToken = ByteString.EMPTY_BYTE_STRING;
        this._current = false;
        this._hasPendingChanges = true;
      }
      Object.defineProperty(TargetState2.prototype, "current", {
        get: function() {
          return this._current;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TargetState2.prototype, "resumeToken", {
        get: function() {
          return this._resumeToken;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TargetState2.prototype, "isPending", {
        get: function() {
          return this.pendingResponses !== 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TargetState2.prototype, "hasPendingChanges", {
        get: function() {
          return this._hasPendingChanges;
        },
        enumerable: false,
        configurable: true
      });
      TargetState2.prototype.updateResumeToken = function(resumeToken) {
        if (resumeToken.approximateByteSize() > 0) {
          this._hasPendingChanges = true;
          this._resumeToken = resumeToken;
        }
      };
      TargetState2.prototype.toTargetChange = function() {
        var addedDocuments = documentKeySet();
        var modifiedDocuments = documentKeySet();
        var removedDocuments = documentKeySet();
        this.documentChanges.forEach(function(key, changeType) {
          switch (changeType) {
            case 0:
              addedDocuments = addedDocuments.add(key);
              break;
            case 2:
              modifiedDocuments = modifiedDocuments.add(key);
              break;
            case 1:
              removedDocuments = removedDocuments.add(key);
              break;
            default:
              fail();
          }
        });
        return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);
      };
      TargetState2.prototype.clearPendingChanges = function() {
        this._hasPendingChanges = false;
        this.documentChanges = snapshotChangesMap();
      };
      TargetState2.prototype.addDocumentChange = function(key, changeType) {
        this._hasPendingChanges = true;
        this.documentChanges = this.documentChanges.insert(key, changeType);
      };
      TargetState2.prototype.removeDocumentChange = function(key) {
        this._hasPendingChanges = true;
        this.documentChanges = this.documentChanges.remove(key);
      };
      TargetState2.prototype.recordPendingTargetRequest = function() {
        this.pendingResponses += 1;
      };
      TargetState2.prototype.recordTargetResponse = function() {
        this.pendingResponses -= 1;
      };
      TargetState2.prototype.markCurrent = function() {
        this._hasPendingChanges = true;
        this._current = true;
      };
      return TargetState2;
    }();
    var LOG_TAG$f = "WatchChangeAggregator";
    var WatchChangeAggregator = function() {
      function WatchChangeAggregator2(metadataProvider) {
        this.metadataProvider = metadataProvider;
        this.targetStates = new Map();
        this.pendingDocumentUpdates = mutableDocumentMap();
        this.pendingDocumentTargetMapping = documentTargetMap();
        this.pendingTargetResets = new SortedSet(primitiveComparator);
      }
      WatchChangeAggregator2.prototype.handleDocumentChange = function(docChange) {
        for (var _i = 0, _d = docChange.updatedTargetIds; _i < _d.length; _i++) {
          var targetId = _d[_i];
          if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {
            this.addDocumentToTarget(targetId, docChange.newDoc);
          } else {
            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
          }
        }
        for (var _e = 0, _f = docChange.removedTargetIds; _e < _f.length; _e++) {
          var targetId = _f[_e];
          this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
        }
      };
      WatchChangeAggregator2.prototype.handleTargetChange = function(targetChange) {
        var _this = this;
        this.forEachTarget(targetChange, function(targetId) {
          var targetState = _this.ensureTargetState(targetId);
          switch (targetChange.state) {
            case 0:
              if (_this.isActiveTarget(targetId)) {
                targetState.updateResumeToken(targetChange.resumeToken);
              }
              break;
            case 1:
              targetState.recordTargetResponse();
              if (!targetState.isPending) {
                targetState.clearPendingChanges();
              }
              targetState.updateResumeToken(targetChange.resumeToken);
              break;
            case 2:
              targetState.recordTargetResponse();
              if (!targetState.isPending) {
                _this.removeTarget(targetId);
              }
              break;
            case 3:
              if (_this.isActiveTarget(targetId)) {
                targetState.markCurrent();
                targetState.updateResumeToken(targetChange.resumeToken);
              }
              break;
            case 4:
              if (_this.isActiveTarget(targetId)) {
                _this.resetTarget(targetId);
                targetState.updateResumeToken(targetChange.resumeToken);
              }
              break;
            default:
              fail();
          }
        });
      };
      WatchChangeAggregator2.prototype.forEachTarget = function(targetChange, fn) {
        var _this = this;
        if (targetChange.targetIds.length > 0) {
          targetChange.targetIds.forEach(fn);
        } else {
          this.targetStates.forEach(function(_, targetId) {
            if (_this.isActiveTarget(targetId)) {
              fn(targetId);
            }
          });
        }
      };
      WatchChangeAggregator2.prototype.handleExistenceFilter = function(watchChange) {
        var targetId = watchChange.targetId;
        var expectedCount = watchChange.existenceFilter.count;
        var targetData = this.targetDataForActiveTarget(targetId);
        if (targetData) {
          var target = targetData.target;
          if (isDocumentTarget(target)) {
            if (expectedCount === 0) {
              var key = new DocumentKey(target.path);
              this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));
            } else {
              hardAssert(expectedCount === 1);
            }
          } else {
            var currentSize = this.getCurrentDocumentCountForTarget(targetId);
            if (currentSize !== expectedCount) {
              this.resetTarget(targetId);
              this.pendingTargetResets = this.pendingTargetResets.add(targetId);
            }
          }
        }
      };
      WatchChangeAggregator2.prototype.createRemoteEvent = function(snapshotVersion) {
        var _this = this;
        var targetChanges = new Map();
        this.targetStates.forEach(function(targetState, targetId) {
          var targetData = _this.targetDataForActiveTarget(targetId);
          if (targetData) {
            if (targetState.current && isDocumentTarget(targetData.target)) {
              var key = new DocumentKey(targetData.target.path);
              if (_this.pendingDocumentUpdates.get(key) === null && !_this.targetContainsDocument(targetId, key)) {
                _this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));
              }
            }
            if (targetState.hasPendingChanges) {
              targetChanges.set(targetId, targetState.toTargetChange());
              targetState.clearPendingChanges();
            }
          }
        });
        var resolvedLimboDocuments = documentKeySet();
        this.pendingDocumentTargetMapping.forEach(function(key, targets) {
          var isOnlyLimboTarget = true;
          targets.forEachWhile(function(targetId) {
            var targetData = _this.targetDataForActiveTarget(targetId);
            if (targetData && targetData.purpose !== 2) {
              isOnlyLimboTarget = false;
              return false;
            }
            return true;
          });
          if (isOnlyLimboTarget) {
            resolvedLimboDocuments = resolvedLimboDocuments.add(key);
          }
        });
        var remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);
        this.pendingDocumentUpdates = mutableDocumentMap();
        this.pendingDocumentTargetMapping = documentTargetMap();
        this.pendingTargetResets = new SortedSet(primitiveComparator);
        return remoteEvent;
      };
      WatchChangeAggregator2.prototype.addDocumentToTarget = function(targetId, document2) {
        if (!this.isActiveTarget(targetId)) {
          return;
        }
        var changeType = this.targetContainsDocument(targetId, document2.key) ? 2 : 0;
        var targetState = this.ensureTargetState(targetId);
        targetState.addDocumentChange(document2.key, changeType);
        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document2.key, document2);
        this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(document2.key, this.ensureDocumentTargetMapping(document2.key).add(targetId));
      };
      WatchChangeAggregator2.prototype.removeDocumentFromTarget = function(targetId, key, updatedDocument) {
        if (!this.isActiveTarget(targetId)) {
          return;
        }
        var targetState = this.ensureTargetState(targetId);
        if (this.targetContainsDocument(targetId, key)) {
          targetState.addDocumentChange(key, 1);
        } else {
          targetState.removeDocumentChange(key);
        }
        this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));
        if (updatedDocument) {
          this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);
        }
      };
      WatchChangeAggregator2.prototype.removeTarget = function(targetId) {
        this.targetStates.delete(targetId);
      };
      WatchChangeAggregator2.prototype.getCurrentDocumentCountForTarget = function(targetId) {
        var targetState = this.ensureTargetState(targetId);
        var targetChange = targetState.toTargetChange();
        return this.metadataProvider.getRemoteKeysForTarget(targetId).size + targetChange.addedDocuments.size - targetChange.removedDocuments.size;
      };
      WatchChangeAggregator2.prototype.recordPendingTargetRequest = function(targetId) {
        var targetState = this.ensureTargetState(targetId);
        targetState.recordPendingTargetRequest();
      };
      WatchChangeAggregator2.prototype.ensureTargetState = function(targetId) {
        var result = this.targetStates.get(targetId);
        if (!result) {
          result = new TargetState();
          this.targetStates.set(targetId, result);
        }
        return result;
      };
      WatchChangeAggregator2.prototype.ensureDocumentTargetMapping = function(key) {
        var targetMapping = this.pendingDocumentTargetMapping.get(key);
        if (!targetMapping) {
          targetMapping = new SortedSet(primitiveComparator);
          this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, targetMapping);
        }
        return targetMapping;
      };
      WatchChangeAggregator2.prototype.isActiveTarget = function(targetId) {
        var targetActive = this.targetDataForActiveTarget(targetId) !== null;
        if (!targetActive) {
          logDebug(LOG_TAG$f, "Detected inactive target", targetId);
        }
        return targetActive;
      };
      WatchChangeAggregator2.prototype.targetDataForActiveTarget = function(targetId) {
        var targetState = this.targetStates.get(targetId);
        return targetState && targetState.isPending ? null : this.metadataProvider.getTargetDataForTarget(targetId);
      };
      WatchChangeAggregator2.prototype.resetTarget = function(targetId) {
        var _this = this;
        this.targetStates.set(targetId, new TargetState());
        var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
        existingKeys.forEach(function(key) {
          _this.removeDocumentFromTarget(targetId, key, null);
        });
      };
      WatchChangeAggregator2.prototype.targetContainsDocument = function(targetId, key) {
        var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
        return existingKeys.has(key);
      };
      return WatchChangeAggregator2;
    }();
    function documentTargetMap() {
      return new SortedMap(DocumentKey.comparator);
    }
    function snapshotChangesMap() {
      return new SortedMap(DocumentKey.comparator);
    }
    var DIRECTIONS = function() {
      var dirs = {};
      dirs["asc"] = "ASCENDING";
      dirs["desc"] = "DESCENDING";
      return dirs;
    }();
    var OPERATORS = function() {
      var ops = {};
      ops["<"] = "LESS_THAN";
      ops["<="] = "LESS_THAN_OR_EQUAL";
      ops[">"] = "GREATER_THAN";
      ops[">="] = "GREATER_THAN_OR_EQUAL";
      ops["=="] = "EQUAL";
      ops["!="] = "NOT_EQUAL";
      ops["array-contains"] = "ARRAY_CONTAINS";
      ops["in"] = "IN";
      ops["not-in"] = "NOT_IN";
      ops["array-contains-any"] = "ARRAY_CONTAINS_ANY";
      return ops;
    }();
    function assertPresent(value, description) {
    }
    var JsonProtoSerializer = function() {
      function JsonProtoSerializer2(databaseId, useProto3Json) {
        this.databaseId = databaseId;
        this.useProto3Json = useProto3Json;
      }
      return JsonProtoSerializer2;
    }();
    function fromRpcStatus(status) {
      var code = status.code === void 0 ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);
      return new FirestoreError(code, status.message || "");
    }
    function toInt32Proto(serializer, val) {
      if (serializer.useProto3Json || isNullOrUndefined(val)) {
        return val;
      } else {
        return { value: val };
      }
    }
    function fromInt32Proto(val) {
      var result;
      if (typeof val === "object") {
        result = val.value;
      } else {
        result = val;
      }
      return isNullOrUndefined(result) ? null : result;
    }
    function toTimestamp(serializer, timestamp) {
      if (serializer.useProto3Json) {
        var jsDateStr = new Date(timestamp.seconds * 1e3).toISOString();
        var strUntilSeconds = jsDateStr.replace(/\.\d*/, "").replace("Z", "");
        var nanoStr = ("000000000" + timestamp.nanoseconds).slice(-9);
        return strUntilSeconds + "." + nanoStr + "Z";
      } else {
        return {
          seconds: "" + timestamp.seconds,
          nanos: timestamp.nanoseconds
        };
      }
    }
    function fromTimestamp(date) {
      var timestamp = normalizeTimestamp(date);
      return new Timestamp(timestamp.seconds, timestamp.nanos);
    }
    function toBytes(serializer, bytes) {
      if (serializer.useProto3Json) {
        return bytes.toBase64();
      } else {
        return bytes.toUint8Array();
      }
    }
    function fromBytes(serializer, value) {
      if (serializer.useProto3Json) {
        hardAssert(value === void 0 || typeof value === "string");
        return ByteString.fromBase64String(value ? value : "");
      } else {
        hardAssert(value === void 0 || value instanceof Uint8Array);
        return ByteString.fromUint8Array(value ? value : new Uint8Array());
      }
    }
    function toVersion(serializer, version2) {
      return toTimestamp(serializer, version2.toTimestamp());
    }
    function fromVersion(version2) {
      hardAssert(!!version2);
      return SnapshotVersion.fromTimestamp(fromTimestamp(version2));
    }
    function toResourceName(databaseId, path2) {
      return fullyQualifiedPrefixPath(databaseId).child("documents").child(path2).canonicalString();
    }
    function fromResourceName(name) {
      var resource = ResourcePath.fromString(name);
      hardAssert(isValidResourceName(resource));
      return resource;
    }
    function toName(serializer, key) {
      return toResourceName(serializer.databaseId, key.path);
    }
    function fromName(serializer, name) {
      var resource = fromResourceName(name);
      if (resource.get(1) !== serializer.databaseId.projectId) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + resource.get(1) + " vs " + serializer.databaseId.projectId);
      }
      if (resource.get(3) !== serializer.databaseId.database) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + resource.get(3) + " vs " + serializer.databaseId.database);
      }
      return new DocumentKey(extractLocalPathFromResourceName(resource));
    }
    function toQueryPath(serializer, path2) {
      return toResourceName(serializer.databaseId, path2);
    }
    function fromQueryPath(name) {
      var resourceName = fromResourceName(name);
      if (resourceName.length === 4) {
        return ResourcePath.emptyPath();
      }
      return extractLocalPathFromResourceName(resourceName);
    }
    function getEncodedDatabaseId(serializer) {
      var path2 = new ResourcePath([
        "projects",
        serializer.databaseId.projectId,
        "databases",
        serializer.databaseId.database
      ]);
      return path2.canonicalString();
    }
    function fullyQualifiedPrefixPath(databaseId) {
      return new ResourcePath([
        "projects",
        databaseId.projectId,
        "databases",
        databaseId.database
      ]);
    }
    function extractLocalPathFromResourceName(resourceName) {
      hardAssert(resourceName.length > 4 && resourceName.get(4) === "documents");
      return resourceName.popFirst(5);
    }
    function toMutationDocument(serializer, key, fields) {
      return {
        name: toName(serializer, key),
        fields: fields.value.mapValue.fields
      };
    }
    function toDocument(serializer, document2) {
      return {
        name: toName(serializer, document2.key),
        fields: document2.data.value.mapValue.fields,
        updateTime: toTimestamp(serializer, document2.version.toTimestamp())
      };
    }
    function fromDocument(serializer, document2, hasCommittedMutations) {
      var key = fromName(serializer, document2.name);
      var version2 = fromVersion(document2.updateTime);
      var data = new ObjectValue({ mapValue: { fields: document2.fields } });
      var result = MutableDocument.newFoundDocument(key, version2, data);
      if (hasCommittedMutations) {
        result.setHasCommittedMutations();
      }
      return hasCommittedMutations ? result.setHasCommittedMutations() : result;
    }
    function fromFound(serializer, doc2) {
      hardAssert(!!doc2.found);
      assertPresent(doc2.found.name);
      assertPresent(doc2.found.updateTime);
      var key = fromName(serializer, doc2.found.name);
      var version2 = fromVersion(doc2.found.updateTime);
      var data = new ObjectValue({ mapValue: { fields: doc2.found.fields } });
      return MutableDocument.newFoundDocument(key, version2, data);
    }
    function fromMissing(serializer, result) {
      hardAssert(!!result.missing);
      hardAssert(!!result.readTime);
      var key = fromName(serializer, result.missing);
      var version2 = fromVersion(result.readTime);
      return MutableDocument.newNoDocument(key, version2);
    }
    function fromBatchGetDocumentsResponse(serializer, result) {
      if ("found" in result) {
        return fromFound(serializer, result);
      } else if ("missing" in result) {
        return fromMissing(serializer, result);
      }
      return fail();
    }
    function fromWatchChange(serializer, change) {
      var watchChange;
      if ("targetChange" in change) {
        assertPresent(change.targetChange);
        var state = fromWatchTargetChangeState(change.targetChange.targetChangeType || "NO_CHANGE");
        var targetIds = change.targetChange.targetIds || [];
        var resumeToken = fromBytes(serializer, change.targetChange.resumeToken);
        var causeProto = change.targetChange.cause;
        var cause = causeProto && fromRpcStatus(causeProto);
        watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);
      } else if ("documentChange" in change) {
        assertPresent(change.documentChange);
        var entityChange = change.documentChange;
        assertPresent(entityChange.document);
        assertPresent(entityChange.document.name);
        assertPresent(entityChange.document.updateTime);
        var key = fromName(serializer, entityChange.document.name);
        var version_1 = fromVersion(entityChange.document.updateTime);
        var data = new ObjectValue({
          mapValue: { fields: entityChange.document.fields }
        });
        var doc_1 = MutableDocument.newFoundDocument(key, version_1, data);
        var updatedTargetIds = entityChange.targetIds || [];
        var removedTargetIds = entityChange.removedTargetIds || [];
        watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc_1.key, doc_1);
      } else if ("documentDelete" in change) {
        assertPresent(change.documentDelete);
        var docDelete = change.documentDelete;
        assertPresent(docDelete.document);
        var key = fromName(serializer, docDelete.document);
        var version_2 = docDelete.readTime ? fromVersion(docDelete.readTime) : SnapshotVersion.min();
        var doc_2 = MutableDocument.newNoDocument(key, version_2);
        var removedTargetIds = docDelete.removedTargetIds || [];
        watchChange = new DocumentWatchChange([], removedTargetIds, doc_2.key, doc_2);
      } else if ("documentRemove" in change) {
        assertPresent(change.documentRemove);
        var docRemove = change.documentRemove;
        assertPresent(docRemove.document);
        var key = fromName(serializer, docRemove.document);
        var removedTargetIds = docRemove.removedTargetIds || [];
        watchChange = new DocumentWatchChange([], removedTargetIds, key, null);
      } else if ("filter" in change) {
        assertPresent(change.filter);
        var filter = change.filter;
        assertPresent(filter.targetId);
        var count = filter.count || 0;
        var existenceFilter = new ExistenceFilter(count);
        var targetId = filter.targetId;
        watchChange = new ExistenceFilterChange(targetId, existenceFilter);
      } else {
        return fail();
      }
      return watchChange;
    }
    function fromWatchTargetChangeState(state) {
      if (state === "NO_CHANGE") {
        return 0;
      } else if (state === "ADD") {
        return 1;
      } else if (state === "REMOVE") {
        return 2;
      } else if (state === "CURRENT") {
        return 3;
      } else if (state === "RESET") {
        return 4;
      } else {
        return fail();
      }
    }
    function versionFromListenResponse(change) {
      if (!("targetChange" in change)) {
        return SnapshotVersion.min();
      }
      var targetChange = change.targetChange;
      if (targetChange.targetIds && targetChange.targetIds.length) {
        return SnapshotVersion.min();
      }
      if (!targetChange.readTime) {
        return SnapshotVersion.min();
      }
      return fromVersion(targetChange.readTime);
    }
    function toMutation(serializer, mutation) {
      var result;
      if (mutation instanceof SetMutation) {
        result = {
          update: toMutationDocument(serializer, mutation.key, mutation.value)
        };
      } else if (mutation instanceof DeleteMutation) {
        result = { delete: toName(serializer, mutation.key) };
      } else if (mutation instanceof PatchMutation) {
        result = {
          update: toMutationDocument(serializer, mutation.key, mutation.data),
          updateMask: toDocumentMask(mutation.fieldMask)
        };
      } else if (mutation instanceof VerifyMutation) {
        result = {
          verify: toName(serializer, mutation.key)
        };
      } else {
        return fail();
      }
      if (mutation.fieldTransforms.length > 0) {
        result.updateTransforms = mutation.fieldTransforms.map(function(transform) {
          return toFieldTransform(serializer, transform);
        });
      }
      if (!mutation.precondition.isNone) {
        result.currentDocument = toPrecondition(serializer, mutation.precondition);
      }
      return result;
    }
    function fromMutation(serializer, proto) {
      var precondition = proto.currentDocument ? fromPrecondition(proto.currentDocument) : Precondition.none();
      var fieldTransforms = proto.updateTransforms ? proto.updateTransforms.map(function(transform) {
        return fromFieldTransform(serializer, transform);
      }) : [];
      if (proto.update) {
        assertPresent(proto.update.name);
        var key = fromName(serializer, proto.update.name);
        var value = new ObjectValue({
          mapValue: { fields: proto.update.fields }
        });
        if (proto.updateMask) {
          var fieldMask = fromDocumentMask(proto.updateMask);
          return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);
        } else {
          return new SetMutation(key, value, precondition, fieldTransforms);
        }
      } else if (proto.delete) {
        var key = fromName(serializer, proto.delete);
        return new DeleteMutation(key, precondition);
      } else if (proto.verify) {
        var key = fromName(serializer, proto.verify);
        return new VerifyMutation(key, precondition);
      } else {
        return fail();
      }
    }
    function toPrecondition(serializer, precondition) {
      if (precondition.updateTime !== void 0) {
        return {
          updateTime: toVersion(serializer, precondition.updateTime)
        };
      } else if (precondition.exists !== void 0) {
        return { exists: precondition.exists };
      } else {
        return fail();
      }
    }
    function fromPrecondition(precondition) {
      if (precondition.updateTime !== void 0) {
        return Precondition.updateTime(fromVersion(precondition.updateTime));
      } else if (precondition.exists !== void 0) {
        return Precondition.exists(precondition.exists);
      } else {
        return Precondition.none();
      }
    }
    function fromWriteResult(proto, commitTime) {
      var version2 = proto.updateTime ? fromVersion(proto.updateTime) : fromVersion(commitTime);
      if (version2.isEqual(SnapshotVersion.min())) {
        version2 = fromVersion(commitTime);
      }
      return new MutationResult(version2, proto.transformResults || []);
    }
    function fromWriteResults(protos, commitTime) {
      if (protos && protos.length > 0) {
        hardAssert(commitTime !== void 0);
        return protos.map(function(proto) {
          return fromWriteResult(proto, commitTime);
        });
      } else {
        return [];
      }
    }
    function toFieldTransform(serializer, fieldTransform) {
      var transform = fieldTransform.transform;
      if (transform instanceof ServerTimestampTransform) {
        return {
          fieldPath: fieldTransform.field.canonicalString(),
          setToServerValue: "REQUEST_TIME"
        };
      } else if (transform instanceof ArrayUnionTransformOperation) {
        return {
          fieldPath: fieldTransform.field.canonicalString(),
          appendMissingElements: {
            values: transform.elements
          }
        };
      } else if (transform instanceof ArrayRemoveTransformOperation) {
        return {
          fieldPath: fieldTransform.field.canonicalString(),
          removeAllFromArray: {
            values: transform.elements
          }
        };
      } else if (transform instanceof NumericIncrementTransformOperation) {
        return {
          fieldPath: fieldTransform.field.canonicalString(),
          increment: transform.operand
        };
      } else {
        throw fail();
      }
    }
    function fromFieldTransform(serializer, proto) {
      var transform = null;
      if ("setToServerValue" in proto) {
        hardAssert(proto.setToServerValue === "REQUEST_TIME");
        transform = new ServerTimestampTransform();
      } else if ("appendMissingElements" in proto) {
        var values = proto.appendMissingElements.values || [];
        transform = new ArrayUnionTransformOperation(values);
      } else if ("removeAllFromArray" in proto) {
        var values = proto.removeAllFromArray.values || [];
        transform = new ArrayRemoveTransformOperation(values);
      } else if ("increment" in proto) {
        transform = new NumericIncrementTransformOperation(serializer, proto.increment);
      } else {
        fail();
      }
      var fieldPath = FieldPath$1.fromServerFormat(proto.fieldPath);
      return new FieldTransform(fieldPath, transform);
    }
    function toDocumentsTarget(serializer, target) {
      return { documents: [toQueryPath(serializer, target.path)] };
    }
    function fromDocumentsTarget(documentsTarget) {
      var count = documentsTarget.documents.length;
      hardAssert(count === 1);
      var name = documentsTarget.documents[0];
      return queryToTarget(newQueryForPath(fromQueryPath(name)));
    }
    function toQueryTarget(serializer, target) {
      var result = { structuredQuery: {} };
      var path2 = target.path;
      if (target.collectionGroup !== null) {
        result.parent = toQueryPath(serializer, path2);
        result.structuredQuery.from = [
          {
            collectionId: target.collectionGroup,
            allDescendants: true
          }
        ];
      } else {
        result.parent = toQueryPath(serializer, path2.popLast());
        result.structuredQuery.from = [{ collectionId: path2.lastSegment() }];
      }
      var where2 = toFilter(target.filters);
      if (where2) {
        result.structuredQuery.where = where2;
      }
      var orderBy2 = toOrder(target.orderBy);
      if (orderBy2) {
        result.structuredQuery.orderBy = orderBy2;
      }
      var limit2 = toInt32Proto(serializer, target.limit);
      if (limit2 !== null) {
        result.structuredQuery.limit = limit2;
      }
      if (target.startAt) {
        result.structuredQuery.startAt = toCursor(target.startAt);
      }
      if (target.endAt) {
        result.structuredQuery.endAt = toCursor(target.endAt);
      }
      return result;
    }
    function convertQueryTargetToQuery(target) {
      var path2 = fromQueryPath(target.parent);
      var query2 = target.structuredQuery;
      var fromCount = query2.from ? query2.from.length : 0;
      var collectionGroup2 = null;
      if (fromCount > 0) {
        hardAssert(fromCount === 1);
        var from = query2.from[0];
        if (from.allDescendants) {
          collectionGroup2 = from.collectionId;
        } else {
          path2 = path2.child(from.collectionId);
        }
      }
      var filterBy = [];
      if (query2.where) {
        filterBy = fromFilter(query2.where);
      }
      var orderBy2 = [];
      if (query2.orderBy) {
        orderBy2 = fromOrder(query2.orderBy);
      }
      var limit2 = null;
      if (query2.limit) {
        limit2 = fromInt32Proto(query2.limit);
      }
      var startAt2 = null;
      if (query2.startAt) {
        startAt2 = fromCursor(query2.startAt);
      }
      var endAt2 = null;
      if (query2.endAt) {
        endAt2 = fromCursor(query2.endAt);
      }
      return newQuery(path2, collectionGroup2, orderBy2, filterBy, limit2, "F", startAt2, endAt2);
    }
    function fromQueryTarget(target) {
      return queryToTarget(convertQueryTargetToQuery(target));
    }
    function toListenRequestLabels(serializer, targetData) {
      var value = toLabel(serializer, targetData.purpose);
      if (value == null) {
        return null;
      } else {
        return {
          "goog-listen-tags": value
        };
      }
    }
    function toLabel(serializer, purpose) {
      switch (purpose) {
        case 0:
          return null;
        case 1:
          return "existence-filter-mismatch";
        case 2:
          return "limbo-document";
        default:
          return fail();
      }
    }
    function toTarget(serializer, targetData) {
      var result;
      var target = targetData.target;
      if (isDocumentTarget(target)) {
        result = { documents: toDocumentsTarget(serializer, target) };
      } else {
        result = { query: toQueryTarget(serializer, target) };
      }
      result.targetId = targetData.targetId;
      if (targetData.resumeToken.approximateByteSize() > 0) {
        result.resumeToken = toBytes(serializer, targetData.resumeToken);
      } else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
        result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());
      }
      return result;
    }
    function toFilter(filters) {
      if (filters.length === 0) {
        return;
      }
      var protos = filters.map(function(filter) {
        return toUnaryOrFieldFilter(filter);
      });
      if (protos.length === 1) {
        return protos[0];
      }
      return { compositeFilter: { op: "AND", filters: protos } };
    }
    function fromFilter(filter) {
      if (!filter) {
        return [];
      } else if (filter.unaryFilter !== void 0) {
        return [fromUnaryFilter(filter)];
      } else if (filter.fieldFilter !== void 0) {
        return [fromFieldFilter(filter)];
      } else if (filter.compositeFilter !== void 0) {
        return filter.compositeFilter.filters.map(function(f) {
          return fromFilter(f);
        }).reduce(function(accum, current) {
          return accum.concat(current);
        });
      } else {
        return fail();
      }
    }
    function toOrder(orderBys) {
      if (orderBys.length === 0) {
        return;
      }
      return orderBys.map(function(order) {
        return toPropertyOrder(order);
      });
    }
    function fromOrder(orderBys) {
      return orderBys.map(function(order) {
        return fromPropertyOrder(order);
      });
    }
    function toCursor(cursor) {
      return {
        before: cursor.before,
        values: cursor.position
      };
    }
    function fromCursor(cursor) {
      var before = !!cursor.before;
      var position = cursor.values || [];
      return new Bound(position, before);
    }
    function toDirection(dir) {
      return DIRECTIONS[dir];
    }
    function fromDirection(dir) {
      switch (dir) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return void 0;
      }
    }
    function toOperatorName(op) {
      return OPERATORS[op];
    }
    function fromOperatorName(op) {
      switch (op) {
        case "EQUAL":
          return "==";
        case "NOT_EQUAL":
          return "!=";
        case "GREATER_THAN":
          return ">";
        case "GREATER_THAN_OR_EQUAL":
          return ">=";
        case "LESS_THAN":
          return "<";
        case "LESS_THAN_OR_EQUAL":
          return "<=";
        case "ARRAY_CONTAINS":
          return "array-contains";
        case "IN":
          return "in";
        case "NOT_IN":
          return "not-in";
        case "ARRAY_CONTAINS_ANY":
          return "array-contains-any";
        case "OPERATOR_UNSPECIFIED":
          return fail();
        default:
          return fail();
      }
    }
    function toFieldPathReference(path2) {
      return { fieldPath: path2.canonicalString() };
    }
    function fromFieldPathReference(fieldReference) {
      return FieldPath$1.fromServerFormat(fieldReference.fieldPath);
    }
    function toPropertyOrder(orderBy2) {
      return {
        field: toFieldPathReference(orderBy2.field),
        direction: toDirection(orderBy2.dir)
      };
    }
    function fromPropertyOrder(orderBy2) {
      return new OrderBy(fromFieldPathReference(orderBy2.field), fromDirection(orderBy2.direction));
    }
    function fromFieldFilter(filter) {
      return FieldFilter.create(fromFieldPathReference(filter.fieldFilter.field), fromOperatorName(filter.fieldFilter.op), filter.fieldFilter.value);
    }
    function toUnaryOrFieldFilter(filter) {
      if (filter.op === "==") {
        if (isNanValue(filter.value)) {
          return {
            unaryFilter: {
              field: toFieldPathReference(filter.field),
              op: "IS_NAN"
            }
          };
        } else if (isNullValue(filter.value)) {
          return {
            unaryFilter: {
              field: toFieldPathReference(filter.field),
              op: "IS_NULL"
            }
          };
        }
      } else if (filter.op === "!=") {
        if (isNanValue(filter.value)) {
          return {
            unaryFilter: {
              field: toFieldPathReference(filter.field),
              op: "IS_NOT_NAN"
            }
          };
        } else if (isNullValue(filter.value)) {
          return {
            unaryFilter: {
              field: toFieldPathReference(filter.field),
              op: "IS_NOT_NULL"
            }
          };
        }
      }
      return {
        fieldFilter: {
          field: toFieldPathReference(filter.field),
          op: toOperatorName(filter.op),
          value: filter.value
        }
      };
    }
    function fromUnaryFilter(filter) {
      switch (filter.unaryFilter.op) {
        case "IS_NAN":
          var nanField = fromFieldPathReference(filter.unaryFilter.field);
          return FieldFilter.create(nanField, "==", {
            doubleValue: NaN
          });
        case "IS_NULL":
          var nullField = fromFieldPathReference(filter.unaryFilter.field);
          return FieldFilter.create(nullField, "==", {
            nullValue: "NULL_VALUE"
          });
        case "IS_NOT_NAN":
          var notNanField = fromFieldPathReference(filter.unaryFilter.field);
          return FieldFilter.create(notNanField, "!=", {
            doubleValue: NaN
          });
        case "IS_NOT_NULL":
          var notNullField = fromFieldPathReference(filter.unaryFilter.field);
          return FieldFilter.create(notNullField, "!=", {
            nullValue: "NULL_VALUE"
          });
        case "OPERATOR_UNSPECIFIED":
          return fail();
        default:
          return fail();
      }
    }
    function toDocumentMask(fieldMask) {
      var canonicalFields = [];
      fieldMask.fields.forEach(function(field) {
        return canonicalFields.push(field.canonicalString());
      });
      return {
        fieldPaths: canonicalFields
      };
    }
    function fromDocumentMask(proto) {
      var paths = proto.fieldPaths || [];
      return new FieldMask(paths.map(function(path2) {
        return FieldPath$1.fromServerFormat(path2);
      }));
    }
    function isValidResourceName(path2) {
      return path2.length >= 4 && path2.get(0) === "projects" && path2.get(2) === "databases";
    }
    var TargetData = function() {
      function TargetData2(target, targetId, purpose, sequenceNumber, snapshotVersion, lastLimboFreeSnapshotVersion, resumeToken) {
        if (snapshotVersion === void 0) {
          snapshotVersion = SnapshotVersion.min();
        }
        if (lastLimboFreeSnapshotVersion === void 0) {
          lastLimboFreeSnapshotVersion = SnapshotVersion.min();
        }
        if (resumeToken === void 0) {
          resumeToken = ByteString.EMPTY_BYTE_STRING;
        }
        this.target = target;
        this.targetId = targetId;
        this.purpose = purpose;
        this.sequenceNumber = sequenceNumber;
        this.snapshotVersion = snapshotVersion;
        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;
        this.resumeToken = resumeToken;
      }
      TargetData2.prototype.withSequenceNumber = function(sequenceNumber) {
        return new TargetData2(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
      };
      TargetData2.prototype.withResumeToken = function(resumeToken, snapshotVersion) {
        return new TargetData2(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken);
      };
      TargetData2.prototype.withLastLimboFreeSnapshotVersion = function(lastLimboFreeSnapshotVersion) {
        return new TargetData2(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken);
      };
      return TargetData2;
    }();
    var LocalSerializer = function() {
      function LocalSerializer2(remoteSerializer) {
        this.remoteSerializer = remoteSerializer;
      }
      return LocalSerializer2;
    }();
    function fromDbRemoteDocument(localSerializer, remoteDoc) {
      if (remoteDoc.document) {
        return fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);
      } else if (remoteDoc.noDocument) {
        var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);
        var version_3 = fromDbTimestamp(remoteDoc.noDocument.readTime);
        var document_1 = MutableDocument.newNoDocument(key, version_3);
        return remoteDoc.hasCommittedMutations ? document_1.setHasCommittedMutations() : document_1;
      } else if (remoteDoc.unknownDocument) {
        var key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);
        var version_4 = fromDbTimestamp(remoteDoc.unknownDocument.version);
        return MutableDocument.newUnknownDocument(key, version_4);
      } else {
        return fail();
      }
    }
    function toDbRemoteDocument(localSerializer, document2, readTime) {
      var dbReadTime = toDbTimestampKey(readTime);
      var parentPath = document2.key.path.popLast().toArray();
      if (document2.isFoundDocument()) {
        var doc_3 = toDocument(localSerializer.remoteSerializer, document2);
        var hasCommittedMutations = document2.hasCommittedMutations;
        return new DbRemoteDocument(null, null, doc_3, hasCommittedMutations, dbReadTime, parentPath);
      } else if (document2.isNoDocument()) {
        var path2 = document2.key.path.toArray();
        var readTime_1 = toDbTimestamp(document2.version);
        var hasCommittedMutations = document2.hasCommittedMutations;
        return new DbRemoteDocument(null, new DbNoDocument(path2, readTime_1), null, hasCommittedMutations, dbReadTime, parentPath);
      } else if (document2.isUnknownDocument()) {
        var path2 = document2.key.path.toArray();
        var readTime_2 = toDbTimestamp(document2.version);
        return new DbRemoteDocument(new DbUnknownDocument(path2, readTime_2), null, null, true, dbReadTime, parentPath);
      } else {
        return fail();
      }
    }
    function toDbTimestampKey(snapshotVersion) {
      var timestamp = snapshotVersion.toTimestamp();
      return [timestamp.seconds, timestamp.nanoseconds];
    }
    function fromDbTimestampKey(dbTimestampKey) {
      var timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);
      return SnapshotVersion.fromTimestamp(timestamp);
    }
    function toDbTimestamp(snapshotVersion) {
      var timestamp = snapshotVersion.toTimestamp();
      return new DbTimestamp(timestamp.seconds, timestamp.nanoseconds);
    }
    function fromDbTimestamp(dbTimestamp) {
      var timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);
      return SnapshotVersion.fromTimestamp(timestamp);
    }
    function toDbMutationBatch(localSerializer, userId, batch) {
      var serializedBaseMutations = batch.baseMutations.map(function(m) {
        return toMutation(localSerializer.remoteSerializer, m);
      });
      var serializedMutations = batch.mutations.map(function(m) {
        return toMutation(localSerializer.remoteSerializer, m);
      });
      return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toMillis(), serializedBaseMutations, serializedMutations);
    }
    function fromDbMutationBatch(localSerializer, dbBatch) {
      var baseMutations = (dbBatch.baseMutations || []).map(function(m) {
        return fromMutation(localSerializer.remoteSerializer, m);
      });
      for (var i = 0; i < dbBatch.mutations.length - 1; ++i) {
        var currentMutation = dbBatch.mutations[i];
        var hasTransform = i + 1 < dbBatch.mutations.length && dbBatch.mutations[i + 1].transform !== void 0;
        if (hasTransform) {
          var transformMutation = dbBatch.mutations[i + 1];
          currentMutation.updateTransforms = transformMutation.transform.fieldTransforms;
          dbBatch.mutations.splice(i + 1, 1);
          ++i;
        }
      }
      var mutations = dbBatch.mutations.map(function(m) {
        return fromMutation(localSerializer.remoteSerializer, m);
      });
      var timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);
      return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);
    }
    function fromDbTarget(dbTarget) {
      var version2 = fromDbTimestamp(dbTarget.readTime);
      var lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== void 0 ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion) : SnapshotVersion.min();
      var target;
      if (isDocumentQuery(dbTarget.query)) {
        target = fromDocumentsTarget(dbTarget.query);
      } else {
        target = fromQueryTarget(dbTarget.query);
      }
      return new TargetData(target, dbTarget.targetId, 0, dbTarget.lastListenSequenceNumber, version2, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));
    }
    function toDbTarget(localSerializer, targetData) {
      var dbTimestamp = toDbTimestamp(targetData.snapshotVersion);
      var dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);
      var queryProto;
      if (isDocumentTarget(targetData.target)) {
        queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);
      } else {
        queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target);
      }
      var resumeToken = targetData.resumeToken.toBase64();
      return new DbTarget(targetData.targetId, canonifyTarget(targetData.target), dbTimestamp, resumeToken, targetData.sequenceNumber, dbLastLimboFreeTimestamp, queryProto);
    }
    function isDocumentQuery(dbQuery) {
      return dbQuery.documents !== void 0;
    }
    function fromDbBundle(dbBundle) {
      return {
        id: dbBundle.bundleId,
        createTime: fromDbTimestamp(dbBundle.createTime),
        version: dbBundle.version
      };
    }
    function toDbBundle(metadata) {
      return {
        bundleId: metadata.id,
        createTime: toDbTimestamp(fromVersion(metadata.createTime)),
        version: metadata.version
      };
    }
    function fromDbNamedQuery(dbNamedQuery) {
      return {
        name: dbNamedQuery.name,
        query: fromBundledQuery(dbNamedQuery.bundledQuery),
        readTime: fromDbTimestamp(dbNamedQuery.readTime)
      };
    }
    function toDbNamedQuery(query2) {
      return {
        name: query2.name,
        readTime: toDbTimestamp(fromVersion(query2.readTime)),
        bundledQuery: query2.bundledQuery
      };
    }
    function fromBundledQuery(bundledQuery) {
      var query2 = convertQueryTargetToQuery({
        parent: bundledQuery.parent,
        structuredQuery: bundledQuery.structuredQuery
      });
      if (bundledQuery.limitType === "LAST") {
        return queryWithLimit(query2, query2.limit, "L");
      }
      return query2;
    }
    function fromProtoNamedQuery(namedQuery2) {
      return {
        name: namedQuery2.name,
        query: fromBundledQuery(namedQuery2.bundledQuery),
        readTime: fromVersion(namedQuery2.readTime)
      };
    }
    function fromBundleMetadata(metadata) {
      return {
        id: metadata.id,
        version: metadata.version,
        createTime: fromVersion(metadata.createTime)
      };
    }
    var IndexedDbBundleCache = function() {
      function IndexedDbBundleCache2() {
      }
      IndexedDbBundleCache2.prototype.getBundleMetadata = function(transaction, bundleId) {
        return bundlesStore(transaction).get(bundleId).next(function(bundle) {
          if (bundle) {
            return fromDbBundle(bundle);
          }
          return void 0;
        });
      };
      IndexedDbBundleCache2.prototype.saveBundleMetadata = function(transaction, bundleMetadata) {
        return bundlesStore(transaction).put(toDbBundle(bundleMetadata));
      };
      IndexedDbBundleCache2.prototype.getNamedQuery = function(transaction, queryName) {
        return namedQueriesStore(transaction).get(queryName).next(function(query2) {
          if (query2) {
            return fromDbNamedQuery(query2);
          }
          return void 0;
        });
      };
      IndexedDbBundleCache2.prototype.saveNamedQuery = function(transaction, query2) {
        return namedQueriesStore(transaction).put(toDbNamedQuery(query2));
      };
      return IndexedDbBundleCache2;
    }();
    function bundlesStore(txn) {
      return getStore(txn, DbBundle.store);
    }
    function namedQueriesStore(txn) {
      return getStore(txn, DbNamedQuery.store);
    }
    var MemoryIndexManager = function() {
      function MemoryIndexManager2() {
        this.collectionParentIndex = new MemoryCollectionParentIndex();
      }
      MemoryIndexManager2.prototype.addToCollectionParentIndex = function(transaction, collectionPath) {
        this.collectionParentIndex.add(collectionPath);
        return PersistencePromise.resolve();
      };
      MemoryIndexManager2.prototype.getCollectionParents = function(transaction, collectionId) {
        return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));
      };
      return MemoryIndexManager2;
    }();
    var MemoryCollectionParentIndex = function() {
      function MemoryCollectionParentIndex2() {
        this.index = {};
      }
      MemoryCollectionParentIndex2.prototype.add = function(collectionPath) {
        var collectionId = collectionPath.lastSegment();
        var parentPath = collectionPath.popLast();
        var existingParents = this.index[collectionId] || new SortedSet(ResourcePath.comparator);
        var added = !existingParents.has(parentPath);
        this.index[collectionId] = existingParents.add(parentPath);
        return added;
      };
      MemoryCollectionParentIndex2.prototype.has = function(collectionPath) {
        var collectionId = collectionPath.lastSegment();
        var parentPath = collectionPath.popLast();
        var existingParents = this.index[collectionId];
        return existingParents && existingParents.has(parentPath);
      };
      MemoryCollectionParentIndex2.prototype.getEntries = function(collectionId) {
        var parentPaths = this.index[collectionId] || new SortedSet(ResourcePath.comparator);
        return parentPaths.toArray();
      };
      return MemoryCollectionParentIndex2;
    }();
    var IndexedDbIndexManager = function() {
      function IndexedDbIndexManager2() {
        this.collectionParentsCache = new MemoryCollectionParentIndex();
      }
      IndexedDbIndexManager2.prototype.addToCollectionParentIndex = function(transaction, collectionPath) {
        var _this = this;
        if (!this.collectionParentsCache.has(collectionPath)) {
          var collectionId = collectionPath.lastSegment();
          var parentPath = collectionPath.popLast();
          transaction.addOnCommittedListener(function() {
            _this.collectionParentsCache.add(collectionPath);
          });
          var collectionParent = {
            collectionId,
            parent: encodeResourcePath(parentPath)
          };
          return collectionParentsStore(transaction).put(collectionParent);
        }
        return PersistencePromise.resolve();
      };
      IndexedDbIndexManager2.prototype.getCollectionParents = function(transaction, collectionId) {
        var parentPaths = [];
        var range = IDBKeyRange.bound([collectionId, ""], [immediateSuccessor(collectionId), ""], false, true);
        return collectionParentsStore(transaction).loadAll(range).next(function(entries) {
          for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            if (entry.collectionId !== collectionId) {
              break;
            }
            parentPaths.push(decodeResourcePath(entry.parent));
          }
          return parentPaths;
        });
      };
      return IndexedDbIndexManager2;
    }();
    function collectionParentsStore(txn) {
      return getStore(txn, DbCollectionParent.store);
    }
    function removeMutationBatch(txn, userId, batch) {
      var mutationStore = txn.store(DbMutationBatch.store);
      var indexTxn = txn.store(DbDocumentMutation.store);
      var promises = [];
      var range = IDBKeyRange.only(batch.batchId);
      var numDeleted = 0;
      var removePromise = mutationStore.iterate({ range }, function(key, value, control) {
        numDeleted++;
        return control.delete();
      });
      promises.push(removePromise.next(function() {
        hardAssert(numDeleted === 1);
      }));
      var removedDocuments = [];
      for (var _i = 0, _d = batch.mutations; _i < _d.length; _i++) {
        var mutation = _d[_i];
        var indexKey = DbDocumentMutation.key(userId, mutation.key.path, batch.batchId);
        promises.push(indexTxn.delete(indexKey));
        removedDocuments.push(mutation.key);
      }
      return PersistencePromise.waitFor(promises).next(function() {
        return removedDocuments;
      });
    }
    function dbDocumentSize(doc2) {
      if (!doc2) {
        return 0;
      }
      var value;
      if (doc2.document) {
        value = doc2.document;
      } else if (doc2.unknownDocument) {
        value = doc2.unknownDocument;
      } else if (doc2.noDocument) {
        value = doc2.noDocument;
      } else {
        throw fail();
      }
      return JSON.stringify(value).length;
    }
    var IndexedDbMutationQueue = function() {
      function IndexedDbMutationQueue2(userId, serializer, indexManager, referenceDelegate) {
        this.userId = userId;
        this.serializer = serializer;
        this.indexManager = indexManager;
        this.referenceDelegate = referenceDelegate;
        this.documentKeysByBatchId = {};
      }
      IndexedDbMutationQueue2.forUser = function(user, serializer, indexManager, referenceDelegate) {
        hardAssert(user.uid !== "");
        var userId = user.isAuthenticated() ? user.uid : "";
        return new IndexedDbMutationQueue2(userId, serializer, indexManager, referenceDelegate);
      };
      IndexedDbMutationQueue2.prototype.checkEmpty = function(transaction) {
        var empty2 = true;
        var range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
        return mutationsStore(transaction).iterate({ index: DbMutationBatch.userMutationsIndex, range }, function(key, value, control) {
          empty2 = false;
          control.done();
        }).next(function() {
          return empty2;
        });
      };
      IndexedDbMutationQueue2.prototype.addMutationBatch = function(transaction, localWriteTime, baseMutations, mutations) {
        var _this = this;
        var documentStore = documentMutationsStore(transaction);
        var mutationStore = mutationsStore(transaction);
        return mutationStore.add({}).next(function(batchId) {
          hardAssert(typeof batchId === "number");
          var batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);
          var dbBatch = toDbMutationBatch(_this.serializer, _this.userId, batch);
          var promises = [];
          var collectionParents = new SortedSet(function(l, r) {
            return primitiveComparator(l.canonicalString(), r.canonicalString());
          });
          for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
            var mutation = mutations_1[_i];
            var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);
            collectionParents = collectionParents.add(mutation.key.path.popLast());
            promises.push(mutationStore.put(dbBatch));
            promises.push(documentStore.put(indexKey, DbDocumentMutation.PLACEHOLDER));
          }
          collectionParents.forEach(function(parent) {
            promises.push(_this.indexManager.addToCollectionParentIndex(transaction, parent));
          });
          transaction.addOnCommittedListener(function() {
            _this.documentKeysByBatchId[batchId] = batch.keys();
          });
          return PersistencePromise.waitFor(promises).next(function() {
            return batch;
          });
        });
      };
      IndexedDbMutationQueue2.prototype.lookupMutationBatch = function(transaction, batchId) {
        var _this = this;
        return mutationsStore(transaction).get(batchId).next(function(dbBatch) {
          if (dbBatch) {
            hardAssert(dbBatch.userId === _this.userId);
            return fromDbMutationBatch(_this.serializer, dbBatch);
          }
          return null;
        });
      };
      IndexedDbMutationQueue2.prototype.lookupMutationKeys = function(transaction, batchId) {
        var _this = this;
        if (this.documentKeysByBatchId[batchId]) {
          return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);
        } else {
          return this.lookupMutationBatch(transaction, batchId).next(function(batch) {
            if (batch) {
              var keys = batch.keys();
              _this.documentKeysByBatchId[batchId] = keys;
              return keys;
            } else {
              return null;
            }
          });
        }
      };
      IndexedDbMutationQueue2.prototype.getNextMutationBatchAfterBatchId = function(transaction, batchId) {
        var _this = this;
        var nextBatchId = batchId + 1;
        var range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);
        var foundBatch = null;
        return mutationsStore(transaction).iterate({ index: DbMutationBatch.userMutationsIndex, range }, function(key, dbBatch, control) {
          if (dbBatch.userId === _this.userId) {
            hardAssert(dbBatch.batchId >= nextBatchId);
            foundBatch = fromDbMutationBatch(_this.serializer, dbBatch);
          }
          control.done();
        }).next(function() {
          return foundBatch;
        });
      };
      IndexedDbMutationQueue2.prototype.getHighestUnacknowledgedBatchId = function(transaction) {
        var range = IDBKeyRange.upperBound([
          this.userId,
          Number.POSITIVE_INFINITY
        ]);
        var batchId = BATCHID_UNKNOWN;
        return mutationsStore(transaction).iterate({ index: DbMutationBatch.userMutationsIndex, range, reverse: true }, function(key, dbBatch, control) {
          batchId = dbBatch.batchId;
          control.done();
        }).next(function() {
          return batchId;
        });
      };
      IndexedDbMutationQueue2.prototype.getAllMutationBatches = function(transaction) {
        var _this = this;
        var range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);
        return mutationsStore(transaction).loadAll(DbMutationBatch.userMutationsIndex, range).next(function(dbBatches) {
          return dbBatches.map(function(dbBatch) {
            return fromDbMutationBatch(_this.serializer, dbBatch);
          });
        });
      };
      IndexedDbMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKey = function(transaction, documentKey) {
        var _this = this;
        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);
        var indexStart = IDBKeyRange.lowerBound(indexPrefix);
        var results = [];
        return documentMutationsStore(transaction).iterate({ range: indexStart }, function(indexKey, _, control) {
          var userID = indexKey[0], encodedPath = indexKey[1], batchId = indexKey[2];
          var path2 = decodeResourcePath(encodedPath);
          if (userID !== _this.userId || !documentKey.path.isEqual(path2)) {
            control.done();
            return;
          }
          return mutationsStore(transaction).get(batchId).next(function(mutation) {
            if (!mutation) {
              throw fail();
            }
            hardAssert(mutation.userId === _this.userId);
            results.push(fromDbMutationBatch(_this.serializer, mutation));
          });
        }).next(function() {
          return results;
        });
      };
      IndexedDbMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKeys = function(transaction, documentKeys) {
        var _this = this;
        var uniqueBatchIDs = new SortedSet(primitiveComparator);
        var promises = [];
        documentKeys.forEach(function(documentKey) {
          var indexStart = DbDocumentMutation.prefixForPath(_this.userId, documentKey.path);
          var range = IDBKeyRange.lowerBound(indexStart);
          var promise = documentMutationsStore(transaction).iterate({ range }, function(indexKey, _, control) {
            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];
            var path2 = decodeResourcePath(encodedPath);
            if (userID !== _this.userId || !documentKey.path.isEqual(path2)) {
              control.done();
              return;
            }
            uniqueBatchIDs = uniqueBatchIDs.add(batchID);
          });
          promises.push(promise);
        });
        return PersistencePromise.waitFor(promises).next(function() {
          return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
        });
      };
      IndexedDbMutationQueue2.prototype.getAllMutationBatchesAffectingQuery = function(transaction, query2) {
        var _this = this;
        var queryPath = query2.path;
        var immediateChildrenLength = queryPath.length + 1;
        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);
        var indexStart = IDBKeyRange.lowerBound(indexPrefix);
        var uniqueBatchIDs = new SortedSet(primitiveComparator);
        return documentMutationsStore(transaction).iterate({ range: indexStart }, function(indexKey, _, control) {
          var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];
          var path2 = decodeResourcePath(encodedPath);
          if (userID !== _this.userId || !queryPath.isPrefixOf(path2)) {
            control.done();
            return;
          }
          if (path2.length !== immediateChildrenLength) {
            return;
          }
          uniqueBatchIDs = uniqueBatchIDs.add(batchID);
        }).next(function() {
          return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
        });
      };
      IndexedDbMutationQueue2.prototype.lookupMutationBatches = function(transaction, batchIDs) {
        var _this = this;
        var results = [];
        var promises = [];
        batchIDs.forEach(function(batchId) {
          promises.push(mutationsStore(transaction).get(batchId).next(function(mutation) {
            if (mutation === null) {
              throw fail();
            }
            hardAssert(mutation.userId === _this.userId);
            results.push(fromDbMutationBatch(_this.serializer, mutation));
          }));
        });
        return PersistencePromise.waitFor(promises).next(function() {
          return results;
        });
      };
      IndexedDbMutationQueue2.prototype.removeMutationBatch = function(transaction, batch) {
        var _this = this;
        return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(function(removedDocuments) {
          transaction.addOnCommittedListener(function() {
            _this.removeCachedMutationKeys(batch.batchId);
          });
          return PersistencePromise.forEach(removedDocuments, function(key) {
            return _this.referenceDelegate.markPotentiallyOrphaned(transaction, key);
          });
        });
      };
      IndexedDbMutationQueue2.prototype.removeCachedMutationKeys = function(batchId) {
        delete this.documentKeysByBatchId[batchId];
      };
      IndexedDbMutationQueue2.prototype.performConsistencyCheck = function(txn) {
        var _this = this;
        return this.checkEmpty(txn).next(function(empty2) {
          if (!empty2) {
            return PersistencePromise.resolve();
          }
          var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));
          var danglingMutationReferences = [];
          return documentMutationsStore(txn).iterate({ range: startRange }, function(key, _, control) {
            var userID = key[0];
            if (userID !== _this.userId) {
              control.done();
              return;
            } else {
              var path2 = decodeResourcePath(key[1]);
              danglingMutationReferences.push(path2);
            }
          }).next(function() {
            hardAssert(danglingMutationReferences.length === 0);
          });
        });
      };
      IndexedDbMutationQueue2.prototype.containsKey = function(txn, key) {
        return mutationQueueContainsKey(txn, this.userId, key);
      };
      IndexedDbMutationQueue2.prototype.getMutationQueueMetadata = function(transaction) {
        var _this = this;
        return mutationQueuesStore(transaction).get(this.userId).next(function(metadata) {
          return metadata || new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, "");
        });
      };
      return IndexedDbMutationQueue2;
    }();
    function mutationQueueContainsKey(txn, userId, key) {
      var indexKey = DbDocumentMutation.prefixForPath(userId, key.path);
      var encodedPath = indexKey[1];
      var startRange = IDBKeyRange.lowerBound(indexKey);
      var containsKey = false;
      return documentMutationsStore(txn).iterate({ range: startRange, keysOnly: true }, function(key2, value, control) {
        var userID = key2[0], keyPath = key2[1];
        key2[2];
        if (userID === userId && keyPath === encodedPath) {
          containsKey = true;
        }
        control.done();
      }).next(function() {
        return containsKey;
      });
    }
    function mutationQueuesContainKey(txn, docKey) {
      var found = false;
      return mutationQueuesStore(txn).iterateSerial(function(userId) {
        return mutationQueueContainsKey(txn, userId, docKey).next(function(containsKey) {
          if (containsKey) {
            found = true;
          }
          return PersistencePromise.resolve(!containsKey);
        });
      }).next(function() {
        return found;
      });
    }
    function mutationsStore(txn) {
      return getStore(txn, DbMutationBatch.store);
    }
    function documentMutationsStore(txn) {
      return getStore(txn, DbDocumentMutation.store);
    }
    function mutationQueuesStore(txn) {
      return getStore(txn, DbMutationQueue.store);
    }
    var OFFSET = 2;
    var TargetIdGenerator = function() {
      function TargetIdGenerator2(lastId) {
        this.lastId = lastId;
      }
      TargetIdGenerator2.prototype.next = function() {
        this.lastId += OFFSET;
        return this.lastId;
      };
      TargetIdGenerator2.forTargetCache = function() {
        return new TargetIdGenerator2(2 - OFFSET);
      };
      TargetIdGenerator2.forSyncEngine = function() {
        return new TargetIdGenerator2(1 - OFFSET);
      };
      return TargetIdGenerator2;
    }();
    var IndexedDbTargetCache = function() {
      function IndexedDbTargetCache2(referenceDelegate, serializer) {
        this.referenceDelegate = referenceDelegate;
        this.serializer = serializer;
      }
      IndexedDbTargetCache2.prototype.allocateTargetId = function(transaction) {
        var _this = this;
        return this.retrieveMetadata(transaction).next(function(metadata) {
          var targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);
          metadata.highestTargetId = targetIdGenerator.next();
          return _this.saveMetadata(transaction, metadata).next(function() {
            return metadata.highestTargetId;
          });
        });
      };
      IndexedDbTargetCache2.prototype.getLastRemoteSnapshotVersion = function(transaction) {
        return this.retrieveMetadata(transaction).next(function(metadata) {
          return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));
        });
      };
      IndexedDbTargetCache2.prototype.getHighestSequenceNumber = function(transaction) {
        return this.retrieveMetadata(transaction).next(function(targetGlobal) {
          return targetGlobal.highestListenSequenceNumber;
        });
      };
      IndexedDbTargetCache2.prototype.setTargetsMetadata = function(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {
        var _this = this;
        return this.retrieveMetadata(transaction).next(function(metadata) {
          metadata.highestListenSequenceNumber = highestListenSequenceNumber;
          if (lastRemoteSnapshotVersion) {
            metadata.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion.toTimestamp();
          }
          if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {
            metadata.highestListenSequenceNumber = highestListenSequenceNumber;
          }
          return _this.saveMetadata(transaction, metadata);
        });
      };
      IndexedDbTargetCache2.prototype.addTargetData = function(transaction, targetData) {
        var _this = this;
        return this.saveTargetData(transaction, targetData).next(function() {
          return _this.retrieveMetadata(transaction).next(function(metadata) {
            metadata.targetCount += 1;
            _this.updateMetadataFromTargetData(targetData, metadata);
            return _this.saveMetadata(transaction, metadata);
          });
        });
      };
      IndexedDbTargetCache2.prototype.updateTargetData = function(transaction, targetData) {
        return this.saveTargetData(transaction, targetData);
      };
      IndexedDbTargetCache2.prototype.removeTargetData = function(transaction, targetData) {
        var _this = this;
        return this.removeMatchingKeysForTargetId(transaction, targetData.targetId).next(function() {
          return targetsStore(transaction).delete(targetData.targetId);
        }).next(function() {
          return _this.retrieveMetadata(transaction);
        }).next(function(metadata) {
          hardAssert(metadata.targetCount > 0);
          metadata.targetCount -= 1;
          return _this.saveMetadata(transaction, metadata);
        });
      };
      IndexedDbTargetCache2.prototype.removeTargets = function(txn, upperBound, activeTargetIds) {
        var _this = this;
        var count = 0;
        var promises = [];
        return targetsStore(txn).iterate(function(key, value) {
          var targetData = fromDbTarget(value);
          if (targetData.sequenceNumber <= upperBound && activeTargetIds.get(targetData.targetId) === null) {
            count++;
            promises.push(_this.removeTargetData(txn, targetData));
          }
        }).next(function() {
          return PersistencePromise.waitFor(promises);
        }).next(function() {
          return count;
        });
      };
      IndexedDbTargetCache2.prototype.forEachTarget = function(txn, f) {
        return targetsStore(txn).iterate(function(key, value) {
          var targetData = fromDbTarget(value);
          f(targetData);
        });
      };
      IndexedDbTargetCache2.prototype.retrieveMetadata = function(transaction) {
        return globalTargetStore(transaction).get(DbTargetGlobal.key).next(function(metadata) {
          hardAssert(metadata !== null);
          return metadata;
        });
      };
      IndexedDbTargetCache2.prototype.saveMetadata = function(transaction, metadata) {
        return globalTargetStore(transaction).put(DbTargetGlobal.key, metadata);
      };
      IndexedDbTargetCache2.prototype.saveTargetData = function(transaction, targetData) {
        return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));
      };
      IndexedDbTargetCache2.prototype.updateMetadataFromTargetData = function(targetData, metadata) {
        var updated = false;
        if (targetData.targetId > metadata.highestTargetId) {
          metadata.highestTargetId = targetData.targetId;
          updated = true;
        }
        if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {
          metadata.highestListenSequenceNumber = targetData.sequenceNumber;
          updated = true;
        }
        return updated;
      };
      IndexedDbTargetCache2.prototype.getTargetCount = function(transaction) {
        return this.retrieveMetadata(transaction).next(function(metadata) {
          return metadata.targetCount;
        });
      };
      IndexedDbTargetCache2.prototype.getTargetData = function(transaction, target) {
        var canonicalId2 = canonifyTarget(target);
        var range = IDBKeyRange.bound([canonicalId2, Number.NEGATIVE_INFINITY], [canonicalId2, Number.POSITIVE_INFINITY]);
        var result = null;
        return targetsStore(transaction).iterate({ range, index: DbTarget.queryTargetsIndexName }, function(key, value, control) {
          var found = fromDbTarget(value);
          if (targetEquals(target, found.target)) {
            result = found;
            control.done();
          }
        }).next(function() {
          return result;
        });
      };
      IndexedDbTargetCache2.prototype.addMatchingKeys = function(txn, keys, targetId) {
        var _this = this;
        var promises = [];
        var store = documentTargetStore(txn);
        keys.forEach(function(key) {
          var path2 = encodeResourcePath(key.path);
          promises.push(store.put(new DbTargetDocument(targetId, path2)));
          promises.push(_this.referenceDelegate.addReference(txn, targetId, key));
        });
        return PersistencePromise.waitFor(promises);
      };
      IndexedDbTargetCache2.prototype.removeMatchingKeys = function(txn, keys, targetId) {
        var _this = this;
        var store = documentTargetStore(txn);
        return PersistencePromise.forEach(keys, function(key) {
          var path2 = encodeResourcePath(key.path);
          return PersistencePromise.waitFor([
            store.delete([targetId, path2]),
            _this.referenceDelegate.removeReference(txn, targetId, key)
          ]);
        });
      };
      IndexedDbTargetCache2.prototype.removeMatchingKeysForTargetId = function(txn, targetId) {
        var store = documentTargetStore(txn);
        var range = IDBKeyRange.bound([targetId], [targetId + 1], false, true);
        return store.delete(range);
      };
      IndexedDbTargetCache2.prototype.getMatchingKeysForTargetId = function(txn, targetId) {
        var range = IDBKeyRange.bound([targetId], [targetId + 1], false, true);
        var store = documentTargetStore(txn);
        var result = documentKeySet();
        return store.iterate({ range, keysOnly: true }, function(key, _, control) {
          var path2 = decodeResourcePath(key[1]);
          var docKey = new DocumentKey(path2);
          result = result.add(docKey);
        }).next(function() {
          return result;
        });
      };
      IndexedDbTargetCache2.prototype.containsKey = function(txn, key) {
        var path2 = encodeResourcePath(key.path);
        var range = IDBKeyRange.bound([path2], [immediateSuccessor(path2)], false, true);
        var count = 0;
        return documentTargetStore(txn).iterate({
          index: DbTargetDocument.documentTargetsIndex,
          keysOnly: true,
          range
        }, function(_d, _, control) {
          var targetId = _d[0];
          _d[1];
          if (targetId !== 0) {
            count++;
            control.done();
          }
        }).next(function() {
          return count > 0;
        });
      };
      IndexedDbTargetCache2.prototype.getTargetDataForTarget = function(transaction, targetId) {
        return targetsStore(transaction).get(targetId).next(function(found) {
          if (found) {
            return fromDbTarget(found);
          } else {
            return null;
          }
        });
      };
      return IndexedDbTargetCache2;
    }();
    function targetsStore(txn) {
      return getStore(txn, DbTarget.store);
    }
    function globalTargetStore(txn) {
      return getStore(txn, DbTargetGlobal.store);
    }
    function documentTargetStore(txn) {
      return getStore(txn, DbTargetDocument.store);
    }
    function ignoreIfPrimaryLeaseLoss(err) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          if (err.code === Code.FAILED_PRECONDITION && err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {
            logDebug("LocalStore", "Unexpectedly lost primary lease");
          } else {
            throw err;
          }
          return [2];
        });
      });
    }
    var GC_DID_NOT_RUN = {
      didRun: false,
      sequenceNumbersCollected: 0,
      targetsRemoved: 0,
      documentsRemoved: 0
    };
    var LRU_COLLECTION_DISABLED = -1;
    var LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;
    var LruParams = function() {
      function LruParams2(cacheSizeCollectionThreshold, percentileToCollect, maximumSequenceNumbersToCollect) {
        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;
        this.percentileToCollect = percentileToCollect;
        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;
      }
      LruParams2.withCacheSize = function(cacheSize) {
        return new LruParams2(cacheSize, LruParams2.DEFAULT_COLLECTION_PERCENTILE, LruParams2.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
      };
      return LruParams2;
    }();
    LruParams.DEFAULT_COLLECTION_PERCENTILE = 10;
    LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3;
    LruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
    LruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);
    var LOG_TAG$e = "LruGarbageCollector";
    var LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;
    var INITIAL_GC_DELAY_MS = 1 * 60 * 1e3;
    var REGULAR_GC_DELAY_MS = 5 * 60 * 1e3;
    function bufferEntryComparator(_d, _e) {
      var aSequence = _d[0], aIndex = _d[1];
      var bSequence = _e[0], bIndex = _e[1];
      var seqCmp = primitiveComparator(aSequence, bSequence);
      if (seqCmp === 0) {
        return primitiveComparator(aIndex, bIndex);
      } else {
        return seqCmp;
      }
    }
    var RollingSequenceNumberBuffer = function() {
      function RollingSequenceNumberBuffer2(maxElements) {
        this.maxElements = maxElements;
        this.buffer = new SortedSet(bufferEntryComparator);
        this.previousIndex = 0;
      }
      RollingSequenceNumberBuffer2.prototype.nextIndex = function() {
        return ++this.previousIndex;
      };
      RollingSequenceNumberBuffer2.prototype.addElement = function(sequenceNumber) {
        var entry = [sequenceNumber, this.nextIndex()];
        if (this.buffer.size < this.maxElements) {
          this.buffer = this.buffer.add(entry);
        } else {
          var highestValue = this.buffer.last();
          if (bufferEntryComparator(entry, highestValue) < 0) {
            this.buffer = this.buffer.delete(highestValue).add(entry);
          }
        }
      };
      Object.defineProperty(RollingSequenceNumberBuffer2.prototype, "maxValue", {
        get: function() {
          return this.buffer.last()[0];
        },
        enumerable: false,
        configurable: true
      });
      return RollingSequenceNumberBuffer2;
    }();
    var LruScheduler = function() {
      function LruScheduler2(garbageCollector, asyncQueue) {
        this.garbageCollector = garbageCollector;
        this.asyncQueue = asyncQueue;
        this.hasRun = false;
        this.gcTask = null;
      }
      LruScheduler2.prototype.start = function(localStore) {
        if (this.garbageCollector.params.cacheSizeCollectionThreshold !== LRU_COLLECTION_DISABLED) {
          this.scheduleGC(localStore);
        }
      };
      LruScheduler2.prototype.stop = function() {
        if (this.gcTask) {
          this.gcTask.cancel();
          this.gcTask = null;
        }
      };
      Object.defineProperty(LruScheduler2.prototype, "started", {
        get: function() {
          return this.gcTask !== null;
        },
        enumerable: false,
        configurable: true
      });
      LruScheduler2.prototype.scheduleGC = function(localStore) {
        var _this = this;
        var delay = this.hasRun ? REGULAR_GC_DELAY_MS : INITIAL_GC_DELAY_MS;
        logDebug("LruGarbageCollector", "Garbage collection scheduled in " + delay + "ms");
        this.gcTask = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", delay, function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            var e_1;
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  this.gcTask = null;
                  this.hasRun = true;
                  _d.label = 1;
                case 1:
                  _d.trys.push([1, 3, , 7]);
                  return [4, localStore.collectGarbage(this.garbageCollector)];
                case 2:
                  _d.sent();
                  return [3, 7];
                case 3:
                  e_1 = _d.sent();
                  if (!isIndexedDbTransactionError(e_1))
                    return [3, 4];
                  logDebug(LOG_TAG$e, "Ignoring IndexedDB error during garbage collection: ", e_1);
                  return [3, 6];
                case 4:
                  return [4, ignoreIfPrimaryLeaseLoss(e_1)];
                case 5:
                  _d.sent();
                  _d.label = 6;
                case 6:
                  return [3, 7];
                case 7:
                  return [4, this.scheduleGC(localStore)];
                case 8:
                  _d.sent();
                  return [2];
              }
            });
          });
        });
      };
      return LruScheduler2;
    }();
    var LruGarbageCollectorImpl = function() {
      function LruGarbageCollectorImpl2(delegate, params) {
        this.delegate = delegate;
        this.params = params;
      }
      LruGarbageCollectorImpl2.prototype.calculateTargetCount = function(txn, percentile) {
        return this.delegate.getSequenceNumberCount(txn).next(function(targetCount) {
          return Math.floor(percentile / 100 * targetCount);
        });
      };
      LruGarbageCollectorImpl2.prototype.nthSequenceNumber = function(txn, n) {
        var _this = this;
        if (n === 0) {
          return PersistencePromise.resolve(ListenSequence.INVALID);
        }
        var buffer = new RollingSequenceNumberBuffer(n);
        return this.delegate.forEachTarget(txn, function(target) {
          return buffer.addElement(target.sequenceNumber);
        }).next(function() {
          return _this.delegate.forEachOrphanedDocumentSequenceNumber(txn, function(sequenceNumber) {
            return buffer.addElement(sequenceNumber);
          });
        }).next(function() {
          return buffer.maxValue;
        });
      };
      LruGarbageCollectorImpl2.prototype.removeTargets = function(txn, upperBound, activeTargetIds) {
        return this.delegate.removeTargets(txn, upperBound, activeTargetIds);
      };
      LruGarbageCollectorImpl2.prototype.removeOrphanedDocuments = function(txn, upperBound) {
        return this.delegate.removeOrphanedDocuments(txn, upperBound);
      };
      LruGarbageCollectorImpl2.prototype.collect = function(txn, activeTargetIds) {
        var _this = this;
        if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {
          logDebug("LruGarbageCollector", "Garbage collection skipped; disabled");
          return PersistencePromise.resolve(GC_DID_NOT_RUN);
        }
        return this.getCacheSize(txn).next(function(cacheSize) {
          if (cacheSize < _this.params.cacheSizeCollectionThreshold) {
            logDebug("LruGarbageCollector", "Garbage collection skipped; Cache size " + cacheSize + " " + ("is lower than threshold " + _this.params.cacheSizeCollectionThreshold));
            return GC_DID_NOT_RUN;
          } else {
            return _this.runGarbageCollection(txn, activeTargetIds);
          }
        });
      };
      LruGarbageCollectorImpl2.prototype.getCacheSize = function(txn) {
        return this.delegate.getCacheSize(txn);
      };
      LruGarbageCollectorImpl2.prototype.runGarbageCollection = function(txn, activeTargetIds) {
        var _this = this;
        var upperBoundSequenceNumber;
        var sequenceNumbersToCollect, targetsRemoved;
        var countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;
        var startTs = Date.now();
        return this.calculateTargetCount(txn, this.params.percentileToCollect).next(function(sequenceNumbers) {
          if (sequenceNumbers > _this.params.maximumSequenceNumbersToCollect) {
            logDebug("LruGarbageCollector", "Capping sequence numbers to collect down " + ("to the maximum of " + _this.params.maximumSequenceNumbersToCollect + " ") + ("from " + sequenceNumbers));
            sequenceNumbersToCollect = _this.params.maximumSequenceNumbersToCollect;
          } else {
            sequenceNumbersToCollect = sequenceNumbers;
          }
          countedTargetsTs = Date.now();
          return _this.nthSequenceNumber(txn, sequenceNumbersToCollect);
        }).next(function(upperBound) {
          upperBoundSequenceNumber = upperBound;
          foundUpperBoundTs = Date.now();
          return _this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);
        }).next(function(numTargetsRemoved) {
          targetsRemoved = numTargetsRemoved;
          removedTargetsTs = Date.now();
          return _this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);
        }).next(function(documentsRemoved) {
          removedDocumentsTs = Date.now();
          if (getLogLevel() <= logger.LogLevel.DEBUG) {
            var desc = "LRU Garbage Collection\n" + ("	Counted targets in " + (countedTargetsTs - startTs) + "ms\n") + ("	Determined least recently used " + sequenceNumbersToCollect + " in ") + (foundUpperBoundTs - countedTargetsTs + "ms\n") + ("	Removed " + targetsRemoved + " targets in ") + (removedTargetsTs - foundUpperBoundTs + "ms\n") + ("	Removed " + documentsRemoved + " documents in ") + (removedDocumentsTs - removedTargetsTs + "ms\n") + ("Total Duration: " + (removedDocumentsTs - startTs) + "ms");
            logDebug("LruGarbageCollector", desc);
          }
          return PersistencePromise.resolve({
            didRun: true,
            sequenceNumbersCollected: sequenceNumbersToCollect,
            targetsRemoved,
            documentsRemoved
          });
        });
      };
      return LruGarbageCollectorImpl2;
    }();
    function newLruGarbageCollector(delegate, params) {
      return new LruGarbageCollectorImpl(delegate, params);
    }
    var IndexedDbLruDelegateImpl = function() {
      function IndexedDbLruDelegateImpl2(db2, params) {
        this.db = db2;
        this.garbageCollector = newLruGarbageCollector(this, params);
      }
      IndexedDbLruDelegateImpl2.prototype.getSequenceNumberCount = function(txn) {
        var docCountPromise = this.orphanedDocumentCount(txn);
        var targetCountPromise = this.db.getTargetCache().getTargetCount(txn);
        return targetCountPromise.next(function(targetCount) {
          return docCountPromise.next(function(docCount) {
            return targetCount + docCount;
          });
        });
      };
      IndexedDbLruDelegateImpl2.prototype.orphanedDocumentCount = function(txn) {
        var orphanedCount = 0;
        return this.forEachOrphanedDocumentSequenceNumber(txn, function(_) {
          orphanedCount++;
        }).next(function() {
          return orphanedCount;
        });
      };
      IndexedDbLruDelegateImpl2.prototype.forEachTarget = function(txn, f) {
        return this.db.getTargetCache().forEachTarget(txn, f);
      };
      IndexedDbLruDelegateImpl2.prototype.forEachOrphanedDocumentSequenceNumber = function(txn, f) {
        return this.forEachOrphanedDocument(txn, function(docKey, sequenceNumber) {
          return f(sequenceNumber);
        });
      };
      IndexedDbLruDelegateImpl2.prototype.addReference = function(txn, targetId, key) {
        return writeSentinelKey(txn, key);
      };
      IndexedDbLruDelegateImpl2.prototype.removeReference = function(txn, targetId, key) {
        return writeSentinelKey(txn, key);
      };
      IndexedDbLruDelegateImpl2.prototype.removeTargets = function(txn, upperBound, activeTargetIds) {
        return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);
      };
      IndexedDbLruDelegateImpl2.prototype.markPotentiallyOrphaned = function(txn, key) {
        return writeSentinelKey(txn, key);
      };
      IndexedDbLruDelegateImpl2.prototype.isPinned = function(txn, docKey) {
        return mutationQueuesContainKey(txn, docKey);
      };
      IndexedDbLruDelegateImpl2.prototype.removeOrphanedDocuments = function(txn, upperBound) {
        var _this = this;
        var documentCache = this.db.getRemoteDocumentCache();
        var changeBuffer = documentCache.newChangeBuffer();
        var promises = [];
        var documentCount = 0;
        var iteration = this.forEachOrphanedDocument(txn, function(docKey, sequenceNumber) {
          if (sequenceNumber <= upperBound) {
            var p = _this.isPinned(txn, docKey).next(function(isPinned) {
              if (!isPinned) {
                documentCount++;
                return changeBuffer.getEntry(txn, docKey).next(function() {
                  changeBuffer.removeEntry(docKey);
                  return documentTargetStore(txn).delete(sentinelKey$1(docKey));
                });
              }
            });
            promises.push(p);
          }
        });
        return iteration.next(function() {
          return PersistencePromise.waitFor(promises);
        }).next(function() {
          return changeBuffer.apply(txn);
        }).next(function() {
          return documentCount;
        });
      };
      IndexedDbLruDelegateImpl2.prototype.removeTarget = function(txn, targetData) {
        var updated = targetData.withSequenceNumber(txn.currentSequenceNumber);
        return this.db.getTargetCache().updateTargetData(txn, updated);
      };
      IndexedDbLruDelegateImpl2.prototype.updateLimboDocument = function(txn, key) {
        return writeSentinelKey(txn, key);
      };
      IndexedDbLruDelegateImpl2.prototype.forEachOrphanedDocument = function(txn, f) {
        var store = documentTargetStore(txn);
        var nextToReport = ListenSequence.INVALID;
        var nextPath;
        return store.iterate({
          index: DbTargetDocument.documentTargetsIndex
        }, function(_d, _e) {
          var targetId = _d[0];
          _d[1];
          var path2 = _e.path, sequenceNumber = _e.sequenceNumber;
          if (targetId === 0) {
            if (nextToReport !== ListenSequence.INVALID) {
              f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);
            }
            nextToReport = sequenceNumber;
            nextPath = path2;
          } else {
            nextToReport = ListenSequence.INVALID;
          }
        }).next(function() {
          if (nextToReport !== ListenSequence.INVALID) {
            f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);
          }
        });
      };
      IndexedDbLruDelegateImpl2.prototype.getCacheSize = function(txn) {
        return this.db.getRemoteDocumentCache().getSize(txn);
      };
      return IndexedDbLruDelegateImpl2;
    }();
    function sentinelKey$1(key) {
      return [0, encodeResourcePath(key.path)];
    }
    function sentinelRow(key, sequenceNumber) {
      return new DbTargetDocument(0, encodeResourcePath(key.path), sequenceNumber);
    }
    function writeSentinelKey(txn, key) {
      return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));
    }
    var ObjectMap = function() {
      function ObjectMap2(mapKeyFn, equalsFn) {
        this.mapKeyFn = mapKeyFn;
        this.equalsFn = equalsFn;
        this.inner = {};
      }
      ObjectMap2.prototype.get = function(key) {
        var id = this.mapKeyFn(key);
        var matches = this.inner[id];
        if (matches === void 0) {
          return void 0;
        }
        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
          var _d = matches_1[_i], otherKey = _d[0], value = _d[1];
          if (this.equalsFn(otherKey, key)) {
            return value;
          }
        }
        return void 0;
      };
      ObjectMap2.prototype.has = function(key) {
        return this.get(key) !== void 0;
      };
      ObjectMap2.prototype.set = function(key, value) {
        var id = this.mapKeyFn(key);
        var matches = this.inner[id];
        if (matches === void 0) {
          this.inner[id] = [[key, value]];
          return;
        }
        for (var i = 0; i < matches.length; i++) {
          if (this.equalsFn(matches[i][0], key)) {
            matches[i] = [key, value];
            return;
          }
        }
        matches.push([key, value]);
      };
      ObjectMap2.prototype.delete = function(key) {
        var id = this.mapKeyFn(key);
        var matches = this.inner[id];
        if (matches === void 0) {
          return false;
        }
        for (var i = 0; i < matches.length; i++) {
          if (this.equalsFn(matches[i][0], key)) {
            if (matches.length === 1) {
              delete this.inner[id];
            } else {
              matches.splice(i, 1);
            }
            return true;
          }
        }
        return false;
      };
      ObjectMap2.prototype.forEach = function(fn) {
        forEach(this.inner, function(_, entries) {
          for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {
            var _d = entries_2[_i], k = _d[0], v = _d[1];
            fn(k, v);
          }
        });
      };
      ObjectMap2.prototype.isEmpty = function() {
        return isEmpty(this.inner);
      };
      return ObjectMap2;
    }();
    var RemoteDocumentChangeBuffer = function() {
      function RemoteDocumentChangeBuffer2() {
        this.changes = new ObjectMap(function(key) {
          return key.toString();
        }, function(l, r) {
          return l.isEqual(r);
        });
        this.changesApplied = false;
      }
      RemoteDocumentChangeBuffer2.prototype.getReadTime = function(key) {
        var change = this.changes.get(key);
        if (change) {
          return change.readTime;
        }
        return SnapshotVersion.min();
      };
      RemoteDocumentChangeBuffer2.prototype.addEntry = function(document2, readTime) {
        this.assertNotApplied();
        this.changes.set(document2.key, { document: document2, readTime });
      };
      RemoteDocumentChangeBuffer2.prototype.removeEntry = function(key, readTime) {
        if (readTime === void 0) {
          readTime = null;
        }
        this.assertNotApplied();
        this.changes.set(key, {
          document: MutableDocument.newInvalidDocument(key),
          readTime
        });
      };
      RemoteDocumentChangeBuffer2.prototype.getEntry = function(transaction, documentKey) {
        this.assertNotApplied();
        var bufferedEntry = this.changes.get(documentKey);
        if (bufferedEntry !== void 0) {
          return PersistencePromise.resolve(bufferedEntry.document);
        } else {
          return this.getFromCache(transaction, documentKey);
        }
      };
      RemoteDocumentChangeBuffer2.prototype.getEntries = function(transaction, documentKeys) {
        return this.getAllFromCache(transaction, documentKeys);
      };
      RemoteDocumentChangeBuffer2.prototype.apply = function(transaction) {
        this.assertNotApplied();
        this.changesApplied = true;
        return this.applyChanges(transaction);
      };
      RemoteDocumentChangeBuffer2.prototype.assertNotApplied = function() {
      };
      return RemoteDocumentChangeBuffer2;
    }();
    var IndexedDbRemoteDocumentCacheImpl = function() {
      function IndexedDbRemoteDocumentCacheImpl2(serializer, indexManager) {
        this.serializer = serializer;
        this.indexManager = indexManager;
      }
      IndexedDbRemoteDocumentCacheImpl2.prototype.addEntry = function(transaction, key, doc2) {
        var documentStore = remoteDocumentsStore(transaction);
        return documentStore.put(dbKey(key), doc2);
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.removeEntry = function(transaction, documentKey) {
        var store = remoteDocumentsStore(transaction);
        var key = dbKey(documentKey);
        return store.delete(key);
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.updateMetadata = function(transaction, sizeDelta) {
        var _this = this;
        return this.getMetadata(transaction).next(function(metadata) {
          metadata.byteSize += sizeDelta;
          return _this.setMetadata(transaction, metadata);
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getEntry = function(transaction, documentKey) {
        var _this = this;
        return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function(dbRemoteDoc) {
          return _this.maybeDecodeDocument(documentKey, dbRemoteDoc);
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getSizedEntry = function(transaction, documentKey) {
        var _this = this;
        return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function(dbRemoteDoc) {
          var doc2 = _this.maybeDecodeDocument(documentKey, dbRemoteDoc);
          return {
            document: doc2,
            size: dbDocumentSize(dbRemoteDoc)
          };
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getEntries = function(transaction, documentKeys) {
        var _this = this;
        var results = mutableDocumentMap();
        return this.forEachDbEntry(transaction, documentKeys, function(key, dbRemoteDoc) {
          var doc2 = _this.maybeDecodeDocument(key, dbRemoteDoc);
          results = results.insert(key, doc2);
        }).next(function() {
          return results;
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getSizedEntries = function(transaction, documentKeys) {
        var _this = this;
        var results = mutableDocumentMap();
        var sizeMap = new SortedMap(DocumentKey.comparator);
        return this.forEachDbEntry(transaction, documentKeys, function(key, dbRemoteDoc) {
          var doc2 = _this.maybeDecodeDocument(key, dbRemoteDoc);
          results = results.insert(key, doc2);
          sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));
        }).next(function() {
          return { documents: results, sizeMap };
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.forEachDbEntry = function(transaction, documentKeys, callback) {
        if (documentKeys.isEmpty()) {
          return PersistencePromise.resolve();
        }
        var range = IDBKeyRange.bound(documentKeys.first().path.toArray(), documentKeys.last().path.toArray());
        var keyIter = documentKeys.getIterator();
        var nextKey = keyIter.getNext();
        return remoteDocumentsStore(transaction).iterate({ range }, function(potentialKeyRaw, dbRemoteDoc, control) {
          var potentialKey = DocumentKey.fromSegments(potentialKeyRaw);
          while (nextKey && DocumentKey.comparator(nextKey, potentialKey) < 0) {
            callback(nextKey, null);
            nextKey = keyIter.getNext();
          }
          if (nextKey && nextKey.isEqual(potentialKey)) {
            callback(nextKey, dbRemoteDoc);
            nextKey = keyIter.hasNext() ? keyIter.getNext() : null;
          }
          if (nextKey) {
            control.skip(nextKey.path.toArray());
          } else {
            control.done();
          }
        }).next(function() {
          while (nextKey) {
            callback(nextKey, null);
            nextKey = keyIter.hasNext() ? keyIter.getNext() : null;
          }
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getDocumentsMatchingQuery = function(transaction, query2, sinceReadTime) {
        var _this = this;
        var results = mutableDocumentMap();
        var immediateChildrenPathLength = query2.path.length + 1;
        var iterationOptions = {};
        if (sinceReadTime.isEqual(SnapshotVersion.min())) {
          var startKey = query2.path.toArray();
          iterationOptions.range = IDBKeyRange.lowerBound(startKey);
        } else {
          var collectionKey = query2.path.toArray();
          var readTimeKey = toDbTimestampKey(sinceReadTime);
          iterationOptions.range = IDBKeyRange.lowerBound([collectionKey, readTimeKey], true);
          iterationOptions.index = DbRemoteDocument.collectionReadTimeIndex;
        }
        return remoteDocumentsStore(transaction).iterate(iterationOptions, function(key, dbRemoteDoc, control) {
          if (key.length !== immediateChildrenPathLength) {
            return;
          }
          var document2 = fromDbRemoteDocument(_this.serializer, dbRemoteDoc);
          if (!query2.path.isPrefixOf(document2.key.path)) {
            control.done();
          } else if (queryMatches(query2, document2)) {
            results = results.insert(document2.key, document2);
          }
        }).next(function() {
          return results;
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.newChangeBuffer = function(options2) {
        return new IndexedDbRemoteDocumentChangeBuffer(this, !!options2 && options2.trackRemovals);
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getSize = function(txn) {
        return this.getMetadata(txn).next(function(metadata) {
          return metadata.byteSize;
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getMetadata = function(txn) {
        return documentGlobalStore(txn).get(DbRemoteDocumentGlobal.key).next(function(metadata) {
          hardAssert(!!metadata);
          return metadata;
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.setMetadata = function(txn, metadata) {
        return documentGlobalStore(txn).put(DbRemoteDocumentGlobal.key, metadata);
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.maybeDecodeDocument = function(documentKey, dbRemoteDoc) {
        if (dbRemoteDoc) {
          var doc_4 = fromDbRemoteDocument(this.serializer, dbRemoteDoc);
          var isSentinelRemoval = doc_4.isNoDocument() && doc_4.version.isEqual(SnapshotVersion.min());
          if (!isSentinelRemoval) {
            return doc_4;
          }
        }
        return MutableDocument.newInvalidDocument(documentKey);
      };
      return IndexedDbRemoteDocumentCacheImpl2;
    }();
    function newIndexedDbRemoteDocumentCache(serializer, indexManager) {
      return new IndexedDbRemoteDocumentCacheImpl(serializer, indexManager);
    }
    function remoteDocumentCacheGetNewDocumentChanges(remoteDocumentCache, transaction, sinceReadTime) {
      var remoteDocumentCacheImpl = debugCast(remoteDocumentCache);
      var changedDocs = mutableDocumentMap();
      var lastReadTime = toDbTimestampKey(sinceReadTime);
      var documentsStore = remoteDocumentsStore(transaction);
      var range = IDBKeyRange.lowerBound(lastReadTime, true);
      return documentsStore.iterate({ index: DbRemoteDocument.readTimeIndex, range }, function(_, dbRemoteDoc) {
        var doc2 = fromDbRemoteDocument(remoteDocumentCacheImpl.serializer, dbRemoteDoc);
        changedDocs = changedDocs.insert(doc2.key, doc2);
        lastReadTime = dbRemoteDoc.readTime;
      }).next(function() {
        return {
          changedDocs,
          readTime: fromDbTimestampKey(lastReadTime)
        };
      });
    }
    function remoteDocumentCacheGetLastReadTime(transaction) {
      var documentsStore = remoteDocumentsStore(transaction);
      var readTime = SnapshotVersion.min();
      return documentsStore.iterate({ index: DbRemoteDocument.readTimeIndex, reverse: true }, function(key, dbRemoteDoc, control) {
        if (dbRemoteDoc.readTime) {
          readTime = fromDbTimestampKey(dbRemoteDoc.readTime);
        }
        control.done();
      }).next(function() {
        return readTime;
      });
    }
    var IndexedDbRemoteDocumentChangeBuffer = function(_super) {
      tslib.__extends(IndexedDbRemoteDocumentChangeBuffer2, _super);
      function IndexedDbRemoteDocumentChangeBuffer2(documentCache, trackRemovals) {
        var _this = _super.call(this) || this;
        _this.documentCache = documentCache;
        _this.trackRemovals = trackRemovals;
        _this.documentSizes = new ObjectMap(function(key) {
          return key.toString();
        }, function(l, r) {
          return l.isEqual(r);
        });
        return _this;
      }
      IndexedDbRemoteDocumentChangeBuffer2.prototype.applyChanges = function(transaction) {
        var _this = this;
        var promises = [];
        var sizeDelta = 0;
        var collectionParents = new SortedSet(function(l, r) {
          return primitiveComparator(l.canonicalString(), r.canonicalString());
        });
        this.changes.forEach(function(key, documentChange) {
          var previousSize = _this.documentSizes.get(key);
          if (documentChange.document.isValidDocument()) {
            var doc_5 = toDbRemoteDocument(_this.documentCache.serializer, documentChange.document, _this.getReadTime(key));
            collectionParents = collectionParents.add(key.path.popLast());
            var size = dbDocumentSize(doc_5);
            sizeDelta += size - previousSize;
            promises.push(_this.documentCache.addEntry(transaction, key, doc_5));
          } else {
            sizeDelta -= previousSize;
            if (_this.trackRemovals) {
              var deletedDoc = toDbRemoteDocument(_this.documentCache.serializer, MutableDocument.newNoDocument(key, SnapshotVersion.min()), _this.getReadTime(key));
              promises.push(_this.documentCache.addEntry(transaction, key, deletedDoc));
            } else {
              promises.push(_this.documentCache.removeEntry(transaction, key));
            }
          }
        });
        collectionParents.forEach(function(parent) {
          promises.push(_this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent));
        });
        promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));
        return PersistencePromise.waitFor(promises);
      };
      IndexedDbRemoteDocumentChangeBuffer2.prototype.getFromCache = function(transaction, documentKey) {
        var _this = this;
        return this.documentCache.getSizedEntry(transaction, documentKey).next(function(getResult) {
          _this.documentSizes.set(documentKey, getResult.size);
          return getResult.document;
        });
      };
      IndexedDbRemoteDocumentChangeBuffer2.prototype.getAllFromCache = function(transaction, documentKeys) {
        var _this = this;
        return this.documentCache.getSizedEntries(transaction, documentKeys).next(function(_d) {
          var documents = _d.documents, sizeMap = _d.sizeMap;
          sizeMap.forEach(function(documentKey, size) {
            _this.documentSizes.set(documentKey, size);
          });
          return documents;
        });
      };
      return IndexedDbRemoteDocumentChangeBuffer2;
    }(RemoteDocumentChangeBuffer);
    function documentGlobalStore(txn) {
      return getStore(txn, DbRemoteDocumentGlobal.store);
    }
    function remoteDocumentsStore(txn) {
      return getStore(txn, DbRemoteDocument.store);
    }
    function dbKey(docKey) {
      return docKey.path.toArray();
    }
    var SchemaConverter = function() {
      function SchemaConverter2(serializer) {
        this.serializer = serializer;
      }
      SchemaConverter2.prototype.createOrUpgrade = function(db2, txn, fromVersion2, toVersion2) {
        var _this = this;
        hardAssert(fromVersion2 < toVersion2 && fromVersion2 >= 0 && toVersion2 <= SCHEMA_VERSION);
        var simpleDbTransaction = new SimpleDbTransaction("createOrUpgrade", txn);
        if (fromVersion2 < 1 && toVersion2 >= 1) {
          createPrimaryClientStore(db2);
          createMutationQueue(db2);
          createQueryCache(db2);
          createRemoteDocumentCache(db2);
        }
        var p = PersistencePromise.resolve();
        if (fromVersion2 < 3 && toVersion2 >= 3) {
          if (fromVersion2 !== 0) {
            dropQueryCache(db2);
            createQueryCache(db2);
          }
          p = p.next(function() {
            return writeEmptyTargetGlobalEntry(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 4 && toVersion2 >= 4) {
          if (fromVersion2 !== 0) {
            p = p.next(function() {
              return upgradeMutationBatchSchemaAndMigrateData(db2, simpleDbTransaction);
            });
          }
          p = p.next(function() {
            createClientMetadataStore(db2);
          });
        }
        if (fromVersion2 < 5 && toVersion2 >= 5) {
          p = p.next(function() {
            return _this.removeAcknowledgedMutations(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 6 && toVersion2 >= 6) {
          p = p.next(function() {
            createDocumentGlobalStore(db2);
            return _this.addDocumentGlobal(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 7 && toVersion2 >= 7) {
          p = p.next(function() {
            return _this.ensureSequenceNumbers(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 8 && toVersion2 >= 8) {
          p = p.next(function() {
            return _this.createCollectionParentIndex(db2, simpleDbTransaction);
          });
        }
        if (fromVersion2 < 9 && toVersion2 >= 9) {
          p = p.next(function() {
            dropRemoteDocumentChangesStore(db2);
            createRemoteDocumentReadTimeIndex(txn);
          });
        }
        if (fromVersion2 < 10 && toVersion2 >= 10) {
          p = p.next(function() {
            return _this.rewriteCanonicalIds(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 11 && toVersion2 >= 11) {
          p = p.next(function() {
            createBundlesStore(db2);
            createNamedQueriesStore(db2);
          });
        }
        return p;
      };
      SchemaConverter2.prototype.addDocumentGlobal = function(txn) {
        var byteCount = 0;
        return txn.store(DbRemoteDocument.store).iterate(function(_, doc2) {
          byteCount += dbDocumentSize(doc2);
        }).next(function() {
          var metadata = new DbRemoteDocumentGlobal(byteCount);
          return txn.store(DbRemoteDocumentGlobal.store).put(DbRemoteDocumentGlobal.key, metadata);
        });
      };
      SchemaConverter2.prototype.removeAcknowledgedMutations = function(txn) {
        var _this = this;
        var queuesStore = txn.store(DbMutationQueue.store);
        var mutationsStore2 = txn.store(DbMutationBatch.store);
        return queuesStore.loadAll().next(function(queues) {
          return PersistencePromise.forEach(queues, function(queue) {
            var range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);
            return mutationsStore2.loadAll(DbMutationBatch.userMutationsIndex, range).next(function(dbBatches) {
              return PersistencePromise.forEach(dbBatches, function(dbBatch) {
                hardAssert(dbBatch.userId === queue.userId);
                var batch = fromDbMutationBatch(_this.serializer, dbBatch);
                return removeMutationBatch(txn, queue.userId, batch).next(function() {
                });
              });
            });
          });
        });
      };
      SchemaConverter2.prototype.ensureSequenceNumbers = function(txn) {
        var documentTargetStore2 = txn.store(DbTargetDocument.store);
        var documentsStore = txn.store(DbRemoteDocument.store);
        var globalTargetStore2 = txn.store(DbTargetGlobal.store);
        return globalTargetStore2.get(DbTargetGlobal.key).next(function(metadata) {
          var writeSentinelKey2 = function(path2) {
            return documentTargetStore2.put(new DbTargetDocument(0, encodeResourcePath(path2), metadata.highestListenSequenceNumber));
          };
          var promises = [];
          return documentsStore.iterate(function(key, doc2) {
            var path2 = new ResourcePath(key);
            var docSentinelKey = sentinelKey(path2);
            promises.push(documentTargetStore2.get(docSentinelKey).next(function(maybeSentinel) {
              if (!maybeSentinel) {
                return writeSentinelKey2(path2);
              } else {
                return PersistencePromise.resolve();
              }
            }));
          }).next(function() {
            return PersistencePromise.waitFor(promises);
          });
        });
      };
      SchemaConverter2.prototype.createCollectionParentIndex = function(db2, txn) {
        db2.createObjectStore(DbCollectionParent.store, {
          keyPath: DbCollectionParent.keyPath
        });
        var collectionParentsStore2 = txn.store(DbCollectionParent.store);
        var cache = new MemoryCollectionParentIndex();
        var addEntry = function(collectionPath) {
          if (cache.add(collectionPath)) {
            var collectionId = collectionPath.lastSegment();
            var parentPath = collectionPath.popLast();
            return collectionParentsStore2.put({
              collectionId,
              parent: encodeResourcePath(parentPath)
            });
          }
        };
        return txn.store(DbRemoteDocument.store).iterate({ keysOnly: true }, function(pathSegments, _) {
          var path2 = new ResourcePath(pathSegments);
          return addEntry(path2.popLast());
        }).next(function() {
          return txn.store(DbDocumentMutation.store).iterate({ keysOnly: true }, function(_d, _) {
            _d[0];
            var encodedPath = _d[1];
            _d[2];
            var path2 = decodeResourcePath(encodedPath);
            return addEntry(path2.popLast());
          });
        });
      };
      SchemaConverter2.prototype.rewriteCanonicalIds = function(txn) {
        var _this = this;
        var targetStore = txn.store(DbTarget.store);
        return targetStore.iterate(function(key, originalDbTarget) {
          var originalTargetData = fromDbTarget(originalDbTarget);
          var updatedDbTarget = toDbTarget(_this.serializer, originalTargetData);
          return targetStore.put(updatedDbTarget);
        });
      };
      return SchemaConverter2;
    }();
    function sentinelKey(path2) {
      return [0, encodeResourcePath(path2)];
    }
    function createPrimaryClientStore(db2) {
      db2.createObjectStore(DbPrimaryClient.store);
    }
    function createMutationQueue(db2) {
      db2.createObjectStore(DbMutationQueue.store, {
        keyPath: DbMutationQueue.keyPath
      });
      var mutationBatchesStore = db2.createObjectStore(DbMutationBatch.store, {
        keyPath: DbMutationBatch.keyPath,
        autoIncrement: true
      });
      mutationBatchesStore.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, { unique: true });
      db2.createObjectStore(DbDocumentMutation.store);
    }
    function upgradeMutationBatchSchemaAndMigrateData(db2, txn) {
      var v1MutationsStore = txn.store(DbMutationBatch.store);
      return v1MutationsStore.loadAll().next(function(existingMutations) {
        db2.deleteObjectStore(DbMutationBatch.store);
        var mutationsStore2 = db2.createObjectStore(DbMutationBatch.store, {
          keyPath: DbMutationBatch.keyPath,
          autoIncrement: true
        });
        mutationsStore2.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, { unique: true });
        var v3MutationsStore = txn.store(DbMutationBatch.store);
        var writeAll = existingMutations.map(function(mutation) {
          return v3MutationsStore.put(mutation);
        });
        return PersistencePromise.waitFor(writeAll);
      });
    }
    function createRemoteDocumentCache(db2) {
      db2.createObjectStore(DbRemoteDocument.store);
    }
    function createDocumentGlobalStore(db2) {
      db2.createObjectStore(DbRemoteDocumentGlobal.store);
    }
    function createQueryCache(db2) {
      var targetDocumentsStore = db2.createObjectStore(DbTargetDocument.store, {
        keyPath: DbTargetDocument.keyPath
      });
      targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });
      var targetStore = db2.createObjectStore(DbTarget.store, {
        keyPath: DbTarget.keyPath
      });
      targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });
      db2.createObjectStore(DbTargetGlobal.store);
    }
    function dropQueryCache(db2) {
      db2.deleteObjectStore(DbTargetDocument.store);
      db2.deleteObjectStore(DbTarget.store);
      db2.deleteObjectStore(DbTargetGlobal.store);
    }
    function dropRemoteDocumentChangesStore(db2) {
      if (db2.objectStoreNames.contains("remoteDocumentChanges")) {
        db2.deleteObjectStore("remoteDocumentChanges");
      }
    }
    function writeEmptyTargetGlobalEntry(txn) {
      var globalStore = txn.store(DbTargetGlobal.store);
      var metadata = new DbTargetGlobal(0, 0, SnapshotVersion.min().toTimestamp(), 0);
      return globalStore.put(DbTargetGlobal.key, metadata);
    }
    function createRemoteDocumentReadTimeIndex(txn) {
      var remoteDocumentStore = txn.objectStore(DbRemoteDocument.store);
      remoteDocumentStore.createIndex(DbRemoteDocument.readTimeIndex, DbRemoteDocument.readTimeIndexPath, { unique: false });
      remoteDocumentStore.createIndex(DbRemoteDocument.collectionReadTimeIndex, DbRemoteDocument.collectionReadTimeIndexPath, { unique: false });
    }
    function createClientMetadataStore(db2) {
      db2.createObjectStore(DbClientMetadata.store, {
        keyPath: DbClientMetadata.keyPath
      });
    }
    function createBundlesStore(db2) {
      db2.createObjectStore(DbBundle.store, {
        keyPath: DbBundle.keyPath
      });
    }
    function createNamedQueriesStore(db2) {
      db2.createObjectStore(DbNamedQuery.store, {
        keyPath: DbNamedQuery.keyPath
      });
    }
    var LOG_TAG$d = "IndexedDbPersistence";
    var MAX_CLIENT_AGE_MS = 30 * 60 * 1e3;
    var MAX_PRIMARY_ELIGIBLE_AGE_MS = 5e3;
    var CLIENT_METADATA_REFRESH_INTERVAL_MS = 4e3;
    var PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
    var UNSUPPORTED_PLATFORM_ERROR_MSG = "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.";
    var ZOMBIED_CLIENTS_KEY_PREFIX = "firestore_zombie";
    var MAIN_DATABASE = "main";
    var IndexedDbPersistence = function() {
      function IndexedDbPersistence2(allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window2, document2, serializer, sequenceNumberSyncer, forceOwningTab) {
        this.allowTabSynchronization = allowTabSynchronization;
        this.persistenceKey = persistenceKey;
        this.clientId = clientId;
        this.queue = queue;
        this.window = window2;
        this.document = document2;
        this.sequenceNumberSyncer = sequenceNumberSyncer;
        this.forceOwningTab = forceOwningTab;
        this.listenSequence = null;
        this._started = false;
        this.isPrimary = false;
        this.networkEnabled = true;
        this.windowUnloadHandler = null;
        this.inForeground = false;
        this.documentVisibilityHandler = null;
        this.clientMetadataRefresher = null;
        this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;
        this.primaryStateListener = function(_) {
          return Promise.resolve();
        };
        if (!IndexedDbPersistence2.isAvailable()) {
          throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);
        }
        this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);
        this.dbName = persistenceKey + MAIN_DATABASE;
        this.serializer = new LocalSerializer(serializer);
        this.simpleDb = new SimpleDb(this.dbName, SCHEMA_VERSION, new SchemaConverter(this.serializer));
        this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);
        this.indexManager = new IndexedDbIndexManager();
        this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer, this.indexManager);
        this.bundleCache = new IndexedDbBundleCache();
        if (this.window && this.window.localStorage) {
          this.webStorage = this.window.localStorage;
        } else {
          this.webStorage = null;
          if (forceOwningTab === false) {
            logError(LOG_TAG$d, "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.");
          }
        }
      }
      IndexedDbPersistence2.prototype.start = function() {
        var _this = this;
        return this.updateClientMetadataAndTryBecomePrimary().then(function() {
          if (!_this.isPrimary && !_this.allowTabSynchronization) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
          }
          _this.attachVisibilityHandler();
          _this.attachWindowUnloadHook();
          _this.scheduleClientMetadataAndPrimaryLeaseRefreshes();
          return _this.runTransaction("getHighestListenSequenceNumber", "readonly", function(txn) {
            return _this.targetCache.getHighestSequenceNumber(txn);
          });
        }).then(function(highestListenSequenceNumber) {
          _this.listenSequence = new ListenSequence(highestListenSequenceNumber, _this.sequenceNumberSyncer);
        }).then(function() {
          _this._started = true;
        }).catch(function(reason) {
          _this.simpleDb && _this.simpleDb.close();
          return Promise.reject(reason);
        });
      };
      IndexedDbPersistence2.prototype.setPrimaryStateListener = function(primaryStateListener) {
        var _this = this;
        this.primaryStateListener = function(primaryState) {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              if (this.started) {
                return [2, primaryStateListener(primaryState)];
              }
              return [2];
            });
          });
        };
        return primaryStateListener(this.isPrimary);
      };
      IndexedDbPersistence2.prototype.setDatabaseDeletedListener = function(databaseDeletedListener) {
        var _this = this;
        this.simpleDb.setVersionChangeListener(function(event) {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  if (!(event.newVersion === null))
                    return [3, 2];
                  return [4, databaseDeletedListener()];
                case 1:
                  _d.sent();
                  _d.label = 2;
                case 2:
                  return [2];
              }
            });
          });
        });
      };
      IndexedDbPersistence2.prototype.setNetworkEnabled = function(networkEnabled) {
        var _this = this;
        if (this.networkEnabled !== networkEnabled) {
          this.networkEnabled = networkEnabled;
          this.queue.enqueueAndForget(function() {
            return tslib.__awaiter(_this, void 0, void 0, function() {
              return tslib.__generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    if (!this.started)
                      return [3, 2];
                    return [4, this.updateClientMetadataAndTryBecomePrimary()];
                  case 1:
                    _d.sent();
                    _d.label = 2;
                  case 2:
                    return [2];
                }
              });
            });
          });
        }
      };
      IndexedDbPersistence2.prototype.updateClientMetadataAndTryBecomePrimary = function() {
        var _this = this;
        return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", function(txn) {
          var metadataStore = clientMetadataStore(txn);
          return metadataStore.put(new DbClientMetadata(_this.clientId, Date.now(), _this.networkEnabled, _this.inForeground)).next(function() {
            if (_this.isPrimary) {
              return _this.verifyPrimaryLease(txn).next(function(success) {
                if (!success) {
                  _this.isPrimary = false;
                  _this.queue.enqueueRetryable(function() {
                    return _this.primaryStateListener(false);
                  });
                }
              });
            }
          }).next(function() {
            return _this.canActAsPrimary(txn);
          }).next(function(canActAsPrimary) {
            if (_this.isPrimary && !canActAsPrimary) {
              return _this.releasePrimaryLeaseIfHeld(txn).next(function() {
                return false;
              });
            } else if (canActAsPrimary) {
              return _this.acquireOrExtendPrimaryLease(txn).next(function() {
                return true;
              });
            } else {
              return false;
            }
          });
        }).catch(function(e) {
          if (isIndexedDbTransactionError(e)) {
            logDebug(LOG_TAG$d, "Failed to extend owner lease: ", e);
            return _this.isPrimary;
          }
          if (!_this.allowTabSynchronization) {
            throw e;
          }
          logDebug(LOG_TAG$d, "Releasing owner lease after error during lease refresh", e);
          return false;
        }).then(function(isPrimary) {
          if (_this.isPrimary !== isPrimary) {
            _this.queue.enqueueRetryable(function() {
              return _this.primaryStateListener(isPrimary);
            });
          }
          _this.isPrimary = isPrimary;
        });
      };
      IndexedDbPersistence2.prototype.verifyPrimaryLease = function(txn) {
        var _this = this;
        var store = primaryClientStore(txn);
        return store.get(DbPrimaryClient.key).next(function(primaryClient) {
          return PersistencePromise.resolve(_this.isLocalClient(primaryClient));
        });
      };
      IndexedDbPersistence2.prototype.removeClientMetadata = function(txn) {
        var metadataStore = clientMetadataStore(txn);
        return metadataStore.delete(this.clientId);
      };
      IndexedDbPersistence2.prototype.maybeGarbageCollectMultiClientState = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var inactiveClients, _i, inactiveClients_1, inactiveClient;
          var _this = this;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!(this.isPrimary && !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)))
                  return [3, 2];
                this.lastGarbageCollectionTime = Date.now();
                return [4, this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", function(txn) {
                  var metadataStore = getStore(txn, DbClientMetadata.store);
                  return metadataStore.loadAll().next(function(existingClients) {
                    var active = _this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);
                    var inactive = existingClients.filter(function(client) {
                      return active.indexOf(client) === -1;
                    });
                    return PersistencePromise.forEach(inactive, function(inactiveClient2) {
                      return metadataStore.delete(inactiveClient2.clientId);
                    }).next(function() {
                      return inactive;
                    });
                  });
                }).catch(function() {
                  return [];
                })];
              case 1:
                inactiveClients = _d.sent();
                if (this.webStorage) {
                  for (_i = 0, inactiveClients_1 = inactiveClients; _i < inactiveClients_1.length; _i++) {
                    inactiveClient = inactiveClients_1[_i];
                    this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));
                  }
                }
                _d.label = 2;
              case 2:
                return [2];
            }
          });
        });
      };
      IndexedDbPersistence2.prototype.scheduleClientMetadataAndPrimaryLeaseRefreshes = function() {
        var _this = this;
        this.clientMetadataRefresher = this.queue.enqueueAfterDelay("client_metadata_refresh", CLIENT_METADATA_REFRESH_INTERVAL_MS, function() {
          return _this.updateClientMetadataAndTryBecomePrimary().then(function() {
            return _this.maybeGarbageCollectMultiClientState();
          }).then(function() {
            return _this.scheduleClientMetadataAndPrimaryLeaseRefreshes();
          });
        });
      };
      IndexedDbPersistence2.prototype.isLocalClient = function(client) {
        return client ? client.ownerId === this.clientId : false;
      };
      IndexedDbPersistence2.prototype.canActAsPrimary = function(txn) {
        var _this = this;
        if (this.forceOwningTab) {
          return PersistencePromise.resolve(true);
        }
        var store = primaryClientStore(txn);
        return store.get(DbPrimaryClient.key).next(function(currentPrimary) {
          var currentLeaseIsValid = currentPrimary !== null && _this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) && !_this.isClientZombied(currentPrimary.ownerId);
          if (currentLeaseIsValid) {
            if (_this.isLocalClient(currentPrimary) && _this.networkEnabled) {
              return true;
            }
            if (!_this.isLocalClient(currentPrimary)) {
              if (!currentPrimary.allowTabSynchronization) {
                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
              }
              return false;
            }
          }
          if (_this.networkEnabled && _this.inForeground) {
            return true;
          }
          return clientMetadataStore(txn).loadAll().next(function(existingClients) {
            var preferredCandidate = _this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(function(otherClient) {
              if (_this.clientId !== otherClient.clientId) {
                var otherClientHasBetterNetworkState = !_this.networkEnabled && otherClient.networkEnabled;
                var otherClientHasBetterVisibility = !_this.inForeground && otherClient.inForeground;
                var otherClientHasSameNetworkState = _this.networkEnabled === otherClient.networkEnabled;
                if (otherClientHasBetterNetworkState || otherClientHasBetterVisibility && otherClientHasSameNetworkState) {
                  return true;
                }
              }
              return false;
            });
            return preferredCandidate === void 0;
          });
        }).next(function(canActAsPrimary) {
          if (_this.isPrimary !== canActAsPrimary) {
            logDebug(LOG_TAG$d, "Client " + (canActAsPrimary ? "is" : "is not") + " eligible for a primary lease.");
          }
          return canActAsPrimary;
        });
      };
      IndexedDbPersistence2.prototype.shutdown = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var _this = this;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this._started = false;
                this.markClientZombied();
                if (this.clientMetadataRefresher) {
                  this.clientMetadataRefresher.cancel();
                  this.clientMetadataRefresher = null;
                }
                this.detachVisibilityHandler();
                this.detachWindowUnloadHook();
                return [4, this.simpleDb.runTransaction("shutdown", "readwrite", [DbPrimaryClient.store, DbClientMetadata.store], function(simpleDbTxn) {
                  var persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);
                  return _this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(function() {
                    return _this.removeClientMetadata(persistenceTransaction);
                  });
                })];
              case 1:
                _d.sent();
                this.simpleDb.close();
                this.removeClientZombiedEntry();
                return [2];
            }
          });
        });
      };
      IndexedDbPersistence2.prototype.filterActiveClients = function(clients, activityThresholdMs) {
        var _this = this;
        return clients.filter(function(client) {
          return _this.isWithinAge(client.updateTimeMs, activityThresholdMs) && !_this.isClientZombied(client.clientId);
        });
      };
      IndexedDbPersistence2.prototype.getActiveClients = function() {
        var _this = this;
        return this.runTransaction("getActiveClients", "readonly", function(txn) {
          return clientMetadataStore(txn).loadAll().next(function(clients) {
            return _this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(function(clientMetadata) {
              return clientMetadata.clientId;
            });
          });
        });
      };
      Object.defineProperty(IndexedDbPersistence2.prototype, "started", {
        get: function() {
          return this._started;
        },
        enumerable: false,
        configurable: true
      });
      IndexedDbPersistence2.prototype.getMutationQueue = function(user) {
        return IndexedDbMutationQueue.forUser(user, this.serializer, this.indexManager, this.referenceDelegate);
      };
      IndexedDbPersistence2.prototype.getTargetCache = function() {
        return this.targetCache;
      };
      IndexedDbPersistence2.prototype.getRemoteDocumentCache = function() {
        return this.remoteDocumentCache;
      };
      IndexedDbPersistence2.prototype.getIndexManager = function() {
        return this.indexManager;
      };
      IndexedDbPersistence2.prototype.getBundleCache = function() {
        return this.bundleCache;
      };
      IndexedDbPersistence2.prototype.runTransaction = function(action, mode, transactionOperation) {
        var _this = this;
        logDebug(LOG_TAG$d, "Starting transaction:", action);
        var simpleDbMode = mode === "readonly" ? "readonly" : "readwrite";
        var persistenceTransaction;
        return this.simpleDb.runTransaction(action, simpleDbMode, ALL_STORES, function(simpleDbTxn) {
          persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, _this.listenSequence ? _this.listenSequence.next() : ListenSequence.INVALID);
          if (mode === "readwrite-primary") {
            return _this.verifyPrimaryLease(persistenceTransaction).next(function(holdsPrimaryLease) {
              if (holdsPrimaryLease) {
                return true;
              }
              return _this.canActAsPrimary(persistenceTransaction);
            }).next(function(holdsPrimaryLease) {
              if (!holdsPrimaryLease) {
                logError("Failed to obtain primary lease for action '" + action + "'.");
                _this.isPrimary = false;
                _this.queue.enqueueRetryable(function() {
                  return _this.primaryStateListener(false);
                });
                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);
              }
              return transactionOperation(persistenceTransaction);
            }).next(function(result) {
              return _this.acquireOrExtendPrimaryLease(persistenceTransaction).next(function() {
                return result;
              });
            });
          } else {
            return _this.verifyAllowTabSynchronization(persistenceTransaction).next(function() {
              return transactionOperation(persistenceTransaction);
            });
          }
        }).then(function(result) {
          persistenceTransaction.raiseOnCommittedEvent();
          return result;
        });
      };
      IndexedDbPersistence2.prototype.verifyAllowTabSynchronization = function(txn) {
        var _this = this;
        var store = primaryClientStore(txn);
        return store.get(DbPrimaryClient.key).next(function(currentPrimary) {
          var currentLeaseIsValid = currentPrimary !== null && _this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) && !_this.isClientZombied(currentPrimary.ownerId);
          if (currentLeaseIsValid && !_this.isLocalClient(currentPrimary)) {
            if (!_this.forceOwningTab && (!_this.allowTabSynchronization || !currentPrimary.allowTabSynchronization)) {
              throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
            }
          }
        });
      };
      IndexedDbPersistence2.prototype.acquireOrExtendPrimaryLease = function(txn) {
        var newPrimary = new DbPrimaryClient(this.clientId, this.allowTabSynchronization, Date.now());
        return primaryClientStore(txn).put(DbPrimaryClient.key, newPrimary);
      };
      IndexedDbPersistence2.isAvailable = function() {
        return SimpleDb.isAvailable();
      };
      IndexedDbPersistence2.prototype.releasePrimaryLeaseIfHeld = function(txn) {
        var _this = this;
        var store = primaryClientStore(txn);
        return store.get(DbPrimaryClient.key).next(function(primaryClient) {
          if (_this.isLocalClient(primaryClient)) {
            logDebug(LOG_TAG$d, "Releasing primary lease.");
            return store.delete(DbPrimaryClient.key);
          } else {
            return PersistencePromise.resolve();
          }
        });
      };
      IndexedDbPersistence2.prototype.isWithinAge = function(updateTimeMs, maxAgeMs) {
        var now = Date.now();
        var minAcceptable = now - maxAgeMs;
        var maxAcceptable = now;
        if (updateTimeMs < minAcceptable) {
          return false;
        } else if (updateTimeMs > maxAcceptable) {
          logError("Detected an update time that is in the future: " + updateTimeMs + " > " + maxAcceptable);
          return false;
        }
        return true;
      };
      IndexedDbPersistence2.prototype.attachVisibilityHandler = function() {
        var _this = this;
        if (this.document !== null && typeof this.document.addEventListener === "function") {
          this.documentVisibilityHandler = function() {
            _this.queue.enqueueAndForget(function() {
              _this.inForeground = _this.document.visibilityState === "visible";
              return _this.updateClientMetadataAndTryBecomePrimary();
            });
          };
          this.document.addEventListener("visibilitychange", this.documentVisibilityHandler);
          this.inForeground = this.document.visibilityState === "visible";
        }
      };
      IndexedDbPersistence2.prototype.detachVisibilityHandler = function() {
        if (this.documentVisibilityHandler) {
          this.document.removeEventListener("visibilitychange", this.documentVisibilityHandler);
          this.documentVisibilityHandler = null;
        }
      };
      IndexedDbPersistence2.prototype.attachWindowUnloadHook = function() {
        var _this = this;
        var _a;
        if (typeof ((_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener) === "function") {
          this.windowUnloadHandler = function() {
            _this.markClientZombied();
            if (util.isSafari() && navigator.appVersion.match("Version/14")) {
              _this.queue.enterRestrictedMode(true);
            }
            _this.queue.enqueueAndForget(function() {
              return _this.shutdown();
            });
          };
          this.window.addEventListener("pagehide", this.windowUnloadHandler);
        }
      };
      IndexedDbPersistence2.prototype.detachWindowUnloadHook = function() {
        if (this.windowUnloadHandler) {
          this.window.removeEventListener("pagehide", this.windowUnloadHandler);
          this.windowUnloadHandler = null;
        }
      };
      IndexedDbPersistence2.prototype.isClientZombied = function(clientId) {
        var _a;
        try {
          var isZombied = ((_a = this.webStorage) === null || _a === void 0 ? void 0 : _a.getItem(this.zombiedClientLocalStorageKey(clientId))) !== null;
          logDebug(LOG_TAG$d, "Client '" + clientId + "' " + (isZombied ? "is" : "is not") + " zombied in LocalStorage");
          return isZombied;
        } catch (e) {
          logError(LOG_TAG$d, "Failed to get zombied client id.", e);
          return false;
        }
      };
      IndexedDbPersistence2.prototype.markClientZombied = function() {
        if (!this.webStorage) {
          return;
        }
        try {
          this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));
        } catch (e) {
          logError("Failed to set zombie client id.", e);
        }
      };
      IndexedDbPersistence2.prototype.removeClientZombiedEntry = function() {
        if (!this.webStorage) {
          return;
        }
        try {
          this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));
        } catch (e) {
        }
      };
      IndexedDbPersistence2.prototype.zombiedClientLocalStorageKey = function(clientId) {
        return ZOMBIED_CLIENTS_KEY_PREFIX + "_" + this.persistenceKey + "_" + clientId;
      };
      return IndexedDbPersistence2;
    }();
    function primaryClientStore(txn) {
      return getStore(txn, DbPrimaryClient.store);
    }
    function clientMetadataStore(txn) {
      return getStore(txn, DbClientMetadata.store);
    }
    function indexedDbStoragePrefix(databaseId, persistenceKey) {
      var database = databaseId.projectId;
      if (!databaseId.isDefaultDatabase) {
        database += "." + databaseId.database;
      }
      return "firestore/" + persistenceKey + "/" + database + "/";
    }
    function indexedDbClearPersistence(persistenceKey) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var dbName;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!SimpleDb.isAvailable()) {
                return [2, Promise.resolve()];
              }
              dbName = persistenceKey + MAIN_DATABASE;
              return [4, SimpleDb.delete(dbName)];
            case 1:
              _d.sent();
              return [2];
          }
        });
      });
    }
    var LocalDocumentsView = function() {
      function LocalDocumentsView2(remoteDocumentCache, mutationQueue, indexManager) {
        this.remoteDocumentCache = remoteDocumentCache;
        this.mutationQueue = mutationQueue;
        this.indexManager = indexManager;
      }
      LocalDocumentsView2.prototype.getDocument = function(transaction, key) {
        var _this = this;
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction, key).next(function(batches) {
          return _this.getDocumentInternal(transaction, key, batches);
        });
      };
      LocalDocumentsView2.prototype.getDocumentInternal = function(transaction, key, inBatches) {
        return this.remoteDocumentCache.getEntry(transaction, key).next(function(doc2) {
          for (var _i = 0, inBatches_1 = inBatches; _i < inBatches_1.length; _i++) {
            var batch = inBatches_1[_i];
            batch.applyToLocalView(doc2);
          }
          return doc2;
        });
      };
      LocalDocumentsView2.prototype.applyLocalMutationsToDocuments = function(docs, batches) {
        docs.forEach(function(key, localView) {
          for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
            var batch = batches_1[_i];
            batch.applyToLocalView(localView);
          }
        });
      };
      LocalDocumentsView2.prototype.getDocuments = function(transaction, keys) {
        var _this = this;
        return this.remoteDocumentCache.getEntries(transaction, keys).next(function(docs) {
          return _this.applyLocalViewToDocuments(transaction, docs).next(function() {
            return docs;
          });
        });
      };
      LocalDocumentsView2.prototype.applyLocalViewToDocuments = function(transaction, baseDocs) {
        var _this = this;
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(transaction, baseDocs).next(function(batches) {
          return _this.applyLocalMutationsToDocuments(baseDocs, batches);
        });
      };
      LocalDocumentsView2.prototype.getDocumentsMatchingQuery = function(transaction, query2, sinceReadTime) {
        if (isDocumentQuery$1(query2)) {
          return this.getDocumentsMatchingDocumentQuery(transaction, query2.path);
        } else if (isCollectionGroupQuery(query2)) {
          return this.getDocumentsMatchingCollectionGroupQuery(transaction, query2, sinceReadTime);
        } else {
          return this.getDocumentsMatchingCollectionQuery(transaction, query2, sinceReadTime);
        }
      };
      LocalDocumentsView2.prototype.getDocumentsMatchingDocumentQuery = function(transaction, docPath) {
        return this.getDocument(transaction, new DocumentKey(docPath)).next(function(document2) {
          var result = documentMap();
          if (document2.isFoundDocument()) {
            result = result.insert(document2.key, document2);
          }
          return result;
        });
      };
      LocalDocumentsView2.prototype.getDocumentsMatchingCollectionGroupQuery = function(transaction, query2, sinceReadTime) {
        var _this = this;
        var collectionId = query2.collectionGroup;
        var results = documentMap();
        return this.indexManager.getCollectionParents(transaction, collectionId).next(function(parents) {
          return PersistencePromise.forEach(parents, function(parent) {
            var collectionQuery = asCollectionQueryAtPath(query2, parent.child(collectionId));
            return _this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, sinceReadTime).next(function(r) {
              r.forEach(function(key, doc2) {
                results = results.insert(key, doc2);
              });
            });
          }).next(function() {
            return results;
          });
        });
      };
      LocalDocumentsView2.prototype.getDocumentsMatchingCollectionQuery = function(transaction, query2, sinceReadTime) {
        var _this = this;
        var results;
        var mutationBatches;
        return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query2, sinceReadTime).next(function(queryResults) {
          results = queryResults;
          return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query2);
        }).next(function(matchingMutationBatches) {
          mutationBatches = matchingMutationBatches;
          return _this.addMissingBaseDocuments(transaction, mutationBatches, results).next(function(mergedDocuments) {
            results = mergedDocuments;
            for (var _i = 0, mutationBatches_1 = mutationBatches; _i < mutationBatches_1.length; _i++) {
              var batch = mutationBatches_1[_i];
              for (var _d = 0, _e = batch.mutations; _d < _e.length; _d++) {
                var mutation = _e[_d];
                var key = mutation.key;
                var document_2 = results.get(key);
                if (document_2 == null) {
                  document_2 = MutableDocument.newInvalidDocument(key);
                  results = results.insert(key, document_2);
                }
                applyMutationToLocalView(mutation, document_2, batch.localWriteTime);
                if (!document_2.isFoundDocument()) {
                  results = results.remove(key);
                }
              }
            }
          });
        }).next(function() {
          results.forEach(function(key, doc2) {
            if (!queryMatches(query2, doc2)) {
              results = results.remove(key);
            }
          });
          return results;
        });
      };
      LocalDocumentsView2.prototype.addMissingBaseDocuments = function(transaction, matchingMutationBatches, existingDocuments) {
        var missingBaseDocEntriesForPatching = documentKeySet();
        for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {
          var batch = matchingMutationBatches_1[_i];
          for (var _d = 0, _e = batch.mutations; _d < _e.length; _d++) {
            var mutation = _e[_d];
            if (mutation instanceof PatchMutation && existingDocuments.get(mutation.key) === null) {
              missingBaseDocEntriesForPatching = missingBaseDocEntriesForPatching.add(mutation.key);
            }
          }
        }
        var mergedDocuments = existingDocuments;
        return this.remoteDocumentCache.getEntries(transaction, missingBaseDocEntriesForPatching).next(function(missingBaseDocs) {
          missingBaseDocs.forEach(function(key, doc2) {
            if (doc2.isFoundDocument()) {
              mergedDocuments = mergedDocuments.insert(key, doc2);
            }
          });
          return mergedDocuments;
        });
      };
      return LocalDocumentsView2;
    }();
    var LOG_TAG$c = "LocalStore";
    var RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;
    var LocalStoreImpl = function() {
      function LocalStoreImpl2(persistence, queryEngine, initialUser, serializer) {
        this.persistence = persistence;
        this.queryEngine = queryEngine;
        this.serializer = serializer;
        this.targetDataByTarget = new SortedMap(primitiveComparator);
        this.targetIdByTarget = new ObjectMap(function(t) {
          return canonifyTarget(t);
        }, targetEquals);
        this.lastDocumentChangeReadTime = SnapshotVersion.min();
        this.mutationQueue = persistence.getMutationQueue(initialUser);
        this.remoteDocuments = persistence.getRemoteDocumentCache();
        this.targetCache = persistence.getTargetCache();
        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.persistence.getIndexManager());
        this.bundleCache = persistence.getBundleCache();
        this.queryEngine.setLocalDocumentsView(this.localDocuments);
      }
      LocalStoreImpl2.prototype.collectGarbage = function(garbageCollector) {
        var _this = this;
        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", function(txn) {
          return garbageCollector.collect(txn, _this.targetDataByTarget);
        });
      };
      return LocalStoreImpl2;
    }();
    function newLocalStore(persistence, queryEngine, initialUser, serializer) {
      return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);
    }
    function localStoreHandleUserChange(localStore, user) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl, newMutationQueue, newLocalDocuments, result;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              localStoreImpl = debugCast(localStore);
              newMutationQueue = localStoreImpl.mutationQueue;
              newLocalDocuments = localStoreImpl.localDocuments;
              return [4, localStoreImpl.persistence.runTransaction("Handle user change", "readonly", function(txn) {
                var oldBatches;
                return localStoreImpl.mutationQueue.getAllMutationBatches(txn).next(function(promisedOldBatches) {
                  oldBatches = promisedOldBatches;
                  newMutationQueue = localStoreImpl.persistence.getMutationQueue(user);
                  newLocalDocuments = new LocalDocumentsView(localStoreImpl.remoteDocuments, newMutationQueue, localStoreImpl.persistence.getIndexManager());
                  return newMutationQueue.getAllMutationBatches(txn);
                }).next(function(newBatches) {
                  var removedBatchIds = [];
                  var addedBatchIds = [];
                  var changedKeys = documentKeySet();
                  for (var _i = 0, oldBatches_1 = oldBatches; _i < oldBatches_1.length; _i++) {
                    var batch = oldBatches_1[_i];
                    removedBatchIds.push(batch.batchId);
                    for (var _d2 = 0, _e = batch.mutations; _d2 < _e.length; _d2++) {
                      var mutation = _e[_d2];
                      changedKeys = changedKeys.add(mutation.key);
                    }
                  }
                  for (var _f = 0, newBatches_1 = newBatches; _f < newBatches_1.length; _f++) {
                    var batch = newBatches_1[_f];
                    addedBatchIds.push(batch.batchId);
                    for (var _g = 0, _h = batch.mutations; _g < _h.length; _g++) {
                      var mutation = _h[_g];
                      changedKeys = changedKeys.add(mutation.key);
                    }
                  }
                  return newLocalDocuments.getDocuments(txn, changedKeys).next(function(affectedDocuments) {
                    return {
                      affectedDocuments,
                      removedBatchIds,
                      addedBatchIds
                    };
                  });
                });
              })];
            case 1:
              result = _d.sent();
              localStoreImpl.mutationQueue = newMutationQueue;
              localStoreImpl.localDocuments = newLocalDocuments;
              localStoreImpl.queryEngine.setLocalDocumentsView(localStoreImpl.localDocuments);
              return [2, result];
          }
        });
      });
    }
    function localStoreWriteLocally(localStore, mutations) {
      var localStoreImpl = debugCast(localStore);
      var localWriteTime = Timestamp.now();
      var keys = mutations.reduce(function(keys2, m) {
        return keys2.add(m.key);
      }, documentKeySet());
      var existingDocs;
      return localStoreImpl.persistence.runTransaction("Locally write mutations", "readwrite", function(txn) {
        return localStoreImpl.localDocuments.getDocuments(txn, keys).next(function(docs) {
          existingDocs = docs;
          var baseMutations = [];
          for (var _i = 0, mutations_2 = mutations; _i < mutations_2.length; _i++) {
            var mutation = mutations_2[_i];
            var baseValue = extractMutationBaseValue(mutation, existingDocs.get(mutation.key));
            if (baseValue != null) {
              baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.value.mapValue), Precondition.exists(true)));
            }
          }
          return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);
        });
      }).then(function(batch) {
        batch.applyToLocalDocumentSet(existingDocs);
        return { batchId: batch.batchId, changes: existingDocs };
      });
    }
    function localStoreAcknowledgeBatch(localStore, batchResult) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("Acknowledge batch", "readwrite-primary", function(txn) {
        var affected = batchResult.batch.keys();
        var documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({
          trackRemovals: true
        });
        return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer).next(function() {
          return documentBuffer.apply(txn);
        }).next(function() {
          return localStoreImpl.mutationQueue.performConsistencyCheck(txn);
        }).next(function() {
          return localStoreImpl.localDocuments.getDocuments(txn, affected);
        });
      });
    }
    function localStoreRejectBatch(localStore, batchId) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("Reject batch", "readwrite-primary", function(txn) {
        var affectedKeys;
        return localStoreImpl.mutationQueue.lookupMutationBatch(txn, batchId).next(function(batch) {
          hardAssert(batch !== null);
          affectedKeys = batch.keys();
          return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);
        }).next(function() {
          return localStoreImpl.mutationQueue.performConsistencyCheck(txn);
        }).next(function() {
          return localStoreImpl.localDocuments.getDocuments(txn, affectedKeys);
        });
      });
    }
    function localStoreGetHighestUnacknowledgedBatchId(localStore) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", function(txn) {
        return localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn);
      });
    }
    function localStoreGetLastRemoteSnapshotVersion(localStore) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("Get last remote snapshot version", "readonly", function(txn) {
        return localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn);
      });
    }
    function localStoreApplyRemoteEventToLocalCache(localStore, remoteEvent) {
      var localStoreImpl = debugCast(localStore);
      var remoteVersion = remoteEvent.snapshotVersion;
      var newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;
      return localStoreImpl.persistence.runTransaction("Apply remote event", "readwrite-primary", function(txn) {
        var documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({
          trackRemovals: true
        });
        newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;
        var promises = [];
        remoteEvent.targetChanges.forEach(function(change, targetId) {
          var oldTargetData = newTargetDataByTargetMap.get(targetId);
          if (!oldTargetData) {
            return;
          }
          promises.push(localStoreImpl.targetCache.removeMatchingKeys(txn, change.removedDocuments, targetId).next(function() {
            return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);
          }));
          var resumeToken = change.resumeToken;
          if (resumeToken.approximateByteSize() > 0) {
            var newTargetData = oldTargetData.withResumeToken(resumeToken, remoteVersion).withSequenceNumber(txn.currentSequenceNumber);
            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);
            if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {
              promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));
            }
          }
        });
        var changedDocs = mutableDocumentMap();
        remoteEvent.documentUpdates.forEach(function(key, doc2) {
          if (remoteEvent.resolvedLimboDocuments.has(key)) {
            promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));
          }
        });
        promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates, remoteVersion, void 0).next(function(result) {
          changedDocs = result;
        }));
        if (!remoteVersion.isEqual(SnapshotVersion.min())) {
          var updateRemoteVersion = localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn).next(function(lastRemoteSnapshotVersion) {
            return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);
          });
          promises.push(updateRemoteVersion);
        }
        return PersistencePromise.waitFor(promises).next(function() {
          return documentBuffer.apply(txn);
        }).next(function() {
          return localStoreImpl.localDocuments.applyLocalViewToDocuments(txn, changedDocs);
        }).next(function() {
          return changedDocs;
        });
      }).then(function(changedDocs) {
        localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;
        return changedDocs;
      });
    }
    function populateDocumentChangeBuffer(txn, documentBuffer, documents, globalVersion, documentVersions) {
      var updatedKeys = documentKeySet();
      documents.forEach(function(k) {
        return updatedKeys = updatedKeys.add(k);
      });
      return documentBuffer.getEntries(txn, updatedKeys).next(function(existingDocs) {
        var changedDocs = mutableDocumentMap();
        documents.forEach(function(key, doc2) {
          var existingDoc = existingDocs.get(key);
          var docReadTime = (documentVersions === null || documentVersions === void 0 ? void 0 : documentVersions.get(key)) || globalVersion;
          if (doc2.isNoDocument() && doc2.version.isEqual(SnapshotVersion.min())) {
            documentBuffer.removeEntry(key, docReadTime);
            changedDocs = changedDocs.insert(key, doc2);
          } else if (!existingDoc.isValidDocument() || doc2.version.compareTo(existingDoc.version) > 0 || doc2.version.compareTo(existingDoc.version) === 0 && existingDoc.hasPendingWrites) {
            documentBuffer.addEntry(doc2, docReadTime);
            changedDocs = changedDocs.insert(key, doc2);
          } else {
            logDebug(LOG_TAG$c, "Ignoring outdated watch update for ", key, ". Current version:", existingDoc.version, " Watch version:", doc2.version);
          }
        });
        return changedDocs;
      });
    }
    function shouldPersistTargetData(oldTargetData, newTargetData, change) {
      hardAssert(newTargetData.resumeToken.approximateByteSize() > 0);
      if (oldTargetData.resumeToken.approximateByteSize() === 0) {
        return true;
      }
      var timeDelta = newTargetData.snapshotVersion.toMicroseconds() - oldTargetData.snapshotVersion.toMicroseconds();
      if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {
        return true;
      }
      var changes = change.addedDocuments.size + change.modifiedDocuments.size + change.removedDocuments.size;
      return changes > 0;
    }
    function localStoreNotifyLocalViewChanges(localStore, viewChanges) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl, e_2, _i, viewChanges_1, viewChange, targetId, targetData, lastLimboFreeSnapshotVersion, updatedTargetData;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              localStoreImpl = debugCast(localStore);
              _d.label = 1;
            case 1:
              _d.trys.push([1, 3, , 4]);
              return [4, localStoreImpl.persistence.runTransaction("notifyLocalViewChanges", "readwrite", function(txn) {
                return PersistencePromise.forEach(viewChanges, function(viewChange2) {
                  return PersistencePromise.forEach(viewChange2.addedKeys, function(key) {
                    return localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange2.targetId, key);
                  }).next(function() {
                    return PersistencePromise.forEach(viewChange2.removedKeys, function(key) {
                      return localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange2.targetId, key);
                    });
                  });
                });
              })];
            case 2:
              _d.sent();
              return [3, 4];
            case 3:
              e_2 = _d.sent();
              if (isIndexedDbTransactionError(e_2)) {
                logDebug(LOG_TAG$c, "Failed to update sequence numbers: " + e_2);
              } else {
                throw e_2;
              }
              return [3, 4];
            case 4:
              for (_i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {
                viewChange = viewChanges_1[_i];
                targetId = viewChange.targetId;
                if (!viewChange.fromCache) {
                  targetData = localStoreImpl.targetDataByTarget.get(targetId);
                  lastLimboFreeSnapshotVersion = targetData.snapshotVersion;
                  updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);
                  localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);
                }
              }
              return [2];
          }
        });
      });
    }
    function localStoreGetNextMutationBatch(localStore, afterBatchId) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("Get next mutation batch", "readonly", function(txn) {
        if (afterBatchId === void 0) {
          afterBatchId = BATCHID_UNKNOWN;
        }
        return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);
      });
    }
    function localStoreReadDocument(localStore, key) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("read document", "readonly", function(txn) {
        return localStoreImpl.localDocuments.getDocument(txn, key);
      });
    }
    function localStoreAllocateTarget(localStore, target) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("Allocate target", "readwrite", function(txn) {
        var targetData;
        return localStoreImpl.targetCache.getTargetData(txn, target).next(function(cached) {
          if (cached) {
            targetData = cached;
            return PersistencePromise.resolve(targetData);
          } else {
            return localStoreImpl.targetCache.allocateTargetId(txn).next(function(targetId) {
              targetData = new TargetData(target, targetId, 0, txn.currentSequenceNumber);
              return localStoreImpl.targetCache.addTargetData(txn, targetData).next(function() {
                return targetData;
              });
            });
          }
        });
      }).then(function(targetData) {
        var cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);
        if (cachedTargetData === null || targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) > 0) {
          localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);
          localStoreImpl.targetIdByTarget.set(target, targetData.targetId);
        }
        return targetData;
      });
    }
    function localStoreGetTargetData(localStore, transaction, target) {
      var localStoreImpl = debugCast(localStore);
      var targetId = localStoreImpl.targetIdByTarget.get(target);
      if (targetId !== void 0) {
        return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));
      } else {
        return localStoreImpl.targetCache.getTargetData(transaction, target);
      }
    }
    function localStoreReleaseTarget(localStore, targetId, keepPersistedTargetData) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl, targetData, mode, e_3;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              localStoreImpl = debugCast(localStore);
              targetData = localStoreImpl.targetDataByTarget.get(targetId);
              mode = keepPersistedTargetData ? "readwrite" : "readwrite-primary";
              _d.label = 1;
            case 1:
              _d.trys.push([1, 4, , 5]);
              if (!!keepPersistedTargetData)
                return [3, 3];
              return [4, localStoreImpl.persistence.runTransaction("Release target", mode, function(txn) {
                return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);
              })];
            case 2:
              _d.sent();
              _d.label = 3;
            case 3:
              return [3, 5];
            case 4:
              e_3 = _d.sent();
              if (isIndexedDbTransactionError(e_3)) {
                logDebug(LOG_TAG$c, "Failed to update sequence numbers for target " + targetId + ": " + e_3);
              } else {
                throw e_3;
              }
              return [3, 5];
            case 5:
              localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.remove(targetId);
              localStoreImpl.targetIdByTarget.delete(targetData.target);
              return [2];
          }
        });
      });
    }
    function localStoreExecuteQuery(localStore, query2, usePreviousResults) {
      var localStoreImpl = debugCast(localStore);
      var lastLimboFreeSnapshotVersion = SnapshotVersion.min();
      var remoteKeys = documentKeySet();
      return localStoreImpl.persistence.runTransaction("Execute query", "readonly", function(txn) {
        return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query2)).next(function(targetData) {
          if (targetData) {
            lastLimboFreeSnapshotVersion = targetData.lastLimboFreeSnapshotVersion;
            return localStoreImpl.targetCache.getMatchingKeysForTargetId(txn, targetData.targetId).next(function(result) {
              remoteKeys = result;
            });
          }
        }).next(function() {
          return localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query2, usePreviousResults ? lastLimboFreeSnapshotVersion : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet());
        }).next(function(documents) {
          return { documents, remoteKeys };
        });
      });
    }
    function applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {
      var batch = batchResult.batch;
      var docKeys = batch.keys();
      var promiseChain = PersistencePromise.resolve();
      docKeys.forEach(function(docKey) {
        promiseChain = promiseChain.next(function() {
          return documentBuffer.getEntry(txn, docKey);
        }).next(function(doc2) {
          var ackVersion = batchResult.docVersions.get(docKey);
          hardAssert(ackVersion !== null);
          if (doc2.version.compareTo(ackVersion) < 0) {
            batch.applyToRemoteDocument(doc2, batchResult);
            if (doc2.isValidDocument()) {
              documentBuffer.addEntry(doc2, batchResult.commitVersion);
            }
          }
        });
      });
      return promiseChain.next(function() {
        return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);
      });
    }
    function localStoreLookupMutationDocuments(localStore, batchId) {
      var localStoreImpl = debugCast(localStore);
      var mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);
      return localStoreImpl.persistence.runTransaction("Lookup mutation documents", "readonly", function(txn) {
        return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(function(keys) {
          if (keys) {
            return localStoreImpl.localDocuments.getDocuments(txn, keys);
          } else {
            return PersistencePromise.resolve(null);
          }
        });
      });
    }
    function localStoreRemoveCachedMutationBatchMetadata(localStore, batchId) {
      var mutationQueueImpl = debugCast(debugCast(localStore, LocalStoreImpl).mutationQueue);
      mutationQueueImpl.removeCachedMutationKeys(batchId);
    }
    function localStoreGetActiveClients(localStore) {
      var persistenceImpl = debugCast(debugCast(localStore, LocalStoreImpl).persistence);
      return persistenceImpl.getActiveClients();
    }
    function localStoreGetCachedTarget(localStore, targetId) {
      var localStoreImpl = debugCast(localStore);
      var targetCacheImpl = debugCast(localStoreImpl.targetCache);
      var cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);
      if (cachedTargetData) {
        return Promise.resolve(cachedTargetData.target);
      } else {
        return localStoreImpl.persistence.runTransaction("Get target data", "readonly", function(txn) {
          return targetCacheImpl.getTargetDataForTarget(txn, targetId).next(function(targetData) {
            return targetData ? targetData.target : null;
          });
        });
      }
    }
    function localStoreGetNewDocumentChanges(localStore) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("Get new document changes", "readonly", function(txn) {
        return remoteDocumentCacheGetNewDocumentChanges(localStoreImpl.remoteDocuments, txn, localStoreImpl.lastDocumentChangeReadTime);
      }).then(function(_d) {
        var changedDocs = _d.changedDocs, readTime = _d.readTime;
        localStoreImpl.lastDocumentChangeReadTime = readTime;
        return changedDocs;
      });
    }
    function localStoreSynchronizeLastDocumentChangeReadTime(localStore) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl;
        return tslib.__generator(this, function(_d) {
          localStoreImpl = debugCast(localStore);
          return [2, localStoreImpl.persistence.runTransaction("Synchronize last document change read time", "readonly", function(txn) {
            return remoteDocumentCacheGetLastReadTime(txn);
          }).then(function(readTime) {
            localStoreImpl.lastDocumentChangeReadTime = readTime;
          })];
        });
      });
    }
    function umbrellaTarget(bundleName) {
      return queryToTarget(newQueryForPath(ResourcePath.fromString("__bundle__/docs/" + bundleName)));
    }
    function localStoreApplyBundledDocuments(localStore, bundleConverter, documents, bundleName) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl, documentKeys, documentMap2, versionMap, _i, documents_1, bundleDoc, documentKey, documentBuffer, umbrellaTargetData;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              localStoreImpl = debugCast(localStore);
              documentKeys = documentKeySet();
              documentMap2 = mutableDocumentMap();
              versionMap = documentVersionMap();
              for (_i = 0, documents_1 = documents; _i < documents_1.length; _i++) {
                bundleDoc = documents_1[_i];
                documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);
                if (bundleDoc.document) {
                  documentKeys = documentKeys.add(documentKey);
                }
                documentMap2 = documentMap2.insert(documentKey, bundleConverter.toMutableDocument(bundleDoc));
                versionMap = versionMap.insert(documentKey, bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));
              }
              documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({
                trackRemovals: true
              });
              return [4, localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName))];
            case 1:
              umbrellaTargetData = _d.sent();
              return [2, localStoreImpl.persistence.runTransaction("Apply bundle documents", "readwrite", function(txn) {
                return populateDocumentChangeBuffer(txn, documentBuffer, documentMap2, SnapshotVersion.min(), versionMap).next(function(changedDocs) {
                  documentBuffer.apply(txn);
                  return changedDocs;
                }).next(function(changedDocs) {
                  return localStoreImpl.targetCache.removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId).next(function() {
                    return localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId);
                  }).next(function() {
                    return localStoreImpl.localDocuments.applyLocalViewToDocuments(txn, changedDocs);
                  }).next(function() {
                    return changedDocs;
                  });
                });
              })];
          }
        });
      });
    }
    function localStoreHasNewerBundle(localStore, bundleMetadata) {
      var localStoreImpl = debugCast(localStore);
      var currentReadTime = fromVersion(bundleMetadata.createTime);
      return localStoreImpl.persistence.runTransaction("hasNewerBundle", "readonly", function(transaction) {
        return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);
      }).then(function(cached) {
        return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;
      });
    }
    function localStoreSaveBundle(localStore, bundleMetadata) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("Save bundle", "readwrite", function(transaction) {
        return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);
      });
    }
    function localStoreGetNamedQuery(localStore, queryName) {
      var localStoreImpl = debugCast(localStore);
      return localStoreImpl.persistence.runTransaction("Get named query", "readonly", function(transaction) {
        return localStoreImpl.bundleCache.getNamedQuery(transaction, queryName);
      });
    }
    function localStoreSaveNamedQuery(localStore, query2, documents) {
      if (documents === void 0) {
        documents = documentKeySet();
      }
      return tslib.__awaiter(this, void 0, void 0, function() {
        var allocated, localStoreImpl;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, localStoreAllocateTarget(localStore, queryToTarget(fromBundledQuery(query2.bundledQuery)))];
            case 1:
              allocated = _d.sent();
              localStoreImpl = debugCast(localStore);
              return [2, localStoreImpl.persistence.runTransaction("Save named query", "readwrite", function(transaction) {
                var readTime = fromVersion(query2.readTime);
                if (allocated.snapshotVersion.compareTo(readTime) >= 0) {
                  return localStoreImpl.bundleCache.saveNamedQuery(transaction, query2);
                }
                var newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);
                localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);
                return localStoreImpl.targetCache.updateTargetData(transaction, newTargetData).next(function() {
                  return localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId);
                }).next(function() {
                  return localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId);
                }).next(function() {
                  return localStoreImpl.bundleCache.saveNamedQuery(transaction, query2);
                });
              })];
          }
        });
      });
    }
    var MemoryBundleCache = function() {
      function MemoryBundleCache2(serializer) {
        this.serializer = serializer;
        this.bundles = new Map();
        this.namedQueries = new Map();
      }
      MemoryBundleCache2.prototype.getBundleMetadata = function(transaction, bundleId) {
        return PersistencePromise.resolve(this.bundles.get(bundleId));
      };
      MemoryBundleCache2.prototype.saveBundleMetadata = function(transaction, bundleMetadata) {
        this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));
        return PersistencePromise.resolve();
      };
      MemoryBundleCache2.prototype.getNamedQuery = function(transaction, queryName) {
        return PersistencePromise.resolve(this.namedQueries.get(queryName));
      };
      MemoryBundleCache2.prototype.saveNamedQuery = function(transaction, query2) {
        this.namedQueries.set(query2.name, fromProtoNamedQuery(query2));
        return PersistencePromise.resolve();
      };
      return MemoryBundleCache2;
    }();
    var ReferenceSet = function() {
      function ReferenceSet2() {
        this.refsByKey = new SortedSet(DocReference.compareByKey);
        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);
      }
      ReferenceSet2.prototype.isEmpty = function() {
        return this.refsByKey.isEmpty();
      };
      ReferenceSet2.prototype.addReference = function(key, id) {
        var ref = new DocReference(key, id);
        this.refsByKey = this.refsByKey.add(ref);
        this.refsByTarget = this.refsByTarget.add(ref);
      };
      ReferenceSet2.prototype.addReferences = function(keys, id) {
        var _this = this;
        keys.forEach(function(key) {
          return _this.addReference(key, id);
        });
      };
      ReferenceSet2.prototype.removeReference = function(key, id) {
        this.removeRef(new DocReference(key, id));
      };
      ReferenceSet2.prototype.removeReferences = function(keys, id) {
        var _this = this;
        keys.forEach(function(key) {
          return _this.removeReference(key, id);
        });
      };
      ReferenceSet2.prototype.removeReferencesForId = function(id) {
        var _this = this;
        var emptyKey = new DocumentKey(new ResourcePath([]));
        var startRef = new DocReference(emptyKey, id);
        var endRef = new DocReference(emptyKey, id + 1);
        var keys = [];
        this.refsByTarget.forEachInRange([startRef, endRef], function(ref) {
          _this.removeRef(ref);
          keys.push(ref.key);
        });
        return keys;
      };
      ReferenceSet2.prototype.removeAllReferences = function() {
        var _this = this;
        this.refsByKey.forEach(function(ref) {
          return _this.removeRef(ref);
        });
      };
      ReferenceSet2.prototype.removeRef = function(ref) {
        this.refsByKey = this.refsByKey.delete(ref);
        this.refsByTarget = this.refsByTarget.delete(ref);
      };
      ReferenceSet2.prototype.referencesForId = function(id) {
        var emptyKey = new DocumentKey(new ResourcePath([]));
        var startRef = new DocReference(emptyKey, id);
        var endRef = new DocReference(emptyKey, id + 1);
        var keys = documentKeySet();
        this.refsByTarget.forEachInRange([startRef, endRef], function(ref) {
          keys = keys.add(ref.key);
        });
        return keys;
      };
      ReferenceSet2.prototype.containsKey = function(key) {
        var ref = new DocReference(key, 0);
        var firstRef = this.refsByKey.firstAfterOrEqual(ref);
        return firstRef !== null && key.isEqual(firstRef.key);
      };
      return ReferenceSet2;
    }();
    var DocReference = function() {
      function DocReference2(key, targetOrBatchId) {
        this.key = key;
        this.targetOrBatchId = targetOrBatchId;
      }
      DocReference2.compareByKey = function(left, right) {
        return DocumentKey.comparator(left.key, right.key) || primitiveComparator(left.targetOrBatchId, right.targetOrBatchId);
      };
      DocReference2.compareByTargetId = function(left, right) {
        return primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) || DocumentKey.comparator(left.key, right.key);
      };
      return DocReference2;
    }();
    var MemoryMutationQueue = function() {
      function MemoryMutationQueue2(indexManager, referenceDelegate) {
        this.indexManager = indexManager;
        this.referenceDelegate = referenceDelegate;
        this.mutationQueue = [];
        this.nextBatchId = 1;
        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);
      }
      MemoryMutationQueue2.prototype.checkEmpty = function(transaction) {
        return PersistencePromise.resolve(this.mutationQueue.length === 0);
      };
      MemoryMutationQueue2.prototype.addMutationBatch = function(transaction, localWriteTime, baseMutations, mutations) {
        var batchId = this.nextBatchId;
        this.nextBatchId++;
        if (this.mutationQueue.length > 0) {
          this.mutationQueue[this.mutationQueue.length - 1];
        }
        var batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);
        this.mutationQueue.push(batch);
        for (var _i = 0, mutations_3 = mutations; _i < mutations_3.length; _i++) {
          var mutation = mutations_3[_i];
          this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));
          this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());
        }
        return PersistencePromise.resolve(batch);
      };
      MemoryMutationQueue2.prototype.lookupMutationBatch = function(transaction, batchId) {
        return PersistencePromise.resolve(this.findMutationBatch(batchId));
      };
      MemoryMutationQueue2.prototype.getNextMutationBatchAfterBatchId = function(transaction, batchId) {
        var nextBatchId = batchId + 1;
        var rawIndex = this.indexOfBatchId(nextBatchId);
        var index2 = rawIndex < 0 ? 0 : rawIndex;
        return PersistencePromise.resolve(this.mutationQueue.length > index2 ? this.mutationQueue[index2] : null);
      };
      MemoryMutationQueue2.prototype.getHighestUnacknowledgedBatchId = function() {
        return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);
      };
      MemoryMutationQueue2.prototype.getAllMutationBatches = function(transaction) {
        return PersistencePromise.resolve(this.mutationQueue.slice());
      };
      MemoryMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKey = function(transaction, documentKey) {
        var _this = this;
        var start = new DocReference(documentKey, 0);
        var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);
        var result = [];
        this.batchesByDocumentKey.forEachInRange([start, end], function(ref) {
          var batch = _this.findMutationBatch(ref.targetOrBatchId);
          result.push(batch);
        });
        return PersistencePromise.resolve(result);
      };
      MemoryMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKeys = function(transaction, documentKeys) {
        var _this = this;
        var uniqueBatchIDs = new SortedSet(primitiveComparator);
        documentKeys.forEach(function(documentKey) {
          var start = new DocReference(documentKey, 0);
          var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);
          _this.batchesByDocumentKey.forEachInRange([start, end], function(ref) {
            uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);
          });
        });
        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
      };
      MemoryMutationQueue2.prototype.getAllMutationBatchesAffectingQuery = function(transaction, query2) {
        var prefix = query2.path;
        var immediateChildrenPathLength = prefix.length + 1;
        var startPath = prefix;
        if (!DocumentKey.isDocumentKey(startPath)) {
          startPath = startPath.child("");
        }
        var start = new DocReference(new DocumentKey(startPath), 0);
        var uniqueBatchIDs = new SortedSet(primitiveComparator);
        this.batchesByDocumentKey.forEachWhile(function(ref) {
          var rowKeyPath = ref.key.path;
          if (!prefix.isPrefixOf(rowKeyPath)) {
            return false;
          } else {
            if (rowKeyPath.length === immediateChildrenPathLength) {
              uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);
            }
            return true;
          }
        }, start);
        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
      };
      MemoryMutationQueue2.prototype.findMutationBatches = function(batchIDs) {
        var _this = this;
        var result = [];
        batchIDs.forEach(function(batchId) {
          var batch = _this.findMutationBatch(batchId);
          if (batch !== null) {
            result.push(batch);
          }
        });
        return result;
      };
      MemoryMutationQueue2.prototype.removeMutationBatch = function(transaction, batch) {
        var _this = this;
        var batchIndex = this.indexOfExistingBatchId(batch.batchId, "removed");
        hardAssert(batchIndex === 0);
        this.mutationQueue.shift();
        var references = this.batchesByDocumentKey;
        return PersistencePromise.forEach(batch.mutations, function(mutation) {
          var ref = new DocReference(mutation.key, batch.batchId);
          references = references.delete(ref);
          return _this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);
        }).next(function() {
          _this.batchesByDocumentKey = references;
        });
      };
      MemoryMutationQueue2.prototype.removeCachedMutationKeys = function(batchId) {
      };
      MemoryMutationQueue2.prototype.containsKey = function(txn, key) {
        var ref = new DocReference(key, 0);
        var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);
        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));
      };
      MemoryMutationQueue2.prototype.performConsistencyCheck = function(txn) {
        if (this.mutationQueue.length === 0)
          ;
        return PersistencePromise.resolve();
      };
      MemoryMutationQueue2.prototype.indexOfExistingBatchId = function(batchId, action) {
        var index2 = this.indexOfBatchId(batchId);
        return index2;
      };
      MemoryMutationQueue2.prototype.indexOfBatchId = function(batchId) {
        if (this.mutationQueue.length === 0) {
          return 0;
        }
        var firstBatchId = this.mutationQueue[0].batchId;
        return batchId - firstBatchId;
      };
      MemoryMutationQueue2.prototype.findMutationBatch = function(batchId) {
        var index2 = this.indexOfBatchId(batchId);
        if (index2 < 0 || index2 >= this.mutationQueue.length) {
          return null;
        }
        var batch = this.mutationQueue[index2];
        return batch;
      };
      return MemoryMutationQueue2;
    }();
    function documentEntryMap() {
      return new SortedMap(DocumentKey.comparator);
    }
    var MemoryRemoteDocumentCacheImpl = function() {
      function MemoryRemoteDocumentCacheImpl2(indexManager, sizer) {
        this.indexManager = indexManager;
        this.sizer = sizer;
        this.docs = documentEntryMap();
        this.size = 0;
      }
      MemoryRemoteDocumentCacheImpl2.prototype.addEntry = function(transaction, doc2, readTime) {
        var key = doc2.key;
        var entry = this.docs.get(key);
        var previousSize = entry ? entry.size : 0;
        var currentSize = this.sizer(doc2);
        this.docs = this.docs.insert(key, {
          document: doc2.clone(),
          size: currentSize,
          readTime
        });
        this.size += currentSize - previousSize;
        return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());
      };
      MemoryRemoteDocumentCacheImpl2.prototype.removeEntry = function(documentKey) {
        var entry = this.docs.get(documentKey);
        if (entry) {
          this.docs = this.docs.remove(documentKey);
          this.size -= entry.size;
        }
      };
      MemoryRemoteDocumentCacheImpl2.prototype.getEntry = function(transaction, documentKey) {
        var entry = this.docs.get(documentKey);
        return PersistencePromise.resolve(entry ? entry.document.clone() : MutableDocument.newInvalidDocument(documentKey));
      };
      MemoryRemoteDocumentCacheImpl2.prototype.getEntries = function(transaction, documentKeys) {
        var _this = this;
        var results = mutableDocumentMap();
        documentKeys.forEach(function(documentKey) {
          var entry = _this.docs.get(documentKey);
          results = results.insert(documentKey, entry ? entry.document.clone() : MutableDocument.newInvalidDocument(documentKey));
        });
        return PersistencePromise.resolve(results);
      };
      MemoryRemoteDocumentCacheImpl2.prototype.getDocumentsMatchingQuery = function(transaction, query2, sinceReadTime) {
        var results = mutableDocumentMap();
        var prefix = new DocumentKey(query2.path.child(""));
        var iterator = this.docs.getIteratorFrom(prefix);
        while (iterator.hasNext()) {
          var _d = iterator.getNext(), key = _d.key, _e = _d.value, document_3 = _e.document, readTime = _e.readTime;
          if (!query2.path.isPrefixOf(key.path)) {
            break;
          }
          if (readTime.compareTo(sinceReadTime) <= 0) {
            continue;
          }
          if (!queryMatches(query2, document_3)) {
            continue;
          }
          results = results.insert(document_3.key, document_3.clone());
        }
        return PersistencePromise.resolve(results);
      };
      MemoryRemoteDocumentCacheImpl2.prototype.forEachDocumentKey = function(transaction, f) {
        return PersistencePromise.forEach(this.docs, function(key) {
          return f(key);
        });
      };
      MemoryRemoteDocumentCacheImpl2.prototype.newChangeBuffer = function(options2) {
        return new MemoryRemoteDocumentChangeBuffer(this);
      };
      MemoryRemoteDocumentCacheImpl2.prototype.getSize = function(txn) {
        return PersistencePromise.resolve(this.size);
      };
      return MemoryRemoteDocumentCacheImpl2;
    }();
    function newMemoryRemoteDocumentCache(indexManager, sizer) {
      return new MemoryRemoteDocumentCacheImpl(indexManager, sizer);
    }
    var MemoryRemoteDocumentChangeBuffer = function(_super) {
      tslib.__extends(MemoryRemoteDocumentChangeBuffer2, _super);
      function MemoryRemoteDocumentChangeBuffer2(documentCache) {
        var _this = _super.call(this) || this;
        _this.documentCache = documentCache;
        return _this;
      }
      MemoryRemoteDocumentChangeBuffer2.prototype.applyChanges = function(transaction) {
        var _this = this;
        var promises = [];
        this.changes.forEach(function(key, doc2) {
          if (doc2.document.isValidDocument()) {
            promises.push(_this.documentCache.addEntry(transaction, doc2.document, _this.getReadTime(key)));
          } else {
            _this.documentCache.removeEntry(key);
          }
        });
        return PersistencePromise.waitFor(promises);
      };
      MemoryRemoteDocumentChangeBuffer2.prototype.getFromCache = function(transaction, documentKey) {
        return this.documentCache.getEntry(transaction, documentKey);
      };
      MemoryRemoteDocumentChangeBuffer2.prototype.getAllFromCache = function(transaction, documentKeys) {
        return this.documentCache.getEntries(transaction, documentKeys);
      };
      return MemoryRemoteDocumentChangeBuffer2;
    }(RemoteDocumentChangeBuffer);
    var MemoryTargetCache = function() {
      function MemoryTargetCache2(persistence) {
        this.persistence = persistence;
        this.targets = new ObjectMap(function(t) {
          return canonifyTarget(t);
        }, targetEquals);
        this.lastRemoteSnapshotVersion = SnapshotVersion.min();
        this.highestTargetId = 0;
        this.highestSequenceNumber = 0;
        this.references = new ReferenceSet();
        this.targetCount = 0;
        this.targetIdGenerator = TargetIdGenerator.forTargetCache();
      }
      MemoryTargetCache2.prototype.forEachTarget = function(txn, f) {
        this.targets.forEach(function(_, targetData) {
          return f(targetData);
        });
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.getLastRemoteSnapshotVersion = function(transaction) {
        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);
      };
      MemoryTargetCache2.prototype.getHighestSequenceNumber = function(transaction) {
        return PersistencePromise.resolve(this.highestSequenceNumber);
      };
      MemoryTargetCache2.prototype.allocateTargetId = function(transaction) {
        this.highestTargetId = this.targetIdGenerator.next();
        return PersistencePromise.resolve(this.highestTargetId);
      };
      MemoryTargetCache2.prototype.setTargetsMetadata = function(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {
        if (lastRemoteSnapshotVersion) {
          this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
        }
        if (highestListenSequenceNumber > this.highestSequenceNumber) {
          this.highestSequenceNumber = highestListenSequenceNumber;
        }
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.saveTargetData = function(targetData) {
        this.targets.set(targetData.target, targetData);
        var targetId = targetData.targetId;
        if (targetId > this.highestTargetId) {
          this.targetIdGenerator = new TargetIdGenerator(targetId);
          this.highestTargetId = targetId;
        }
        if (targetData.sequenceNumber > this.highestSequenceNumber) {
          this.highestSequenceNumber = targetData.sequenceNumber;
        }
      };
      MemoryTargetCache2.prototype.addTargetData = function(transaction, targetData) {
        this.saveTargetData(targetData);
        this.targetCount += 1;
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.updateTargetData = function(transaction, targetData) {
        this.saveTargetData(targetData);
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.removeTargetData = function(transaction, targetData) {
        this.targets.delete(targetData.target);
        this.references.removeReferencesForId(targetData.targetId);
        this.targetCount -= 1;
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.removeTargets = function(transaction, upperBound, activeTargetIds) {
        var _this = this;
        var count = 0;
        var removals = [];
        this.targets.forEach(function(key, targetData) {
          if (targetData.sequenceNumber <= upperBound && activeTargetIds.get(targetData.targetId) === null) {
            _this.targets.delete(key);
            removals.push(_this.removeMatchingKeysForTargetId(transaction, targetData.targetId));
            count++;
          }
        });
        return PersistencePromise.waitFor(removals).next(function() {
          return count;
        });
      };
      MemoryTargetCache2.prototype.getTargetCount = function(transaction) {
        return PersistencePromise.resolve(this.targetCount);
      };
      MemoryTargetCache2.prototype.getTargetData = function(transaction, target) {
        var targetData = this.targets.get(target) || null;
        return PersistencePromise.resolve(targetData);
      };
      MemoryTargetCache2.prototype.addMatchingKeys = function(txn, keys, targetId) {
        this.references.addReferences(keys, targetId);
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.removeMatchingKeys = function(txn, keys, targetId) {
        this.references.removeReferences(keys, targetId);
        var referenceDelegate = this.persistence.referenceDelegate;
        var promises = [];
        if (referenceDelegate) {
          keys.forEach(function(key) {
            promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));
          });
        }
        return PersistencePromise.waitFor(promises);
      };
      MemoryTargetCache2.prototype.removeMatchingKeysForTargetId = function(txn, targetId) {
        this.references.removeReferencesForId(targetId);
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.getMatchingKeysForTargetId = function(txn, targetId) {
        var matchingKeys = this.references.referencesForId(targetId);
        return PersistencePromise.resolve(matchingKeys);
      };
      MemoryTargetCache2.prototype.containsKey = function(txn, key) {
        return PersistencePromise.resolve(this.references.containsKey(key));
      };
      return MemoryTargetCache2;
    }();
    var LOG_TAG$b = "MemoryPersistence";
    var MemoryPersistence = function() {
      function MemoryPersistence2(referenceDelegateFactory, serializer) {
        var _this = this;
        this.mutationQueues = {};
        this.listenSequence = new ListenSequence(0);
        this._started = false;
        this._started = true;
        this.referenceDelegate = referenceDelegateFactory(this);
        this.targetCache = new MemoryTargetCache(this);
        var sizer = function(doc2) {
          return _this.referenceDelegate.documentSize(doc2);
        };
        this.indexManager = new MemoryIndexManager();
        this.remoteDocumentCache = newMemoryRemoteDocumentCache(this.indexManager, sizer);
        this.serializer = new LocalSerializer(serializer);
        this.bundleCache = new MemoryBundleCache(this.serializer);
      }
      MemoryPersistence2.prototype.start = function() {
        return Promise.resolve();
      };
      MemoryPersistence2.prototype.shutdown = function() {
        this._started = false;
        return Promise.resolve();
      };
      Object.defineProperty(MemoryPersistence2.prototype, "started", {
        get: function() {
          return this._started;
        },
        enumerable: false,
        configurable: true
      });
      MemoryPersistence2.prototype.setDatabaseDeletedListener = function() {
      };
      MemoryPersistence2.prototype.setNetworkEnabled = function() {
      };
      MemoryPersistence2.prototype.getIndexManager = function() {
        return this.indexManager;
      };
      MemoryPersistence2.prototype.getMutationQueue = function(user) {
        var queue = this.mutationQueues[user.toKey()];
        if (!queue) {
          queue = new MemoryMutationQueue(this.indexManager, this.referenceDelegate);
          this.mutationQueues[user.toKey()] = queue;
        }
        return queue;
      };
      MemoryPersistence2.prototype.getTargetCache = function() {
        return this.targetCache;
      };
      MemoryPersistence2.prototype.getRemoteDocumentCache = function() {
        return this.remoteDocumentCache;
      };
      MemoryPersistence2.prototype.getBundleCache = function() {
        return this.bundleCache;
      };
      MemoryPersistence2.prototype.runTransaction = function(action, mode, transactionOperation) {
        var _this = this;
        logDebug(LOG_TAG$b, "Starting transaction:", action);
        var txn = new MemoryTransaction(this.listenSequence.next());
        this.referenceDelegate.onTransactionStarted();
        return transactionOperation(txn).next(function(result) {
          return _this.referenceDelegate.onTransactionCommitted(txn).next(function() {
            return result;
          });
        }).toPromise().then(function(result) {
          txn.raiseOnCommittedEvent();
          return result;
        });
      };
      MemoryPersistence2.prototype.mutationQueuesContainKey = function(transaction, key) {
        return PersistencePromise.or(Object.values(this.mutationQueues).map(function(queue) {
          return function() {
            return queue.containsKey(transaction, key);
          };
        }));
      };
      return MemoryPersistence2;
    }();
    var MemoryTransaction = function(_super) {
      tslib.__extends(MemoryTransaction2, _super);
      function MemoryTransaction2(currentSequenceNumber) {
        var _this = _super.call(this) || this;
        _this.currentSequenceNumber = currentSequenceNumber;
        return _this;
      }
      return MemoryTransaction2;
    }(PersistenceTransaction);
    var MemoryEagerDelegate = function() {
      function MemoryEagerDelegate2(persistence) {
        this.persistence = persistence;
        this.localViewReferences = new ReferenceSet();
        this._orphanedDocuments = null;
      }
      MemoryEagerDelegate2.factory = function(persistence) {
        return new MemoryEagerDelegate2(persistence);
      };
      Object.defineProperty(MemoryEagerDelegate2.prototype, "orphanedDocuments", {
        get: function() {
          if (!this._orphanedDocuments) {
            throw fail();
          } else {
            return this._orphanedDocuments;
          }
        },
        enumerable: false,
        configurable: true
      });
      MemoryEagerDelegate2.prototype.addReference = function(txn, targetId, key) {
        this.localViewReferences.addReference(key, targetId);
        this.orphanedDocuments.delete(key.toString());
        return PersistencePromise.resolve();
      };
      MemoryEagerDelegate2.prototype.removeReference = function(txn, targetId, key) {
        this.localViewReferences.removeReference(key, targetId);
        this.orphanedDocuments.add(key.toString());
        return PersistencePromise.resolve();
      };
      MemoryEagerDelegate2.prototype.markPotentiallyOrphaned = function(txn, key) {
        this.orphanedDocuments.add(key.toString());
        return PersistencePromise.resolve();
      };
      MemoryEagerDelegate2.prototype.removeTarget = function(txn, targetData) {
        var _this = this;
        var orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);
        orphaned.forEach(function(key) {
          return _this.orphanedDocuments.add(key.toString());
        });
        var cache = this.persistence.getTargetCache();
        return cache.getMatchingKeysForTargetId(txn, targetData.targetId).next(function(keys) {
          keys.forEach(function(key) {
            return _this.orphanedDocuments.add(key.toString());
          });
        }).next(function() {
          return cache.removeTargetData(txn, targetData);
        });
      };
      MemoryEagerDelegate2.prototype.onTransactionStarted = function() {
        this._orphanedDocuments = new Set();
      };
      MemoryEagerDelegate2.prototype.onTransactionCommitted = function(txn) {
        var _this = this;
        var cache = this.persistence.getRemoteDocumentCache();
        var changeBuffer = cache.newChangeBuffer();
        return PersistencePromise.forEach(this.orphanedDocuments, function(path2) {
          var key = DocumentKey.fromPath(path2);
          return _this.isReferenced(txn, key).next(function(isReferenced) {
            if (!isReferenced) {
              changeBuffer.removeEntry(key);
            }
          });
        }).next(function() {
          _this._orphanedDocuments = null;
          return changeBuffer.apply(txn);
        });
      };
      MemoryEagerDelegate2.prototype.updateLimboDocument = function(txn, key) {
        var _this = this;
        return this.isReferenced(txn, key).next(function(isReferenced) {
          if (isReferenced) {
            _this.orphanedDocuments.delete(key.toString());
          } else {
            _this.orphanedDocuments.add(key.toString());
          }
        });
      };
      MemoryEagerDelegate2.prototype.documentSize = function(doc2) {
        return 0;
      };
      MemoryEagerDelegate2.prototype.isReferenced = function(txn, key) {
        var _this = this;
        return PersistencePromise.or([
          function() {
            return PersistencePromise.resolve(_this.localViewReferences.containsKey(key));
          },
          function() {
            return _this.persistence.getTargetCache().containsKey(txn, key);
          },
          function() {
            return _this.persistence.mutationQueuesContainKey(txn, key);
          }
        ]);
      };
      return MemoryEagerDelegate2;
    }();
    var QueryEngine = function() {
      function QueryEngine2() {
      }
      QueryEngine2.prototype.setLocalDocumentsView = function(localDocuments) {
        this.localDocumentsView = localDocuments;
      };
      QueryEngine2.prototype.getDocumentsMatchingQuery = function(transaction, query2, lastLimboFreeSnapshotVersion, remoteKeys) {
        var _this = this;
        if (matchesAllDocuments(query2)) {
          return this.executeFullCollectionScan(transaction, query2);
        }
        if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {
          return this.executeFullCollectionScan(transaction, query2);
        }
        return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(function(documents) {
          var previousResults = _this.applyQuery(query2, documents);
          if ((hasLimitToFirst(query2) || hasLimitToLast(query2)) && _this.needsRefill(query2.limitType, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {
            return _this.executeFullCollectionScan(transaction, query2);
          }
          if (getLogLevel() <= logger.LogLevel.DEBUG) {
            logDebug("QueryEngine", "Re-using previous result from %s to execute query: %s", lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query2));
          }
          return _this.localDocumentsView.getDocumentsMatchingQuery(transaction, query2, lastLimboFreeSnapshotVersion).next(function(updatedResults) {
            previousResults.forEach(function(doc2) {
              updatedResults = updatedResults.insert(doc2.key, doc2);
            });
            return updatedResults;
          });
        });
      };
      QueryEngine2.prototype.applyQuery = function(query2, documents) {
        var queryResults = new SortedSet(newQueryComparator(query2));
        documents.forEach(function(_, maybeDoc) {
          if (queryMatches(query2, maybeDoc)) {
            queryResults = queryResults.add(maybeDoc);
          }
        });
        return queryResults;
      };
      QueryEngine2.prototype.needsRefill = function(limitType, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {
        if (remoteKeys.size !== sortedPreviousResults.size) {
          return true;
        }
        var docAtLimitEdge = limitType === "F" ? sortedPreviousResults.last() : sortedPreviousResults.first();
        if (!docAtLimitEdge) {
          return false;
        }
        return docAtLimitEdge.hasPendingWrites || docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0;
      };
      QueryEngine2.prototype.executeFullCollectionScan = function(transaction, query2) {
        if (getLogLevel() <= logger.LogLevel.DEBUG) {
          logDebug("QueryEngine", "Using full collection scan to execute query:", stringifyQuery(query2));
        }
        return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query2, SnapshotVersion.min());
      };
      return QueryEngine2;
    }();
    var User = function() {
      function User2(uid) {
        this.uid = uid;
      }
      User2.prototype.isAuthenticated = function() {
        return this.uid != null;
      };
      User2.prototype.toKey = function() {
        if (this.isAuthenticated()) {
          return "uid:" + this.uid;
        } else {
          return "anonymous-user";
        }
      };
      User2.prototype.isEqual = function(otherUser) {
        return otherUser.uid === this.uid;
      };
      return User2;
    }();
    User.UNAUTHENTICATED = new User(null);
    User.GOOGLE_CREDENTIALS = new User("google-credentials-uid");
    User.FIRST_PARTY = new User("first-party-uid");
    var CLIENT_STATE_KEY_PREFIX = "firestore_clients";
    function createWebStorageClientStateKey(persistenceKey, clientId) {
      return CLIENT_STATE_KEY_PREFIX + "_" + persistenceKey + "_" + clientId;
    }
    var MUTATION_BATCH_KEY_PREFIX = "firestore_mutations";
    function createWebStorageMutationBatchKey(persistenceKey, user, batchId) {
      var mutationKey = MUTATION_BATCH_KEY_PREFIX + "_" + persistenceKey + "_" + batchId;
      if (user.isAuthenticated()) {
        mutationKey += "_" + user.uid;
      }
      return mutationKey;
    }
    var QUERY_TARGET_KEY_PREFIX = "firestore_targets";
    function createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {
      return QUERY_TARGET_KEY_PREFIX + "_" + persistenceKey + "_" + targetId;
    }
    var ONLINE_STATE_KEY_PREFIX = "firestore_online_state";
    function createWebStorageOnlineStateKey(persistenceKey) {
      return ONLINE_STATE_KEY_PREFIX + "_" + persistenceKey;
    }
    var BUNDLE_LOADED_KEY_PREFIX = "firestore_bundle_loaded";
    function createBundleLoadedKey(persistenceKey) {
      return BUNDLE_LOADED_KEY_PREFIX + "_" + persistenceKey;
    }
    var SEQUENCE_NUMBER_KEY_PREFIX = "firestore_sequence_number";
    function createWebStorageSequenceNumberKey(persistenceKey) {
      return SEQUENCE_NUMBER_KEY_PREFIX + "_" + persistenceKey;
    }
    var LOG_TAG$a = "SharedClientState";
    var MutationMetadata = function() {
      function MutationMetadata2(user, batchId, state, error3) {
        this.user = user;
        this.batchId = batchId;
        this.state = state;
        this.error = error3;
      }
      MutationMetadata2.fromWebStorageEntry = function(user, batchId, value) {
        var mutationBatch = JSON.parse(value);
        var validData = typeof mutationBatch === "object" && ["pending", "acknowledged", "rejected"].indexOf(mutationBatch.state) !== -1 && (mutationBatch.error === void 0 || typeof mutationBatch.error === "object");
        var firestoreError = void 0;
        if (validData && mutationBatch.error) {
          validData = typeof mutationBatch.error.message === "string" && typeof mutationBatch.error.code === "string";
          if (validData) {
            firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);
          }
        }
        if (validData) {
          return new MutationMetadata2(user, batchId, mutationBatch.state, firestoreError);
        } else {
          logError(LOG_TAG$a, "Failed to parse mutation state for ID '" + batchId + "': " + value);
          return null;
        }
      };
      MutationMetadata2.prototype.toWebStorageJSON = function() {
        var batchMetadata = {
          state: this.state,
          updateTimeMs: Date.now()
        };
        if (this.error) {
          batchMetadata.error = {
            code: this.error.code,
            message: this.error.message
          };
        }
        return JSON.stringify(batchMetadata);
      };
      return MutationMetadata2;
    }();
    var QueryTargetMetadata = function() {
      function QueryTargetMetadata2(targetId, state, error3) {
        this.targetId = targetId;
        this.state = state;
        this.error = error3;
      }
      QueryTargetMetadata2.fromWebStorageEntry = function(targetId, value) {
        var targetState = JSON.parse(value);
        var validData = typeof targetState === "object" && ["not-current", "current", "rejected"].indexOf(targetState.state) !== -1 && (targetState.error === void 0 || typeof targetState.error === "object");
        var firestoreError = void 0;
        if (validData && targetState.error) {
          validData = typeof targetState.error.message === "string" && typeof targetState.error.code === "string";
          if (validData) {
            firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);
          }
        }
        if (validData) {
          return new QueryTargetMetadata2(targetId, targetState.state, firestoreError);
        } else {
          logError(LOG_TAG$a, "Failed to parse target state for ID '" + targetId + "': " + value);
          return null;
        }
      };
      QueryTargetMetadata2.prototype.toWebStorageJSON = function() {
        var targetState = {
          state: this.state,
          updateTimeMs: Date.now()
        };
        if (this.error) {
          targetState.error = {
            code: this.error.code,
            message: this.error.message
          };
        }
        return JSON.stringify(targetState);
      };
      return QueryTargetMetadata2;
    }();
    var RemoteClientState = function() {
      function RemoteClientState2(clientId, activeTargetIds) {
        this.clientId = clientId;
        this.activeTargetIds = activeTargetIds;
      }
      RemoteClientState2.fromWebStorageEntry = function(clientId, value) {
        var clientState = JSON.parse(value);
        var validData = typeof clientState === "object" && clientState.activeTargetIds instanceof Array;
        var activeTargetIdsSet = targetIdSet();
        for (var i = 0; validData && i < clientState.activeTargetIds.length; ++i) {
          validData = isSafeInteger(clientState.activeTargetIds[i]);
          activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);
        }
        if (validData) {
          return new RemoteClientState2(clientId, activeTargetIdsSet);
        } else {
          logError(LOG_TAG$a, "Failed to parse client data for instance '" + clientId + "': " + value);
          return null;
        }
      };
      return RemoteClientState2;
    }();
    var SharedOnlineState = function() {
      function SharedOnlineState2(clientId, onlineState) {
        this.clientId = clientId;
        this.onlineState = onlineState;
      }
      SharedOnlineState2.fromWebStorageEntry = function(value) {
        var onlineState = JSON.parse(value);
        var validData = typeof onlineState === "object" && ["Unknown", "Online", "Offline"].indexOf(onlineState.onlineState) !== -1 && typeof onlineState.clientId === "string";
        if (validData) {
          return new SharedOnlineState2(onlineState.clientId, onlineState.onlineState);
        } else {
          logError(LOG_TAG$a, "Failed to parse online state: " + value);
          return null;
        }
      };
      return SharedOnlineState2;
    }();
    var LocalClientState = function() {
      function LocalClientState2() {
        this.activeTargetIds = targetIdSet();
      }
      LocalClientState2.prototype.addQueryTarget = function(targetId) {
        this.activeTargetIds = this.activeTargetIds.add(targetId);
      };
      LocalClientState2.prototype.removeQueryTarget = function(targetId) {
        this.activeTargetIds = this.activeTargetIds.delete(targetId);
      };
      LocalClientState2.prototype.toWebStorageJSON = function() {
        var data = {
          activeTargetIds: this.activeTargetIds.toArray(),
          updateTimeMs: Date.now()
        };
        return JSON.stringify(data);
      };
      return LocalClientState2;
    }();
    var WebStorageSharedClientState = function() {
      function WebStorageSharedClientState2(window2, queue, persistenceKey, localClientId, initialUser) {
        this.window = window2;
        this.queue = queue;
        this.persistenceKey = persistenceKey;
        this.localClientId = localClientId;
        this.syncEngine = null;
        this.onlineStateHandler = null;
        this.sequenceNumberHandler = null;
        this.storageListener = this.handleWebStorageEvent.bind(this);
        this.activeClients = new SortedMap(primitiveComparator);
        this.started = false;
        this.earlyEvents = [];
        var escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        this.storage = this.window.localStorage;
        this.currentUser = initialUser;
        this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);
        this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);
        this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());
        this.clientStateKeyRe = new RegExp("^" + CLIENT_STATE_KEY_PREFIX + "_" + escapedPersistenceKey + "_([^_]*)$");
        this.mutationBatchKeyRe = new RegExp("^" + MUTATION_BATCH_KEY_PREFIX + "_" + escapedPersistenceKey + "_(\\d+)(?:_(.*))?$");
        this.queryTargetKeyRe = new RegExp("^" + QUERY_TARGET_KEY_PREFIX + "_" + escapedPersistenceKey + "_(\\d+)$");
        this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);
        this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);
        this.window.addEventListener("storage", this.storageListener);
      }
      WebStorageSharedClientState2.isAvailable = function(window2) {
        return !!(window2 && window2.localStorage);
      };
      WebStorageSharedClientState2.prototype.start = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var existingClients, _i, existingClients_1, clientId, storageItem, clientState, onlineStateJSON, onlineState, _d, _e, event_1;
          var _this = this;
          return tslib.__generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                return [4, this.syncEngine.getActiveClients()];
              case 1:
                existingClients = _f.sent();
                for (_i = 0, existingClients_1 = existingClients; _i < existingClients_1.length; _i++) {
                  clientId = existingClients_1[_i];
                  if (clientId === this.localClientId) {
                    continue;
                  }
                  storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));
                  if (storageItem) {
                    clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);
                    if (clientState) {
                      this.activeClients = this.activeClients.insert(clientState.clientId, clientState);
                    }
                  }
                }
                this.persistClientState();
                onlineStateJSON = this.storage.getItem(this.onlineStateKey);
                if (onlineStateJSON) {
                  onlineState = this.fromWebStorageOnlineState(onlineStateJSON);
                  if (onlineState) {
                    this.handleOnlineStateEvent(onlineState);
                  }
                }
                for (_d = 0, _e = this.earlyEvents; _d < _e.length; _d++) {
                  event_1 = _e[_d];
                  this.handleWebStorageEvent(event_1);
                }
                this.earlyEvents = [];
                this.window.addEventListener("pagehide", function() {
                  return _this.shutdown();
                });
                this.started = true;
                return [2];
            }
          });
        });
      };
      WebStorageSharedClientState2.prototype.writeSequenceNumber = function(sequenceNumber) {
        this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));
      };
      WebStorageSharedClientState2.prototype.getAllActiveQueryTargets = function() {
        return this.extractActiveQueryTargets(this.activeClients);
      };
      WebStorageSharedClientState2.prototype.isActiveQueryTarget = function(targetId) {
        var found = false;
        this.activeClients.forEach(function(key, value) {
          if (value.activeTargetIds.has(targetId)) {
            found = true;
          }
        });
        return found;
      };
      WebStorageSharedClientState2.prototype.addPendingMutation = function(batchId) {
        this.persistMutationState(batchId, "pending");
      };
      WebStorageSharedClientState2.prototype.updateMutationState = function(batchId, state, error3) {
        this.persistMutationState(batchId, state, error3);
        this.removeMutationState(batchId);
      };
      WebStorageSharedClientState2.prototype.addLocalQueryTarget = function(targetId) {
        var queryState = "not-current";
        if (this.isActiveQueryTarget(targetId)) {
          var storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));
          if (storageItem) {
            var metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);
            if (metadata) {
              queryState = metadata.state;
            }
          }
        }
        this.localClientState.addQueryTarget(targetId);
        this.persistClientState();
        return queryState;
      };
      WebStorageSharedClientState2.prototype.removeLocalQueryTarget = function(targetId) {
        this.localClientState.removeQueryTarget(targetId);
        this.persistClientState();
      };
      WebStorageSharedClientState2.prototype.isLocalQueryTarget = function(targetId) {
        return this.localClientState.activeTargetIds.has(targetId);
      };
      WebStorageSharedClientState2.prototype.clearQueryState = function(targetId) {
        this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));
      };
      WebStorageSharedClientState2.prototype.updateQueryState = function(targetId, state, error3) {
        this.persistQueryTargetState(targetId, state, error3);
      };
      WebStorageSharedClientState2.prototype.handleUserChange = function(user, removedBatchIds, addedBatchIds) {
        var _this = this;
        removedBatchIds.forEach(function(batchId) {
          _this.removeMutationState(batchId);
        });
        this.currentUser = user;
        addedBatchIds.forEach(function(batchId) {
          _this.addPendingMutation(batchId);
        });
      };
      WebStorageSharedClientState2.prototype.setOnlineState = function(onlineState) {
        this.persistOnlineState(onlineState);
      };
      WebStorageSharedClientState2.prototype.notifyBundleLoaded = function() {
        this.persistBundleLoadedState();
      };
      WebStorageSharedClientState2.prototype.shutdown = function() {
        if (this.started) {
          this.window.removeEventListener("storage", this.storageListener);
          this.removeItem(this.localClientStorageKey);
          this.started = false;
        }
      };
      WebStorageSharedClientState2.prototype.getItem = function(key) {
        var value = this.storage.getItem(key);
        logDebug(LOG_TAG$a, "READ", key, value);
        return value;
      };
      WebStorageSharedClientState2.prototype.setItem = function(key, value) {
        logDebug(LOG_TAG$a, "SET", key, value);
        this.storage.setItem(key, value);
      };
      WebStorageSharedClientState2.prototype.removeItem = function(key) {
        logDebug(LOG_TAG$a, "REMOVE", key);
        this.storage.removeItem(key);
      };
      WebStorageSharedClientState2.prototype.handleWebStorageEvent = function(event) {
        var _this = this;
        var storageEvent = event;
        if (storageEvent.storageArea === this.storage) {
          logDebug(LOG_TAG$a, "EVENT", storageEvent.key, storageEvent.newValue);
          if (storageEvent.key === this.localClientStorageKey) {
            logError("Received WebStorage notification for local change. Another client might have garbage-collected our state");
            return;
          }
          this.queue.enqueueRetryable(function() {
            return tslib.__awaiter(_this, void 0, void 0, function() {
              var clientState, clientId, mutationMetadata, queryTargetMetadata, onlineState, sequenceNumber;
              return tslib.__generator(this, function(_d) {
                if (!this.started) {
                  this.earlyEvents.push(storageEvent);
                  return [2];
                }
                if (storageEvent.key === null) {
                  return [2];
                }
                if (this.clientStateKeyRe.test(storageEvent.key)) {
                  if (storageEvent.newValue != null) {
                    clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);
                    if (clientState) {
                      return [2, this.handleClientStateEvent(clientState.clientId, clientState)];
                    }
                  } else {
                    clientId = this.fromWebStorageClientStateKey(storageEvent.key);
                    return [2, this.handleClientStateEvent(clientId, null)];
                  }
                } else if (this.mutationBatchKeyRe.test(storageEvent.key)) {
                  if (storageEvent.newValue !== null) {
                    mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);
                    if (mutationMetadata) {
                      return [2, this.handleMutationBatchEvent(mutationMetadata)];
                    }
                  }
                } else if (this.queryTargetKeyRe.test(storageEvent.key)) {
                  if (storageEvent.newValue !== null) {
                    queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);
                    if (queryTargetMetadata) {
                      return [2, this.handleQueryTargetEvent(queryTargetMetadata)];
                    }
                  }
                } else if (storageEvent.key === this.onlineStateKey) {
                  if (storageEvent.newValue !== null) {
                    onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);
                    if (onlineState) {
                      return [2, this.handleOnlineStateEvent(onlineState)];
                    }
                  }
                } else if (storageEvent.key === this.sequenceNumberKey) {
                  sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);
                  if (sequenceNumber !== ListenSequence.INVALID) {
                    this.sequenceNumberHandler(sequenceNumber);
                  }
                } else if (storageEvent.key === this.bundleLoadedKey) {
                  return [2, this.syncEngine.synchronizeWithChangedDocuments()];
                }
                return [2];
              });
            });
          });
        }
      };
      Object.defineProperty(WebStorageSharedClientState2.prototype, "localClientState", {
        get: function() {
          return this.activeClients.get(this.localClientId);
        },
        enumerable: false,
        configurable: true
      });
      WebStorageSharedClientState2.prototype.persistClientState = function() {
        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());
      };
      WebStorageSharedClientState2.prototype.persistMutationState = function(batchId, state, error3) {
        var mutationState = new MutationMetadata(this.currentUser, batchId, state, error3);
        var mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);
        this.setItem(mutationKey, mutationState.toWebStorageJSON());
      };
      WebStorageSharedClientState2.prototype.removeMutationState = function(batchId) {
        var mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);
        this.removeItem(mutationKey);
      };
      WebStorageSharedClientState2.prototype.persistOnlineState = function(onlineState) {
        var entry = {
          clientId: this.localClientId,
          onlineState
        };
        this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));
      };
      WebStorageSharedClientState2.prototype.persistQueryTargetState = function(targetId, state, error3) {
        var targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);
        var targetMetadata = new QueryTargetMetadata(targetId, state, error3);
        this.setItem(targetKey, targetMetadata.toWebStorageJSON());
      };
      WebStorageSharedClientState2.prototype.persistBundleLoadedState = function() {
        this.setItem(this.bundleLoadedKey, "value-not-used");
      };
      WebStorageSharedClientState2.prototype.fromWebStorageClientStateKey = function(key) {
        var match = this.clientStateKeyRe.exec(key);
        return match ? match[1] : null;
      };
      WebStorageSharedClientState2.prototype.fromWebStorageClientState = function(key, value) {
        var clientId = this.fromWebStorageClientStateKey(key);
        return RemoteClientState.fromWebStorageEntry(clientId, value);
      };
      WebStorageSharedClientState2.prototype.fromWebStorageMutationMetadata = function(key, value) {
        var match = this.mutationBatchKeyRe.exec(key);
        var batchId = Number(match[1]);
        var userId = match[2] !== void 0 ? match[2] : null;
        return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);
      };
      WebStorageSharedClientState2.prototype.fromWebStorageQueryTargetMetadata = function(key, value) {
        var match = this.queryTargetKeyRe.exec(key);
        var targetId = Number(match[1]);
        return QueryTargetMetadata.fromWebStorageEntry(targetId, value);
      };
      WebStorageSharedClientState2.prototype.fromWebStorageOnlineState = function(value) {
        return SharedOnlineState.fromWebStorageEntry(value);
      };
      WebStorageSharedClientState2.prototype.handleMutationBatchEvent = function(mutationBatch) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            if (mutationBatch.user.uid !== this.currentUser.uid) {
              logDebug(LOG_TAG$a, "Ignoring mutation for non-active user " + mutationBatch.user.uid);
              return [2];
            }
            return [2, this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error)];
          });
        });
      };
      WebStorageSharedClientState2.prototype.handleQueryTargetEvent = function(targetMetadata) {
        return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);
      };
      WebStorageSharedClientState2.prototype.handleClientStateEvent = function(clientId, clientState) {
        var _this = this;
        var updatedClients = clientState ? this.activeClients.insert(clientId, clientState) : this.activeClients.remove(clientId);
        var existingTargets = this.extractActiveQueryTargets(this.activeClients);
        var newTargets = this.extractActiveQueryTargets(updatedClients);
        var addedTargets = [];
        var removedTargets = [];
        newTargets.forEach(function(targetId) {
          if (!existingTargets.has(targetId)) {
            addedTargets.push(targetId);
          }
        });
        existingTargets.forEach(function(targetId) {
          if (!newTargets.has(targetId)) {
            removedTargets.push(targetId);
          }
        });
        return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(function() {
          _this.activeClients = updatedClients;
        });
      };
      WebStorageSharedClientState2.prototype.handleOnlineStateEvent = function(onlineState) {
        if (this.activeClients.get(onlineState.clientId)) {
          this.onlineStateHandler(onlineState.onlineState);
        }
      };
      WebStorageSharedClientState2.prototype.extractActiveQueryTargets = function(clients) {
        var activeTargets = targetIdSet();
        clients.forEach(function(kev, value) {
          activeTargets = activeTargets.unionWith(value.activeTargetIds);
        });
        return activeTargets;
      };
      return WebStorageSharedClientState2;
    }();
    function fromWebStorageSequenceNumber(seqString) {
      var sequenceNumber = ListenSequence.INVALID;
      if (seqString != null) {
        try {
          var parsed = JSON.parse(seqString);
          hardAssert(typeof parsed === "number");
          sequenceNumber = parsed;
        } catch (e) {
          logError(LOG_TAG$a, "Failed to read sequence number from WebStorage", e);
        }
      }
      return sequenceNumber;
    }
    var MemorySharedClientState = function() {
      function MemorySharedClientState2() {
        this.localState = new LocalClientState();
        this.queryState = {};
        this.onlineStateHandler = null;
        this.sequenceNumberHandler = null;
      }
      MemorySharedClientState2.prototype.addPendingMutation = function(batchId) {
      };
      MemorySharedClientState2.prototype.updateMutationState = function(batchId, state, error3) {
      };
      MemorySharedClientState2.prototype.addLocalQueryTarget = function(targetId) {
        this.localState.addQueryTarget(targetId);
        return this.queryState[targetId] || "not-current";
      };
      MemorySharedClientState2.prototype.updateQueryState = function(targetId, state, error3) {
        this.queryState[targetId] = state;
      };
      MemorySharedClientState2.prototype.removeLocalQueryTarget = function(targetId) {
        this.localState.removeQueryTarget(targetId);
      };
      MemorySharedClientState2.prototype.isLocalQueryTarget = function(targetId) {
        return this.localState.activeTargetIds.has(targetId);
      };
      MemorySharedClientState2.prototype.clearQueryState = function(targetId) {
        delete this.queryState[targetId];
      };
      MemorySharedClientState2.prototype.getAllActiveQueryTargets = function() {
        return this.localState.activeTargetIds;
      };
      MemorySharedClientState2.prototype.isActiveQueryTarget = function(targetId) {
        return this.localState.activeTargetIds.has(targetId);
      };
      MemorySharedClientState2.prototype.start = function() {
        this.localState = new LocalClientState();
        return Promise.resolve();
      };
      MemorySharedClientState2.prototype.handleUserChange = function(user, removedBatchIds, addedBatchIds) {
      };
      MemorySharedClientState2.prototype.setOnlineState = function(onlineState) {
      };
      MemorySharedClientState2.prototype.shutdown = function() {
      };
      MemorySharedClientState2.prototype.writeSequenceNumber = function(sequenceNumber) {
      };
      MemorySharedClientState2.prototype.notifyBundleLoaded = function() {
      };
      return MemorySharedClientState2;
    }();
    var NoopConnectivityMonitor = function() {
      function NoopConnectivityMonitor2() {
      }
      NoopConnectivityMonitor2.prototype.addCallback = function(callback) {
      };
      NoopConnectivityMonitor2.prototype.shutdown = function() {
      };
      return NoopConnectivityMonitor2;
    }();
    var StreamBridge = function() {
      function StreamBridge2(args) {
        this.sendFn = args.sendFn;
        this.closeFn = args.closeFn;
      }
      StreamBridge2.prototype.onOpen = function(callback) {
        this.wrappedOnOpen = callback;
      };
      StreamBridge2.prototype.onClose = function(callback) {
        this.wrappedOnClose = callback;
      };
      StreamBridge2.prototype.onMessage = function(callback) {
        this.wrappedOnMessage = callback;
      };
      StreamBridge2.prototype.close = function() {
        this.closeFn();
      };
      StreamBridge2.prototype.send = function(msg) {
        this.sendFn(msg);
      };
      StreamBridge2.prototype.callOnOpen = function() {
        this.wrappedOnOpen();
      };
      StreamBridge2.prototype.callOnClose = function(err) {
        this.wrappedOnClose(err);
      };
      StreamBridge2.prototype.callOnMessage = function(msg) {
        this.wrappedOnMessage(msg);
      };
      return StreamBridge2;
    }();
    function nodePromise(action) {
      return new Promise(function(resolve2, reject) {
        action(function(error3, value) {
          if (error3) {
            reject(error3);
          } else {
            resolve2(value);
          }
        });
      });
    }
    var LOG_TAG$9 = "Connection";
    var X_GOOG_API_CLIENT_VALUE = "gl-node/" + process.versions.node + " fire/" + SDK_VERSION + " grpc/" + package_json.version;
    function createMetadata(databasePath, token, appId) {
      hardAssert(token === null || token.type === "OAuth");
      var metadata = new grpcJs.Metadata();
      if (token) {
        for (var header in token.authHeaders) {
          if (token.authHeaders.hasOwnProperty(header)) {
            metadata.set(header, token.authHeaders[header]);
          }
        }
      }
      if (appId) {
        metadata.set("X-Firebase-GMPID", appId);
      }
      metadata.set("X-Goog-Api-Client", X_GOOG_API_CLIENT_VALUE);
      metadata.set("Google-Cloud-Resource-Prefix", databasePath);
      return metadata;
    }
    var GrpcConnection = function() {
      function GrpcConnection2(protos, databaseInfo) {
        this.databaseInfo = databaseInfo;
        this.cachedStub = null;
        this.firestore = protos["google"]["firestore"]["v1"];
        this.databasePath = "projects/" + databaseInfo.databaseId.projectId + "/databases/" + databaseInfo.databaseId.database;
      }
      GrpcConnection2.prototype.ensureActiveStub = function() {
        if (!this.cachedStub) {
          logDebug(LOG_TAG$9, "Creating Firestore stub.");
          var credentials$1 = this.databaseInfo.ssl ? grpcJs.credentials.createSsl() : grpcJs.credentials.createInsecure();
          this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials$1);
        }
        return this.cachedStub;
      };
      GrpcConnection2.prototype.invokeRPC = function(rpcName, path2, request, token) {
        var stub = this.ensureActiveStub();
        var metadata = createMetadata(this.databasePath, token, this.databaseInfo.appId);
        var jsonRequest = Object.assign({ database: this.databasePath }, request);
        return nodePromise(function(callback) {
          logDebug(LOG_TAG$9, "RPC '" + rpcName + "' invoked with request:", request);
          return stub[rpcName](jsonRequest, metadata, function(grpcError, value) {
            if (grpcError) {
              logDebug(LOG_TAG$9, "RPC '" + rpcName + "' failed with error:", grpcError);
              callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));
            } else {
              logDebug(LOG_TAG$9, "RPC '" + rpcName + "' completed with response:", value);
              callback(void 0, value);
            }
          });
        });
      };
      GrpcConnection2.prototype.invokeStreamingRPC = function(rpcName, path2, request, token) {
        var results = [];
        var responseDeferred = new Deferred();
        logDebug(LOG_TAG$9, "RPC '" + rpcName + "' invoked (streaming) with request:", request);
        var stub = this.ensureActiveStub();
        var metadata = createMetadata(this.databasePath, token, this.databaseInfo.appId);
        var jsonRequest = Object.assign(Object.assign({}, request), { database: this.databasePath });
        var stream = stub[rpcName](jsonRequest, metadata);
        stream.on("data", function(response) {
          logDebug(LOG_TAG$9, "RPC " + rpcName + " received result:", response);
          results.push(response);
        });
        stream.on("end", function() {
          logDebug(LOG_TAG$9, "RPC '" + rpcName + "' completed.");
          responseDeferred.resolve(results);
        });
        stream.on("error", function(grpcError) {
          logDebug(LOG_TAG$9, "RPC '" + rpcName + "' failed with error:", grpcError);
          var code = mapCodeFromRpcCode(grpcError.code);
          responseDeferred.reject(new FirestoreError(code, grpcError.message));
        });
        return responseDeferred.promise;
      };
      GrpcConnection2.prototype.openStream = function(rpcName, token) {
        var stub = this.ensureActiveStub();
        var metadata = createMetadata(this.databasePath, token, this.databaseInfo.appId);
        var grpcStream = stub[rpcName](metadata);
        var closed = false;
        var close = function(err) {
          if (!closed) {
            closed = true;
            stream.callOnClose(err);
            grpcStream.end();
          }
        };
        var stream = new StreamBridge({
          sendFn: function(msg) {
            if (!closed) {
              logDebug(LOG_TAG$9, "GRPC stream sending:", msg);
              try {
                grpcStream.write(msg);
              } catch (e) {
                logError("Failure sending:", msg);
                logError("Error:", e);
                throw e;
              }
            } else {
              logDebug(LOG_TAG$9, "Not sending because gRPC stream is closed:", msg);
            }
          },
          closeFn: function() {
            logDebug(LOG_TAG$9, "GRPC stream closed locally via close().");
            close();
          }
        });
        grpcStream.on("data", function(msg) {
          if (!closed) {
            logDebug(LOG_TAG$9, "GRPC stream received:", msg);
            stream.callOnMessage(msg);
          }
        });
        grpcStream.on("end", function() {
          logDebug(LOG_TAG$9, "GRPC stream ended.");
          close();
        });
        grpcStream.on("error", function(grpcError) {
          if (!closed) {
            logWarn(LOG_TAG$9, "GRPC stream error. Code:", grpcError.code, "Message:", grpcError.message);
            var code = mapCodeFromRpcCode(grpcError.code);
            close(new FirestoreError(code, grpcError.message));
          }
        });
        logDebug(LOG_TAG$9, "Opening GRPC stream");
        setTimeout(function() {
          stream.callOnOpen();
        }, 0);
        return stream;
      };
      return GrpcConnection2;
    }();
    var protoLoaderOptions = {
      longs: String,
      enums: String,
      defaults: true,
      oneofs: false
    };
    function loadProtos() {
      var root = path.resolve(__dirname, "../protos");
      var firestoreProtoFile = path.join(root, "google/firestore/v1/firestore.proto");
      var packageDefinition = protoLoader.loadSync(firestoreProtoFile, Object.assign(Object.assign({}, protoLoaderOptions), { includeDirs: [root] }));
      return grpcJs.loadPackageDefinition(packageDefinition);
    }
    function newConnection(databaseInfo) {
      var protos = loadProtos();
      return new GrpcConnection(protos, databaseInfo);
    }
    function newConnectivityMonitor() {
      return new NoopConnectivityMonitor();
    }
    function getWindow() {
      if (process.env.USE_MOCK_PERSISTENCE === "YES") {
        return window;
      }
      return null;
    }
    function getDocument() {
      return null;
    }
    function newSerializer(databaseId) {
      return new JsonProtoSerializer(databaseId, false);
    }
    function newTextEncoder() {
      return new util$1.TextEncoder();
    }
    function newTextDecoder() {
      return new util$1.TextDecoder("utf-8");
    }
    var LOG_TAG$8 = "ExponentialBackoff";
    var DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1e3;
    var DEFAULT_BACKOFF_FACTOR = 1.5;
    var DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1e3;
    var ExponentialBackoff = function() {
      function ExponentialBackoff2(queue, timerId, initialDelayMs, backoffFactor, maxDelayMs) {
        if (initialDelayMs === void 0) {
          initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;
        }
        if (backoffFactor === void 0) {
          backoffFactor = DEFAULT_BACKOFF_FACTOR;
        }
        if (maxDelayMs === void 0) {
          maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;
        }
        this.queue = queue;
        this.timerId = timerId;
        this.initialDelayMs = initialDelayMs;
        this.backoffFactor = backoffFactor;
        this.maxDelayMs = maxDelayMs;
        this.currentBaseMs = 0;
        this.timerPromise = null;
        this.lastAttemptTime = Date.now();
        this.reset();
      }
      ExponentialBackoff2.prototype.reset = function() {
        this.currentBaseMs = 0;
      };
      ExponentialBackoff2.prototype.resetToMax = function() {
        this.currentBaseMs = this.maxDelayMs;
      };
      ExponentialBackoff2.prototype.backoffAndRun = function(op) {
        var _this = this;
        this.cancel();
        var desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());
        var delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);
        var remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);
        if (remainingDelayMs > 0) {
          logDebug(LOG_TAG$8, "Backing off for " + remainingDelayMs + " ms " + ("(base delay: " + this.currentBaseMs + " ms, ") + ("delay with jitter: " + desiredDelayWithJitterMs + " ms, ") + ("last attempt: " + delaySoFarMs + " ms ago)"));
        }
        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, function() {
          _this.lastAttemptTime = Date.now();
          return op();
        });
        this.currentBaseMs *= this.backoffFactor;
        if (this.currentBaseMs < this.initialDelayMs) {
          this.currentBaseMs = this.initialDelayMs;
        }
        if (this.currentBaseMs > this.maxDelayMs) {
          this.currentBaseMs = this.maxDelayMs;
        }
      };
      ExponentialBackoff2.prototype.skipBackoff = function() {
        if (this.timerPromise !== null) {
          this.timerPromise.skipDelay();
          this.timerPromise = null;
        }
      };
      ExponentialBackoff2.prototype.cancel = function() {
        if (this.timerPromise !== null) {
          this.timerPromise.cancel();
          this.timerPromise = null;
        }
      };
      ExponentialBackoff2.prototype.jitterDelayMs = function() {
        return (Math.random() - 0.5) * this.currentBaseMs;
      };
      return ExponentialBackoff2;
    }();
    var LOG_TAG$7 = "PersistentStream";
    var IDLE_TIMEOUT_MS = 60 * 1e3;
    var PersistentStream = function() {
      function PersistentStream2(queue, connectionTimerId, idleTimerId, connection, credentialsProvider, listener) {
        this.queue = queue;
        this.idleTimerId = idleTimerId;
        this.connection = connection;
        this.credentialsProvider = credentialsProvider;
        this.listener = listener;
        this.state = 0;
        this.closeCount = 0;
        this.idleTimer = null;
        this.stream = null;
        this.backoff = new ExponentialBackoff(queue, connectionTimerId);
      }
      PersistentStream2.prototype.isStarted = function() {
        return this.state === 1 || this.state === 2 || this.state === 4;
      };
      PersistentStream2.prototype.isOpen = function() {
        return this.state === 2;
      };
      PersistentStream2.prototype.start = function() {
        if (this.state === 3) {
          this.performBackoff();
          return;
        }
        this.auth();
      };
      PersistentStream2.prototype.stop = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!this.isStarted())
                  return [3, 2];
                return [4, this.close(0)];
              case 1:
                _d.sent();
                _d.label = 2;
              case 2:
                return [2];
            }
          });
        });
      };
      PersistentStream2.prototype.inhibitBackoff = function() {
        this.state = 0;
        this.backoff.reset();
      };
      PersistentStream2.prototype.markIdle = function() {
        var _this = this;
        if (this.isOpen() && this.idleTimer === null) {
          this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, function() {
            return _this.handleIdleCloseTimer();
          });
        }
      };
      PersistentStream2.prototype.sendRequest = function(msg) {
        this.cancelIdleCheck();
        this.stream.send(msg);
      };
      PersistentStream2.prototype.handleIdleCloseTimer = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            if (this.isOpen()) {
              return [2, this.close(0)];
            }
            return [2];
          });
        });
      };
      PersistentStream2.prototype.cancelIdleCheck = function() {
        if (this.idleTimer) {
          this.idleTimer.cancel();
          this.idleTimer = null;
        }
      };
      PersistentStream2.prototype.close = function(finalState, error3) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this.cancelIdleCheck();
                this.backoff.cancel();
                this.closeCount++;
                if (finalState !== 3) {
                  this.backoff.reset();
                } else if (error3 && error3.code === Code.RESOURCE_EXHAUSTED) {
                  logError(error3.toString());
                  logError("Using maximum backoff delay to prevent overloading the backend.");
                  this.backoff.resetToMax();
                } else if (error3 && error3.code === Code.UNAUTHENTICATED) {
                  this.credentialsProvider.invalidateToken();
                }
                if (this.stream !== null) {
                  this.tearDown();
                  this.stream.close();
                  this.stream = null;
                }
                this.state = finalState;
                return [4, this.listener.onClose(error3)];
              case 1:
                _d.sent();
                return [2];
            }
          });
        });
      };
      PersistentStream2.prototype.tearDown = function() {
      };
      PersistentStream2.prototype.auth = function() {
        var _this = this;
        this.state = 1;
        var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
        var closeCount = this.closeCount;
        this.credentialsProvider.getToken().then(function(token) {
          if (_this.closeCount === closeCount) {
            _this.startStream(token);
          }
        }, function(error3) {
          dispatchIfNotClosed(function() {
            var rpcError = new FirestoreError(Code.UNKNOWN, "Fetching auth token failed: " + error3.message);
            return _this.handleStreamClose(rpcError);
          });
        });
      };
      PersistentStream2.prototype.startStream = function(token) {
        var _this = this;
        var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
        this.stream = this.startRpc(token);
        this.stream.onOpen(function() {
          dispatchIfNotClosed(function() {
            _this.state = 2;
            return _this.listener.onOpen();
          });
        });
        this.stream.onClose(function(error3) {
          dispatchIfNotClosed(function() {
            return _this.handleStreamClose(error3);
          });
        });
        this.stream.onMessage(function(msg) {
          dispatchIfNotClosed(function() {
            return _this.onMessage(msg);
          });
        });
      };
      PersistentStream2.prototype.performBackoff = function() {
        var _this = this;
        this.state = 4;
        this.backoff.backoffAndRun(function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              this.state = 0;
              this.start();
              return [2];
            });
          });
        });
      };
      PersistentStream2.prototype.handleStreamClose = function(error3) {
        logDebug(LOG_TAG$7, "close with error: " + error3);
        this.stream = null;
        return this.close(3, error3);
      };
      PersistentStream2.prototype.getCloseGuardedDispatcher = function(startCloseCount) {
        var _this = this;
        return function(fn) {
          _this.queue.enqueueAndForget(function() {
            if (_this.closeCount === startCloseCount) {
              return fn();
            } else {
              logDebug(LOG_TAG$7, "stream callback skipped by getCloseGuardedDispatcher.");
              return Promise.resolve();
            }
          });
        };
      };
      return PersistentStream2;
    }();
    var PersistentListenStream = function(_super) {
      tslib.__extends(PersistentListenStream2, _super);
      function PersistentListenStream2(queue, connection, credentials, serializer, listener) {
        var _this = _super.call(this, queue, "listen_stream_connection_backoff", "listen_stream_idle", connection, credentials, listener) || this;
        _this.serializer = serializer;
        return _this;
      }
      PersistentListenStream2.prototype.startRpc = function(token) {
        return this.connection.openStream("Listen", token);
      };
      PersistentListenStream2.prototype.onMessage = function(watchChangeProto) {
        this.backoff.reset();
        var watchChange = fromWatchChange(this.serializer, watchChangeProto);
        var snapshot = versionFromListenResponse(watchChangeProto);
        return this.listener.onWatchChange(watchChange, snapshot);
      };
      PersistentListenStream2.prototype.watch = function(targetData) {
        var request = {};
        request.database = getEncodedDatabaseId(this.serializer);
        request.addTarget = toTarget(this.serializer, targetData);
        var labels = toListenRequestLabels(this.serializer, targetData);
        if (labels) {
          request.labels = labels;
        }
        this.sendRequest(request);
      };
      PersistentListenStream2.prototype.unwatch = function(targetId) {
        var request = {};
        request.database = getEncodedDatabaseId(this.serializer);
        request.removeTarget = targetId;
        this.sendRequest(request);
      };
      return PersistentListenStream2;
    }(PersistentStream);
    var PersistentWriteStream = function(_super) {
      tslib.__extends(PersistentWriteStream2, _super);
      function PersistentWriteStream2(queue, connection, credentials, serializer, listener) {
        var _this = _super.call(this, queue, "write_stream_connection_backoff", "write_stream_idle", connection, credentials, listener) || this;
        _this.serializer = serializer;
        _this.handshakeComplete_ = false;
        return _this;
      }
      Object.defineProperty(PersistentWriteStream2.prototype, "handshakeComplete", {
        get: function() {
          return this.handshakeComplete_;
        },
        enumerable: false,
        configurable: true
      });
      PersistentWriteStream2.prototype.start = function() {
        this.handshakeComplete_ = false;
        this.lastStreamToken = void 0;
        _super.prototype.start.call(this);
      };
      PersistentWriteStream2.prototype.tearDown = function() {
        if (this.handshakeComplete_) {
          this.writeMutations([]);
        }
      };
      PersistentWriteStream2.prototype.startRpc = function(token) {
        return this.connection.openStream("Write", token);
      };
      PersistentWriteStream2.prototype.onMessage = function(responseProto) {
        hardAssert(!!responseProto.streamToken);
        this.lastStreamToken = responseProto.streamToken;
        if (!this.handshakeComplete_) {
          hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0);
          this.handshakeComplete_ = true;
          return this.listener.onHandshakeComplete();
        } else {
          this.backoff.reset();
          var results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);
          var commitVersion = fromVersion(responseProto.commitTime);
          return this.listener.onMutationResult(commitVersion, results);
        }
      };
      PersistentWriteStream2.prototype.writeHandshake = function() {
        var request = {};
        request.database = getEncodedDatabaseId(this.serializer);
        this.sendRequest(request);
      };
      PersistentWriteStream2.prototype.writeMutations = function(mutations) {
        var _this = this;
        var request = {
          streamToken: this.lastStreamToken,
          writes: mutations.map(function(mutation) {
            return toMutation(_this.serializer, mutation);
          })
        };
        this.sendRequest(request);
      };
      return PersistentWriteStream2;
    }(PersistentStream);
    var Datastore = function() {
      function Datastore2() {
      }
      return Datastore2;
    }();
    var DatastoreImpl = function(_super) {
      tslib.__extends(DatastoreImpl2, _super);
      function DatastoreImpl2(credentials, connection, serializer) {
        var _this = _super.call(this) || this;
        _this.credentials = credentials;
        _this.connection = connection;
        _this.serializer = serializer;
        _this.terminated = false;
        return _this;
      }
      DatastoreImpl2.prototype.verifyInitialized = function() {
        if (this.terminated) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "The client has already been terminated.");
        }
      };
      DatastoreImpl2.prototype.invokeRPC = function(rpcName, path2, request) {
        var _this = this;
        this.verifyInitialized();
        return this.credentials.getToken().then(function(token) {
          return _this.connection.invokeRPC(rpcName, path2, request, token);
        }).catch(function(error3) {
          if (error3.name === "FirebaseError") {
            if (error3.code === Code.UNAUTHENTICATED) {
              _this.credentials.invalidateToken();
            }
            throw error3;
          } else {
            throw new FirestoreError(Code.UNKNOWN, error3.toString());
          }
        });
      };
      DatastoreImpl2.prototype.invokeStreamingRPC = function(rpcName, path2, request) {
        var _this = this;
        this.verifyInitialized();
        return this.credentials.getToken().then(function(token) {
          return _this.connection.invokeStreamingRPC(rpcName, path2, request, token);
        }).catch(function(error3) {
          if (error3.name === "FirebaseError") {
            if (error3.code === Code.UNAUTHENTICATED) {
              _this.credentials.invalidateToken();
            }
            throw error3;
          } else {
            throw new FirestoreError(Code.UNKNOWN, error3.toString());
          }
        });
      };
      DatastoreImpl2.prototype.terminate = function() {
        this.terminated = true;
      };
      return DatastoreImpl2;
    }(Datastore);
    function newDatastore(credentials, connection, serializer) {
      return new DatastoreImpl(credentials, connection, serializer);
    }
    function invokeCommitRpc(datastore, mutations) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var datastoreImpl, path2, request;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              datastoreImpl = debugCast(datastore);
              path2 = getEncodedDatabaseId(datastoreImpl.serializer) + "/documents";
              request = {
                writes: mutations.map(function(m) {
                  return toMutation(datastoreImpl.serializer, m);
                })
              };
              return [4, datastoreImpl.invokeRPC("Commit", path2, request)];
            case 1:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function invokeBatchGetDocumentsRpc(datastore, keys) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var datastoreImpl, path2, request, response, docs, result;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              datastoreImpl = debugCast(datastore);
              path2 = getEncodedDatabaseId(datastoreImpl.serializer) + "/documents";
              request = {
                documents: keys.map(function(k) {
                  return toName(datastoreImpl.serializer, k);
                })
              };
              return [4, datastoreImpl.invokeStreamingRPC("BatchGetDocuments", path2, request)];
            case 1:
              response = _d.sent();
              docs = new Map();
              response.forEach(function(proto) {
                var doc2 = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);
                docs.set(doc2.key.toString(), doc2);
              });
              result = [];
              keys.forEach(function(key) {
                var doc2 = docs.get(key.toString());
                hardAssert(!!doc2);
                result.push(doc2);
              });
              return [2, result];
          }
        });
      });
    }
    function newPersistentWriteStream(datastore, queue, listener) {
      var datastoreImpl = debugCast(datastore);
      datastoreImpl.verifyInitialized();
      return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.credentials, datastoreImpl.serializer, listener);
    }
    function newPersistentWatchStream(datastore, queue, listener) {
      var datastoreImpl = debugCast(datastore);
      datastoreImpl.verifyInitialized();
      return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.credentials, datastoreImpl.serializer, listener);
    }
    var LOG_TAG$6 = "OnlineStateTracker";
    var MAX_WATCH_STREAM_FAILURES = 1;
    var ONLINE_STATE_TIMEOUT_MS = 10 * 1e3;
    var OnlineStateTracker = function() {
      function OnlineStateTracker2(asyncQueue, onlineStateHandler) {
        this.asyncQueue = asyncQueue;
        this.onlineStateHandler = onlineStateHandler;
        this.state = "Unknown";
        this.watchStreamFailures = 0;
        this.onlineStateTimer = null;
        this.shouldWarnClientIsOffline = true;
      }
      OnlineStateTracker2.prototype.handleWatchStreamStart = function() {
        var _this = this;
        if (this.watchStreamFailures === 0) {
          this.setAndBroadcast("Unknown");
          this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay("online_state_timeout", ONLINE_STATE_TIMEOUT_MS, function() {
            _this.onlineStateTimer = null;
            _this.logClientOfflineWarningIfNecessary("Backend didn't respond within " + ONLINE_STATE_TIMEOUT_MS / 1e3 + " seconds.");
            _this.setAndBroadcast("Offline");
            return Promise.resolve();
          });
        }
      };
      OnlineStateTracker2.prototype.handleWatchStreamFailure = function(error3) {
        if (this.state === "Online") {
          this.setAndBroadcast("Unknown");
        } else {
          this.watchStreamFailures++;
          if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {
            this.clearOnlineStateTimer();
            this.logClientOfflineWarningIfNecessary("Connection failed " + MAX_WATCH_STREAM_FAILURES + " " + ("times. Most recent error: " + error3.toString()));
            this.setAndBroadcast("Offline");
          }
        }
      };
      OnlineStateTracker2.prototype.set = function(newState) {
        this.clearOnlineStateTimer();
        this.watchStreamFailures = 0;
        if (newState === "Online") {
          this.shouldWarnClientIsOffline = false;
        }
        this.setAndBroadcast(newState);
      };
      OnlineStateTracker2.prototype.setAndBroadcast = function(newState) {
        if (newState !== this.state) {
          this.state = newState;
          this.onlineStateHandler(newState);
        }
      };
      OnlineStateTracker2.prototype.logClientOfflineWarningIfNecessary = function(details) {
        var message = "Could not reach Cloud Firestore backend. " + details + "\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.";
        if (this.shouldWarnClientIsOffline) {
          logError(message);
          this.shouldWarnClientIsOffline = false;
        } else {
          logDebug(LOG_TAG$6, message);
        }
      };
      OnlineStateTracker2.prototype.clearOnlineStateTimer = function() {
        if (this.onlineStateTimer !== null) {
          this.onlineStateTimer.cancel();
          this.onlineStateTimer = null;
        }
      };
      return OnlineStateTracker2;
    }();
    var LOG_TAG$5 = "RemoteStore";
    var MAX_PENDING_WRITES = 10;
    var RemoteStoreImpl = function() {
      function RemoteStoreImpl2(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {
        var _this = this;
        this.localStore = localStore;
        this.datastore = datastore;
        this.asyncQueue = asyncQueue;
        this.remoteSyncer = {};
        this.writePipeline = [];
        this.listenTargets = new Map();
        this.offlineCauses = new Set();
        this.onNetworkStatusChange = [];
        this.connectivityMonitor = connectivityMonitor;
        this.connectivityMonitor.addCallback(function(_) {
          asyncQueue.enqueueAndForget(function() {
            return tslib.__awaiter(_this, void 0, void 0, function() {
              return tslib.__generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    if (!canUseNetwork(this))
                      return [3, 2];
                    logDebug(LOG_TAG$5, "Restarting streams for network reachability change.");
                    return [4, restartNetwork(this)];
                  case 1:
                    _d.sent();
                    _d.label = 2;
                  case 2:
                    return [2];
                }
              });
            });
          });
        });
        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);
      }
      return RemoteStoreImpl2;
    }();
    function newRemoteStore(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {
      return new RemoteStoreImpl(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);
    }
    function remoteStoreEnableNetwork(remoteStore) {
      var remoteStoreImpl = debugCast(remoteStore);
      remoteStoreImpl.offlineCauses.delete(0);
      return enableNetworkInternal(remoteStoreImpl);
    }
    function enableNetworkInternal(remoteStoreImpl) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var _i, _d, networkStatusHandler;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              if (!canUseNetwork(remoteStoreImpl))
                return [3, 4];
              _i = 0, _d = remoteStoreImpl.onNetworkStatusChange;
              _e.label = 1;
            case 1:
              if (!(_i < _d.length))
                return [3, 4];
              networkStatusHandler = _d[_i];
              return [4, networkStatusHandler(true)];
            case 2:
              _e.sent();
              _e.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }
    function remoteStoreDisableNetwork(remoteStore) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              remoteStoreImpl.offlineCauses.add(0);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              remoteStoreImpl.onlineStateTracker.set("Offline");
              return [2];
          }
        });
      });
    }
    function disableNetworkInternal(remoteStoreImpl) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var _i, _d, networkStatusHandler;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              _i = 0, _d = remoteStoreImpl.onNetworkStatusChange;
              _e.label = 1;
            case 1:
              if (!(_i < _d.length))
                return [3, 4];
              networkStatusHandler = _d[_i];
              return [4, networkStatusHandler(false)];
            case 2:
              _e.sent();
              _e.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }
    function remoteStoreShutdown(remoteStore) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              logDebug(LOG_TAG$5, "RemoteStore shutting down.");
              remoteStoreImpl.offlineCauses.add(5);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              remoteStoreImpl.connectivityMonitor.shutdown();
              remoteStoreImpl.onlineStateTracker.set("Unknown");
              return [2];
          }
        });
      });
    }
    function remoteStoreListen(remoteStore, targetData) {
      var remoteStoreImpl = debugCast(remoteStore);
      if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {
        return;
      }
      remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);
      if (shouldStartWatchStream(remoteStoreImpl)) {
        startWatchStream(remoteStoreImpl);
      } else if (ensureWatchStream(remoteStoreImpl).isOpen()) {
        sendWatchRequest(remoteStoreImpl, targetData);
      }
    }
    function remoteStoreUnlisten(remoteStore, targetId) {
      var remoteStoreImpl = debugCast(remoteStore);
      var watchStream = ensureWatchStream(remoteStoreImpl);
      remoteStoreImpl.listenTargets.delete(targetId);
      if (watchStream.isOpen()) {
        sendUnwatchRequest(remoteStoreImpl, targetId);
      }
      if (remoteStoreImpl.listenTargets.size === 0) {
        if (watchStream.isOpen()) {
          watchStream.markIdle();
        } else if (canUseNetwork(remoteStoreImpl)) {
          remoteStoreImpl.onlineStateTracker.set("Unknown");
        }
      }
    }
    function sendWatchRequest(remoteStoreImpl, targetData) {
      remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);
      ensureWatchStream(remoteStoreImpl).watch(targetData);
    }
    function sendUnwatchRequest(remoteStoreImpl, targetId) {
      remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);
      ensureWatchStream(remoteStoreImpl).unwatch(targetId);
    }
    function startWatchStream(remoteStoreImpl) {
      remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({
        getRemoteKeysForTarget: function(targetId) {
          return remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId);
        },
        getTargetDataForTarget: function(targetId) {
          return remoteStoreImpl.listenTargets.get(targetId) || null;
        }
      });
      ensureWatchStream(remoteStoreImpl).start();
      remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();
    }
    function shouldStartWatchStream(remoteStoreImpl) {
      return canUseNetwork(remoteStoreImpl) && !ensureWatchStream(remoteStoreImpl).isStarted() && remoteStoreImpl.listenTargets.size > 0;
    }
    function canUseNetwork(remoteStore) {
      var remoteStoreImpl = debugCast(remoteStore);
      return remoteStoreImpl.offlineCauses.size === 0;
    }
    function cleanUpWatchStreamState(remoteStoreImpl) {
      remoteStoreImpl.watchChangeAggregator = void 0;
    }
    function onWatchStreamOpen(remoteStoreImpl) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          remoteStoreImpl.listenTargets.forEach(function(targetData, targetId) {
            sendWatchRequest(remoteStoreImpl, targetData);
          });
          return [2];
        });
      });
    }
    function onWatchStreamClose(remoteStoreImpl, error3) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          cleanUpWatchStreamState(remoteStoreImpl);
          if (shouldStartWatchStream(remoteStoreImpl)) {
            remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error3);
            startWatchStream(remoteStoreImpl);
          } else {
            remoteStoreImpl.onlineStateTracker.set("Unknown");
          }
          return [2];
        });
      });
    }
    function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var e_4, lastRemoteSnapshotVersion, e_5;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl.onlineStateTracker.set("Online");
              if (!(watchChange instanceof WatchTargetChange && watchChange.state === 2 && watchChange.cause))
                return [3, 6];
              _d.label = 1;
            case 1:
              _d.trys.push([1, 3, , 5]);
              return [4, handleTargetError(remoteStoreImpl, watchChange)];
            case 2:
              _d.sent();
              return [3, 5];
            case 3:
              e_4 = _d.sent();
              logDebug(LOG_TAG$5, "Failed to remove targets %s: %s ", watchChange.targetIds.join(","), e_4);
              return [4, disableNetworkUntilRecovery(remoteStoreImpl, e_4)];
            case 4:
              _d.sent();
              return [3, 5];
            case 5:
              return [2];
            case 6:
              if (watchChange instanceof DocumentWatchChange) {
                remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);
              } else if (watchChange instanceof ExistenceFilterChange) {
                remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);
              } else {
                remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);
              }
              if (!!snapshotVersion.isEqual(SnapshotVersion.min()))
                return [3, 13];
              _d.label = 7;
            case 7:
              _d.trys.push([7, 11, , 13]);
              return [4, localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore)];
            case 8:
              lastRemoteSnapshotVersion = _d.sent();
              if (!(snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0))
                return [3, 10];
              return [4, raiseWatchSnapshot(remoteStoreImpl, snapshotVersion)];
            case 9:
              _d.sent();
              _d.label = 10;
            case 10:
              return [3, 13];
            case 11:
              e_5 = _d.sent();
              logDebug(LOG_TAG$5, "Failed to raise snapshot:", e_5);
              return [4, disableNetworkUntilRecovery(remoteStoreImpl, e_5)];
            case 12:
              _d.sent();
              return [3, 13];
            case 13:
              return [2];
          }
        });
      });
    }
    function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var _this = this;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!isIndexedDbTransactionError(e))
                return [3, 2];
              remoteStoreImpl.offlineCauses.add(1);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              remoteStoreImpl.onlineStateTracker.set("Offline");
              if (!op) {
                op = function() {
                  return localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);
                };
              }
              remoteStoreImpl.asyncQueue.enqueueRetryable(function() {
                return tslib.__awaiter(_this, void 0, void 0, function() {
                  return tslib.__generator(this, function(_d2) {
                    switch (_d2.label) {
                      case 0:
                        logDebug(LOG_TAG$5, "Retrying IndexedDB access");
                        return [4, op()];
                      case 1:
                        _d2.sent();
                        remoteStoreImpl.offlineCauses.delete(1);
                        return [4, enableNetworkInternal(remoteStoreImpl)];
                      case 2:
                        _d2.sent();
                        return [2];
                    }
                  });
                });
              });
              return [3, 3];
            case 2:
              throw e;
            case 3:
              return [2];
          }
        });
      });
    }
    function executeWithRecovery(remoteStoreImpl, op) {
      return op().catch(function(e) {
        return disableNetworkUntilRecovery(remoteStoreImpl, e, op);
      });
    }
    function raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {
      var remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);
      remoteEvent.targetChanges.forEach(function(change, targetId) {
        if (change.resumeToken.approximateByteSize() > 0) {
          var targetData = remoteStoreImpl.listenTargets.get(targetId);
          if (targetData) {
            remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));
          }
        }
      });
      remoteEvent.targetMismatches.forEach(function(targetId) {
        var targetData = remoteStoreImpl.listenTargets.get(targetId);
        if (!targetData) {
          return;
        }
        remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));
        sendUnwatchRequest(remoteStoreImpl, targetId);
        var requestTargetData = new TargetData(targetData.target, targetId, 1, targetData.sequenceNumber);
        sendWatchRequest(remoteStoreImpl, requestTargetData);
      });
      return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);
    }
    function handleTargetError(remoteStoreImpl, watchChange) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var error3, _i, _d, targetId;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              error3 = watchChange.cause;
              _i = 0, _d = watchChange.targetIds;
              _e.label = 1;
            case 1:
              if (!(_i < _d.length))
                return [3, 4];
              targetId = _d[_i];
              if (!remoteStoreImpl.listenTargets.has(targetId))
                return [3, 3];
              return [4, remoteStoreImpl.remoteSyncer.rejectListen(targetId, error3)];
            case 2:
              _e.sent();
              remoteStoreImpl.listenTargets.delete(targetId);
              remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);
              _e.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }
    function fillWritePipeline(remoteStore) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl, writeStream, lastBatchIdRetrieved, batch, e_6;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              writeStream = ensureWriteStream(remoteStoreImpl);
              lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0 ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1].batchId : BATCHID_UNKNOWN;
              _d.label = 1;
            case 1:
              if (!canAddToWritePipeline(remoteStoreImpl))
                return [3, 7];
              _d.label = 2;
            case 2:
              _d.trys.push([2, 4, , 6]);
              return [4, localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved)];
            case 3:
              batch = _d.sent();
              if (batch === null) {
                if (remoteStoreImpl.writePipeline.length === 0) {
                  writeStream.markIdle();
                }
                return [3, 7];
              } else {
                lastBatchIdRetrieved = batch.batchId;
                addToWritePipeline(remoteStoreImpl, batch);
              }
              return [3, 6];
            case 4:
              e_6 = _d.sent();
              return [4, disableNetworkUntilRecovery(remoteStoreImpl, e_6)];
            case 5:
              _d.sent();
              return [3, 6];
            case 6:
              return [3, 1];
            case 7:
              if (shouldStartWriteStream(remoteStoreImpl)) {
                startWriteStream(remoteStoreImpl);
              }
              return [2];
          }
        });
      });
    }
    function canAddToWritePipeline(remoteStoreImpl) {
      return canUseNetwork(remoteStoreImpl) && remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES;
    }
    function addToWritePipeline(remoteStoreImpl, batch) {
      remoteStoreImpl.writePipeline.push(batch);
      var writeStream = ensureWriteStream(remoteStoreImpl);
      if (writeStream.isOpen() && writeStream.handshakeComplete) {
        writeStream.writeMutations(batch.mutations);
      }
    }
    function shouldStartWriteStream(remoteStoreImpl) {
      return canUseNetwork(remoteStoreImpl) && !ensureWriteStream(remoteStoreImpl).isStarted() && remoteStoreImpl.writePipeline.length > 0;
    }
    function startWriteStream(remoteStoreImpl) {
      ensureWriteStream(remoteStoreImpl).start();
    }
    function onWriteStreamOpen(remoteStoreImpl) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          ensureWriteStream(remoteStoreImpl).writeHandshake();
          return [2];
        });
      });
    }
    function onWriteHandshakeComplete(remoteStoreImpl) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var writeStream, _i, _d, batch;
        return tslib.__generator(this, function(_e) {
          writeStream = ensureWriteStream(remoteStoreImpl);
          for (_i = 0, _d = remoteStoreImpl.writePipeline; _i < _d.length; _i++) {
            batch = _d[_i];
            writeStream.writeMutations(batch.mutations);
          }
          return [2];
        });
      });
    }
    function onMutationResult(remoteStoreImpl, commitVersion, results) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var batch, success;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              batch = remoteStoreImpl.writePipeline.shift();
              success = MutationBatchResult.from(batch, commitVersion, results);
              return [4, executeWithRecovery(remoteStoreImpl, function() {
                return remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success);
              })];
            case 1:
              _d.sent();
              return [4, fillWritePipeline(remoteStoreImpl)];
            case 2:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function onWriteStreamClose(remoteStoreImpl, error3) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!(error3 && ensureWriteStream(remoteStoreImpl).handshakeComplete))
                return [3, 2];
              return [4, handleWriteError(remoteStoreImpl, error3)];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              if (shouldStartWriteStream(remoteStoreImpl)) {
                startWriteStream(remoteStoreImpl);
              }
              return [2];
          }
        });
      });
    }
    function handleWriteError(remoteStoreImpl, error3) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var batch_1;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!isPermanentWriteError(error3.code))
                return [3, 3];
              batch_1 = remoteStoreImpl.writePipeline.shift();
              ensureWriteStream(remoteStoreImpl).inhibitBackoff();
              return [4, executeWithRecovery(remoteStoreImpl, function() {
                return remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch_1.batchId, error3);
              })];
            case 1:
              _d.sent();
              return [4, fillWritePipeline(remoteStoreImpl)];
            case 2:
              _d.sent();
              _d.label = 3;
            case 3:
              return [2];
          }
        });
      });
    }
    function restartNetwork(remoteStore) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              remoteStoreImpl.offlineCauses.add(4);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              remoteStoreImpl.onlineStateTracker.set("Unknown");
              remoteStoreImpl.offlineCauses.delete(4);
              return [4, enableNetworkInternal(remoteStoreImpl)];
            case 2:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function remoteStoreHandleCredentialChange(remoteStore, user) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl, usesNetwork;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              remoteStoreImpl.asyncQueue.verifyOperationInProgress();
              logDebug(LOG_TAG$5, "RemoteStore received new credentials");
              usesNetwork = canUseNetwork(remoteStoreImpl);
              remoteStoreImpl.offlineCauses.add(3);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              if (usesNetwork) {
                remoteStoreImpl.onlineStateTracker.set("Unknown");
              }
              return [4, remoteStoreImpl.remoteSyncer.handleCredentialChange(user)];
            case 2:
              _d.sent();
              remoteStoreImpl.offlineCauses.delete(3);
              return [4, enableNetworkInternal(remoteStoreImpl)];
            case 3:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              if (!isPrimary)
                return [3, 2];
              remoteStoreImpl.offlineCauses.delete(2);
              return [4, enableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              return [3, 4];
            case 2:
              if (!!isPrimary)
                return [3, 4];
              remoteStoreImpl.offlineCauses.add(2);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 3:
              _d.sent();
              remoteStoreImpl.onlineStateTracker.set("Unknown");
              _d.label = 4;
            case 4:
              return [2];
          }
        });
      });
    }
    function ensureWatchStream(remoteStoreImpl) {
      var _this = this;
      if (!remoteStoreImpl.watchStream) {
        remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {
          onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),
          onClose: onWatchStreamClose.bind(null, remoteStoreImpl),
          onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)
        });
        remoteStoreImpl.onNetworkStatusChange.push(function(enabled) {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  if (!enabled)
                    return [3, 1];
                  remoteStoreImpl.watchStream.inhibitBackoff();
                  if (shouldStartWatchStream(remoteStoreImpl)) {
                    startWatchStream(remoteStoreImpl);
                  } else {
                    remoteStoreImpl.onlineStateTracker.set("Unknown");
                  }
                  return [3, 3];
                case 1:
                  return [4, remoteStoreImpl.watchStream.stop()];
                case 2:
                  _d.sent();
                  cleanUpWatchStreamState(remoteStoreImpl);
                  _d.label = 3;
                case 3:
                  return [2];
              }
            });
          });
        });
      }
      return remoteStoreImpl.watchStream;
    }
    function ensureWriteStream(remoteStoreImpl) {
      var _this = this;
      if (!remoteStoreImpl.writeStream) {
        remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {
          onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),
          onClose: onWriteStreamClose.bind(null, remoteStoreImpl),
          onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),
          onMutationResult: onMutationResult.bind(null, remoteStoreImpl)
        });
        remoteStoreImpl.onNetworkStatusChange.push(function(enabled) {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  if (!enabled)
                    return [3, 2];
                  remoteStoreImpl.writeStream.inhibitBackoff();
                  return [4, fillWritePipeline(remoteStoreImpl)];
                case 1:
                  _d.sent();
                  return [3, 4];
                case 2:
                  return [4, remoteStoreImpl.writeStream.stop()];
                case 3:
                  _d.sent();
                  if (remoteStoreImpl.writePipeline.length > 0) {
                    logDebug(LOG_TAG$5, "Stopping write stream with " + remoteStoreImpl.writePipeline.length + " pending writes");
                    remoteStoreImpl.writePipeline = [];
                  }
                  _d.label = 4;
                case 4:
                  return [2];
              }
            });
          });
        });
      }
      return remoteStoreImpl.writeStream;
    }
    var LOG_TAG$4 = "AsyncQueue";
    var DelayedOperation = function() {
      function DelayedOperation2(asyncQueue, timerId, targetTimeMs, op, removalCallback) {
        this.asyncQueue = asyncQueue;
        this.timerId = timerId;
        this.targetTimeMs = targetTimeMs;
        this.op = op;
        this.removalCallback = removalCallback;
        this.deferred = new Deferred();
        this.then = this.deferred.promise.then.bind(this.deferred.promise);
        this.deferred.promise.catch(function(err) {
        });
      }
      DelayedOperation2.createAndSchedule = function(asyncQueue, timerId, delayMs, op, removalCallback) {
        var targetTime = Date.now() + delayMs;
        var delayedOp = new DelayedOperation2(asyncQueue, timerId, targetTime, op, removalCallback);
        delayedOp.start(delayMs);
        return delayedOp;
      };
      DelayedOperation2.prototype.start = function(delayMs) {
        var _this = this;
        this.timerHandle = setTimeout(function() {
          return _this.handleDelayElapsed();
        }, delayMs);
      };
      DelayedOperation2.prototype.skipDelay = function() {
        return this.handleDelayElapsed();
      };
      DelayedOperation2.prototype.cancel = function(reason) {
        if (this.timerHandle !== null) {
          this.clearTimeout();
          this.deferred.reject(new FirestoreError(Code.CANCELLED, "Operation cancelled" + (reason ? ": " + reason : "")));
        }
      };
      DelayedOperation2.prototype.handleDelayElapsed = function() {
        var _this = this;
        this.asyncQueue.enqueueAndForget(function() {
          if (_this.timerHandle !== null) {
            _this.clearTimeout();
            return _this.op().then(function(result) {
              return _this.deferred.resolve(result);
            });
          } else {
            return Promise.resolve();
          }
        });
      };
      DelayedOperation2.prototype.clearTimeout = function() {
        if (this.timerHandle !== null) {
          this.removalCallback(this);
          clearTimeout(this.timerHandle);
          this.timerHandle = null;
        }
      };
      return DelayedOperation2;
    }();
    function wrapInUserErrorIfRecoverable(e, msg) {
      logError(LOG_TAG$4, msg + ": " + e);
      if (isIndexedDbTransactionError(e)) {
        return new FirestoreError(Code.UNAVAILABLE, msg + ": " + e);
      } else {
        throw e;
      }
    }
    var DocumentSet = function() {
      function DocumentSet2(comp) {
        if (comp) {
          this.comparator = function(d1, d2) {
            return comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);
          };
        } else {
          this.comparator = function(d1, d2) {
            return DocumentKey.comparator(d1.key, d2.key);
          };
        }
        this.keyedMap = documentMap();
        this.sortedSet = new SortedMap(this.comparator);
      }
      DocumentSet2.emptySet = function(oldSet) {
        return new DocumentSet2(oldSet.comparator);
      };
      DocumentSet2.prototype.has = function(key) {
        return this.keyedMap.get(key) != null;
      };
      DocumentSet2.prototype.get = function(key) {
        return this.keyedMap.get(key);
      };
      DocumentSet2.prototype.first = function() {
        return this.sortedSet.minKey();
      };
      DocumentSet2.prototype.last = function() {
        return this.sortedSet.maxKey();
      };
      DocumentSet2.prototype.isEmpty = function() {
        return this.sortedSet.isEmpty();
      };
      DocumentSet2.prototype.indexOf = function(key) {
        var doc2 = this.keyedMap.get(key);
        return doc2 ? this.sortedSet.indexOf(doc2) : -1;
      };
      Object.defineProperty(DocumentSet2.prototype, "size", {
        get: function() {
          return this.sortedSet.size;
        },
        enumerable: false,
        configurable: true
      });
      DocumentSet2.prototype.forEach = function(cb) {
        this.sortedSet.inorderTraversal(function(k, v) {
          cb(k);
          return false;
        });
      };
      DocumentSet2.prototype.add = function(doc2) {
        var set = this.delete(doc2.key);
        return set.copy(set.keyedMap.insert(doc2.key, doc2), set.sortedSet.insert(doc2, null));
      };
      DocumentSet2.prototype.delete = function(key) {
        var doc2 = this.get(key);
        if (!doc2) {
          return this;
        }
        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc2));
      };
      DocumentSet2.prototype.isEqual = function(other) {
        if (!(other instanceof DocumentSet2)) {
          return false;
        }
        if (this.size !== other.size) {
          return false;
        }
        var thisIt = this.sortedSet.getIterator();
        var otherIt = other.sortedSet.getIterator();
        while (thisIt.hasNext()) {
          var thisDoc = thisIt.getNext().key;
          var otherDoc = otherIt.getNext().key;
          if (!thisDoc.isEqual(otherDoc)) {
            return false;
          }
        }
        return true;
      };
      DocumentSet2.prototype.toString = function() {
        var docStrings = [];
        this.forEach(function(doc2) {
          docStrings.push(doc2.toString());
        });
        if (docStrings.length === 0) {
          return "DocumentSet ()";
        } else {
          return "DocumentSet (\n  " + docStrings.join("  \n") + "\n)";
        }
      };
      DocumentSet2.prototype.copy = function(keyedMap, sortedSet) {
        var newSet = new DocumentSet2();
        newSet.comparator = this.comparator;
        newSet.keyedMap = keyedMap;
        newSet.sortedSet = sortedSet;
        return newSet;
      };
      return DocumentSet2;
    }();
    var DocumentChangeSet = function() {
      function DocumentChangeSet2() {
        this.changeMap = new SortedMap(DocumentKey.comparator);
      }
      DocumentChangeSet2.prototype.track = function(change) {
        var key = change.doc.key;
        var oldChange = this.changeMap.get(key);
        if (!oldChange) {
          this.changeMap = this.changeMap.insert(key, change);
          return;
        }
        if (change.type !== 0 && oldChange.type === 3) {
          this.changeMap = this.changeMap.insert(key, change);
        } else if (change.type === 3 && oldChange.type !== 1) {
          this.changeMap = this.changeMap.insert(key, {
            type: oldChange.type,
            doc: change.doc
          });
        } else if (change.type === 2 && oldChange.type === 2) {
          this.changeMap = this.changeMap.insert(key, {
            type: 2,
            doc: change.doc
          });
        } else if (change.type === 2 && oldChange.type === 0) {
          this.changeMap = this.changeMap.insert(key, {
            type: 0,
            doc: change.doc
          });
        } else if (change.type === 1 && oldChange.type === 0) {
          this.changeMap = this.changeMap.remove(key);
        } else if (change.type === 1 && oldChange.type === 2) {
          this.changeMap = this.changeMap.insert(key, {
            type: 1,
            doc: oldChange.doc
          });
        } else if (change.type === 0 && oldChange.type === 1) {
          this.changeMap = this.changeMap.insert(key, {
            type: 2,
            doc: change.doc
          });
        } else {
          fail();
        }
      };
      DocumentChangeSet2.prototype.getChanges = function() {
        var changes = [];
        this.changeMap.inorderTraversal(function(key, change) {
          changes.push(change);
        });
        return changes;
      };
      return DocumentChangeSet2;
    }();
    var ViewSnapshot = function() {
      function ViewSnapshot2(query2, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges) {
        this.query = query2;
        this.docs = docs;
        this.oldDocs = oldDocs;
        this.docChanges = docChanges;
        this.mutatedKeys = mutatedKeys;
        this.fromCache = fromCache;
        this.syncStateChanged = syncStateChanged;
        this.excludesMetadataChanges = excludesMetadataChanges;
      }
      ViewSnapshot2.fromInitialDocuments = function(query2, documents, mutatedKeys, fromCache) {
        var changes = [];
        documents.forEach(function(doc2) {
          changes.push({ type: 0, doc: doc2 });
        });
        return new ViewSnapshot2(query2, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, true, false);
      };
      Object.defineProperty(ViewSnapshot2.prototype, "hasPendingWrites", {
        get: function() {
          return !this.mutatedKeys.isEmpty();
        },
        enumerable: false,
        configurable: true
      });
      ViewSnapshot2.prototype.isEqual = function(other) {
        if (this.fromCache !== other.fromCache || this.syncStateChanged !== other.syncStateChanged || !this.mutatedKeys.isEqual(other.mutatedKeys) || !queryEquals(this.query, other.query) || !this.docs.isEqual(other.docs) || !this.oldDocs.isEqual(other.oldDocs)) {
          return false;
        }
        var changes = this.docChanges;
        var otherChanges = other.docChanges;
        if (changes.length !== otherChanges.length) {
          return false;
        }
        for (var i = 0; i < changes.length; i++) {
          if (changes[i].type !== otherChanges[i].type || !changes[i].doc.isEqual(otherChanges[i].doc)) {
            return false;
          }
        }
        return true;
      };
      return ViewSnapshot2;
    }();
    var QueryListenersInfo = function() {
      function QueryListenersInfo2() {
        this.viewSnap = void 0;
        this.listeners = [];
      }
      return QueryListenersInfo2;
    }();
    function newEventManager() {
      return new EventManagerImpl();
    }
    var EventManagerImpl = function() {
      function EventManagerImpl2() {
        this.queries = new ObjectMap(function(q) {
          return canonifyQuery(q);
        }, queryEquals);
        this.onlineState = "Unknown";
        this.snapshotsInSyncListeners = new Set();
      }
      return EventManagerImpl2;
    }();
    function eventManagerListen(eventManager, listener) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var eventManagerImpl, query2, firstListen, queryInfo, _d, e_7, firestoreError, raisedEvent;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              eventManagerImpl = debugCast(eventManager);
              query2 = listener.query;
              firstListen = false;
              queryInfo = eventManagerImpl.queries.get(query2);
              if (!queryInfo) {
                firstListen = true;
                queryInfo = new QueryListenersInfo();
              }
              if (!firstListen)
                return [3, 4];
              _e.label = 1;
            case 1:
              _e.trys.push([1, 3, , 4]);
              _d = queryInfo;
              return [4, eventManagerImpl.onListen(query2)];
            case 2:
              _d.viewSnap = _e.sent();
              return [3, 4];
            case 3:
              e_7 = _e.sent();
              firestoreError = wrapInUserErrorIfRecoverable(e_7, "Initialization of query '" + stringifyQuery(listener.query) + "' failed");
              listener.onError(firestoreError);
              return [2];
            case 4:
              eventManagerImpl.queries.set(query2, queryInfo);
              queryInfo.listeners.push(listener);
              listener.applyOnlineStateChange(eventManagerImpl.onlineState);
              if (queryInfo.viewSnap) {
                raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);
                if (raisedEvent) {
                  raiseSnapshotsInSyncEvent(eventManagerImpl);
                }
              }
              return [2];
          }
        });
      });
    }
    function eventManagerUnlisten(eventManager, listener) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var eventManagerImpl, query2, lastListen, queryInfo, i;
        return tslib.__generator(this, function(_d) {
          eventManagerImpl = debugCast(eventManager);
          query2 = listener.query;
          lastListen = false;
          queryInfo = eventManagerImpl.queries.get(query2);
          if (queryInfo) {
            i = queryInfo.listeners.indexOf(listener);
            if (i >= 0) {
              queryInfo.listeners.splice(i, 1);
              lastListen = queryInfo.listeners.length === 0;
            }
          }
          if (lastListen) {
            eventManagerImpl.queries.delete(query2);
            return [2, eventManagerImpl.onUnlisten(query2)];
          }
          return [2];
        });
      });
    }
    function eventManagerOnWatchChange(eventManager, viewSnaps) {
      var eventManagerImpl = debugCast(eventManager);
      var raisedEvent = false;
      for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {
        var viewSnap = viewSnaps_1[_i];
        var query_1 = viewSnap.query;
        var queryInfo = eventManagerImpl.queries.get(query_1);
        if (queryInfo) {
          for (var _d = 0, _e = queryInfo.listeners; _d < _e.length; _d++) {
            var listener = _e[_d];
            if (listener.onViewSnapshot(viewSnap)) {
              raisedEvent = true;
            }
          }
          queryInfo.viewSnap = viewSnap;
        }
      }
      if (raisedEvent) {
        raiseSnapshotsInSyncEvent(eventManagerImpl);
      }
    }
    function eventManagerOnWatchError(eventManager, query2, error3) {
      var eventManagerImpl = debugCast(eventManager);
      var queryInfo = eventManagerImpl.queries.get(query2);
      if (queryInfo) {
        for (var _i = 0, _d = queryInfo.listeners; _i < _d.length; _i++) {
          var listener = _d[_i];
          listener.onError(error3);
        }
      }
      eventManagerImpl.queries.delete(query2);
    }
    function eventManagerOnOnlineStateChange(eventManager, onlineState) {
      var eventManagerImpl = debugCast(eventManager);
      eventManagerImpl.onlineState = onlineState;
      var raisedEvent = false;
      eventManagerImpl.queries.forEach(function(_, queryInfo) {
        for (var _i = 0, _d = queryInfo.listeners; _i < _d.length; _i++) {
          var listener = _d[_i];
          if (listener.applyOnlineStateChange(onlineState)) {
            raisedEvent = true;
          }
        }
      });
      if (raisedEvent) {
        raiseSnapshotsInSyncEvent(eventManagerImpl);
      }
    }
    function addSnapshotsInSyncListener(eventManager, observer) {
      var eventManagerImpl = debugCast(eventManager);
      eventManagerImpl.snapshotsInSyncListeners.add(observer);
      observer.next();
    }
    function removeSnapshotsInSyncListener(eventManager, observer) {
      var eventManagerImpl = debugCast(eventManager);
      eventManagerImpl.snapshotsInSyncListeners.delete(observer);
    }
    function raiseSnapshotsInSyncEvent(eventManagerImpl) {
      eventManagerImpl.snapshotsInSyncListeners.forEach(function(observer) {
        observer.next();
      });
    }
    var QueryListener = function() {
      function QueryListener2(query2, queryObserver, options2) {
        this.query = query2;
        this.queryObserver = queryObserver;
        this.raisedInitialEvent = false;
        this.snap = null;
        this.onlineState = "Unknown";
        this.options = options2 || {};
      }
      QueryListener2.prototype.onViewSnapshot = function(snap) {
        if (!this.options.includeMetadataChanges) {
          var docChanges = [];
          for (var _i = 0, _d = snap.docChanges; _i < _d.length; _i++) {
            var docChange = _d[_i];
            if (docChange.type !== 3) {
              docChanges.push(docChange);
            }
          }
          snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, true);
        }
        var raisedEvent = false;
        if (!this.raisedInitialEvent) {
          if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {
            this.raiseInitialEvent(snap);
            raisedEvent = true;
          }
        } else if (this.shouldRaiseEvent(snap)) {
          this.queryObserver.next(snap);
          raisedEvent = true;
        }
        this.snap = snap;
        return raisedEvent;
      };
      QueryListener2.prototype.onError = function(error3) {
        this.queryObserver.error(error3);
      };
      QueryListener2.prototype.applyOnlineStateChange = function(onlineState) {
        this.onlineState = onlineState;
        var raisedEvent = false;
        if (this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, onlineState)) {
          this.raiseInitialEvent(this.snap);
          raisedEvent = true;
        }
        return raisedEvent;
      };
      QueryListener2.prototype.shouldRaiseInitialEvent = function(snap, onlineState) {
        if (!snap.fromCache) {
          return true;
        }
        var maybeOnline = onlineState !== "Offline";
        if (this.options.waitForSyncWhenOnline && maybeOnline) {
          return false;
        }
        return !snap.docs.isEmpty() || onlineState === "Offline";
      };
      QueryListener2.prototype.shouldRaiseEvent = function(snap) {
        if (snap.docChanges.length > 0) {
          return true;
        }
        var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;
        if (snap.syncStateChanged || hasPendingWritesChanged) {
          return this.options.includeMetadataChanges === true;
        }
        return false;
      };
      QueryListener2.prototype.raiseInitialEvent = function(snap) {
        snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache);
        this.raisedInitialEvent = true;
        this.queryObserver.next(snap);
      };
      return QueryListener2;
    }();
    var LocalViewChanges = function() {
      function LocalViewChanges2(targetId, fromCache, addedKeys, removedKeys) {
        this.targetId = targetId;
        this.fromCache = fromCache;
        this.addedKeys = addedKeys;
        this.removedKeys = removedKeys;
      }
      LocalViewChanges2.fromSnapshot = function(targetId, viewSnapshot) {
        var addedKeys = documentKeySet();
        var removedKeys = documentKeySet();
        for (var _i = 0, _d = viewSnapshot.docChanges; _i < _d.length; _i++) {
          var docChange = _d[_i];
          switch (docChange.type) {
            case 0:
              addedKeys = addedKeys.add(docChange.doc.key);
              break;
            case 1:
              removedKeys = removedKeys.add(docChange.doc.key);
              break;
          }
        }
        return new LocalViewChanges2(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);
      };
      return LocalViewChanges2;
    }();
    var BundleLoadResult = function() {
      function BundleLoadResult2(progress, changedDocs) {
        this.progress = progress;
        this.changedDocs = changedDocs;
      }
      return BundleLoadResult2;
    }();
    var BundleConverterImpl = function() {
      function BundleConverterImpl2(serializer) {
        this.serializer = serializer;
      }
      BundleConverterImpl2.prototype.toDocumentKey = function(name) {
        return fromName(this.serializer, name);
      };
      BundleConverterImpl2.prototype.toMutableDocument = function(bundledDoc) {
        if (bundledDoc.metadata.exists) {
          return fromDocument(this.serializer, bundledDoc.document, false);
        } else {
          return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));
        }
      };
      BundleConverterImpl2.prototype.toSnapshotVersion = function(time) {
        return fromVersion(time);
      };
      return BundleConverterImpl2;
    }();
    var BundleLoader = function() {
      function BundleLoader2(bundleMetadata, localStore, serializer) {
        this.bundleMetadata = bundleMetadata;
        this.localStore = localStore;
        this.serializer = serializer;
        this.queries = [];
        this.documents = [];
        this.progress = bundleInitialProgress(bundleMetadata);
      }
      BundleLoader2.prototype.addSizedElement = function(element) {
        this.progress.bytesLoaded += element.byteLength;
        var documentsLoaded = this.progress.documentsLoaded;
        if (element.payload.namedQuery) {
          this.queries.push(element.payload.namedQuery);
        } else if (element.payload.documentMetadata) {
          this.documents.push({ metadata: element.payload.documentMetadata });
          if (!element.payload.documentMetadata.exists) {
            ++documentsLoaded;
          }
        } else if (element.payload.document) {
          this.documents[this.documents.length - 1].document = element.payload.document;
          ++documentsLoaded;
        }
        if (documentsLoaded !== this.progress.documentsLoaded) {
          this.progress.documentsLoaded = documentsLoaded;
          return Object.assign({}, this.progress);
        }
        return null;
      };
      BundleLoader2.prototype.getQueryDocumentMapping = function(documents) {
        var queryDocumentMap = new Map();
        var bundleConverter = new BundleConverterImpl(this.serializer);
        for (var _i = 0, documents_2 = documents; _i < documents_2.length; _i++) {
          var bundleDoc = documents_2[_i];
          if (bundleDoc.metadata.queries) {
            var documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);
            for (var _d = 0, _e = bundleDoc.metadata.queries; _d < _e.length; _d++) {
              var queryName = _e[_d];
              var documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);
              queryDocumentMap.set(queryName, documentKeys);
            }
          }
        }
        return queryDocumentMap;
      };
      BundleLoader2.prototype.complete = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var changedDocuments, queryDocumentMap, _i, _d, q;
          return tslib.__generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                return [4, localStoreApplyBundledDocuments(this.localStore, new BundleConverterImpl(this.serializer), this.documents, this.bundleMetadata.id)];
              case 1:
                changedDocuments = _e.sent();
                queryDocumentMap = this.getQueryDocumentMapping(this.documents);
                _i = 0, _d = this.queries;
                _e.label = 2;
              case 2:
                if (!(_i < _d.length))
                  return [3, 5];
                q = _d[_i];
                return [4, localStoreSaveNamedQuery(this.localStore, q, queryDocumentMap.get(q.name))];
              case 3:
                _e.sent();
                _e.label = 4;
              case 4:
                _i++;
                return [3, 2];
              case 5:
                this.progress.taskState = "Success";
                return [2, new BundleLoadResult(Object.assign({}, this.progress), changedDocuments)];
            }
          });
        });
      };
      return BundleLoader2;
    }();
    function bundleInitialProgress(metadata) {
      return {
        taskState: "Running",
        documentsLoaded: 0,
        bytesLoaded: 0,
        totalDocuments: metadata.totalDocuments,
        totalBytes: metadata.totalBytes
      };
    }
    function bundleSuccessProgress(metadata) {
      return {
        taskState: "Success",
        documentsLoaded: metadata.totalDocuments,
        bytesLoaded: metadata.totalBytes,
        totalDocuments: metadata.totalDocuments,
        totalBytes: metadata.totalBytes
      };
    }
    var AddedLimboDocument = function() {
      function AddedLimboDocument2(key) {
        this.key = key;
      }
      return AddedLimboDocument2;
    }();
    var RemovedLimboDocument = function() {
      function RemovedLimboDocument2(key) {
        this.key = key;
      }
      return RemovedLimboDocument2;
    }();
    var View = function() {
      function View2(query2, _syncedDocuments) {
        this.query = query2;
        this._syncedDocuments = _syncedDocuments;
        this.syncState = null;
        this.current = false;
        this.limboDocuments = documentKeySet();
        this.mutatedKeys = documentKeySet();
        this.docComparator = newQueryComparator(query2);
        this.documentSet = new DocumentSet(this.docComparator);
      }
      Object.defineProperty(View2.prototype, "syncedDocuments", {
        get: function() {
          return this._syncedDocuments;
        },
        enumerable: false,
        configurable: true
      });
      View2.prototype.computeDocChanges = function(docChanges, previousChanges) {
        var _this = this;
        var changeSet = previousChanges ? previousChanges.changeSet : new DocumentChangeSet();
        var oldDocumentSet = previousChanges ? previousChanges.documentSet : this.documentSet;
        var newMutatedKeys = previousChanges ? previousChanges.mutatedKeys : this.mutatedKeys;
        var newDocumentSet = oldDocumentSet;
        var needsRefill = false;
        var lastDocInLimit = hasLimitToFirst(this.query) && oldDocumentSet.size === this.query.limit ? oldDocumentSet.last() : null;
        var firstDocInLimit = hasLimitToLast(this.query) && oldDocumentSet.size === this.query.limit ? oldDocumentSet.first() : null;
        docChanges.inorderTraversal(function(key, entry) {
          var oldDoc2 = oldDocumentSet.get(key);
          var newDoc = queryMatches(_this.query, entry) ? entry : null;
          var oldDocHadPendingMutations = oldDoc2 ? _this.mutatedKeys.has(oldDoc2.key) : false;
          var newDocHasPendingMutations = newDoc ? newDoc.hasLocalMutations || _this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations : false;
          var changeApplied = false;
          if (oldDoc2 && newDoc) {
            var docsEqual = oldDoc2.data.isEqual(newDoc.data);
            if (!docsEqual) {
              if (!_this.shouldWaitForSyncedDocument(oldDoc2, newDoc)) {
                changeSet.track({
                  type: 2,
                  doc: newDoc
                });
                changeApplied = true;
                if (lastDocInLimit && _this.docComparator(newDoc, lastDocInLimit) > 0 || firstDocInLimit && _this.docComparator(newDoc, firstDocInLimit) < 0) {
                  needsRefill = true;
                }
              }
            } else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {
              changeSet.track({ type: 3, doc: newDoc });
              changeApplied = true;
            }
          } else if (!oldDoc2 && newDoc) {
            changeSet.track({ type: 0, doc: newDoc });
            changeApplied = true;
          } else if (oldDoc2 && !newDoc) {
            changeSet.track({ type: 1, doc: oldDoc2 });
            changeApplied = true;
            if (lastDocInLimit || firstDocInLimit) {
              needsRefill = true;
            }
          }
          if (changeApplied) {
            if (newDoc) {
              newDocumentSet = newDocumentSet.add(newDoc);
              if (newDocHasPendingMutations) {
                newMutatedKeys = newMutatedKeys.add(key);
              } else {
                newMutatedKeys = newMutatedKeys.delete(key);
              }
            } else {
              newDocumentSet = newDocumentSet.delete(key);
              newMutatedKeys = newMutatedKeys.delete(key);
            }
          }
        });
        if (hasLimitToFirst(this.query) || hasLimitToLast(this.query)) {
          while (newDocumentSet.size > this.query.limit) {
            var oldDoc = hasLimitToFirst(this.query) ? newDocumentSet.last() : newDocumentSet.first();
            newDocumentSet = newDocumentSet.delete(oldDoc.key);
            newMutatedKeys = newMutatedKeys.delete(oldDoc.key);
            changeSet.track({ type: 1, doc: oldDoc });
          }
        }
        return {
          documentSet: newDocumentSet,
          changeSet,
          needsRefill,
          mutatedKeys: newMutatedKeys
        };
      };
      View2.prototype.shouldWaitForSyncedDocument = function(oldDoc, newDoc) {
        return oldDoc.hasLocalMutations && newDoc.hasCommittedMutations && !newDoc.hasLocalMutations;
      };
      View2.prototype.applyChanges = function(docChanges, updateLimboDocuments, targetChange) {
        var _this = this;
        var oldDocs = this.documentSet;
        this.documentSet = docChanges.documentSet;
        this.mutatedKeys = docChanges.mutatedKeys;
        var changes = docChanges.changeSet.getChanges();
        changes.sort(function(c1, c2) {
          return compareChangeType(c1.type, c2.type) || _this.docComparator(c1.doc, c2.doc);
        });
        this.applyTargetChange(targetChange);
        var limboChanges = updateLimboDocuments ? this.updateLimboDocuments() : [];
        var synced = this.limboDocuments.size === 0 && this.current;
        var newSyncState = synced ? 1 : 0;
        var syncStateChanged = newSyncState !== this.syncState;
        this.syncState = newSyncState;
        if (changes.length === 0 && !syncStateChanged) {
          return { limboChanges };
        } else {
          var snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0, syncStateChanged, false);
          return {
            snapshot: snap,
            limboChanges
          };
        }
      };
      View2.prototype.applyOnlineStateChange = function(onlineState) {
        if (this.current && onlineState === "Offline") {
          this.current = false;
          return this.applyChanges({
            documentSet: this.documentSet,
            changeSet: new DocumentChangeSet(),
            mutatedKeys: this.mutatedKeys,
            needsRefill: false
          }, false);
        } else {
          return { limboChanges: [] };
        }
      };
      View2.prototype.shouldBeInLimbo = function(key) {
        if (this._syncedDocuments.has(key)) {
          return false;
        }
        if (!this.documentSet.has(key)) {
          return false;
        }
        if (this.documentSet.get(key).hasLocalMutations) {
          return false;
        }
        return true;
      };
      View2.prototype.applyTargetChange = function(targetChange) {
        var _this = this;
        if (targetChange) {
          targetChange.addedDocuments.forEach(function(key) {
            return _this._syncedDocuments = _this._syncedDocuments.add(key);
          });
          targetChange.modifiedDocuments.forEach(function(key) {
          });
          targetChange.removedDocuments.forEach(function(key) {
            return _this._syncedDocuments = _this._syncedDocuments.delete(key);
          });
          this.current = targetChange.current;
        }
      };
      View2.prototype.updateLimboDocuments = function() {
        var _this = this;
        if (!this.current) {
          return [];
        }
        var oldLimboDocuments = this.limboDocuments;
        this.limboDocuments = documentKeySet();
        this.documentSet.forEach(function(doc2) {
          if (_this.shouldBeInLimbo(doc2.key)) {
            _this.limboDocuments = _this.limboDocuments.add(doc2.key);
          }
        });
        var changes = [];
        oldLimboDocuments.forEach(function(key) {
          if (!_this.limboDocuments.has(key)) {
            changes.push(new RemovedLimboDocument(key));
          }
        });
        this.limboDocuments.forEach(function(key) {
          if (!oldLimboDocuments.has(key)) {
            changes.push(new AddedLimboDocument(key));
          }
        });
        return changes;
      };
      View2.prototype.synchronizeWithPersistedState = function(queryResult) {
        this._syncedDocuments = queryResult.remoteKeys;
        this.limboDocuments = documentKeySet();
        var docChanges = this.computeDocChanges(queryResult.documents);
        return this.applyChanges(docChanges, true);
      };
      View2.prototype.computeInitialSnapshot = function() {
        return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0);
      };
      return View2;
    }();
    function compareChangeType(c1, c2) {
      var order = function(change) {
        switch (change) {
          case 0:
            return 1;
          case 2:
            return 2;
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return fail();
        }
      };
      return order(c1) - order(c2);
    }
    var LOG_TAG$3 = "SyncEngine";
    var QueryView = function() {
      function QueryView2(query2, targetId, view) {
        this.query = query2;
        this.targetId = targetId;
        this.view = view;
      }
      return QueryView2;
    }();
    var LimboResolution = function() {
      function LimboResolution2(key) {
        this.key = key;
        this.receivedDocument = false;
      }
      return LimboResolution2;
    }();
    var SyncEngineImpl = function() {
      function SyncEngineImpl2(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions) {
        this.localStore = localStore;
        this.remoteStore = remoteStore;
        this.eventManager = eventManager;
        this.sharedClientState = sharedClientState;
        this.currentUser = currentUser;
        this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;
        this.syncEngineListener = {};
        this.queryViewsByQuery = new ObjectMap(function(q) {
          return canonifyQuery(q);
        }, queryEquals);
        this.queriesByTarget = new Map();
        this.enqueuedLimboResolutions = new Set();
        this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);
        this.activeLimboResolutionsByTarget = new Map();
        this.limboDocumentRefs = new ReferenceSet();
        this.mutationUserCallbacks = {};
        this.pendingWritesCallbacks = new Map();
        this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();
        this.onlineState = "Unknown";
        this._isPrimaryClient = void 0;
      }
      Object.defineProperty(SyncEngineImpl2.prototype, "isPrimaryClient", {
        get: function() {
          return this._isPrimaryClient === true;
        },
        enumerable: false,
        configurable: true
      });
      return SyncEngineImpl2;
    }();
    function newSyncEngine(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {
      var syncEngine = new SyncEngineImpl(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);
      if (isPrimary) {
        syncEngine._isPrimaryClient = true;
      }
      return syncEngine;
    }
    function syncEngineListen(syncEngine, query2) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, targetId, viewSnapshot, queryView, targetData, status_1;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = ensureWatchCallbacks(syncEngine);
              queryView = syncEngineImpl.queryViewsByQuery.get(query2);
              if (!queryView)
                return [3, 1];
              targetId = queryView.targetId;
              syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId);
              viewSnapshot = queryView.view.computeInitialSnapshot();
              return [3, 4];
            case 1:
              return [4, localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query2))];
            case 2:
              targetData = _d.sent();
              status_1 = syncEngineImpl.sharedClientState.addLocalQueryTarget(targetData.targetId);
              targetId = targetData.targetId;
              return [4, initializeViewAndComputeSnapshot(syncEngineImpl, query2, targetId, status_1 === "current")];
            case 3:
              viewSnapshot = _d.sent();
              if (syncEngineImpl.isPrimaryClient) {
                remoteStoreListen(syncEngineImpl.remoteStore, targetData);
              }
              _d.label = 4;
            case 4:
              return [2, viewSnapshot];
          }
        });
      });
    }
    function initializeViewAndComputeSnapshot(syncEngineImpl, query2, targetId, current) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var queryResult, view, viewDocChanges, synthesizedTargetChange, viewChange, data;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl.applyDocChanges = function(queryView, changes, remoteEvent) {
                return applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);
              };
              return [4, localStoreExecuteQuery(syncEngineImpl.localStore, query2, true)];
            case 1:
              queryResult = _d.sent();
              view = new View(query2, queryResult.remoteKeys);
              viewDocChanges = view.computeDocChanges(queryResult.documents);
              synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== "Offline");
              viewChange = view.applyChanges(viewDocChanges, syncEngineImpl.isPrimaryClient, synthesizedTargetChange);
              updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);
              data = new QueryView(query2, targetId, view);
              syncEngineImpl.queryViewsByQuery.set(query2, data);
              if (syncEngineImpl.queriesByTarget.has(targetId)) {
                syncEngineImpl.queriesByTarget.get(targetId).push(query2);
              } else {
                syncEngineImpl.queriesByTarget.set(targetId, [query2]);
              }
              return [2, viewChange.snapshot];
          }
        });
      });
    }
    function syncEngineUnlisten(syncEngine, query2) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, queryView, queries, targetRemainsActive;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              queryView = syncEngineImpl.queryViewsByQuery.get(query2);
              queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);
              if (queries.length > 1) {
                syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(function(q) {
                  return !queryEquals(q, query2);
                }));
                syncEngineImpl.queryViewsByQuery.delete(query2);
                return [2];
              }
              if (!syncEngineImpl.isPrimaryClient)
                return [3, 3];
              syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);
              targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);
              if (!!targetRemainsActive)
                return [3, 2];
              return [4, localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, false).then(function() {
                syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);
                remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);
                removeAndCleanupTarget(syncEngineImpl, queryView.targetId);
              }).catch(ignoreIfPrimaryLeaseLoss)];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              return [3, 5];
            case 3:
              removeAndCleanupTarget(syncEngineImpl, queryView.targetId);
              return [4, localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, true)];
            case 4:
              _d.sent();
              _d.label = 5;
            case 5:
              return [2];
          }
        });
      });
    }
    function syncEngineWrite(syncEngine, batch, userCallback) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, result, e_8, error3;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);
              _d.label = 1;
            case 1:
              _d.trys.push([1, 5, , 6]);
              return [4, localStoreWriteLocally(syncEngineImpl.localStore, batch)];
            case 2:
              result = _d.sent();
              syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);
              addMutationCallback(syncEngineImpl, result.batchId, userCallback);
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes)];
            case 3:
              _d.sent();
              return [4, fillWritePipeline(syncEngineImpl.remoteStore)];
            case 4:
              _d.sent();
              return [3, 6];
            case 5:
              e_8 = _d.sent();
              error3 = wrapInUserErrorIfRecoverable(e_8, "Failed to persist write");
              userCallback.reject(error3);
              return [3, 6];
            case 6:
              return [2];
          }
        });
      });
    }
    function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, changes, error_2;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              _d.label = 1;
            case 1:
              _d.trys.push([1, 4, , 6]);
              return [4, localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent)];
            case 2:
              changes = _d.sent();
              remoteEvent.targetChanges.forEach(function(targetChange, targetId) {
                var limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);
                if (limboResolution) {
                  hardAssert(targetChange.addedDocuments.size + targetChange.modifiedDocuments.size + targetChange.removedDocuments.size <= 1);
                  if (targetChange.addedDocuments.size > 0) {
                    limboResolution.receivedDocument = true;
                  } else if (targetChange.modifiedDocuments.size > 0) {
                    hardAssert(limboResolution.receivedDocument);
                  } else if (targetChange.removedDocuments.size > 0) {
                    hardAssert(limboResolution.receivedDocument);
                    limboResolution.receivedDocument = false;
                  } else
                    ;
                }
              });
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent)];
            case 3:
              _d.sent();
              return [3, 6];
            case 4:
              error_2 = _d.sent();
              return [4, ignoreIfPrimaryLeaseLoss(error_2)];
            case 5:
              _d.sent();
              return [3, 6];
            case 6:
              return [2];
          }
        });
      });
    }
    function syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {
      var syncEngineImpl = debugCast(syncEngine);
      if (syncEngineImpl.isPrimaryClient && source === 0 || !syncEngineImpl.isPrimaryClient && source === 1) {
        var newViewSnapshots_1 = [];
        syncEngineImpl.queryViewsByQuery.forEach(function(query2, queryView) {
          var viewChange = queryView.view.applyOnlineStateChange(onlineState);
          if (viewChange.snapshot) {
            newViewSnapshots_1.push(viewChange.snapshot);
          }
        });
        eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);
        if (newViewSnapshots_1.length) {
          syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots_1);
        }
        syncEngineImpl.onlineState = onlineState;
        if (syncEngineImpl.isPrimaryClient) {
          syncEngineImpl.sharedClientState.setOnlineState(onlineState);
        }
      }
    }
    function syncEngineRejectListen(syncEngine, targetId, err) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, limboResolution, limboKey, documentUpdates, resolvedLimboDocuments, event_2;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              syncEngineImpl.sharedClientState.updateQueryState(targetId, "rejected", err);
              limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);
              limboKey = limboResolution && limboResolution.key;
              if (!limboKey)
                return [3, 2];
              documentUpdates = new SortedMap(DocumentKey.comparator);
              documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));
              resolvedLimboDocuments = documentKeySet().add(limboKey);
              event_2 = new RemoteEvent(SnapshotVersion.min(), new Map(), new SortedSet(primitiveComparator), documentUpdates, resolvedLimboDocuments);
              return [4, syncEngineApplyRemoteEvent(syncEngineImpl, event_2)];
            case 1:
              _d.sent();
              syncEngineImpl.activeLimboTargetsByKey = syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);
              syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);
              pumpEnqueuedLimboResolutions(syncEngineImpl);
              return [3, 4];
            case 2:
              return [4, localStoreReleaseTarget(syncEngineImpl.localStore, targetId, false).then(function() {
                return removeAndCleanupTarget(syncEngineImpl, targetId, err);
              }).catch(ignoreIfPrimaryLeaseLoss)];
            case 3:
              _d.sent();
              _d.label = 4;
            case 4:
              return [2];
          }
        });
      });
    }
    function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, batchId, changes, error_3;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              batchId = mutationBatchResult.batch.batchId;
              _d.label = 1;
            case 1:
              _d.trys.push([1, 4, , 6]);
              return [4, localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult)];
            case 2:
              changes = _d.sent();
              processUserCallback(syncEngineImpl, batchId, null);
              triggerPendingWritesCallbacks(syncEngineImpl, batchId);
              syncEngineImpl.sharedClientState.updateMutationState(batchId, "acknowledged");
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes)];
            case 3:
              _d.sent();
              return [3, 6];
            case 4:
              error_3 = _d.sent();
              return [4, ignoreIfPrimaryLeaseLoss(error_3)];
            case 5:
              _d.sent();
              return [3, 6];
            case 6:
              return [2];
          }
        });
      });
    }
    function syncEngineRejectFailedWrite(syncEngine, batchId, error3) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, changes, error_4;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              _d.label = 1;
            case 1:
              _d.trys.push([1, 4, , 6]);
              return [4, localStoreRejectBatch(syncEngineImpl.localStore, batchId)];
            case 2:
              changes = _d.sent();
              processUserCallback(syncEngineImpl, batchId, error3);
              triggerPendingWritesCallbacks(syncEngineImpl, batchId);
              syncEngineImpl.sharedClientState.updateMutationState(batchId, "rejected", error3);
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes)];
            case 3:
              _d.sent();
              return [3, 6];
            case 4:
              error_4 = _d.sent();
              return [4, ignoreIfPrimaryLeaseLoss(error_4)];
            case 5:
              _d.sent();
              return [3, 6];
            case 6:
              return [2];
          }
        });
      });
    }
    function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, highestBatchId, callbacks, e_9, firestoreError;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              if (!canUseNetwork(syncEngineImpl.remoteStore)) {
                logDebug(LOG_TAG$3, "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
              }
              _d.label = 1;
            case 1:
              _d.trys.push([1, 3, , 4]);
              return [4, localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore)];
            case 2:
              highestBatchId = _d.sent();
              if (highestBatchId === BATCHID_UNKNOWN) {
                callback.resolve();
                return [2];
              }
              callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];
              callbacks.push(callback);
              syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);
              return [3, 4];
            case 3:
              e_9 = _d.sent();
              firestoreError = wrapInUserErrorIfRecoverable(e_9, "Initialization of waitForPendingWrites() operation failed");
              callback.reject(firestoreError);
              return [3, 4];
            case 4:
              return [2];
          }
        });
      });
    }
    function triggerPendingWritesCallbacks(syncEngineImpl, batchId) {
      (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(function(callback) {
        callback.resolve();
      });
      syncEngineImpl.pendingWritesCallbacks.delete(batchId);
    }
    function rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {
      syncEngineImpl.pendingWritesCallbacks.forEach(function(callbacks) {
        callbacks.forEach(function(callback) {
          callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));
        });
      });
      syncEngineImpl.pendingWritesCallbacks.clear();
    }
    function addMutationCallback(syncEngineImpl, batchId, callback) {
      var newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];
      if (!newCallbacks) {
        newCallbacks = new SortedMap(primitiveComparator);
      }
      newCallbacks = newCallbacks.insert(batchId, callback);
      syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] = newCallbacks;
    }
    function processUserCallback(syncEngine, batchId, error3) {
      var syncEngineImpl = debugCast(syncEngine);
      var newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];
      if (newCallbacks) {
        var callback = newCallbacks.get(batchId);
        if (callback) {
          if (error3) {
            callback.reject(error3);
          } else {
            callback.resolve();
          }
          newCallbacks = newCallbacks.remove(batchId);
        }
        syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] = newCallbacks;
      }
    }
    function removeAndCleanupTarget(syncEngineImpl, targetId, error3) {
      if (error3 === void 0) {
        error3 = null;
      }
      syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);
      for (var _i = 0, _d = syncEngineImpl.queriesByTarget.get(targetId); _i < _d.length; _i++) {
        var query_2 = _d[_i];
        syncEngineImpl.queryViewsByQuery.delete(query_2);
        if (error3) {
          syncEngineImpl.syncEngineListener.onWatchError(query_2, error3);
        }
      }
      syncEngineImpl.queriesByTarget.delete(targetId);
      if (syncEngineImpl.isPrimaryClient) {
        var limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);
        limboKeys.forEach(function(limboKey) {
          var isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);
          if (!isReferenced) {
            removeLimboTarget(syncEngineImpl, limboKey);
          }
        });
      }
    }
    function removeLimboTarget(syncEngineImpl, key) {
      syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());
      var limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);
      if (limboTargetId === null) {
        return;
      }
      remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);
      syncEngineImpl.activeLimboTargetsByKey = syncEngineImpl.activeLimboTargetsByKey.remove(key);
      syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);
      pumpEnqueuedLimboResolutions(syncEngineImpl);
    }
    function updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {
      for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {
        var limboChange = limboChanges_1[_i];
        if (limboChange instanceof AddedLimboDocument) {
          syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);
          trackLimboChange(syncEngineImpl, limboChange);
        } else if (limboChange instanceof RemovedLimboDocument) {
          logDebug(LOG_TAG$3, "Document no longer in limbo: " + limboChange.key);
          syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);
          var isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);
          if (!isReferenced) {
            removeLimboTarget(syncEngineImpl, limboChange.key);
          }
        } else {
          fail();
        }
      }
    }
    function trackLimboChange(syncEngineImpl, limboChange) {
      var key = limboChange.key;
      var keyString = key.path.canonicalString();
      if (!syncEngineImpl.activeLimboTargetsByKey.get(key) && !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {
        logDebug(LOG_TAG$3, "New document in limbo: " + key);
        syncEngineImpl.enqueuedLimboResolutions.add(keyString);
        pumpEnqueuedLimboResolutions(syncEngineImpl);
      }
    }
    function pumpEnqueuedLimboResolutions(syncEngineImpl) {
      while (syncEngineImpl.enqueuedLimboResolutions.size > 0 && syncEngineImpl.activeLimboTargetsByKey.size < syncEngineImpl.maxConcurrentLimboResolutions) {
        var keyString = syncEngineImpl.enqueuedLimboResolutions.values().next().value;
        syncEngineImpl.enqueuedLimboResolutions.delete(keyString);
        var key = new DocumentKey(ResourcePath.fromString(keyString));
        var limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();
        syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));
        syncEngineImpl.activeLimboTargetsByKey = syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);
        remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, 2, ListenSequence.INVALID));
      }
    }
    function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, newSnaps, docChangesInAllViews, queriesProcessed;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              newSnaps = [];
              docChangesInAllViews = [];
              queriesProcessed = [];
              if (syncEngineImpl.queryViewsByQuery.isEmpty()) {
                return [2];
              }
              syncEngineImpl.queryViewsByQuery.forEach(function(_, queryView) {
                queriesProcessed.push(syncEngineImpl.applyDocChanges(queryView, changes, remoteEvent).then(function(viewSnapshot) {
                  if (viewSnapshot) {
                    if (syncEngineImpl.isPrimaryClient) {
                      syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, viewSnapshot.fromCache ? "not-current" : "current");
                    }
                    newSnaps.push(viewSnapshot);
                    var docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);
                    docChangesInAllViews.push(docChanges);
                  }
                }));
              });
              return [4, Promise.all(queriesProcessed)];
            case 1:
              _d.sent();
              syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);
              return [4, localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews)];
            case 2:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var viewDocChanges, targetChange, viewChange;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              viewDocChanges = queryView.view.computeDocChanges(changes);
              if (!viewDocChanges.needsRefill)
                return [3, 2];
              return [4, localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, false).then(function(_d2) {
                var documents = _d2.documents;
                return queryView.view.computeDocChanges(documents, viewDocChanges);
              })];
            case 1:
              viewDocChanges = _d.sent();
              _d.label = 2;
            case 2:
              targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);
              viewChange = queryView.view.applyChanges(viewDocChanges, syncEngineImpl.isPrimaryClient, targetChange);
              updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);
              return [2, viewChange.snapshot];
          }
        });
      });
    }
    function syncEngineHandleCredentialChange(syncEngine, user) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, userChanged, result;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              userChanged = !syncEngineImpl.currentUser.isEqual(user);
              if (!userChanged)
                return [3, 3];
              logDebug(LOG_TAG$3, "User change. New user:", user.toKey());
              return [4, localStoreHandleUserChange(syncEngineImpl.localStore, user)];
            case 1:
              result = _d.sent();
              syncEngineImpl.currentUser = user;
              rejectOutstandingPendingWritesCallbacks(syncEngineImpl, "'waitForPendingWrites' promise is rejected due to a user change.");
              syncEngineImpl.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments)];
            case 2:
              _d.sent();
              _d.label = 3;
            case 3:
              return [2];
          }
        });
      });
    }
    function syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {
      var syncEngineImpl = debugCast(syncEngine);
      var limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);
      if (limboResolution && limboResolution.receivedDocument) {
        return documentKeySet().add(limboResolution.key);
      } else {
        var keySet = documentKeySet();
        var queries = syncEngineImpl.queriesByTarget.get(targetId);
        if (!queries) {
          return keySet;
        }
        for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {
          var query_3 = queries_1[_i];
          var queryView = syncEngineImpl.queryViewsByQuery.get(query_3);
          keySet = keySet.unionWith(queryView.view.syncedDocuments);
        }
        return keySet;
      }
    }
    function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, queryResult, viewSnapshot;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              return [4, localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, true)];
            case 1:
              queryResult = _d.sent();
              viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);
              if (syncEngineImpl.isPrimaryClient) {
                updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);
              }
              return [2, viewSnapshot];
          }
        });
      });
    }
    function syncEngineSynchronizeWithChangedDocuments(syncEngine) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl;
        return tslib.__generator(this, function(_d) {
          syncEngineImpl = debugCast(syncEngine);
          return [2, localStoreGetNewDocumentChanges(syncEngineImpl.localStore).then(function(changes) {
            return syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);
          })];
        });
      });
    }
    function syncEngineApplyBatchState(syncEngine, batchId, batchState, error3) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, documents;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              return [4, localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId)];
            case 1:
              documents = _d.sent();
              if (documents === null) {
                logDebug(LOG_TAG$3, "Cannot apply mutation batch with id: " + batchId);
                return [2];
              }
              if (!(batchState === "pending"))
                return [3, 3];
              return [4, fillWritePipeline(syncEngineImpl.remoteStore)];
            case 2:
              _d.sent();
              return [3, 4];
            case 3:
              if (batchState === "acknowledged" || batchState === "rejected") {
                processUserCallback(syncEngineImpl, batchId, error3 ? error3 : null);
                triggerPendingWritesCallbacks(syncEngineImpl, batchId);
                localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);
              } else {
                fail();
              }
              _d.label = 4;
            case 4:
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents)];
            case 5:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function syncEngineApplyPrimaryState(syncEngine, isPrimary) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, activeTargets, activeQueries, _i, activeQueries_1, targetData, activeTargets_1, p_1;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              ensureWatchCallbacks(syncEngineImpl);
              syncEngineEnsureWriteCallbacks(syncEngineImpl);
              if (!(isPrimary === true && syncEngineImpl._isPrimaryClient !== true))
                return [3, 3];
              activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();
              return [4, synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray())];
            case 1:
              activeQueries = _d.sent();
              syncEngineImpl._isPrimaryClient = true;
              return [4, remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true)];
            case 2:
              _d.sent();
              for (_i = 0, activeQueries_1 = activeQueries; _i < activeQueries_1.length; _i++) {
                targetData = activeQueries_1[_i];
                remoteStoreListen(syncEngineImpl.remoteStore, targetData);
              }
              return [3, 7];
            case 3:
              if (!(isPrimary === false && syncEngineImpl._isPrimaryClient !== false))
                return [3, 7];
              activeTargets_1 = [];
              p_1 = Promise.resolve();
              syncEngineImpl.queriesByTarget.forEach(function(_, targetId) {
                if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {
                  activeTargets_1.push(targetId);
                } else {
                  p_1 = p_1.then(function() {
                    removeAndCleanupTarget(syncEngineImpl, targetId);
                    return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, true);
                  });
                }
                remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);
              });
              return [4, p_1];
            case 4:
              _d.sent();
              return [4, synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets_1)];
            case 5:
              _d.sent();
              resetLimboDocuments(syncEngineImpl);
              syncEngineImpl._isPrimaryClient = false;
              return [4, remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false)];
            case 6:
              _d.sent();
              _d.label = 7;
            case 7:
              return [2];
          }
        });
      });
    }
    function resetLimboDocuments(syncEngine) {
      var syncEngineImpl = debugCast(syncEngine);
      syncEngineImpl.activeLimboResolutionsByTarget.forEach(function(_, targetId) {
        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);
      });
      syncEngineImpl.limboDocumentRefs.removeAllReferences();
      syncEngineImpl.activeLimboResolutionsByTarget = new Map();
      syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);
    }
    function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, activeQueries, newViewSnapshots, _i, targets_1, targetId, targetData, queries, _d, queries_2, query_4, queryView, viewChange, target;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              activeQueries = [];
              newViewSnapshots = [];
              _i = 0, targets_1 = targets;
              _e.label = 1;
            case 1:
              if (!(_i < targets_1.length))
                return [3, 13];
              targetId = targets_1[_i];
              targetData = void 0;
              queries = syncEngineImpl.queriesByTarget.get(targetId);
              if (!(queries && queries.length !== 0))
                return [3, 7];
              return [4, localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]))];
            case 2:
              targetData = _e.sent();
              _d = 0, queries_2 = queries;
              _e.label = 3;
            case 3:
              if (!(_d < queries_2.length))
                return [3, 6];
              query_4 = queries_2[_d];
              queryView = syncEngineImpl.queryViewsByQuery.get(query_4);
              return [4, synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView)];
            case 4:
              viewChange = _e.sent();
              if (viewChange.snapshot) {
                newViewSnapshots.push(viewChange.snapshot);
              }
              _e.label = 5;
            case 5:
              _d++;
              return [3, 3];
            case 6:
              return [3, 11];
            case 7:
              return [4, localStoreGetCachedTarget(syncEngineImpl.localStore, targetId)];
            case 8:
              target = _e.sent();
              return [4, localStoreAllocateTarget(syncEngineImpl.localStore, target)];
            case 9:
              targetData = _e.sent();
              return [4, initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, false)];
            case 10:
              _e.sent();
              _e.label = 11;
            case 11:
              activeQueries.push(targetData);
              _e.label = 12;
            case 12:
              _i++;
              return [3, 1];
            case 13:
              syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);
              return [2, activeQueries];
          }
        });
      });
    }
    function synthesizeTargetToQuery(target) {
      return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, "F", target.startAt, target.endAt);
    }
    function syncEngineGetActiveClients(syncEngine) {
      var syncEngineImpl = debugCast(syncEngine);
      return localStoreGetActiveClients(syncEngineImpl.localStore);
    }
    function syncEngineApplyTargetState(syncEngine, targetId, state, error3) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, _d, changes, synthesizedRemoteEvent;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              if (syncEngineImpl._isPrimaryClient) {
                logDebug(LOG_TAG$3, "Ignoring unexpected query state notification.");
                return [2];
              }
              if (!syncEngineImpl.queriesByTarget.has(targetId))
                return [3, 7];
              _d = state;
              switch (_d) {
                case "current":
                  return [3, 1];
                case "not-current":
                  return [3, 1];
                case "rejected":
                  return [3, 4];
              }
              return [3, 6];
            case 1:
              return [4, localStoreGetNewDocumentChanges(syncEngineImpl.localStore)];
            case 2:
              changes = _e.sent();
              synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === "current");
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent)];
            case 3:
              _e.sent();
              return [3, 7];
            case 4:
              return [4, localStoreReleaseTarget(syncEngineImpl.localStore, targetId, true)];
            case 5:
              _e.sent();
              removeAndCleanupTarget(syncEngineImpl, targetId, error3);
              return [3, 7];
            case 6:
              fail();
              _e.label = 7;
            case 7:
              return [2];
          }
        });
      });
    }
    function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, _i, added_1, targetId, target, targetData, _loop_5, _d, removed_1, targetId;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              syncEngineImpl = ensureWatchCallbacks(syncEngine);
              if (!syncEngineImpl._isPrimaryClient) {
                return [2];
              }
              _i = 0, added_1 = added;
              _e.label = 1;
            case 1:
              if (!(_i < added_1.length))
                return [3, 6];
              targetId = added_1[_i];
              if (syncEngineImpl.queriesByTarget.has(targetId)) {
                logDebug(LOG_TAG$3, "Adding an already active target " + targetId);
                return [3, 5];
              }
              return [4, localStoreGetCachedTarget(syncEngineImpl.localStore, targetId)];
            case 2:
              target = _e.sent();
              return [4, localStoreAllocateTarget(syncEngineImpl.localStore, target)];
            case 3:
              targetData = _e.sent();
              return [4, initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, false)];
            case 4:
              _e.sent();
              remoteStoreListen(syncEngineImpl.remoteStore, targetData);
              _e.label = 5;
            case 5:
              _i++;
              return [3, 1];
            case 6:
              _loop_5 = function(targetId2) {
                return tslib.__generator(this, function(_f) {
                  switch (_f.label) {
                    case 0:
                      if (!syncEngineImpl.queriesByTarget.has(targetId2)) {
                        return [2, "continue"];
                      }
                      return [4, localStoreReleaseTarget(syncEngineImpl.localStore, targetId2, false).then(function() {
                        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId2);
                        removeAndCleanupTarget(syncEngineImpl, targetId2);
                      }).catch(ignoreIfPrimaryLeaseLoss)];
                    case 1:
                      _f.sent();
                      return [2];
                  }
                });
              };
              _d = 0, removed_1 = removed;
              _e.label = 7;
            case 7:
              if (!(_d < removed_1.length))
                return [3, 10];
              targetId = removed_1[_d];
              return [5, _loop_5(targetId)];
            case 8:
              _e.sent();
              _e.label = 9;
            case 9:
              _d++;
              return [3, 7];
            case 10:
              return [2];
          }
        });
      });
    }
    function ensureWatchCallbacks(syncEngine) {
      var syncEngineImpl = debugCast(syncEngine);
      syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent = syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);
      syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget = syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);
      syncEngineImpl.remoteStore.remoteSyncer.rejectListen = syncEngineRejectListen.bind(null, syncEngineImpl);
      syncEngineImpl.syncEngineListener.onWatchChange = eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);
      syncEngineImpl.syncEngineListener.onWatchError = eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);
      return syncEngineImpl;
    }
    function syncEngineEnsureWriteCallbacks(syncEngine) {
      var syncEngineImpl = debugCast(syncEngine);
      syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite = syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);
      syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite = syncEngineRejectFailedWrite.bind(null, syncEngineImpl);
      return syncEngineImpl;
    }
    function syncEngineLoadBundle(syncEngine, bundleReader, task) {
      var syncEngineImpl = debugCast(syncEngine);
      loadBundleImpl(syncEngineImpl, bundleReader, task).then(function() {
        syncEngineImpl.sharedClientState.notifyBundleLoaded();
      });
    }
    function loadBundleImpl(syncEngine, reader, task) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var metadata, skip, loader, element, progress, result, e_10;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 13, , 14]);
              return [4, reader.getMetadata()];
            case 1:
              metadata = _d.sent();
              return [4, localStoreHasNewerBundle(syncEngine.localStore, metadata)];
            case 2:
              skip = _d.sent();
              if (!skip)
                return [3, 4];
              return [4, reader.close()];
            case 3:
              _d.sent();
              task._completeWith(bundleSuccessProgress(metadata));
              return [2];
            case 4:
              task._updateProgress(bundleInitialProgress(metadata));
              loader = new BundleLoader(metadata, syncEngine.localStore, reader.serializer);
              return [4, reader.nextElement()];
            case 5:
              element = _d.sent();
              _d.label = 6;
            case 6:
              if (!element)
                return [3, 9];
              return [4, loader.addSizedElement(element)];
            case 7:
              progress = _d.sent();
              if (progress) {
                task._updateProgress(progress);
              }
              return [4, reader.nextElement()];
            case 8:
              element = _d.sent();
              return [3, 6];
            case 9:
              return [4, loader.complete()];
            case 10:
              result = _d.sent();
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, void 0)];
            case 11:
              _d.sent();
              return [4, localStoreSaveBundle(syncEngine.localStore, metadata)];
            case 12:
              _d.sent();
              task._completeWith(result.progress);
              return [3, 14];
            case 13:
              e_10 = _d.sent();
              logWarn(LOG_TAG$3, "Loading bundle failed with " + e_10);
              task._failWith(e_10);
              return [3, 14];
            case 14:
              return [2];
          }
        });
      });
    }
    var MemoryOfflineComponentProvider = function() {
      function MemoryOfflineComponentProvider2() {
        this.synchronizeTabs = false;
      }
      MemoryOfflineComponentProvider2.prototype.initialize = function(cfg) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this.serializer = newSerializer(cfg.databaseInfo.databaseId);
                this.sharedClientState = this.createSharedClientState(cfg);
                this.persistence = this.createPersistence(cfg);
                return [4, this.persistence.start()];
              case 1:
                _d.sent();
                this.gcScheduler = this.createGarbageCollectionScheduler(cfg);
                this.localStore = this.createLocalStore(cfg);
                return [2];
            }
          });
        });
      };
      MemoryOfflineComponentProvider2.prototype.createGarbageCollectionScheduler = function(cfg) {
        return null;
      };
      MemoryOfflineComponentProvider2.prototype.createLocalStore = function(cfg) {
        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);
      };
      MemoryOfflineComponentProvider2.prototype.createPersistence = function(cfg) {
        return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);
      };
      MemoryOfflineComponentProvider2.prototype.createSharedClientState = function(cfg) {
        return new MemorySharedClientState();
      };
      MemoryOfflineComponentProvider2.prototype.terminate = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (this.gcScheduler) {
                  this.gcScheduler.stop();
                }
                return [4, this.sharedClientState.shutdown()];
              case 1:
                _d.sent();
                return [4, this.persistence.shutdown()];
              case 2:
                _d.sent();
                return [2];
            }
          });
        });
      };
      return MemoryOfflineComponentProvider2;
    }();
    var IndexedDbOfflineComponentProvider = function(_super) {
      tslib.__extends(IndexedDbOfflineComponentProvider2, _super);
      function IndexedDbOfflineComponentProvider2(onlineComponentProvider, cacheSizeBytes, forceOwnership) {
        var _this = _super.call(this) || this;
        _this.onlineComponentProvider = onlineComponentProvider;
        _this.cacheSizeBytes = cacheSizeBytes;
        _this.forceOwnership = forceOwnership;
        _this.synchronizeTabs = false;
        return _this;
      }
      IndexedDbOfflineComponentProvider2.prototype.initialize = function(cfg) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, _super.prototype.initialize.call(this, cfg)];
              case 1:
                _d.sent();
                return [4, localStoreSynchronizeLastDocumentChangeReadTime(this.localStore)];
              case 2:
                _d.sent();
                return [4, this.onlineComponentProvider.initialize(this, cfg)];
              case 3:
                _d.sent();
                return [4, syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine)];
              case 4:
                _d.sent();
                return [4, fillWritePipeline(this.onlineComponentProvider.remoteStore)];
              case 5:
                _d.sent();
                return [2];
            }
          });
        });
      };
      IndexedDbOfflineComponentProvider2.prototype.createLocalStore = function(cfg) {
        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);
      };
      IndexedDbOfflineComponentProvider2.prototype.createGarbageCollectionScheduler = function(cfg) {
        var garbageCollector = this.persistence.referenceDelegate.garbageCollector;
        return new LruScheduler(garbageCollector, cfg.asyncQueue);
      };
      IndexedDbOfflineComponentProvider2.prototype.createPersistence = function(cfg) {
        var persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);
        var lruParams = this.cacheSizeBytes !== void 0 ? LruParams.withCacheSize(this.cacheSizeBytes) : LruParams.DEFAULT;
        return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);
      };
      IndexedDbOfflineComponentProvider2.prototype.createSharedClientState = function(cfg) {
        return new MemorySharedClientState();
      };
      return IndexedDbOfflineComponentProvider2;
    }(MemoryOfflineComponentProvider);
    var MultiTabOfflineComponentProvider = function(_super) {
      tslib.__extends(MultiTabOfflineComponentProvider2, _super);
      function MultiTabOfflineComponentProvider2(onlineComponentProvider, cacheSizeBytes) {
        var _this = _super.call(this, onlineComponentProvider, cacheSizeBytes, false) || this;
        _this.onlineComponentProvider = onlineComponentProvider;
        _this.cacheSizeBytes = cacheSizeBytes;
        _this.synchronizeTabs = true;
        return _this;
      }
      MultiTabOfflineComponentProvider2.prototype.initialize = function(cfg) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var syncEngine;
          var _this = this;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, _super.prototype.initialize.call(this, cfg)];
              case 1:
                _d.sent();
                syncEngine = this.onlineComponentProvider.syncEngine;
                if (!(this.sharedClientState instanceof WebStorageSharedClientState))
                  return [3, 3];
                this.sharedClientState.syncEngine = {
                  applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),
                  applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),
                  applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),
                  getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),
                  synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)
                };
                return [4, this.sharedClientState.start()];
              case 2:
                _d.sent();
                _d.label = 3;
              case 3:
                return [4, this.persistence.setPrimaryStateListener(function(isPrimary) {
                  return tslib.__awaiter(_this, void 0, void 0, function() {
                    return tslib.__generator(this, function(_d2) {
                      switch (_d2.label) {
                        case 0:
                          return [4, syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary)];
                        case 1:
                          _d2.sent();
                          if (this.gcScheduler) {
                            if (isPrimary && !this.gcScheduler.started) {
                              this.gcScheduler.start(this.localStore);
                            } else if (!isPrimary) {
                              this.gcScheduler.stop();
                            }
                          }
                          return [2];
                      }
                    });
                  });
                })];
              case 4:
                _d.sent();
                return [2];
            }
          });
        });
      };
      MultiTabOfflineComponentProvider2.prototype.createSharedClientState = function(cfg) {
        var window2 = getWindow();
        if (!WebStorageSharedClientState.isAvailable(window2)) {
          throw new FirestoreError(Code.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
        }
        var persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);
        return new WebStorageSharedClientState(window2, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);
      };
      return MultiTabOfflineComponentProvider2;
    }(IndexedDbOfflineComponentProvider);
    var OnlineComponentProvider = function() {
      function OnlineComponentProvider2() {
      }
      OnlineComponentProvider2.prototype.initialize = function(offlineComponentProvider, cfg) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var _this = this;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (this.localStore) {
                  return [2];
                }
                this.localStore = offlineComponentProvider.localStore;
                this.sharedClientState = offlineComponentProvider.sharedClientState;
                this.datastore = this.createDatastore(cfg);
                this.remoteStore = this.createRemoteStore(cfg);
                this.eventManager = this.createEventManager(cfg);
                this.syncEngine = this.createSyncEngine(cfg, !offlineComponentProvider.synchronizeTabs);
                this.sharedClientState.onlineStateHandler = function(onlineState) {
                  return syncEngineApplyOnlineStateChange(_this.syncEngine, onlineState, 1);
                };
                this.remoteStore.remoteSyncer.handleCredentialChange = syncEngineHandleCredentialChange.bind(null, this.syncEngine);
                return [4, remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient)];
              case 1:
                _d.sent();
                return [2];
            }
          });
        });
      };
      OnlineComponentProvider2.prototype.createEventManager = function(cfg) {
        return newEventManager();
      };
      OnlineComponentProvider2.prototype.createDatastore = function(cfg) {
        var serializer = newSerializer(cfg.databaseInfo.databaseId);
        var connection = newConnection(cfg.databaseInfo);
        return newDatastore(cfg.credentials, connection, serializer);
      };
      OnlineComponentProvider2.prototype.createRemoteStore = function(cfg) {
        var _this = this;
        return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, function(onlineState) {
          return syncEngineApplyOnlineStateChange(_this.syncEngine, onlineState, 0);
        }, newConnectivityMonitor());
      };
      OnlineComponentProvider2.prototype.createSyncEngine = function(cfg, startAsPrimary) {
        return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);
      };
      OnlineComponentProvider2.prototype.terminate = function() {
        return remoteStoreShutdown(this.remoteStore);
      };
      return OnlineComponentProvider2;
    }();
    var DEFAULT_BYTES_PER_READ = 10240;
    function toByteStreamReaderHelper(source, bytesPerRead) {
      if (bytesPerRead === void 0) {
        bytesPerRead = DEFAULT_BYTES_PER_READ;
      }
      var readFrom = 0;
      var reader = {
        read: function() {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var result;
            return tslib.__generator(this, function(_d) {
              if (readFrom < source.byteLength) {
                result = {
                  value: source.slice(readFrom, readFrom + bytesPerRead),
                  done: false
                };
                readFrom += bytesPerRead;
                return [2, result];
              }
              return [2, { done: true }];
            });
          });
        },
        cancel: function() {
          return tslib.__awaiter(this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              return [2];
            });
          });
        },
        releaseLock: function() {
        },
        closed: Promise.reject("unimplemented")
      };
      return reader;
    }
    function validateNonEmptyArgument(functionName, argumentName, argument) {
      if (!argument) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() cannot be called with an empty " + argumentName + ".");
      }
    }
    function validateSetOptions(methodName, options2) {
      if (options2 === void 0) {
        return {
          merge: false
        };
      }
      if (options2.mergeFields !== void 0 && options2.merge !== void 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid options passed to function " + methodName + '(): You cannot specify both "merge" and "mergeFields".');
      }
      return options2;
    }
    function validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {
      if (argument1 === true && argument2 === true) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, optionName1 + " and " + optionName2 + " cannot be used together.");
      }
    }
    function validateDocumentPath(path2) {
      if (!DocumentKey.isDocumentKey(path2)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but " + path2 + " has " + path2.length + ".");
      }
    }
    function validateCollectionPath(path2) {
      if (DocumentKey.isDocumentKey(path2)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid collection reference. Collection references must have an odd number of segments, but " + path2 + " has " + path2.length + ".");
      }
    }
    function isPlainObject(input) {
      return typeof input === "object" && input !== null && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);
    }
    function valueDescription(input) {
      if (input === void 0) {
        return "undefined";
      } else if (input === null) {
        return "null";
      } else if (typeof input === "string") {
        if (input.length > 20) {
          input = input.substring(0, 20) + "...";
        }
        return JSON.stringify(input);
      } else if (typeof input === "number" || typeof input === "boolean") {
        return "" + input;
      } else if (typeof input === "object") {
        if (input instanceof Array) {
          return "an array";
        } else {
          var customObjectName = tryGetCustomObjectType(input);
          if (customObjectName) {
            return "a custom " + customObjectName + " object";
          } else {
            return "an object";
          }
        }
      } else if (typeof input === "function") {
        return "a function";
      } else {
        return fail();
      }
    }
    function tryGetCustomObjectType(input) {
      if (input.constructor) {
        var funcNameRegex = /function\s+([^\s(]+)\s*\(/;
        var results = funcNameRegex.exec(input.constructor.toString());
        if (results && results.length > 1) {
          return results[1];
        }
      }
      return null;
    }
    function cast(obj, constructor) {
      if ("_delegate" in obj) {
        obj = obj._delegate;
      }
      if (!(obj instanceof constructor)) {
        if (constructor.name === obj.constructor.name) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
        } else {
          var description = valueDescription(obj);
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected type '" + constructor.name + "', but it was: " + description);
        }
      }
      return obj;
    }
    function validatePositiveNumber(functionName, n) {
      if (n <= 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires a positive number, but it was: " + n + ".");
      }
    }
    function toByteStreamReader(source, bytesPerRead) {
      if (!(source instanceof Uint8Array)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "NodePlatform.toByteStreamReader expects source to be Uint8Array, got " + valueDescription(source));
      }
      return toByteStreamReaderHelper(source, bytesPerRead);
    }
    var AsyncObserver = function() {
      function AsyncObserver2(observer) {
        this.observer = observer;
        this.muted = false;
      }
      AsyncObserver2.prototype.next = function(value) {
        if (this.observer.next) {
          this.scheduleEvent(this.observer.next, value);
        }
      };
      AsyncObserver2.prototype.error = function(error3) {
        if (this.observer.error) {
          this.scheduleEvent(this.observer.error, error3);
        } else {
          console.error("Uncaught Error in snapshot listener:", error3);
        }
      };
      AsyncObserver2.prototype.mute = function() {
        this.muted = true;
      };
      AsyncObserver2.prototype.scheduleEvent = function(eventHandler, event) {
        var _this = this;
        if (!this.muted) {
          setTimeout(function() {
            if (!_this.muted) {
              eventHandler(event);
            }
          }, 0);
        }
      };
      return AsyncObserver2;
    }();
    var SizedBundleElement = function() {
      function SizedBundleElement2(payload, byteLength) {
        this.payload = payload;
        this.byteLength = byteLength;
      }
      SizedBundleElement2.prototype.isBundleMetadata = function() {
        return "metadata" in this.payload;
      };
      return SizedBundleElement2;
    }();
    var BundleReaderImpl = function() {
      function BundleReaderImpl2(reader, serializer) {
        var _this = this;
        this.reader = reader;
        this.serializer = serializer;
        this.metadata = new Deferred();
        this.buffer = new Uint8Array();
        this.textDecoder = newTextDecoder();
        this.nextElementImpl().then(function(element) {
          if (element && element.isBundleMetadata()) {
            _this.metadata.resolve(element.payload.metadata);
          } else {
            _this.metadata.reject(new Error("The first element of the bundle is not a metadata, it is\n             " + JSON.stringify(element === null || element === void 0 ? void 0 : element.payload)));
          }
        }, function(error3) {
          return _this.metadata.reject(error3);
        });
      }
      BundleReaderImpl2.prototype.close = function() {
        return this.reader.cancel();
      };
      BundleReaderImpl2.prototype.getMetadata = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            return [2, this.metadata.promise];
          });
        });
      };
      BundleReaderImpl2.prototype.nextElement = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, this.getMetadata()];
              case 1:
                _d.sent();
                return [2, this.nextElementImpl()];
            }
          });
        });
      };
      BundleReaderImpl2.prototype.nextElementImpl = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var lengthBuffer, lengthString, length, jsonString;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, this.readLength()];
              case 1:
                lengthBuffer = _d.sent();
                if (lengthBuffer === null) {
                  return [2, null];
                }
                lengthString = this.textDecoder.decode(lengthBuffer);
                length = Number(lengthString);
                if (isNaN(length)) {
                  this.raiseError("length string (" + lengthString + ") is not valid number");
                }
                return [4, this.readJsonString(length)];
              case 2:
                jsonString = _d.sent();
                return [2, new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length)];
            }
          });
        });
      };
      BundleReaderImpl2.prototype.indexOfOpenBracket = function() {
        return this.buffer.findIndex(function(v) {
          return v === "{".charCodeAt(0);
        });
      };
      BundleReaderImpl2.prototype.readLength = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var done, position, result;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!(this.indexOfOpenBracket() < 0))
                  return [3, 2];
                return [4, this.pullMoreDataToBuffer()];
              case 1:
                done = _d.sent();
                if (done) {
                  return [3, 2];
                }
                return [3, 0];
              case 2:
                if (this.buffer.length === 0) {
                  return [2, null];
                }
                position = this.indexOfOpenBracket();
                if (position < 0) {
                  this.raiseError("Reached the end of bundle when a length string is expected.");
                }
                result = this.buffer.slice(0, position);
                this.buffer = this.buffer.slice(position);
                return [2, result];
            }
          });
        });
      };
      BundleReaderImpl2.prototype.readJsonString = function(length) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var done, result;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!(this.buffer.length < length))
                  return [3, 2];
                return [4, this.pullMoreDataToBuffer()];
              case 1:
                done = _d.sent();
                if (done) {
                  this.raiseError("Reached the end of bundle when more is expected.");
                }
                return [3, 0];
              case 2:
                result = this.textDecoder.decode(this.buffer.slice(0, length));
                this.buffer = this.buffer.slice(length);
                return [2, result];
            }
          });
        });
      };
      BundleReaderImpl2.prototype.raiseError = function(message) {
        this.reader.cancel();
        throw new Error("Invalid bundle format: " + message);
      };
      BundleReaderImpl2.prototype.pullMoreDataToBuffer = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var result, newBuffer;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, this.reader.read()];
              case 1:
                result = _d.sent();
                if (!result.done) {
                  newBuffer = new Uint8Array(this.buffer.length + result.value.length);
                  newBuffer.set(this.buffer);
                  newBuffer.set(result.value, this.buffer.length);
                  this.buffer = newBuffer;
                }
                return [2, result.done];
            }
          });
        });
      };
      return BundleReaderImpl2;
    }();
    function newBundleReader(reader, serializer) {
      return new BundleReaderImpl(reader, serializer);
    }
    var Transaction$3 = function() {
      function Transaction$32(datastore) {
        this.datastore = datastore;
        this.readVersions = new Map();
        this.mutations = [];
        this.committed = false;
        this.lastWriteError = null;
        this.writtenDocs = new Set();
      }
      Transaction$32.prototype.lookup = function(keys) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var docs;
          var _this = this;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this.ensureCommitNotCalled();
                if (this.mutations.length > 0) {
                  throw new FirestoreError(Code.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
                }
                return [4, invokeBatchGetDocumentsRpc(this.datastore, keys)];
              case 1:
                docs = _d.sent();
                docs.forEach(function(doc2) {
                  return _this.recordVersion(doc2);
                });
                return [2, docs];
            }
          });
        });
      };
      Transaction$32.prototype.set = function(key, data) {
        this.write(data.toMutation(key, this.precondition(key)));
        this.writtenDocs.add(key.toString());
      };
      Transaction$32.prototype.update = function(key, data) {
        try {
          this.write(data.toMutation(key, this.preconditionForUpdate(key)));
        } catch (e) {
          this.lastWriteError = e;
        }
        this.writtenDocs.add(key.toString());
      };
      Transaction$32.prototype.delete = function(key) {
        this.write(new DeleteMutation(key, this.precondition(key)));
        this.writtenDocs.add(key.toString());
      };
      Transaction$32.prototype.commit = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var unwritten;
          var _this = this;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this.ensureCommitNotCalled();
                if (this.lastWriteError) {
                  throw this.lastWriteError;
                }
                unwritten = this.readVersions;
                this.mutations.forEach(function(mutation) {
                  unwritten.delete(mutation.key.toString());
                });
                unwritten.forEach(function(_, path2) {
                  var key = DocumentKey.fromPath(path2);
                  _this.mutations.push(new VerifyMutation(key, _this.precondition(key)));
                });
                return [4, invokeCommitRpc(this.datastore, this.mutations)];
              case 1:
                _d.sent();
                this.committed = true;
                return [2];
            }
          });
        });
      };
      Transaction$32.prototype.recordVersion = function(doc2) {
        var docVersion;
        if (doc2.isFoundDocument()) {
          docVersion = doc2.version;
        } else if (doc2.isNoDocument()) {
          docVersion = SnapshotVersion.min();
        } else {
          throw fail();
        }
        var existingVersion = this.readVersions.get(doc2.key.toString());
        if (existingVersion) {
          if (!docVersion.isEqual(existingVersion)) {
            throw new FirestoreError(Code.ABORTED, "Document version changed between two reads.");
          }
        } else {
          this.readVersions.set(doc2.key.toString(), docVersion);
        }
      };
      Transaction$32.prototype.precondition = function(key) {
        var version2 = this.readVersions.get(key.toString());
        if (!this.writtenDocs.has(key.toString()) && version2) {
          return Precondition.updateTime(version2);
        } else {
          return Precondition.none();
        }
      };
      Transaction$32.prototype.preconditionForUpdate = function(key) {
        var version2 = this.readVersions.get(key.toString());
        if (!this.writtenDocs.has(key.toString()) && version2) {
          if (version2.isEqual(SnapshotVersion.min())) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
          }
          return Precondition.updateTime(version2);
        } else {
          return Precondition.exists(true);
        }
      };
      Transaction$32.prototype.write = function(mutation) {
        this.ensureCommitNotCalled();
        this.mutations.push(mutation);
      };
      Transaction$32.prototype.ensureCommitNotCalled = function() {
      };
      return Transaction$32;
    }();
    var DEFAULT_MAX_ATTEMPTS_COUNT = 5;
    var TransactionRunner = function() {
      function TransactionRunner2(asyncQueue, datastore, updateFunction, deferred) {
        this.asyncQueue = asyncQueue;
        this.datastore = datastore;
        this.updateFunction = updateFunction;
        this.deferred = deferred;
        this.attemptsRemaining = DEFAULT_MAX_ATTEMPTS_COUNT;
        this.backoff = new ExponentialBackoff(this.asyncQueue, "transaction_retry");
      }
      TransactionRunner2.prototype.run = function() {
        this.attemptsRemaining -= 1;
        this.runWithBackOff();
      };
      TransactionRunner2.prototype.runWithBackOff = function() {
        var _this = this;
        this.backoff.backoffAndRun(function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            var transaction, userPromise;
            var _this2 = this;
            return tslib.__generator(this, function(_d) {
              transaction = new Transaction$3(this.datastore);
              userPromise = this.tryRunUpdateFunction(transaction);
              if (userPromise) {
                userPromise.then(function(result) {
                  _this2.asyncQueue.enqueueAndForget(function() {
                    return transaction.commit().then(function() {
                      _this2.deferred.resolve(result);
                    }).catch(function(commitError) {
                      _this2.handleTransactionError(commitError);
                    });
                  });
                }).catch(function(userPromiseError) {
                  _this2.handleTransactionError(userPromiseError);
                });
              }
              return [2];
            });
          });
        });
      };
      TransactionRunner2.prototype.tryRunUpdateFunction = function(transaction) {
        try {
          var userPromise = this.updateFunction(transaction);
          if (isNullOrUndefined(userPromise) || !userPromise.catch || !userPromise.then) {
            this.deferred.reject(Error("Transaction callback must return a Promise"));
            return null;
          }
          return userPromise;
        } catch (error3) {
          this.deferred.reject(error3);
          return null;
        }
      };
      TransactionRunner2.prototype.handleTransactionError = function(error3) {
        var _this = this;
        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error3)) {
          this.attemptsRemaining -= 1;
          this.asyncQueue.enqueueAndForget(function() {
            _this.runWithBackOff();
            return Promise.resolve();
          });
        } else {
          this.deferred.reject(error3);
        }
      };
      TransactionRunner2.prototype.isRetryableTransactionError = function(error3) {
        if (error3.name === "FirebaseError") {
          var code = error3.code;
          return code === "aborted" || code === "failed-precondition" || !isPermanentError(code);
        }
        return false;
      };
      return TransactionRunner2;
    }();
    var LOG_TAG$2 = "FirestoreClient";
    var MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;
    var FirestoreClient = function() {
      function FirestoreClient2(credentials, asyncQueue, databaseInfo) {
        var _this = this;
        this.credentials = credentials;
        this.asyncQueue = asyncQueue;
        this.databaseInfo = databaseInfo;
        this.user = User.UNAUTHENTICATED;
        this.clientId = AutoId.newId();
        this.credentialListener = function() {
          return Promise.resolve();
        };
        this.credentials.setChangeListener(asyncQueue, function(user) {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  logDebug(LOG_TAG$2, "Received user=", user.uid);
                  return [4, this.credentialListener(user)];
                case 1:
                  _d.sent();
                  this.user = user;
                  return [2];
              }
            });
          });
        });
      }
      FirestoreClient2.prototype.getConfiguration = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            return [2, {
              asyncQueue: this.asyncQueue,
              databaseInfo: this.databaseInfo,
              clientId: this.clientId,
              credentials: this.credentials,
              initialUser: this.user,
              maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS
            }];
          });
        });
      };
      FirestoreClient2.prototype.setCredentialChangeListener = function(listener) {
        this.credentialListener = listener;
      };
      FirestoreClient2.prototype.verifyNotTerminated = function() {
        if (this.asyncQueue.isShuttingDown) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "The client has already been terminated.");
        }
      };
      FirestoreClient2.prototype.terminate = function() {
        var _this = this;
        this.asyncQueue.enterRestrictedMode();
        var deferred = new Deferred();
        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            var e_11, firestoreError;
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  _d.trys.push([0, 5, , 6]);
                  if (!this.onlineComponents)
                    return [3, 2];
                  return [4, this.onlineComponents.terminate()];
                case 1:
                  _d.sent();
                  _d.label = 2;
                case 2:
                  if (!this.offlineComponents)
                    return [3, 4];
                  return [4, this.offlineComponents.terminate()];
                case 3:
                  _d.sent();
                  _d.label = 4;
                case 4:
                  this.credentials.removeChangeListener();
                  deferred.resolve();
                  return [3, 6];
                case 5:
                  e_11 = _d.sent();
                  firestoreError = wrapInUserErrorIfRecoverable(e_11, "Failed to shutdown persistence");
                  deferred.reject(firestoreError);
                  return [3, 6];
                case 6:
                  return [2];
              }
            });
          });
        });
        return deferred.promise;
      };
      return FirestoreClient2;
    }();
    function setOfflineComponentProvider(client, offlineComponentProvider) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var configuration, currentUser;
        var _this = this;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              client.asyncQueue.verifyOperationInProgress();
              logDebug(LOG_TAG$2, "Initializing OfflineComponentProvider");
              return [4, client.getConfiguration()];
            case 1:
              configuration = _d.sent();
              return [4, offlineComponentProvider.initialize(configuration)];
            case 2:
              _d.sent();
              currentUser = configuration.initialUser;
              client.setCredentialChangeListener(function(user) {
                return tslib.__awaiter(_this, void 0, void 0, function() {
                  return tslib.__generator(this, function(_d2) {
                    switch (_d2.label) {
                      case 0:
                        if (!!currentUser.isEqual(user))
                          return [3, 2];
                        return [4, localStoreHandleUserChange(offlineComponentProvider.localStore, user)];
                      case 1:
                        _d2.sent();
                        currentUser = user;
                        _d2.label = 2;
                      case 2:
                        return [2];
                    }
                  });
                });
              });
              offlineComponentProvider.persistence.setDatabaseDeletedListener(function() {
                return client.terminate();
              });
              client.offlineComponents = offlineComponentProvider;
              return [2];
          }
        });
      });
    }
    function setOnlineComponentProvider(client, onlineComponentProvider) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var offlineComponentProvider, configuration;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              client.asyncQueue.verifyOperationInProgress();
              return [4, ensureOfflineComponents(client)];
            case 1:
              offlineComponentProvider = _d.sent();
              logDebug(LOG_TAG$2, "Initializing OnlineComponentProvider");
              return [4, client.getConfiguration()];
            case 2:
              configuration = _d.sent();
              return [4, onlineComponentProvider.initialize(offlineComponentProvider, configuration)];
            case 3:
              _d.sent();
              client.setCredentialChangeListener(function(user) {
                return remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user);
              });
              client.onlineComponents = onlineComponentProvider;
              return [2];
          }
        });
      });
    }
    function ensureOfflineComponents(client) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!!client.offlineComponents)
                return [3, 2];
              logDebug(LOG_TAG$2, "Using default OfflineComponentProvider");
              return [4, setOfflineComponentProvider(client, new MemoryOfflineComponentProvider())];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              return [2, client.offlineComponents];
          }
        });
      });
    }
    function ensureOnlineComponents(client) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!!client.onlineComponents)
                return [3, 2];
              logDebug(LOG_TAG$2, "Using default OnlineComponentProvider");
              return [4, setOnlineComponentProvider(client, new OnlineComponentProvider())];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              return [2, client.onlineComponents];
          }
        });
      });
    }
    function getPersistence(client) {
      return ensureOfflineComponents(client).then(function(c) {
        return c.persistence;
      });
    }
    function getLocalStore(client) {
      return ensureOfflineComponents(client).then(function(c) {
        return c.localStore;
      });
    }
    function getRemoteStore(client) {
      return ensureOnlineComponents(client).then(function(c) {
        return c.remoteStore;
      });
    }
    function getSyncEngine(client) {
      return ensureOnlineComponents(client).then(function(c) {
        return c.syncEngine;
      });
    }
    function getDatastore(client) {
      return ensureOnlineComponents(client).then(function(c) {
        return c.datastore;
      });
    }
    function getEventManager(client) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var onlineComponentProvider, eventManager;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, ensureOnlineComponents(client)];
            case 1:
              onlineComponentProvider = _d.sent();
              eventManager = onlineComponentProvider.eventManager;
              eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);
              eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);
              return [2, eventManager];
          }
        });
      });
    }
    function firestoreClientEnableNetwork(client) {
      var _this = this;
      return client.asyncQueue.enqueue(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var persistence, remoteStore;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getPersistence(client)];
              case 1:
                persistence = _d.sent();
                return [4, getRemoteStore(client)];
              case 2:
                remoteStore = _d.sent();
                persistence.setNetworkEnabled(true);
                return [2, remoteStoreEnableNetwork(remoteStore)];
            }
          });
        });
      });
    }
    function firestoreClientDisableNetwork(client) {
      var _this = this;
      return client.asyncQueue.enqueue(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var persistence, remoteStore;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getPersistence(client)];
              case 1:
                persistence = _d.sent();
                return [4, getRemoteStore(client)];
              case 2:
                remoteStore = _d.sent();
                persistence.setNetworkEnabled(false);
                return [2, remoteStoreDisableNetwork(remoteStore)];
            }
          });
        });
      });
    }
    function firestoreClientWaitForPendingWrites(client) {
      var _this = this;
      var deferred = new Deferred();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var syncEngine;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getSyncEngine(client)];
              case 1:
                syncEngine = _d.sent();
                return [2, syncEngineRegisterPendingWritesCallback(syncEngine, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientListen(client, query2, options2, observer) {
      var _this = this;
      var wrappedObserver = new AsyncObserver(observer);
      var listener = new QueryListener(query2, wrappedObserver, options2);
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, eventManagerListen(eventManager, listener)];
            }
          });
        });
      });
      return function() {
        wrappedObserver.mute();
        client.asyncQueue.enqueueAndForget(function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            var eventManager;
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  return [4, getEventManager(client)];
                case 1:
                  eventManager = _d.sent();
                  return [2, eventManagerUnlisten(eventManager, listener)];
              }
            });
          });
        });
      };
    }
    function firestoreClientGetDocumentFromLocalCache(client, docKey) {
      var _this = this;
      var deferred = new Deferred();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var localStore;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getLocalStore(client)];
              case 1:
                localStore = _d.sent();
                return [2, readDocumentFromCache(localStore, docKey, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientGetDocumentViaSnapshotListener(client, key, options2) {
      var _this = this;
      if (options2 === void 0) {
        options2 = {};
      }
      var deferred = new Deferred();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options2, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientGetDocumentsFromLocalCache(client, query2) {
      var _this = this;
      var deferred = new Deferred();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var localStore;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getLocalStore(client)];
              case 1:
                localStore = _d.sent();
                return [2, executeQueryFromCache(localStore, query2, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientGetDocumentsViaSnapshotListener(client, query2, options2) {
      var _this = this;
      if (options2 === void 0) {
        options2 = {};
      }
      var deferred = new Deferred();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query2, options2, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientWrite(client, mutations) {
      var _this = this;
      var deferred = new Deferred();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var syncEngine;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getSyncEngine(client)];
              case 1:
                syncEngine = _d.sent();
                return [2, syncEngineWrite(syncEngine, mutations, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientAddSnapshotsInSyncListener(client, observer) {
      var _this = this;
      var wrappedObserver = new AsyncObserver(observer);
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, addSnapshotsInSyncListener(eventManager, wrappedObserver)];
            }
          });
        });
      });
      return function() {
        wrappedObserver.mute();
        client.asyncQueue.enqueueAndForget(function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            var eventManager;
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  return [4, getEventManager(client)];
                case 1:
                  eventManager = _d.sent();
                  return [2, removeSnapshotsInSyncListener(eventManager, wrappedObserver)];
              }
            });
          });
        });
      };
    }
    function firestoreClientTransaction(client, updateFunction) {
      var _this = this;
      var deferred = new Deferred();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var datastore;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getDatastore(client)];
              case 1:
                datastore = _d.sent();
                new TransactionRunner(client.asyncQueue, datastore, updateFunction, deferred).run();
                return [2];
            }
          });
        });
      });
      return deferred.promise;
    }
    function readDocumentFromCache(localStore, docKey, result) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var document_4, e_12, firestoreError;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 2, , 3]);
              return [4, localStoreReadDocument(localStore, docKey)];
            case 1:
              document_4 = _d.sent();
              if (document_4.isFoundDocument()) {
                result.resolve(document_4);
              } else if (document_4.isNoDocument()) {
                result.resolve(null);
              } else {
                result.reject(new FirestoreError(Code.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
              }
              return [3, 3];
            case 2:
              e_12 = _d.sent();
              firestoreError = wrapInUserErrorIfRecoverable(e_12, "Failed to get document '" + docKey + " from cache");
              result.reject(firestoreError);
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    }
    function readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options2, result) {
      var wrappedObserver = new AsyncObserver({
        next: function(snap) {
          asyncQueue.enqueueAndForget(function() {
            return eventManagerUnlisten(eventManager, listener);
          });
          var exists = snap.docs.has(key);
          if (!exists && snap.fromCache) {
            result.reject(new FirestoreError(Code.UNAVAILABLE, "Failed to get document because the client is offline."));
          } else if (exists && snap.fromCache && options2 && options2.source === "server") {
            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)'));
          } else {
            result.resolve(snap);
          }
        },
        error: function(e) {
          return result.reject(e);
        }
      });
      var listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {
        includeMetadataChanges: true,
        waitForSyncWhenOnline: true
      });
      return eventManagerListen(eventManager, listener);
    }
    function executeQueryFromCache(localStore, query2, result) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var queryResult, view, viewDocChanges, viewChange, e_13, firestoreError;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 2, , 3]);
              return [4, localStoreExecuteQuery(localStore, query2, true)];
            case 1:
              queryResult = _d.sent();
              view = new View(query2, queryResult.remoteKeys);
              viewDocChanges = view.computeDocChanges(queryResult.documents);
              viewChange = view.applyChanges(viewDocChanges, false);
              result.resolve(viewChange.snapshot);
              return [3, 3];
            case 2:
              e_13 = _d.sent();
              firestoreError = wrapInUserErrorIfRecoverable(e_13, "Failed to execute query '" + query2 + " against cache");
              result.reject(firestoreError);
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    }
    function executeQueryViaSnapshotListener(eventManager, asyncQueue, query2, options2, result) {
      var wrappedObserver = new AsyncObserver({
        next: function(snapshot) {
          asyncQueue.enqueueAndForget(function() {
            return eventManagerUnlisten(eventManager, listener);
          });
          if (snapshot.fromCache && options2.source === "server") {
            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)'));
          } else {
            result.resolve(snapshot);
          }
        },
        error: function(e) {
          return result.reject(e);
        }
      });
      var listener = new QueryListener(query2, wrappedObserver, {
        includeMetadataChanges: true,
        waitForSyncWhenOnline: true
      });
      return eventManagerListen(eventManager, listener);
    }
    function firestoreClientLoadBundle(client, databaseId, data, resultTask) {
      var _this = this;
      var reader = createBundleReader(data, newSerializer(databaseId));
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var _d;
          return tslib.__generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                _d = syncEngineLoadBundle;
                return [4, getSyncEngine(client)];
              case 1:
                _d.apply(void 0, [_e.sent(), reader, resultTask]);
                return [2];
            }
          });
        });
      });
    }
    function firestoreClientGetNamedQuery(client, queryName) {
      var _this = this;
      return client.asyncQueue.enqueue(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var _d;
          return tslib.__generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                _d = localStoreGetNamedQuery;
                return [4, getLocalStore(client)];
              case 1:
                return [2, _d.apply(void 0, [_e.sent(), queryName])];
            }
          });
        });
      });
    }
    function createBundleReader(data, serializer) {
      var content;
      if (typeof data === "string") {
        content = newTextEncoder().encode(data);
      } else {
        content = data;
      }
      return newBundleReader(toByteStreamReader(content), serializer);
    }
    var DatabaseInfo = function() {
      function DatabaseInfo2(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, useFetchStreams) {
        this.databaseId = databaseId;
        this.appId = appId;
        this.persistenceKey = persistenceKey;
        this.host = host;
        this.ssl = ssl;
        this.forceLongPolling = forceLongPolling;
        this.autoDetectLongPolling = autoDetectLongPolling;
        this.useFetchStreams = useFetchStreams;
      }
      return DatabaseInfo2;
    }();
    var DEFAULT_DATABASE_NAME = "(default)";
    var DatabaseId = function() {
      function DatabaseId2(projectId, database) {
        this.projectId = projectId;
        this.database = database ? database : DEFAULT_DATABASE_NAME;
      }
      Object.defineProperty(DatabaseId2.prototype, "isDefaultDatabase", {
        get: function() {
          return this.database === DEFAULT_DATABASE_NAME;
        },
        enumerable: false,
        configurable: true
      });
      DatabaseId2.prototype.isEqual = function(other) {
        return other instanceof DatabaseId2 && other.projectId === this.projectId && other.database === this.database;
      };
      return DatabaseId2;
    }();
    var LOG_TAG$1 = "ComponentProvider";
    var datastoreInstances = new Map();
    function removeComponents(firestore) {
      var datastore = datastoreInstances.get(firestore);
      if (datastore) {
        logDebug(LOG_TAG$1, "Removing Datastore");
        datastoreInstances.delete(firestore);
        datastore.terminate();
      }
    }
    function makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {
      return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, settings.useFetchStreams);
    }
    var OAuthToken = function() {
      function OAuthToken2(value, user) {
        this.user = user;
        this.type = "OAuth";
        this.authHeaders = {};
        this.authHeaders["Authorization"] = "Bearer " + value;
      }
      return OAuthToken2;
    }();
    var EmptyCredentialsProvider = function() {
      function EmptyCredentialsProvider2() {
        this.changeListener = null;
      }
      EmptyCredentialsProvider2.prototype.getToken = function() {
        return Promise.resolve(null);
      };
      EmptyCredentialsProvider2.prototype.invalidateToken = function() {
      };
      EmptyCredentialsProvider2.prototype.setChangeListener = function(asyncQueue, changeListener) {
        this.changeListener = changeListener;
        asyncQueue.enqueueRetryable(function() {
          return changeListener(User.UNAUTHENTICATED);
        });
      };
      EmptyCredentialsProvider2.prototype.removeChangeListener = function() {
        this.changeListener = null;
      };
      return EmptyCredentialsProvider2;
    }();
    var EmulatorCredentialsProvider = function() {
      function EmulatorCredentialsProvider2(token) {
        this.token = token;
        this.changeListener = null;
      }
      EmulatorCredentialsProvider2.prototype.getToken = function() {
        return Promise.resolve(this.token);
      };
      EmulatorCredentialsProvider2.prototype.invalidateToken = function() {
      };
      EmulatorCredentialsProvider2.prototype.setChangeListener = function(asyncQueue, changeListener) {
        var _this = this;
        this.changeListener = changeListener;
        asyncQueue.enqueueRetryable(function() {
          return changeListener(_this.token.user);
        });
      };
      EmulatorCredentialsProvider2.prototype.removeChangeListener = function() {
        this.changeListener = null;
      };
      return EmulatorCredentialsProvider2;
    }();
    var FirebaseCredentialsProvider = function() {
      function FirebaseCredentialsProvider2(authProvider) {
        var _this = this;
        this.currentUser = User.UNAUTHENTICATED;
        this.authDeferred = new Deferred();
        this.tokenCounter = 0;
        this.forceRefresh = false;
        this.auth = null;
        this.asyncQueue = null;
        this.tokenListener = function() {
          _this.tokenCounter++;
          _this.currentUser = _this.getUser();
          _this.authDeferred.resolve();
          if (_this.changeListener) {
            _this.asyncQueue.enqueueRetryable(function() {
              return _this.changeListener(_this.currentUser);
            });
          }
        };
        var registerAuth = function(auth2) {
          logDebug("FirebaseCredentialsProvider", "Auth detected");
          _this.auth = auth2;
          _this.auth.addAuthTokenListener(_this.tokenListener);
        };
        authProvider.onInit(function(auth2) {
          return registerAuth(auth2);
        });
        setTimeout(function() {
          if (!_this.auth) {
            var auth2 = authProvider.getImmediate({ optional: true });
            if (auth2) {
              registerAuth(auth2);
            } else {
              logDebug("FirebaseCredentialsProvider", "Auth not yet detected");
              _this.authDeferred.resolve();
            }
          }
        }, 0);
      }
      FirebaseCredentialsProvider2.prototype.getToken = function() {
        var _this = this;
        var initialTokenCounter = this.tokenCounter;
        var forceRefresh = this.forceRefresh;
        this.forceRefresh = false;
        if (!this.auth) {
          return Promise.resolve(null);
        }
        return this.auth.getToken(forceRefresh).then(function(tokenData) {
          if (_this.tokenCounter !== initialTokenCounter) {
            logDebug("FirebaseCredentialsProvider", "getToken aborted due to token change.");
            return _this.getToken();
          } else {
            if (tokenData) {
              hardAssert(typeof tokenData.accessToken === "string");
              return new OAuthToken(tokenData.accessToken, _this.currentUser);
            } else {
              return null;
            }
          }
        });
      };
      FirebaseCredentialsProvider2.prototype.invalidateToken = function() {
        this.forceRefresh = true;
      };
      FirebaseCredentialsProvider2.prototype.setChangeListener = function(asyncQueue, changeListener) {
        var _this = this;
        this.asyncQueue = asyncQueue;
        this.asyncQueue.enqueueRetryable(function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  return [4, this.authDeferred.promise];
                case 1:
                  _d.sent();
                  return [4, changeListener(this.currentUser)];
                case 2:
                  _d.sent();
                  this.changeListener = changeListener;
                  return [2];
              }
            });
          });
        });
      };
      FirebaseCredentialsProvider2.prototype.removeChangeListener = function() {
        if (this.auth) {
          this.auth.removeAuthTokenListener(this.tokenListener);
        }
        this.changeListener = function() {
          return Promise.resolve();
        };
      };
      FirebaseCredentialsProvider2.prototype.getUser = function() {
        var currentUid = this.auth && this.auth.getUid();
        hardAssert(currentUid === null || typeof currentUid === "string");
        return new User(currentUid);
      };
      return FirebaseCredentialsProvider2;
    }();
    var FirstPartyToken = function() {
      function FirstPartyToken2(gapi, sessionIndex, iamToken) {
        this.gapi = gapi;
        this.sessionIndex = sessionIndex;
        this.iamToken = iamToken;
        this.type = "FirstParty";
        this.user = User.FIRST_PARTY;
      }
      Object.defineProperty(FirstPartyToken2.prototype, "authHeaders", {
        get: function() {
          var headers = {
            "X-Goog-AuthUser": this.sessionIndex
          };
          var authHeader = this.gapi["auth"]["getAuthHeaderValueForFirstParty"]([]);
          if (authHeader) {
            headers["Authorization"] = authHeader;
          }
          if (this.iamToken) {
            headers["X-Goog-Iam-Authorization-Token"] = this.iamToken;
          }
          return headers;
        },
        enumerable: false,
        configurable: true
      });
      return FirstPartyToken2;
    }();
    var FirstPartyCredentialsProvider = function() {
      function FirstPartyCredentialsProvider2(gapi, sessionIndex, iamToken) {
        this.gapi = gapi;
        this.sessionIndex = sessionIndex;
        this.iamToken = iamToken;
      }
      FirstPartyCredentialsProvider2.prototype.getToken = function() {
        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex, this.iamToken));
      };
      FirstPartyCredentialsProvider2.prototype.setChangeListener = function(asyncQueue, changeListener) {
        asyncQueue.enqueueRetryable(function() {
          return changeListener(User.FIRST_PARTY);
        });
      };
      FirstPartyCredentialsProvider2.prototype.removeChangeListener = function() {
      };
      FirstPartyCredentialsProvider2.prototype.invalidateToken = function() {
      };
      return FirstPartyCredentialsProvider2;
    }();
    function makeCredentialsProvider(credentials) {
      if (!credentials) {
        return new EmptyCredentialsProvider();
      }
      switch (credentials["type"]) {
        case "gapi":
          var client = credentials["client"];
          hardAssert(!!(typeof client === "object" && client !== null && client["auth"] && client["auth"]["getAuthHeaderValueForFirstParty"]));
          return new FirstPartyCredentialsProvider(client, credentials["sessionIndex"] || "0", credentials["iamToken"] || null);
        case "provider":
          return credentials["client"];
        default:
          throw new FirestoreError(Code.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
      }
    }
    var DEFAULT_HOST = "firestore.googleapis.com";
    var DEFAULT_SSL = true;
    var FirestoreSettingsImpl = function() {
      function FirestoreSettingsImpl2(settings) {
        var _a;
        if (settings.host === void 0) {
          if (settings.ssl !== void 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
          }
          this.host = DEFAULT_HOST;
          this.ssl = DEFAULT_SSL;
        } else {
          this.host = settings.host;
          this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;
        }
        this.credentials = settings.credentials;
        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;
        if (settings.cacheSizeBytes === void 0) {
          this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;
        } else {
          if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED && settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "cacheSizeBytes must be at least " + LRU_MINIMUM_CACHE_SIZE_BYTES);
          } else {
            this.cacheSizeBytes = settings.cacheSizeBytes;
          }
        }
        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;
        this.experimentalAutoDetectLongPolling = !!settings.experimentalAutoDetectLongPolling;
        this.useFetchStreams = !!settings.useFetchStreams;
        validateIsNotUsedTogether("experimentalForceLongPolling", settings.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", settings.experimentalAutoDetectLongPolling);
      }
      FirestoreSettingsImpl2.prototype.isEqual = function(other) {
        return this.host === other.host && this.ssl === other.ssl && this.credentials === other.credentials && this.cacheSizeBytes === other.cacheSizeBytes && this.experimentalForceLongPolling === other.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === other.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === other.ignoreUndefinedProperties && this.useFetchStreams === other.useFetchStreams;
      };
      return FirestoreSettingsImpl2;
    }();
    var Firestore$2 = function() {
      function Firestore$22(databaseIdOrApp, authProvider) {
        this.type = "firestore-lite";
        this._persistenceKey = "(lite)";
        this._settings = new FirestoreSettingsImpl({});
        this._settingsFrozen = false;
        if (databaseIdOrApp instanceof DatabaseId) {
          this._databaseId = databaseIdOrApp;
          this._credentials = new EmptyCredentialsProvider();
        } else {
          this._app = databaseIdOrApp;
          this._databaseId = databaseIdFromApp(databaseIdOrApp);
          this._credentials = new FirebaseCredentialsProvider(authProvider);
        }
      }
      Object.defineProperty(Firestore$22.prototype, "app", {
        get: function() {
          if (!this._app) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
          }
          return this._app;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Firestore$22.prototype, "_initialized", {
        get: function() {
          return this._settingsFrozen;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Firestore$22.prototype, "_terminated", {
        get: function() {
          return this._terminateTask !== void 0;
        },
        enumerable: false,
        configurable: true
      });
      Firestore$22.prototype._setSettings = function(settings) {
        if (this._settingsFrozen) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
        }
        this._settings = new FirestoreSettingsImpl(settings);
        if (settings.credentials !== void 0) {
          this._credentials = makeCredentialsProvider(settings.credentials);
        }
      };
      Firestore$22.prototype._getSettings = function() {
        return this._settings;
      };
      Firestore$22.prototype._freezeSettings = function() {
        this._settingsFrozen = true;
        return this._settings;
      };
      Firestore$22.prototype._delete = function() {
        if (!this._terminateTask) {
          this._terminateTask = this._terminate();
        }
        return this._terminateTask;
      };
      Firestore$22.prototype.toJSON = function() {
        return {
          app: this._app,
          databaseId: this._databaseId,
          settings: this._settings
        };
      };
      Firestore$22.prototype._terminate = function() {
        removeComponents(this);
        return Promise.resolve();
      };
      return Firestore$22;
    }();
    function databaseIdFromApp(app) {
      if (!Object.prototype.hasOwnProperty.apply(app.options, ["projectId"])) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      }
      return new DatabaseId(app.options.projectId);
    }
    function connectFirestoreEmulator(firestore, host, port, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      firestore = cast(firestore, Firestore$2);
      var settings = firestore._getSettings();
      if (settings.host !== DEFAULT_HOST && settings.host !== host) {
        logWarn("Host has been set in both settings() and useEmulator(), emulator host will be used");
      }
      firestore._setSettings(Object.assign(Object.assign({}, settings), { host: host + ":" + port, ssl: false }));
      if (options2.mockUserToken) {
        var token = util.createMockUserToken(options2.mockUserToken);
        var uid = options2.mockUserToken.sub || options2.mockUserToken.user_id;
        if (!uid) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
        }
        firestore._credentials = new EmulatorCredentialsProvider(new OAuthToken(token, new User(uid)));
      }
    }
    var DocumentReference$1 = function() {
      function DocumentReference$12(firestore, converter, _key) {
        this.converter = converter;
        this._key = _key;
        this.type = "document";
        this.firestore = firestore;
      }
      Object.defineProperty(DocumentReference$12.prototype, "_path", {
        get: function() {
          return this._key.path;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentReference$12.prototype, "id", {
        get: function() {
          return this._key.path.lastSegment();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentReference$12.prototype, "path", {
        get: function() {
          return this._key.path.canonicalString();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentReference$12.prototype, "parent", {
        get: function() {
          return new CollectionReference$1(this.firestore, this.converter, this._key.path.popLast());
        },
        enumerable: false,
        configurable: true
      });
      DocumentReference$12.prototype.withConverter = function(converter) {
        return new DocumentReference$12(this.firestore, converter, this._key);
      };
      return DocumentReference$12;
    }();
    var Query$1 = function() {
      function Query$12(firestore, converter, _query) {
        this.converter = converter;
        this._query = _query;
        this.type = "query";
        this.firestore = firestore;
      }
      Query$12.prototype.withConverter = function(converter) {
        return new Query$12(this.firestore, converter, this._query);
      };
      return Query$12;
    }();
    var CollectionReference$1 = function(_super) {
      tslib.__extends(CollectionReference$12, _super);
      function CollectionReference$12(firestore, converter, _path) {
        var _this = _super.call(this, firestore, converter, newQueryForPath(_path)) || this;
        _this._path = _path;
        _this.type = "collection";
        return _this;
      }
      Object.defineProperty(CollectionReference$12.prototype, "id", {
        get: function() {
          return this._query.path.lastSegment();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CollectionReference$12.prototype, "path", {
        get: function() {
          return this._query.path.canonicalString();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CollectionReference$12.prototype, "parent", {
        get: function() {
          var parentPath = this._path.popLast();
          if (parentPath.isEmpty()) {
            return null;
          } else {
            return new DocumentReference$1(this.firestore, null, new DocumentKey(parentPath));
          }
        },
        enumerable: false,
        configurable: true
      });
      CollectionReference$12.prototype.withConverter = function(converter) {
        return new CollectionReference$12(this.firestore, converter, this._path);
      };
      return CollectionReference$12;
    }(Query$1);
    function collection(parent, path2) {
      var pathSegments = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        pathSegments[_i - 2] = arguments[_i];
      }
      parent = util.getModularInstance(parent);
      validateNonEmptyArgument("collection", "path", path2);
      if (parent instanceof Firestore$2) {
        var absolutePath = ResourcePath.fromString.apply(ResourcePath, tslib.__spreadArray([path2], pathSegments));
        validateCollectionPath(absolutePath);
        return new CollectionReference$1(parent, null, absolutePath);
      } else {
        if (!(parent instanceof DocumentReference$1) && !(parent instanceof CollectionReference$1)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        }
        var absolutePath = ResourcePath.fromString.apply(ResourcePath, tslib.__spreadArray([parent.path], pathSegments)).child(ResourcePath.fromString(path2));
        validateCollectionPath(absolutePath);
        return new CollectionReference$1(parent.firestore, null, absolutePath);
      }
    }
    function collectionGroup(firestore, collectionId) {
      firestore = cast(firestore, Firestore$2);
      validateNonEmptyArgument("collectionGroup", "collection id", collectionId);
      if (collectionId.indexOf("/") >= 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid collection ID '" + collectionId + "' passed to function collectionGroup(). Collection IDs must not contain '/'.");
      }
      return new Query$1(firestore, null, newQueryForCollectionGroup(collectionId));
    }
    function doc(parent, path2) {
      var pathSegments = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        pathSegments[_i - 2] = arguments[_i];
      }
      parent = util.getModularInstance(parent);
      if (arguments.length === 1) {
        path2 = AutoId.newId();
      }
      validateNonEmptyArgument("doc", "path", path2);
      if (parent instanceof Firestore$2) {
        var absolutePath = ResourcePath.fromString.apply(ResourcePath, tslib.__spreadArray([path2], pathSegments));
        validateDocumentPath(absolutePath);
        return new DocumentReference$1(parent, null, new DocumentKey(absolutePath));
      } else {
        if (!(parent instanceof DocumentReference$1) && !(parent instanceof CollectionReference$1)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        }
        var absolutePath = parent._path.child(ResourcePath.fromString.apply(ResourcePath, tslib.__spreadArray([path2], pathSegments)));
        validateDocumentPath(absolutePath);
        return new DocumentReference$1(parent.firestore, parent instanceof CollectionReference$1 ? parent.converter : null, new DocumentKey(absolutePath));
      }
    }
    function refEqual(left, right) {
      left = util.getModularInstance(left);
      right = util.getModularInstance(right);
      if ((left instanceof DocumentReference$1 || left instanceof CollectionReference$1) && (right instanceof DocumentReference$1 || right instanceof CollectionReference$1)) {
        return left.firestore === right.firestore && left.path === right.path && left.converter === right.converter;
      }
      return false;
    }
    function queryEqual(left, right) {
      left = util.getModularInstance(left);
      right = util.getModularInstance(right);
      if (left instanceof Query$1 && right instanceof Query$1) {
        return left.firestore === right.firestore && queryEquals(left._query, right._query) && left.converter === right.converter;
      }
      return false;
    }
    var LOG_TAG = "AsyncQueue";
    var AsyncQueueImpl = function() {
      function AsyncQueueImpl2() {
        var _this = this;
        this.tail = Promise.resolve();
        this.retryableOps = [];
        this._isShuttingDown = false;
        this.delayedOperations = [];
        this.failure = null;
        this.operationInProgress = false;
        this.skipNonRestrictedTasks = false;
        this.timerIdsToSkip = [];
        this.backoff = new ExponentialBackoff(this, "async_queue_retry");
        this.visibilityHandler = function() {
          _this.backoff.skipBackoff();
        };
      }
      Object.defineProperty(AsyncQueueImpl2.prototype, "isShuttingDown", {
        get: function() {
          return this._isShuttingDown;
        },
        enumerable: false,
        configurable: true
      });
      AsyncQueueImpl2.prototype.enqueueAndForget = function(op) {
        this.enqueue(op);
      };
      AsyncQueueImpl2.prototype.enqueueAndForgetEvenWhileRestricted = function(op) {
        this.verifyNotFailed();
        this.enqueueInternal(op);
      };
      AsyncQueueImpl2.prototype.enterRestrictedMode = function(purgeExistingTasks) {
        if (!this._isShuttingDown) {
          this._isShuttingDown = true;
          this.skipNonRestrictedTasks = purgeExistingTasks || false;
        }
      };
      AsyncQueueImpl2.prototype.enqueue = function(op) {
        var _this = this;
        this.verifyNotFailed();
        if (this._isShuttingDown) {
          return new Promise(function() {
          });
        }
        var task = new Deferred();
        return this.enqueueInternal(function() {
          if (_this._isShuttingDown && _this.skipNonRestrictedTasks) {
            return Promise.resolve();
          }
          op().then(task.resolve, task.reject);
          return task.promise;
        }).then(function() {
          return task.promise;
        });
      };
      AsyncQueueImpl2.prototype.enqueueRetryable = function(op) {
        var _this = this;
        this.enqueueAndForget(function() {
          _this.retryableOps.push(op);
          return _this.retryNextOp();
        });
      };
      AsyncQueueImpl2.prototype.retryNextOp = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var e_14;
          var _this = this;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (this.retryableOps.length === 0) {
                  return [2];
                }
                _d.label = 1;
              case 1:
                _d.trys.push([1, 3, , 4]);
                return [4, this.retryableOps[0]()];
              case 2:
                _d.sent();
                this.retryableOps.shift();
                this.backoff.reset();
                return [3, 4];
              case 3:
                e_14 = _d.sent();
                if (isIndexedDbTransactionError(e_14)) {
                  logDebug(LOG_TAG, "Operation failed with retryable error: " + e_14);
                } else {
                  throw e_14;
                }
                return [3, 4];
              case 4:
                if (this.retryableOps.length > 0) {
                  this.backoff.backoffAndRun(function() {
                    return _this.retryNextOp();
                  });
                }
                return [2];
            }
          });
        });
      };
      AsyncQueueImpl2.prototype.enqueueInternal = function(op) {
        var _this = this;
        var newTail = this.tail.then(function() {
          _this.operationInProgress = true;
          return op().catch(function(error3) {
            _this.failure = error3;
            _this.operationInProgress = false;
            var message = getMessageOrStack(error3);
            logError("INTERNAL UNHANDLED ERROR: ", message);
            throw error3;
          }).then(function(result) {
            _this.operationInProgress = false;
            return result;
          });
        });
        this.tail = newTail;
        return newTail;
      };
      AsyncQueueImpl2.prototype.enqueueAfterDelay = function(timerId, delayMs, op) {
        var _this = this;
        this.verifyNotFailed();
        if (this.timerIdsToSkip.indexOf(timerId) > -1) {
          delayMs = 0;
        }
        var delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, function(removedOp) {
          return _this.removeDelayedOperation(removedOp);
        });
        this.delayedOperations.push(delayedOp);
        return delayedOp;
      };
      AsyncQueueImpl2.prototype.verifyNotFailed = function() {
        if (this.failure) {
          fail();
        }
      };
      AsyncQueueImpl2.prototype.verifyOperationInProgress = function() {
      };
      AsyncQueueImpl2.prototype.drain = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var currentTail;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                currentTail = this.tail;
                return [4, currentTail];
              case 1:
                _d.sent();
                _d.label = 2;
              case 2:
                if (currentTail !== this.tail)
                  return [3, 0];
                _d.label = 3;
              case 3:
                return [2];
            }
          });
        });
      };
      AsyncQueueImpl2.prototype.containsDelayedOperation = function(timerId) {
        for (var _i = 0, _d = this.delayedOperations; _i < _d.length; _i++) {
          var op = _d[_i];
          if (op.timerId === timerId) {
            return true;
          }
        }
        return false;
      };
      AsyncQueueImpl2.prototype.runAllDelayedOperationsUntil = function(lastTimerId) {
        var _this = this;
        return this.drain().then(function() {
          _this.delayedOperations.sort(function(a, b) {
            return a.targetTimeMs - b.targetTimeMs;
          });
          for (var _i = 0, _d = _this.delayedOperations; _i < _d.length; _i++) {
            var op = _d[_i];
            op.skipDelay();
            if (lastTimerId !== "all" && op.timerId === lastTimerId) {
              break;
            }
          }
          return _this.drain();
        });
      };
      AsyncQueueImpl2.prototype.skipDelaysForTimerId = function(timerId) {
        this.timerIdsToSkip.push(timerId);
      };
      AsyncQueueImpl2.prototype.removeDelayedOperation = function(op) {
        var index2 = this.delayedOperations.indexOf(op);
        this.delayedOperations.splice(index2, 1);
      };
      return AsyncQueueImpl2;
    }();
    function newAsyncQueue() {
      return new AsyncQueueImpl();
    }
    function getMessageOrStack(error3) {
      var message = error3.message || "";
      if (error3.stack) {
        if (error3.stack.includes(error3.message)) {
          message = error3.stack;
        } else {
          message = error3.message + "\n" + error3.stack;
        }
      }
      return message;
    }
    var LoadBundleTask = function() {
      function LoadBundleTask2() {
        this._progressObserver = {};
        this._taskCompletionResolver = new Deferred();
        this._lastProgress = {
          taskState: "Running",
          totalBytes: 0,
          totalDocuments: 0,
          bytesLoaded: 0,
          documentsLoaded: 0
        };
      }
      LoadBundleTask2.prototype.onProgress = function(next, error3, complete) {
        this._progressObserver = {
          next,
          error: error3,
          complete
        };
      };
      LoadBundleTask2.prototype.catch = function(onRejected) {
        return this._taskCompletionResolver.promise.catch(onRejected);
      };
      LoadBundleTask2.prototype.then = function(onFulfilled, onRejected) {
        return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);
      };
      LoadBundleTask2.prototype._completeWith = function(progress) {
        this._updateProgress(progress);
        if (this._progressObserver.complete) {
          this._progressObserver.complete();
        }
        this._taskCompletionResolver.resolve(progress);
      };
      LoadBundleTask2.prototype._failWith = function(error3) {
        this._lastProgress.taskState = "Error";
        if (this._progressObserver.next) {
          this._progressObserver.next(this._lastProgress);
        }
        if (this._progressObserver.error) {
          this._progressObserver.error(error3);
        }
        this._taskCompletionResolver.reject(error3);
      };
      LoadBundleTask2.prototype._updateProgress = function(progress) {
        this._lastProgress = progress;
        if (this._progressObserver.next) {
          this._progressObserver.next(progress);
        }
      };
      return LoadBundleTask2;
    }();
    var DOM_EXCEPTION_INVALID_STATE = 11;
    var DOM_EXCEPTION_ABORTED = 20;
    var DOM_EXCEPTION_QUOTA_EXCEEDED = 22;
    var CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;
    var Firestore$1 = function(_super) {
      tslib.__extends(Firestore$12, _super);
      function Firestore$12(databaseIdOrApp, authProvider) {
        var _this = _super.call(this, databaseIdOrApp, authProvider) || this;
        _this.type = "firestore";
        _this._queue = newAsyncQueue();
        _this._persistenceKey = "name" in databaseIdOrApp ? databaseIdOrApp.name : "[DEFAULT]";
        return _this;
      }
      Firestore$12.prototype._terminate = function() {
        if (!this._firestoreClient) {
          configureFirestore(this);
        }
        return this._firestoreClient.terminate();
      };
      return Firestore$12;
    }(Firestore$2);
    function ensureFirestoreConfigured(firestore) {
      if (!firestore._firestoreClient) {
        configureFirestore(firestore);
      }
      firestore._firestoreClient.verifyNotTerminated();
      return firestore._firestoreClient;
    }
    function configureFirestore(firestore) {
      var _a;
      var settings = firestore._freezeSettings();
      var databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || "", firestore._persistenceKey, settings);
      firestore._firestoreClient = new FirestoreClient(firestore._credentials, firestore._queue, databaseInfo);
    }
    function enableIndexedDbPersistence(firestore, persistenceSettings) {
      firestore = cast(firestore, Firestore$1);
      verifyNotInitialized(firestore);
      var client = ensureFirestoreConfigured(firestore);
      var settings = firestore._freezeSettings();
      var onlineComponentProvider = new OnlineComponentProvider();
      var offlineComponentProvider = new IndexedDbOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes, persistenceSettings === null || persistenceSettings === void 0 ? void 0 : persistenceSettings.forceOwnership);
      return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);
    }
    function enableMultiTabIndexedDbPersistence(firestore) {
      firestore = cast(firestore, Firestore$1);
      verifyNotInitialized(firestore);
      var client = ensureFirestoreConfigured(firestore);
      var settings = firestore._freezeSettings();
      var onlineComponentProvider = new OnlineComponentProvider();
      var offlineComponentProvider = new MultiTabOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes);
      return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);
    }
    function setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider) {
      var _this = this;
      var persistenceResult = new Deferred();
      return client.asyncQueue.enqueue(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var e_15;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                _d.trys.push([0, 3, , 4]);
                return [4, setOfflineComponentProvider(client, offlineComponentProvider)];
              case 1:
                _d.sent();
                return [4, setOnlineComponentProvider(client, onlineComponentProvider)];
              case 2:
                _d.sent();
                persistenceResult.resolve();
                return [3, 4];
              case 3:
                e_15 = _d.sent();
                if (!canFallbackFromIndexedDbError(e_15)) {
                  throw e_15;
                }
                console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + e_15);
                persistenceResult.reject(e_15);
                return [3, 4];
              case 4:
                return [2];
            }
          });
        });
      }).then(function() {
        return persistenceResult.promise;
      });
    }
    function canFallbackFromIndexedDbError(error3) {
      if (error3.name === "FirebaseError") {
        return error3.code === Code.FAILED_PRECONDITION || error3.code === Code.UNIMPLEMENTED;
      } else if (typeof DOMException !== "undefined" && error3 instanceof DOMException) {
        return error3.code === DOM_EXCEPTION_QUOTA_EXCEEDED || error3.code === DOM_EXCEPTION_ABORTED || error3.code === DOM_EXCEPTION_INVALID_STATE;
      }
      return true;
    }
    function clearIndexedDbPersistence(firestore) {
      var _this = this;
      if (firestore._initialized && !firestore._terminated) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
      }
      var deferred = new Deferred();
      firestore._queue.enqueueAndForgetEvenWhileRestricted(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var e_16;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                _d.trys.push([0, 2, , 3]);
                return [4, indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey))];
              case 1:
                _d.sent();
                deferred.resolve();
                return [3, 3];
              case 2:
                e_16 = _d.sent();
                deferred.reject(e_16);
                return [3, 3];
              case 3:
                return [2];
            }
          });
        });
      });
      return deferred.promise;
    }
    function waitForPendingWrites(firestore) {
      firestore = cast(firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientWaitForPendingWrites(client);
    }
    function enableNetwork(firestore) {
      firestore = cast(firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientEnableNetwork(client);
    }
    function disableNetwork(firestore) {
      firestore = cast(firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientDisableNetwork(client);
    }
    function loadBundle(firestore, bundleData) {
      firestore = cast(firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      var resultTask = new LoadBundleTask();
      firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);
      return resultTask;
    }
    function namedQuery(firestore, name) {
      firestore = cast(firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientGetNamedQuery(client, name).then(function(namedQuery2) {
        if (!namedQuery2) {
          return null;
        }
        return new Query$1(firestore, null, namedQuery2.query);
      });
    }
    function verifyNotInitialized(firestore) {
      if (firestore._initialized || firestore._terminated) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
      }
    }
    var FieldPath = function() {
      function FieldPath2() {
        var fieldNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fieldNames[_i] = arguments[_i];
        }
        for (var i = 0; i < fieldNames.length; ++i) {
          if (fieldNames[i].length === 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
          }
        }
        this._internalPath = new FieldPath$1(fieldNames);
      }
      FieldPath2.prototype.isEqual = function(other) {
        return this._internalPath.isEqual(other._internalPath);
      };
      return FieldPath2;
    }();
    var Bytes = function() {
      function Bytes2(byteString) {
        this._byteString = byteString;
      }
      Bytes2.fromBase64String = function(base64) {
        try {
          return new Bytes2(ByteString.fromBase64String(base64));
        } catch (e) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e);
        }
      };
      Bytes2.fromUint8Array = function(array) {
        return new Bytes2(ByteString.fromUint8Array(array));
      };
      Bytes2.prototype.toBase64 = function() {
        return this._byteString.toBase64();
      };
      Bytes2.prototype.toUint8Array = function() {
        return this._byteString.toUint8Array();
      };
      Bytes2.prototype.toString = function() {
        return "Bytes(base64: " + this.toBase64() + ")";
      };
      Bytes2.prototype.isEqual = function(other) {
        return this._byteString.isEqual(other._byteString);
      };
      return Bytes2;
    }();
    var FieldValue = function() {
      function FieldValue2(_methodName) {
        this._methodName = _methodName;
      }
      return FieldValue2;
    }();
    var GeoPoint = function() {
      function GeoPoint2(latitude, longitude) {
        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + latitude);
        }
        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + longitude);
        }
        this._lat = latitude;
        this._long = longitude;
      }
      Object.defineProperty(GeoPoint2.prototype, "latitude", {
        get: function() {
          return this._lat;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GeoPoint2.prototype, "longitude", {
        get: function() {
          return this._long;
        },
        enumerable: false,
        configurable: true
      });
      GeoPoint2.prototype.isEqual = function(other) {
        return this._lat === other._lat && this._long === other._long;
      };
      GeoPoint2.prototype.toJSON = function() {
        return { latitude: this._lat, longitude: this._long };
      };
      GeoPoint2.prototype._compareTo = function(other) {
        return primitiveComparator(this._lat, other._lat) || primitiveComparator(this._long, other._long);
      };
      return GeoPoint2;
    }();
    var RESERVED_FIELD_REGEX = /^__.*__$/;
    var ParsedSetData = function() {
      function ParsedSetData2(data, fieldMask, fieldTransforms) {
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
      }
      ParsedSetData2.prototype.toMutation = function(key, precondition) {
        if (this.fieldMask !== null) {
          return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
        } else {
          return new SetMutation(key, this.data, precondition, this.fieldTransforms);
        }
      };
      return ParsedSetData2;
    }();
    var ParsedUpdateData = function() {
      function ParsedUpdateData2(data, fieldMask, fieldTransforms) {
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
      }
      ParsedUpdateData2.prototype.toMutation = function(key, precondition) {
        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
      };
      return ParsedUpdateData2;
    }();
    function isWrite(dataSource) {
      switch (dataSource) {
        case 0:
        case 2:
        case 1:
          return true;
        case 3:
        case 4:
          return false;
        default:
          throw fail();
      }
    }
    var ParseContextImpl = function() {
      function ParseContextImpl2(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {
        this.settings = settings;
        this.databaseId = databaseId;
        this.serializer = serializer;
        this.ignoreUndefinedProperties = ignoreUndefinedProperties;
        if (fieldTransforms === void 0) {
          this.validatePath();
        }
        this.fieldTransforms = fieldTransforms || [];
        this.fieldMask = fieldMask || [];
      }
      Object.defineProperty(ParseContextImpl2.prototype, "path", {
        get: function() {
          return this.settings.path;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ParseContextImpl2.prototype, "dataSource", {
        get: function() {
          return this.settings.dataSource;
        },
        enumerable: false,
        configurable: true
      });
      ParseContextImpl2.prototype.contextWith = function(configuration) {
        return new ParseContextImpl2(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
      };
      ParseContextImpl2.prototype.childContextForField = function(field) {
        var _a;
        var childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
        var context = this.contextWith({ path: childPath, arrayElement: false });
        context.validatePathSegment(field);
        return context;
      };
      ParseContextImpl2.prototype.childContextForFieldPath = function(field) {
        var _a;
        var childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
        var context = this.contextWith({ path: childPath, arrayElement: false });
        context.validatePath();
        return context;
      };
      ParseContextImpl2.prototype.childContextForArray = function(index2) {
        return this.contextWith({ path: void 0, arrayElement: true });
      };
      ParseContextImpl2.prototype.createError = function(reason) {
        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);
      };
      ParseContextImpl2.prototype.contains = function(fieldPath) {
        return this.fieldMask.find(function(field) {
          return fieldPath.isPrefixOf(field);
        }) !== void 0 || this.fieldTransforms.find(function(transform) {
          return fieldPath.isPrefixOf(transform.field);
        }) !== void 0;
      };
      ParseContextImpl2.prototype.validatePath = function() {
        if (!this.path) {
          return;
        }
        for (var i = 0; i < this.path.length; i++) {
          this.validatePathSegment(this.path.get(i));
        }
      };
      ParseContextImpl2.prototype.validatePathSegment = function(segment) {
        if (segment.length === 0) {
          throw this.createError("Document fields must not be empty");
        }
        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {
          throw this.createError('Document fields cannot begin and end with "__"');
        }
      };
      return ParseContextImpl2;
    }();
    var UserDataReader = function() {
      function UserDataReader2(databaseId, ignoreUndefinedProperties, serializer) {
        this.databaseId = databaseId;
        this.ignoreUndefinedProperties = ignoreUndefinedProperties;
        this.serializer = serializer || newSerializer(databaseId);
      }
      UserDataReader2.prototype.createContext = function(dataSource, methodName, targetDoc, hasConverter) {
        if (hasConverter === void 0) {
          hasConverter = false;
        }
        return new ParseContextImpl({
          dataSource,
          methodName,
          targetDoc,
          path: FieldPath$1.emptyPath(),
          arrayElement: false,
          hasConverter
        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
      };
      return UserDataReader2;
    }();
    function newUserDataReader(firestore) {
      var settings = firestore._freezeSettings();
      var serializer = newSerializer(firestore._databaseId);
      return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);
    }
    function parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var context = userDataReader.createContext(options2.merge || options2.mergeFields ? 2 : 0, methodName, targetDoc, hasConverter);
      validatePlainObject("Data must be an object, but it was:", context, input);
      var updateData = parseObject(input, context);
      var fieldMask;
      var fieldTransforms;
      if (options2.merge) {
        fieldMask = new FieldMask(context.fieldMask);
        fieldTransforms = context.fieldTransforms;
      } else if (options2.mergeFields) {
        var validatedFieldPaths = [];
        for (var _i = 0, _d = options2.mergeFields; _i < _d.length; _i++) {
          var stringOrFieldPath = _d[_i];
          var fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);
          if (!context.contains(fieldPath)) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Field '" + fieldPath + "' is specified in your field mask but missing from your input data.");
          }
          if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {
            validatedFieldPaths.push(fieldPath);
          }
        }
        fieldMask = new FieldMask(validatedFieldPaths);
        fieldTransforms = context.fieldTransforms.filter(function(transform) {
          return fieldMask.covers(transform.field);
        });
      } else {
        fieldMask = null;
        fieldTransforms = context.fieldTransforms;
      }
      return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);
    }
    var DeleteFieldValueImpl = function(_super) {
      tslib.__extends(DeleteFieldValueImpl2, _super);
      function DeleteFieldValueImpl2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DeleteFieldValueImpl2.prototype._toFieldTransform = function(context) {
        if (context.dataSource === 2) {
          context.fieldMask.push(context.path);
        } else if (context.dataSource === 1) {
          throw context.createError(this._methodName + "() can only appear at the top level of your update data");
        } else {
          throw context.createError(this._methodName + "() cannot be used with set() unless you pass {merge:true}");
        }
        return null;
      };
      DeleteFieldValueImpl2.prototype.isEqual = function(other) {
        return other instanceof DeleteFieldValueImpl2;
      };
      return DeleteFieldValueImpl2;
    }(FieldValue);
    function createSentinelChildContext(fieldValue, context, arrayElement) {
      return new ParseContextImpl({
        dataSource: 3,
        targetDoc: context.settings.targetDoc,
        methodName: fieldValue._methodName,
        arrayElement
      }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);
    }
    var ServerTimestampFieldValueImpl = function(_super) {
      tslib.__extends(ServerTimestampFieldValueImpl2, _super);
      function ServerTimestampFieldValueImpl2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ServerTimestampFieldValueImpl2.prototype._toFieldTransform = function(context) {
        return new FieldTransform(context.path, new ServerTimestampTransform());
      };
      ServerTimestampFieldValueImpl2.prototype.isEqual = function(other) {
        return other instanceof ServerTimestampFieldValueImpl2;
      };
      return ServerTimestampFieldValueImpl2;
    }(FieldValue);
    var ArrayUnionFieldValueImpl = function(_super) {
      tslib.__extends(ArrayUnionFieldValueImpl2, _super);
      function ArrayUnionFieldValueImpl2(methodName, _elements) {
        var _this = _super.call(this, methodName) || this;
        _this._elements = _elements;
        return _this;
      }
      ArrayUnionFieldValueImpl2.prototype._toFieldTransform = function(context) {
        var parseContext = createSentinelChildContext(this, context, true);
        var parsedElements = this._elements.map(function(element) {
          return parseData(element, parseContext);
        });
        var arrayUnion = new ArrayUnionTransformOperation(parsedElements);
        return new FieldTransform(context.path, arrayUnion);
      };
      ArrayUnionFieldValueImpl2.prototype.isEqual = function(other) {
        return this === other;
      };
      return ArrayUnionFieldValueImpl2;
    }(FieldValue);
    var ArrayRemoveFieldValueImpl = function(_super) {
      tslib.__extends(ArrayRemoveFieldValueImpl2, _super);
      function ArrayRemoveFieldValueImpl2(methodName, _elements) {
        var _this = _super.call(this, methodName) || this;
        _this._elements = _elements;
        return _this;
      }
      ArrayRemoveFieldValueImpl2.prototype._toFieldTransform = function(context) {
        var parseContext = createSentinelChildContext(this, context, true);
        var parsedElements = this._elements.map(function(element) {
          return parseData(element, parseContext);
        });
        var arrayUnion = new ArrayRemoveTransformOperation(parsedElements);
        return new FieldTransform(context.path, arrayUnion);
      };
      ArrayRemoveFieldValueImpl2.prototype.isEqual = function(other) {
        return this === other;
      };
      return ArrayRemoveFieldValueImpl2;
    }(FieldValue);
    var NumericIncrementFieldValueImpl = function(_super) {
      tslib.__extends(NumericIncrementFieldValueImpl2, _super);
      function NumericIncrementFieldValueImpl2(methodName, _operand) {
        var _this = _super.call(this, methodName) || this;
        _this._operand = _operand;
        return _this;
      }
      NumericIncrementFieldValueImpl2.prototype._toFieldTransform = function(context) {
        var numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));
        return new FieldTransform(context.path, numericIncrement);
      };
      NumericIncrementFieldValueImpl2.prototype.isEqual = function(other) {
        return this === other;
      };
      return NumericIncrementFieldValueImpl2;
    }(FieldValue);
    function parseUpdateData(userDataReader, methodName, targetDoc, input) {
      var context = userDataReader.createContext(1, methodName, targetDoc);
      validatePlainObject("Data must be an object, but it was:", context, input);
      var fieldMaskPaths = [];
      var updateData = ObjectValue.empty();
      forEach(input, function(key, value) {
        var path2 = fieldPathFromDotSeparatedString(methodName, key, targetDoc);
        value = util.getModularInstance(value);
        var childContext = context.childContextForFieldPath(path2);
        if (value instanceof DeleteFieldValueImpl) {
          fieldMaskPaths.push(path2);
        } else {
          var parsedValue = parseData(value, childContext);
          if (parsedValue != null) {
            fieldMaskPaths.push(path2);
            updateData.set(path2, parsedValue);
          }
        }
      });
      var mask = new FieldMask(fieldMaskPaths);
      return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
    }
    function parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {
      var context = userDataReader.createContext(1, methodName, targetDoc);
      var keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];
      var values = [value];
      if (moreFieldsAndValues.length % 2 !== 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() needs to be called with an even number of arguments that alternate between field names and values.");
      }
      for (var i = 0; i < moreFieldsAndValues.length; i += 2) {
        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));
        values.push(moreFieldsAndValues[i + 1]);
      }
      var fieldMaskPaths = [];
      var updateData = ObjectValue.empty();
      for (var i = keys.length - 1; i >= 0; --i) {
        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {
          var path2 = keys[i];
          var value_1 = values[i];
          value_1 = util.getModularInstance(value_1);
          var childContext = context.childContextForFieldPath(path2);
          if (value_1 instanceof DeleteFieldValueImpl) {
            fieldMaskPaths.push(path2);
          } else {
            var parsedValue = parseData(value_1, childContext);
            if (parsedValue != null) {
              fieldMaskPaths.push(path2);
              updateData.set(path2, parsedValue);
            }
          }
        }
      }
      var mask = new FieldMask(fieldMaskPaths);
      return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
    }
    function parseQueryValue(userDataReader, methodName, input, allowArrays) {
      if (allowArrays === void 0) {
        allowArrays = false;
      }
      var context = userDataReader.createContext(allowArrays ? 4 : 3, methodName);
      var parsed = parseData(input, context);
      return parsed;
    }
    function parseData(input, context) {
      input = util.getModularInstance(input);
      if (looksLikeJsonObject(input)) {
        validatePlainObject("Unsupported field value:", context, input);
        return parseObject(input, context);
      } else if (input instanceof FieldValue) {
        parseSentinelFieldValue(input, context);
        return null;
      } else if (input === void 0 && context.ignoreUndefinedProperties) {
        return null;
      } else {
        if (context.path) {
          context.fieldMask.push(context.path);
        }
        if (input instanceof Array) {
          if (context.settings.arrayElement && context.dataSource !== 4) {
            throw context.createError("Nested arrays are not supported");
          }
          return parseArray(input, context);
        } else {
          return parseScalarValue(input, context);
        }
      }
    }
    function parseObject(obj, context) {
      var fields = {};
      if (isEmpty(obj)) {
        if (context.path && context.path.length > 0) {
          context.fieldMask.push(context.path);
        }
      } else {
        forEach(obj, function(key, val) {
          var parsedValue = parseData(val, context.childContextForField(key));
          if (parsedValue != null) {
            fields[key] = parsedValue;
          }
        });
      }
      return { mapValue: { fields } };
    }
    function parseArray(array, context) {
      var values = [];
      var entryIndex = 0;
      for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var entry = array_1[_i];
        var parsedEntry = parseData(entry, context.childContextForArray(entryIndex));
        if (parsedEntry == null) {
          parsedEntry = { nullValue: "NULL_VALUE" };
        }
        values.push(parsedEntry);
        entryIndex++;
      }
      return { arrayValue: { values } };
    }
    function parseSentinelFieldValue(value, context) {
      if (!isWrite(context.dataSource)) {
        throw context.createError(value._methodName + "() can only be used with update() and set()");
      }
      if (!context.path) {
        throw context.createError(value._methodName + "() is not currently supported inside arrays");
      }
      var fieldTransform = value._toFieldTransform(context);
      if (fieldTransform) {
        context.fieldTransforms.push(fieldTransform);
      }
    }
    function parseScalarValue(value, context) {
      value = util.getModularInstance(value);
      if (value === null) {
        return { nullValue: "NULL_VALUE" };
      } else if (typeof value === "number") {
        return toNumber(context.serializer, value);
      } else if (typeof value === "boolean") {
        return { booleanValue: value };
      } else if (typeof value === "string") {
        return { stringValue: value };
      } else if (value instanceof Date) {
        var timestamp = Timestamp.fromDate(value);
        return {
          timestampValue: toTimestamp(context.serializer, timestamp)
        };
      } else if (value instanceof Timestamp) {
        var timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1e3) * 1e3);
        return {
          timestampValue: toTimestamp(context.serializer, timestamp)
        };
      } else if (value instanceof GeoPoint) {
        return {
          geoPointValue: {
            latitude: value.latitude,
            longitude: value.longitude
          }
        };
      } else if (value instanceof Bytes) {
        return { bytesValue: toBytes(context.serializer, value._byteString) };
      } else if (value instanceof DocumentReference$1) {
        var thisDb = context.databaseId;
        var otherDb = value.firestore._databaseId;
        if (!otherDb.isEqual(thisDb)) {
          throw context.createError("Document reference is for database " + (otherDb.projectId + "/" + otherDb.database + " but should be ") + ("for database " + thisDb.projectId + "/" + thisDb.database));
        }
        return {
          referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)
        };
      } else {
        throw context.createError("Unsupported field value: " + valueDescription(value));
      }
    }
    function looksLikeJsonObject(input) {
      return typeof input === "object" && input !== null && !(input instanceof Array) && !(input instanceof Date) && !(input instanceof Timestamp) && !(input instanceof GeoPoint) && !(input instanceof Bytes) && !(input instanceof DocumentReference$1) && !(input instanceof FieldValue);
    }
    function validatePlainObject(message, context, input) {
      if (!looksLikeJsonObject(input) || !isPlainObject(input)) {
        var description = valueDescription(input);
        if (description === "an object") {
          throw context.createError(message + " a custom object");
        } else {
          throw context.createError(message + " " + description);
        }
      }
    }
    function fieldPathFromArgument$1(methodName, path2, targetDoc) {
      path2 = util.getModularInstance(path2);
      if (path2 instanceof FieldPath) {
        return path2._internalPath;
      } else if (typeof path2 === "string") {
        return fieldPathFromDotSeparatedString(methodName, path2);
      } else {
        var message = "Field path arguments must be of type string or FieldPath.";
        throw createError(message, methodName, false, void 0, targetDoc);
      }
    }
    var FIELD_PATH_RESERVED = new RegExp("[~\\*/\\[\\]]");
    function fieldPathFromDotSeparatedString(methodName, path2, targetDoc) {
      var found = path2.search(FIELD_PATH_RESERVED);
      if (found >= 0) {
        throw createError("Invalid field path (" + path2 + "). Paths must not contain '~', '*', '/', '[', or ']'", methodName, false, void 0, targetDoc);
      }
      try {
        return new (FieldPath.bind.apply(FieldPath, tslib.__spreadArray([void 0], path2.split("."))))()._internalPath;
      } catch (e) {
        throw createError("Invalid field path (" + path2 + "). Paths must not be empty, begin with '.', end with '.', or contain '..'", methodName, false, void 0, targetDoc);
      }
    }
    function createError(reason, methodName, hasConverter, path2, targetDoc) {
      var hasPath = path2 && !path2.isEmpty();
      var hasDocument = targetDoc !== void 0;
      var message = "Function " + methodName + "() called with invalid data";
      if (hasConverter) {
        message += " (via `toFirestore()`)";
      }
      message += ". ";
      var description = "";
      if (hasPath || hasDocument) {
        description += " (found";
        if (hasPath) {
          description += " in field " + path2;
        }
        if (hasDocument) {
          description += " in document " + targetDoc;
        }
        description += ")";
      }
      return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);
    }
    function fieldMaskContains(haystack, needle) {
      return haystack.some(function(v) {
        return v.isEqual(needle);
      });
    }
    var DocumentSnapshot$2 = function() {
      function DocumentSnapshot$22(_firestore, _userDataWriter, _key, _document, _converter) {
        this._firestore = _firestore;
        this._userDataWriter = _userDataWriter;
        this._key = _key;
        this._document = _document;
        this._converter = _converter;
      }
      Object.defineProperty(DocumentSnapshot$22.prototype, "id", {
        get: function() {
          return this._key.path.lastSegment();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentSnapshot$22.prototype, "ref", {
        get: function() {
          return new DocumentReference$1(this._firestore, this._converter, this._key);
        },
        enumerable: false,
        configurable: true
      });
      DocumentSnapshot$22.prototype.exists = function() {
        return this._document !== null;
      };
      DocumentSnapshot$22.prototype.data = function() {
        if (!this._document) {
          return void 0;
        } else if (this._converter) {
          var snapshot = new QueryDocumentSnapshot$2(this._firestore, this._userDataWriter, this._key, this._document, null);
          return this._converter.fromFirestore(snapshot);
        } else {
          return this._userDataWriter.convertValue(this._document.data.value);
        }
      };
      DocumentSnapshot$22.prototype.get = function(fieldPath) {
        if (this._document) {
          var value = this._document.data.field(fieldPathFromArgument("DocumentSnapshot.get", fieldPath));
          if (value !== null) {
            return this._userDataWriter.convertValue(value);
          }
        }
        return void 0;
      };
      return DocumentSnapshot$22;
    }();
    var QueryDocumentSnapshot$2 = function(_super) {
      tslib.__extends(QueryDocumentSnapshot$22, _super);
      function QueryDocumentSnapshot$22() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      QueryDocumentSnapshot$22.prototype.data = function() {
        return _super.prototype.data.call(this);
      };
      return QueryDocumentSnapshot$22;
    }(DocumentSnapshot$2);
    function fieldPathFromArgument(methodName, arg) {
      if (typeof arg === "string") {
        return fieldPathFromDotSeparatedString(methodName, arg);
      } else if (arg instanceof FieldPath) {
        return arg._internalPath;
      } else {
        return arg._delegate._internalPath;
      }
    }
    var SnapshotMetadata = function() {
      function SnapshotMetadata2(hasPendingWrites, fromCache) {
        this.hasPendingWrites = hasPendingWrites;
        this.fromCache = fromCache;
      }
      SnapshotMetadata2.prototype.isEqual = function(other) {
        return this.hasPendingWrites === other.hasPendingWrites && this.fromCache === other.fromCache;
      };
      return SnapshotMetadata2;
    }();
    var DocumentSnapshot$1 = function(_super) {
      tslib.__extends(DocumentSnapshot$12, _super);
      function DocumentSnapshot$12(_firestore, userDataWriter, key, document2, metadata, converter) {
        var _this = _super.call(this, _firestore, userDataWriter, key, document2, converter) || this;
        _this._firestore = _firestore;
        _this._firestoreImpl = _firestore;
        _this.metadata = metadata;
        return _this;
      }
      DocumentSnapshot$12.prototype.exists = function() {
        return _super.prototype.exists.call(this);
      };
      DocumentSnapshot$12.prototype.data = function(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        if (!this._document) {
          return void 0;
        } else if (this._converter) {
          var snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
          return this._converter.fromFirestore(snapshot, options2);
        } else {
          return this._userDataWriter.convertValue(this._document.data.value, options2.serverTimestamps);
        }
      };
      DocumentSnapshot$12.prototype.get = function(fieldPath, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        if (this._document) {
          var value = this._document.data.field(fieldPathFromArgument("DocumentSnapshot.get", fieldPath));
          if (value !== null) {
            return this._userDataWriter.convertValue(value, options2.serverTimestamps);
          }
        }
        return void 0;
      };
      return DocumentSnapshot$12;
    }(DocumentSnapshot$2);
    var QueryDocumentSnapshot$1 = function(_super) {
      tslib.__extends(QueryDocumentSnapshot$12, _super);
      function QueryDocumentSnapshot$12() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      QueryDocumentSnapshot$12.prototype.data = function(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        return _super.prototype.data.call(this, options2);
      };
      return QueryDocumentSnapshot$12;
    }(DocumentSnapshot$1);
    var QuerySnapshot$1 = function() {
      function QuerySnapshot$12(_firestore, _userDataWriter, query2, _snapshot) {
        this._firestore = _firestore;
        this._userDataWriter = _userDataWriter;
        this._snapshot = _snapshot;
        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);
        this.query = query2;
      }
      Object.defineProperty(QuerySnapshot$12.prototype, "docs", {
        get: function() {
          var result = [];
          this.forEach(function(doc2) {
            return result.push(doc2);
          });
          return result;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QuerySnapshot$12.prototype, "size", {
        get: function() {
          return this._snapshot.docs.size;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QuerySnapshot$12.prototype, "empty", {
        get: function() {
          return this.size === 0;
        },
        enumerable: false,
        configurable: true
      });
      QuerySnapshot$12.prototype.forEach = function(callback, thisArg) {
        var _this = this;
        this._snapshot.docs.forEach(function(doc2) {
          callback.call(thisArg, new QueryDocumentSnapshot$1(_this._firestore, _this._userDataWriter, doc2.key, doc2, new SnapshotMetadata(_this._snapshot.mutatedKeys.has(doc2.key), _this._snapshot.fromCache), _this.query.converter));
        });
      };
      QuerySnapshot$12.prototype.docChanges = function(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        var includeMetadataChanges = !!options2.includeMetadataChanges;
        if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
        }
        if (!this._cachedChanges || this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {
          this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);
          this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;
        }
        return this._cachedChanges;
      };
      return QuerySnapshot$12;
    }();
    function changesFromSnapshot(querySnapshot, includeMetadataChanges) {
      if (querySnapshot._snapshot.oldDocs.isEmpty()) {
        var index_1 = 0;
        return querySnapshot._snapshot.docChanges.map(function(change) {
          var doc2 = new QueryDocumentSnapshot$1(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);
          return {
            type: "added",
            doc: doc2,
            oldIndex: -1,
            newIndex: index_1++
          };
        });
      } else {
        var indexTracker_1 = querySnapshot._snapshot.oldDocs;
        return querySnapshot._snapshot.docChanges.filter(function(change) {
          return includeMetadataChanges || change.type !== 3;
        }).map(function(change) {
          var doc2 = new QueryDocumentSnapshot$1(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);
          var oldIndex = -1;
          var newIndex = -1;
          if (change.type !== 0) {
            oldIndex = indexTracker_1.indexOf(change.doc.key);
            indexTracker_1 = indexTracker_1.delete(change.doc.key);
          }
          if (change.type !== 1) {
            indexTracker_1 = indexTracker_1.add(change.doc);
            newIndex = indexTracker_1.indexOf(change.doc.key);
          }
          return {
            type: resultChangeType(change.type),
            doc: doc2,
            oldIndex,
            newIndex
          };
        });
      }
    }
    function resultChangeType(type) {
      switch (type) {
        case 0:
          return "added";
        case 2:
        case 3:
          return "modified";
        case 1:
          return "removed";
        default:
          return fail();
      }
    }
    function snapshotEqual(left, right) {
      if (left instanceof DocumentSnapshot$1 && right instanceof DocumentSnapshot$1) {
        return left._firestore === right._firestore && left._key.isEqual(right._key) && (left._document === null ? right._document === null : left._document.isEqual(right._document)) && left._converter === right._converter;
      } else if (left instanceof QuerySnapshot$1 && right instanceof QuerySnapshot$1) {
        return left._firestore === right._firestore && queryEqual(left.query, right.query) && left.metadata.isEqual(right.metadata) && left._snapshot.isEqual(right._snapshot);
      }
      return false;
    }
    function validateHasExplicitOrderByForLimitToLast(query2) {
      if (hasLimitToLast(query2) && query2.explicitOrderBy.length === 0) {
        throw new FirestoreError(Code.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
      }
    }
    var QueryConstraint = function() {
      function QueryConstraint2() {
      }
      return QueryConstraint2;
    }();
    function query(query2) {
      var queryConstraints = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        queryConstraints[_i - 1] = arguments[_i];
      }
      for (var _d = 0, queryConstraints_1 = queryConstraints; _d < queryConstraints_1.length; _d++) {
        var constraint = queryConstraints_1[_d];
        query2 = constraint._apply(query2);
      }
      return query2;
    }
    var QueryFilterConstraint = function(_super) {
      tslib.__extends(QueryFilterConstraint2, _super);
      function QueryFilterConstraint2(_field, _op, _value) {
        var _this = _super.call(this) || this;
        _this._field = _field;
        _this._op = _op;
        _this._value = _value;
        _this.type = "where";
        return _this;
      }
      QueryFilterConstraint2.prototype._apply = function(query2) {
        var reader = newUserDataReader(query2.firestore);
        var filter = newQueryFilter(query2._query, "where", reader, query2.firestore._databaseId, this._field, this._op, this._value);
        return new Query$1(query2.firestore, query2.converter, queryWithAddedFilter(query2._query, filter));
      };
      return QueryFilterConstraint2;
    }(QueryConstraint);
    function where(fieldPath, opStr, value) {
      var op = opStr;
      var field = fieldPathFromArgument("where", fieldPath);
      return new QueryFilterConstraint(field, op, value);
    }
    var QueryOrderByConstraint = function(_super) {
      tslib.__extends(QueryOrderByConstraint2, _super);
      function QueryOrderByConstraint2(_field, _direction) {
        var _this = _super.call(this) || this;
        _this._field = _field;
        _this._direction = _direction;
        _this.type = "orderBy";
        return _this;
      }
      QueryOrderByConstraint2.prototype._apply = function(query2) {
        var orderBy2 = newQueryOrderBy(query2._query, this._field, this._direction);
        return new Query$1(query2.firestore, query2.converter, queryWithAddedOrderBy(query2._query, orderBy2));
      };
      return QueryOrderByConstraint2;
    }(QueryConstraint);
    function orderBy(fieldPath, directionStr) {
      if (directionStr === void 0) {
        directionStr = "asc";
      }
      var direction = directionStr;
      var path2 = fieldPathFromArgument("orderBy", fieldPath);
      return new QueryOrderByConstraint(path2, direction);
    }
    var QueryLimitConstraint = function(_super) {
      tslib.__extends(QueryLimitConstraint2, _super);
      function QueryLimitConstraint2(type, _limit, _limitType) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this._limit = _limit;
        _this._limitType = _limitType;
        return _this;
      }
      QueryLimitConstraint2.prototype._apply = function(query2) {
        return new Query$1(query2.firestore, query2.converter, queryWithLimit(query2._query, this._limit, this._limitType));
      };
      return QueryLimitConstraint2;
    }(QueryConstraint);
    function limit(limit2) {
      validatePositiveNumber("limit", limit2);
      return new QueryLimitConstraint("limit", limit2, "F");
    }
    function limitToLast(limit2) {
      validatePositiveNumber("limitToLast", limit2);
      return new QueryLimitConstraint("limitToLast", limit2, "L");
    }
    var QueryStartAtConstraint = function(_super) {
      tslib.__extends(QueryStartAtConstraint2, _super);
      function QueryStartAtConstraint2(type, _docOrFields, _before) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this._docOrFields = _docOrFields;
        _this._before = _before;
        return _this;
      }
      QueryStartAtConstraint2.prototype._apply = function(query2) {
        var bound = newQueryBoundFromDocOrFields(query2, this.type, this._docOrFields, this._before);
        return new Query$1(query2.firestore, query2.converter, queryWithStartAt(query2._query, bound));
      };
      return QueryStartAtConstraint2;
    }(QueryConstraint);
    function startAt() {
      var docOrFields = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        docOrFields[_i] = arguments[_i];
      }
      return new QueryStartAtConstraint("startAt", docOrFields, true);
    }
    function startAfter() {
      var docOrFields = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        docOrFields[_i] = arguments[_i];
      }
      return new QueryStartAtConstraint("startAfter", docOrFields, false);
    }
    var QueryEndAtConstraint = function(_super) {
      tslib.__extends(QueryEndAtConstraint2, _super);
      function QueryEndAtConstraint2(type, _docOrFields, _before) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this._docOrFields = _docOrFields;
        _this._before = _before;
        return _this;
      }
      QueryEndAtConstraint2.prototype._apply = function(query2) {
        var bound = newQueryBoundFromDocOrFields(query2, this.type, this._docOrFields, this._before);
        return new Query$1(query2.firestore, query2.converter, queryWithEndAt(query2._query, bound));
      };
      return QueryEndAtConstraint2;
    }(QueryConstraint);
    function endBefore() {
      var docOrFields = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        docOrFields[_i] = arguments[_i];
      }
      return new QueryEndAtConstraint("endBefore", docOrFields, true);
    }
    function endAt() {
      var docOrFields = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        docOrFields[_i] = arguments[_i];
      }
      return new QueryEndAtConstraint("endAt", docOrFields, false);
    }
    function newQueryBoundFromDocOrFields(query2, methodName, docOrFields, before) {
      docOrFields[0] = util.getModularInstance(docOrFields[0]);
      if (docOrFields[0] instanceof DocumentSnapshot$2) {
        return newQueryBoundFromDocument(query2._query, query2.firestore._databaseId, methodName, docOrFields[0]._document, before);
      } else {
        var reader = newUserDataReader(query2.firestore);
        return newQueryBoundFromFields(query2._query, query2.firestore._databaseId, reader, methodName, docOrFields, before);
      }
    }
    function newQueryFilter(query2, methodName, dataReader, databaseId, fieldPath, op, value) {
      var fieldValue;
      if (fieldPath.isKeyField()) {
        if (op === "array-contains" || op === "array-contains-any") {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. You can't perform '" + op + "' queries on FieldPath.documentId().");
        } else if (op === "in" || op === "not-in") {
          validateDisjunctiveFilterElements(value, op);
          var referenceList = [];
          for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
            var arrayValue = value_2[_i];
            referenceList.push(parseDocumentIdValue(databaseId, query2, arrayValue));
          }
          fieldValue = { arrayValue: { values: referenceList } };
        } else {
          fieldValue = parseDocumentIdValue(databaseId, query2, value);
        }
      } else {
        if (op === "in" || op === "not-in" || op === "array-contains-any") {
          validateDisjunctiveFilterElements(value, op);
        }
        fieldValue = parseQueryValue(dataReader, methodName, value, op === "in" || op === "not-in");
      }
      var filter = FieldFilter.create(fieldPath, op, fieldValue);
      validateNewFilter(query2, filter);
      return filter;
    }
    function newQueryOrderBy(query2, fieldPath, direction) {
      if (query2.startAt !== null) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      }
      if (query2.endAt !== null) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      }
      var orderBy2 = new OrderBy(fieldPath, direction);
      validateNewOrderBy(query2, orderBy2);
      return orderBy2;
    }
    function newQueryBoundFromDocument(query2, databaseId, methodName, doc2, before) {
      if (!doc2) {
        throw new FirestoreError(Code.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for " + (methodName + "()."));
      }
      var components = [];
      for (var _i = 0, _d = queryOrderBy(query2); _i < _d.length; _i++) {
        var orderBy_5 = _d[_i];
        if (orderBy_5.field.isKeyField()) {
          components.push(refValue(databaseId, doc2.key));
        } else {
          var value = doc2.data.field(orderBy_5.field);
          if (isServerTimestamp(value)) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + orderBy_5.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          } else if (value !== null) {
            components.push(value);
          } else {
            var field = orderBy_5.field.canonicalString();
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a " + ("document for which the field '" + field + "' (used as the ") + "orderBy) does not exist.");
          }
        }
      }
      return new Bound(components, before);
    }
    function newQueryBoundFromFields(query2, databaseId, dataReader, methodName, values, before) {
      var orderBy2 = query2.explicitOrderBy;
      if (values.length > orderBy2.length) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "(). The number of arguments must be less than or equal to the number of orderBy() clauses");
      }
      var components = [];
      for (var i = 0; i < values.length; i++) {
        var rawValue = values[i];
        var orderByComponent = orderBy2[i];
        if (orderByComponent.field.isKeyField()) {
          if (typeof rawValue !== "string") {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in " + (methodName + "(), but got a " + typeof rawValue));
          }
          if (!isCollectionGroupQuery(query2) && rawValue.indexOf("/") !== -1) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection and ordering by FieldPath.documentId(), " + ("the value passed to " + methodName + "() must be a plain document ID, but ") + ("'" + rawValue + "' contains a slash."));
          }
          var path2 = query2.path.child(ResourcePath.fromString(rawValue));
          if (!DocumentKey.isDocumentKey(path2)) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection group and ordering by " + ("FieldPath.documentId(), the value passed to " + methodName + "() must result in a ") + ("valid document path, but '" + path2 + "' is not because it contains an odd number ") + "of segments.");
          }
          var key = new DocumentKey(path2);
          components.push(refValue(databaseId, key));
        } else {
          var wrapped = parseQueryValue(dataReader, methodName, rawValue);
          components.push(wrapped);
        }
      }
      return new Bound(components, before);
    }
    function parseDocumentIdValue(databaseId, query2, documentIdValue) {
      documentIdValue = util.getModularInstance(documentIdValue);
      if (typeof documentIdValue === "string") {
        if (documentIdValue === "") {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
        }
        if (!isCollectionGroupQuery(query2) && documentIdValue.indexOf("/") !== -1) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but " + ("'" + documentIdValue + "' contains a '/' character."));
        }
        var path2 = query2.path.child(ResourcePath.fromString(documentIdValue));
        if (!DocumentKey.isDocumentKey(path2)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, " + ("but '" + path2 + "' is not because it has an odd number of segments (" + path2.length + ")."));
        }
        return refValue(databaseId, new DocumentKey(path2));
      } else if (documentIdValue instanceof DocumentReference$1) {
        return refValue(databaseId, documentIdValue._key);
      } else {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: " + (valueDescription(documentIdValue) + "."));
      }
    }
    function validateDisjunctiveFilterElements(value, operator) {
      if (!Array.isArray(value) || value.length === 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. A non-empty array is required for " + ("'" + operator.toString() + "' filters."));
      }
      if (value.length > 10) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. '" + operator.toString() + "' filters support a maximum of 10 elements in the value array.");
      }
    }
    function conflictingOps(op) {
      switch (op) {
        case "!=":
          return ["!=", "not-in"];
        case "array-contains":
          return [
            "array-contains",
            "array-contains-any",
            "not-in"
          ];
        case "in":
          return ["array-contains-any", "in", "not-in"];
        case "array-contains-any":
          return [
            "array-contains",
            "array-contains-any",
            "in",
            "not-in"
          ];
        case "not-in":
          return [
            "array-contains",
            "array-contains-any",
            "in",
            "not-in",
            "!="
          ];
        default:
          return [];
      }
    }
    function validateNewFilter(query2, filter) {
      if (filter.isInequality()) {
        var existingField = getInequalityFilterField(query2);
        if (existingField !== null && !existingField.isEqual(filter.field)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have" + (" inequality filters on '" + existingField.toString() + "'") + (" and '" + filter.field.toString() + "'"));
        }
        var firstOrderByField = getFirstOrderByField(query2);
        if (firstOrderByField !== null) {
          validateOrderByAndInequalityMatch(query2, filter.field, firstOrderByField);
        }
      }
      var conflictingOp = findFilterOperator(query2, conflictingOps(filter.op));
      if (conflictingOp !== null) {
        if (conflictingOp === filter.op) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You cannot use more than one " + ("'" + filter.op.toString() + "' filter."));
        } else {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You cannot use '" + filter.op.toString() + "' filters " + ("with '" + conflictingOp.toString() + "' filters."));
        }
      }
    }
    function validateNewOrderBy(query2, orderBy2) {
      if (getFirstOrderByField(query2) === null) {
        var inequalityField = getInequalityFilterField(query2);
        if (inequalityField !== null) {
          validateOrderByAndInequalityMatch(query2, inequalityField, orderBy2.field);
        }
      }
    }
    function validateOrderByAndInequalityMatch(baseQuery, inequality, orderBy2) {
      if (!orderBy2.isEqual(inequality)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality " + ("(<, <=, !=, not-in, >, or >=) on field '" + inequality.toString() + "' ") + ("and so you must also use '" + inequality.toString() + "' ") + "as your first argument to orderBy(), but your first orderBy() " + ("is on field '" + orderBy2.toString() + "' instead."));
      }
    }
    var AbstractUserDataWriter = function() {
      function AbstractUserDataWriter2() {
      }
      AbstractUserDataWriter2.prototype.convertValue = function(value, serverTimestampBehavior) {
        if (serverTimestampBehavior === void 0) {
          serverTimestampBehavior = "none";
        }
        switch (typeOrder(value)) {
          case 0:
            return null;
          case 1:
            return value.booleanValue;
          case 2:
            return normalizeNumber(value.integerValue || value.doubleValue);
          case 3:
            return this.convertTimestamp(value.timestampValue);
          case 4:
            return this.convertServerTimestamp(value, serverTimestampBehavior);
          case 5:
            return value.stringValue;
          case 6:
            return this.convertBytes(normalizeByteString(value.bytesValue));
          case 7:
            return this.convertReference(value.referenceValue);
          case 8:
            return this.convertGeoPoint(value.geoPointValue);
          case 9:
            return this.convertArray(value.arrayValue, serverTimestampBehavior);
          case 10:
            return this.convertObject(value.mapValue, serverTimestampBehavior);
          default:
            throw fail();
        }
      };
      AbstractUserDataWriter2.prototype.convertObject = function(mapValue, serverTimestampBehavior) {
        var _this = this;
        var result = {};
        forEach(mapValue.fields, function(key, value) {
          result[key] = _this.convertValue(value, serverTimestampBehavior);
        });
        return result;
      };
      AbstractUserDataWriter2.prototype.convertGeoPoint = function(value) {
        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));
      };
      AbstractUserDataWriter2.prototype.convertArray = function(arrayValue, serverTimestampBehavior) {
        var _this = this;
        return (arrayValue.values || []).map(function(value) {
          return _this.convertValue(value, serverTimestampBehavior);
        });
      };
      AbstractUserDataWriter2.prototype.convertServerTimestamp = function(value, serverTimestampBehavior) {
        switch (serverTimestampBehavior) {
          case "previous":
            var previousValue = getPreviousValue(value);
            if (previousValue == null) {
              return null;
            }
            return this.convertValue(previousValue, serverTimestampBehavior);
          case "estimate":
            return this.convertTimestamp(getLocalWriteTime(value));
          default:
            return null;
        }
      };
      AbstractUserDataWriter2.prototype.convertTimestamp = function(value) {
        var normalizedValue = normalizeTimestamp(value);
        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);
      };
      AbstractUserDataWriter2.prototype.convertDocumentKey = function(name, expectedDatabaseId) {
        var resourcePath = ResourcePath.fromString(name);
        hardAssert(isValidResourceName(resourcePath));
        var databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));
        var key = new DocumentKey(resourcePath.popFirst(5));
        if (!databaseId.isEqual(expectedDatabaseId)) {
          logError("Document " + key + " contains a document reference within a different database (" + (databaseId.projectId + "/" + databaseId.database + ") which is not ") + "supported. It will be treated as a reference in the current " + ("database (" + expectedDatabaseId.projectId + "/" + expectedDatabaseId.database + ") ") + "instead.");
        }
        return key;
      };
      return AbstractUserDataWriter2;
    }();
    function applyFirestoreDataConverter(converter, value, options2) {
      var convertedValue;
      if (converter) {
        if (options2 && (options2.merge || options2.mergeFields)) {
          convertedValue = converter.toFirestore(value, options2);
        } else {
          convertedValue = converter.toFirestore(value);
        }
      } else {
        convertedValue = value;
      }
      return convertedValue;
    }
    var LiteUserDataWriter = function(_super) {
      tslib.__extends(LiteUserDataWriter2, _super);
      function LiteUserDataWriter2(firestore) {
        var _this = _super.call(this) || this;
        _this.firestore = firestore;
        return _this;
      }
      LiteUserDataWriter2.prototype.convertBytes = function(bytes) {
        return new Bytes(bytes);
      };
      LiteUserDataWriter2.prototype.convertReference = function(name) {
        var key = this.convertDocumentKey(name, this.firestore._databaseId);
        return new DocumentReference$1(this.firestore, null, key);
      };
      return LiteUserDataWriter2;
    }(AbstractUserDataWriter);
    var WriteBatch$1 = function() {
      function WriteBatch$12(_firestore, _commitHandler) {
        this._firestore = _firestore;
        this._commitHandler = _commitHandler;
        this._mutations = [];
        this._committed = false;
        this._dataReader = newUserDataReader(_firestore);
      }
      WriteBatch$12.prototype.set = function(documentRef, data, options2) {
        this._verifyNotCommitted();
        var ref = validateReference(documentRef, this._firestore);
        var convertedValue = applyFirestoreDataConverter(ref.converter, data, options2);
        var parsed = parseSetData(this._dataReader, "WriteBatch.set", ref._key, convertedValue, ref.converter !== null, options2);
        this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));
        return this;
      };
      WriteBatch$12.prototype.update = function(documentRef, fieldOrUpdateData, value) {
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          moreFieldsAndValues[_i - 3] = arguments[_i];
        }
        this._verifyNotCommitted();
        var ref = validateReference(documentRef, this._firestore);
        fieldOrUpdateData = util.getModularInstance(fieldOrUpdateData);
        var parsed;
        if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath) {
          parsed = parseUpdateVarargs(this._dataReader, "WriteBatch.update", ref._key, fieldOrUpdateData, value, moreFieldsAndValues);
        } else {
          parsed = parseUpdateData(this._dataReader, "WriteBatch.update", ref._key, fieldOrUpdateData);
        }
        this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));
        return this;
      };
      WriteBatch$12.prototype.delete = function(documentRef) {
        this._verifyNotCommitted();
        var ref = validateReference(documentRef, this._firestore);
        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));
        return this;
      };
      WriteBatch$12.prototype.commit = function() {
        this._verifyNotCommitted();
        this._committed = true;
        if (this._mutations.length > 0) {
          return this._commitHandler(this._mutations);
        }
        return Promise.resolve();
      };
      WriteBatch$12.prototype._verifyNotCommitted = function() {
        if (this._committed) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
        }
      };
      return WriteBatch$12;
    }();
    function validateReference(documentRef, firestore) {
      documentRef = util.getModularInstance(documentRef);
      if (documentRef.firestore !== firestore) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
      } else {
        return documentRef;
      }
    }
    var Transaction$2 = function() {
      function Transaction$22(_firestore, _transaction) {
        this._firestore = _firestore;
        this._transaction = _transaction;
        this._dataReader = newUserDataReader(_firestore);
      }
      Transaction$22.prototype.get = function(documentRef) {
        var _this = this;
        var ref = validateReference(documentRef, this._firestore);
        var userDataWriter = new LiteUserDataWriter(this._firestore);
        return this._transaction.lookup([ref._key]).then(function(docs) {
          if (!docs || docs.length !== 1) {
            return fail();
          }
          var doc2 = docs[0];
          if (doc2.isFoundDocument()) {
            return new DocumentSnapshot$2(_this._firestore, userDataWriter, doc2.key, doc2, ref.converter);
          } else if (doc2.isNoDocument()) {
            return new DocumentSnapshot$2(_this._firestore, userDataWriter, ref._key, null, ref.converter);
          } else {
            throw fail();
          }
        });
      };
      Transaction$22.prototype.set = function(documentRef, value, options2) {
        var ref = validateReference(documentRef, this._firestore);
        var convertedValue = applyFirestoreDataConverter(ref.converter, value, options2);
        var parsed = parseSetData(this._dataReader, "Transaction.set", ref._key, convertedValue, ref.converter !== null, options2);
        this._transaction.set(ref._key, parsed);
        return this;
      };
      Transaction$22.prototype.update = function(documentRef, fieldOrUpdateData, value) {
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          moreFieldsAndValues[_i - 3] = arguments[_i];
        }
        var ref = validateReference(documentRef, this._firestore);
        fieldOrUpdateData = util.getModularInstance(fieldOrUpdateData);
        var parsed;
        if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath) {
          parsed = parseUpdateVarargs(this._dataReader, "Transaction.update", ref._key, fieldOrUpdateData, value, moreFieldsAndValues);
        } else {
          parsed = parseUpdateData(this._dataReader, "Transaction.update", ref._key, fieldOrUpdateData);
        }
        this._transaction.update(ref._key, parsed);
        return this;
      };
      Transaction$22.prototype.delete = function(documentRef) {
        var ref = validateReference(documentRef, this._firestore);
        this._transaction.delete(ref._key);
        return this;
      };
      return Transaction$22;
    }();
    function isPartialObserver(obj) {
      return implementsAnyMethods(obj, ["next", "error", "complete"]);
    }
    function implementsAnyMethods(obj, methods) {
      if (typeof obj !== "object" || obj === null) {
        return false;
      }
      var object = obj;
      for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in object && typeof object[method] === "function") {
          return true;
        }
      }
      return false;
    }
    function getDoc(reference) {
      reference = cast(reference, DocumentReference$1);
      var firestore = cast(reference.firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientGetDocumentViaSnapshotListener(client, reference._key).then(function(snapshot) {
        return convertToDocSnapshot(firestore, reference, snapshot);
      });
    }
    var ExpUserDataWriter = function(_super) {
      tslib.__extends(ExpUserDataWriter2, _super);
      function ExpUserDataWriter2(firestore) {
        var _this = _super.call(this) || this;
        _this.firestore = firestore;
        return _this;
      }
      ExpUserDataWriter2.prototype.convertBytes = function(bytes) {
        return new Bytes(bytes);
      };
      ExpUserDataWriter2.prototype.convertReference = function(name) {
        var key = this.convertDocumentKey(name, this.firestore._databaseId);
        return new DocumentReference$1(this.firestore, null, key);
      };
      return ExpUserDataWriter2;
    }(AbstractUserDataWriter);
    function getDocFromCache(reference) {
      reference = cast(reference, DocumentReference$1);
      var firestore = cast(reference.firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      var userDataWriter = new ExpUserDataWriter(firestore);
      return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(function(doc2) {
        return new DocumentSnapshot$1(firestore, userDataWriter, reference._key, doc2, new SnapshotMetadata(doc2 !== null && doc2.hasLocalMutations, true), reference.converter);
      });
    }
    function getDocFromServer(reference) {
      reference = cast(reference, DocumentReference$1);
      var firestore = cast(reference.firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {
        source: "server"
      }).then(function(snapshot) {
        return convertToDocSnapshot(firestore, reference, snapshot);
      });
    }
    function getDocs(query2) {
      query2 = cast(query2, Query$1);
      var firestore = cast(query2.firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      var userDataWriter = new ExpUserDataWriter(firestore);
      validateHasExplicitOrderByForLimitToLast(query2._query);
      return firestoreClientGetDocumentsViaSnapshotListener(client, query2._query).then(function(snapshot) {
        return new QuerySnapshot$1(firestore, userDataWriter, query2, snapshot);
      });
    }
    function getDocsFromCache(query2) {
      query2 = cast(query2, Query$1);
      var firestore = cast(query2.firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      var userDataWriter = new ExpUserDataWriter(firestore);
      return firestoreClientGetDocumentsFromLocalCache(client, query2._query).then(function(snapshot) {
        return new QuerySnapshot$1(firestore, userDataWriter, query2, snapshot);
      });
    }
    function getDocsFromServer(query2) {
      query2 = cast(query2, Query$1);
      var firestore = cast(query2.firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      var userDataWriter = new ExpUserDataWriter(firestore);
      return firestoreClientGetDocumentsViaSnapshotListener(client, query2._query, {
        source: "server"
      }).then(function(snapshot) {
        return new QuerySnapshot$1(firestore, userDataWriter, query2, snapshot);
      });
    }
    function setDoc(reference, data, options2) {
      reference = cast(reference, DocumentReference$1);
      var firestore = cast(reference.firestore, Firestore$1);
      var convertedValue = applyFirestoreDataConverter(reference.converter, data, options2);
      var dataReader = newUserDataReader(firestore);
      var parsed = parseSetData(dataReader, "setDoc", reference._key, convertedValue, reference.converter !== null, options2);
      var mutation = parsed.toMutation(reference._key, Precondition.none());
      return executeWrite(firestore, [mutation]);
    }
    function updateDoc(reference, fieldOrUpdateData, value) {
      var moreFieldsAndValues = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        moreFieldsAndValues[_i - 3] = arguments[_i];
      }
      reference = cast(reference, DocumentReference$1);
      var firestore = cast(reference.firestore, Firestore$1);
      var dataReader = newUserDataReader(firestore);
      fieldOrUpdateData = util.getModularInstance(fieldOrUpdateData);
      var parsed;
      if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath) {
        parsed = parseUpdateVarargs(dataReader, "updateDoc", reference._key, fieldOrUpdateData, value, moreFieldsAndValues);
      } else {
        parsed = parseUpdateData(dataReader, "updateDoc", reference._key, fieldOrUpdateData);
      }
      var mutation = parsed.toMutation(reference._key, Precondition.exists(true));
      return executeWrite(firestore, [mutation]);
    }
    function deleteDoc(reference) {
      var firestore = cast(reference.firestore, Firestore$1);
      var mutations = [new DeleteMutation(reference._key, Precondition.none())];
      return executeWrite(firestore, mutations);
    }
    function addDoc(reference, data) {
      var firestore = cast(reference.firestore, Firestore$1);
      var docRef = doc(reference);
      var convertedValue = applyFirestoreDataConverter(reference.converter, data);
      var dataReader = newUserDataReader(reference.firestore);
      var parsed = parseSetData(dataReader, "addDoc", docRef._key, convertedValue, reference.converter !== null, {});
      var mutation = parsed.toMutation(docRef._key, Precondition.exists(false));
      return executeWrite(firestore, [mutation]).then(function() {
        return docRef;
      });
    }
    function onSnapshot(reference) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var _a, _b, _c;
      reference = util.getModularInstance(reference);
      var options2 = {
        includeMetadataChanges: false
      };
      var currArg = 0;
      if (typeof args[currArg] === "object" && !isPartialObserver(args[currArg])) {
        options2 = args[currArg];
        currArg++;
      }
      var internalOptions = {
        includeMetadataChanges: options2.includeMetadataChanges
      };
      if (isPartialObserver(args[currArg])) {
        var userObserver = args[currArg];
        args[currArg] = (_a = userObserver.next) === null || _a === void 0 ? void 0 : _a.bind(userObserver);
        args[currArg + 1] = (_b = userObserver.error) === null || _b === void 0 ? void 0 : _b.bind(userObserver);
        args[currArg + 2] = (_c = userObserver.complete) === null || _c === void 0 ? void 0 : _c.bind(userObserver);
      }
      var observer;
      var firestore;
      var internalQuery;
      if (reference instanceof DocumentReference$1) {
        firestore = cast(reference.firestore, Firestore$1);
        internalQuery = newQueryForPath(reference._key.path);
        observer = {
          next: function(snapshot) {
            if (args[currArg]) {
              args[currArg](convertToDocSnapshot(firestore, reference, snapshot));
            }
          },
          error: args[currArg + 1],
          complete: args[currArg + 2]
        };
      } else {
        var query_5 = cast(reference, Query$1);
        firestore = cast(query_5.firestore, Firestore$1);
        internalQuery = query_5._query;
        var userDataWriter_1 = new ExpUserDataWriter(firestore);
        observer = {
          next: function(snapshot) {
            if (args[currArg]) {
              args[currArg](new QuerySnapshot$1(firestore, userDataWriter_1, query_5, snapshot));
            }
          },
          error: args[currArg + 1],
          complete: args[currArg + 2]
        };
        validateHasExplicitOrderByForLimitToLast(reference._query);
      }
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientListen(client, internalQuery, internalOptions, observer);
    }
    function onSnapshotsInSync(firestore, arg) {
      firestore = cast(firestore, Firestore$1);
      var client = ensureFirestoreConfigured(firestore);
      var observer = isPartialObserver(arg) ? arg : {
        next: arg
      };
      return firestoreClientAddSnapshotsInSyncListener(client, observer);
    }
    function executeWrite(firestore, mutations) {
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientWrite(client, mutations);
    }
    function convertToDocSnapshot(firestore, ref, snapshot) {
      var doc2 = snapshot.docs.get(ref._key);
      var userDataWriter = new ExpUserDataWriter(firestore);
      return new DocumentSnapshot$1(firestore, userDataWriter, ref._key, doc2, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref.converter);
    }
    var Transaction$1 = function(_super) {
      tslib.__extends(Transaction$12, _super);
      function Transaction$12(_firestore, _transaction) {
        var _this = _super.call(this, _firestore, _transaction) || this;
        _this._firestore = _firestore;
        return _this;
      }
      Transaction$12.prototype.get = function(documentRef) {
        var _this = this;
        var ref = validateReference(documentRef, this._firestore);
        var userDataWriter = new ExpUserDataWriter(this._firestore);
        return _super.prototype.get.call(this, documentRef).then(function(liteDocumentSnapshot) {
          return new DocumentSnapshot$1(_this._firestore, userDataWriter, ref._key, liteDocumentSnapshot._document, new SnapshotMetadata(false, false), ref.converter);
        });
      };
      return Transaction$12;
    }(Transaction$2);
    function runTransaction(firestore, updateFunction) {
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientTransaction(client, function(internalTransaction) {
        return updateFunction(new Transaction$1(firestore, internalTransaction));
      });
    }
    function assertUint8ArrayAvailable() {
      if (typeof Uint8Array === "undefined") {
        throw new FirestoreError(Code.UNIMPLEMENTED, "Uint8Arrays are not available in this environment.");
      }
    }
    var Blob3 = function() {
      function Blob4(_delegate) {
        this._delegate = _delegate;
      }
      Blob4.fromBase64String = function(base64) {
        return new Blob4(Bytes.fromBase64String(base64));
      };
      Blob4.fromUint8Array = function(array) {
        assertUint8ArrayAvailable();
        return new Blob4(Bytes.fromUint8Array(array));
      };
      Blob4.prototype.toBase64 = function() {
        return this._delegate.toBase64();
      };
      Blob4.prototype.toUint8Array = function() {
        assertUint8ArrayAvailable();
        return this._delegate.toUint8Array();
      };
      Blob4.prototype.isEqual = function(other) {
        return this._delegate.isEqual(other._delegate);
      };
      Blob4.prototype.toString = function() {
        return "Blob(base64: " + this.toBase64() + ")";
      };
      return Blob4;
    }();
    var IndexedDbPersistenceProvider = function() {
      function IndexedDbPersistenceProvider2() {
      }
      IndexedDbPersistenceProvider2.prototype.enableIndexedDbPersistence = function(firestore, forceOwnership) {
        return enableIndexedDbPersistence(firestore._delegate, { forceOwnership });
      };
      IndexedDbPersistenceProvider2.prototype.enableMultiTabIndexedDbPersistence = function(firestore) {
        return enableMultiTabIndexedDbPersistence(firestore._delegate);
      };
      IndexedDbPersistenceProvider2.prototype.clearIndexedDbPersistence = function(firestore) {
        return clearIndexedDbPersistence(firestore._delegate);
      };
      return IndexedDbPersistenceProvider2;
    }();
    var Firestore = function() {
      function Firestore2(databaseIdOrApp, _delegate, _persistenceProvider) {
        var _this = this;
        this._delegate = _delegate;
        this._persistenceProvider = _persistenceProvider;
        this.INTERNAL = {
          delete: function() {
            return _this.terminate();
          }
        };
        if (!(databaseIdOrApp instanceof DatabaseId)) {
          this._appCompat = databaseIdOrApp;
        }
      }
      Object.defineProperty(Firestore2.prototype, "_databaseId", {
        get: function() {
          return this._delegate._databaseId;
        },
        enumerable: false,
        configurable: true
      });
      Firestore2.prototype.settings = function(settingsLiteral) {
        var currentSettings = this._delegate._getSettings();
        if (!settingsLiteral.merge && currentSettings.host !== settingsLiteral.host) {
          logWarn("You are overriding the original host. If you did not intend to override your settings, use {merge: true}.");
        }
        if (settingsLiteral.merge) {
          settingsLiteral = Object.assign(Object.assign({}, currentSettings), settingsLiteral);
          delete settingsLiteral.merge;
        }
        this._delegate._setSettings(settingsLiteral);
      };
      Firestore2.prototype.useEmulator = function(host, port, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        connectFirestoreEmulator(this._delegate, host, port, options2);
      };
      Firestore2.prototype.enableNetwork = function() {
        return enableNetwork(this._delegate);
      };
      Firestore2.prototype.disableNetwork = function() {
        return disableNetwork(this._delegate);
      };
      Firestore2.prototype.enablePersistence = function(settings) {
        var synchronizeTabs = false;
        var experimentalForceOwningTab = false;
        if (settings) {
          synchronizeTabs = !!settings.synchronizeTabs;
          experimentalForceOwningTab = !!settings.experimentalForceOwningTab;
          validateIsNotUsedTogether("synchronizeTabs", synchronizeTabs, "experimentalForceOwningTab", experimentalForceOwningTab);
        }
        return synchronizeTabs ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, experimentalForceOwningTab);
      };
      Firestore2.prototype.clearPersistence = function() {
        return this._persistenceProvider.clearIndexedDbPersistence(this);
      };
      Firestore2.prototype.terminate = function() {
        if (this._appCompat) {
          this._appCompat._removeServiceInstance("firestore");
          this._appCompat._removeServiceInstance("firestore-exp");
        }
        return this._delegate._delete();
      };
      Firestore2.prototype.waitForPendingWrites = function() {
        return waitForPendingWrites(this._delegate);
      };
      Firestore2.prototype.onSnapshotsInSync = function(arg) {
        return onSnapshotsInSync(this._delegate, arg);
      };
      Object.defineProperty(Firestore2.prototype, "app", {
        get: function() {
          if (!this._appCompat) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
          }
          return this._appCompat;
        },
        enumerable: false,
        configurable: true
      });
      Firestore2.prototype.collection = function(pathString) {
        try {
          return new CollectionReference(this, collection(this._delegate, pathString));
        } catch (e) {
          throw replaceFunctionName(e, "collection()", "Firestore.collection()");
        }
      };
      Firestore2.prototype.doc = function(pathString) {
        try {
          return new DocumentReference(this, doc(this._delegate, pathString));
        } catch (e) {
          throw replaceFunctionName(e, "doc()", "Firestore.doc()");
        }
      };
      Firestore2.prototype.collectionGroup = function(collectionId) {
        try {
          return new Query(this, collectionGroup(this._delegate, collectionId));
        } catch (e) {
          throw replaceFunctionName(e, "collectionGroup()", "Firestore.collectionGroup()");
        }
      };
      Firestore2.prototype.runTransaction = function(updateFunction) {
        var _this = this;
        return runTransaction(this._delegate, function(transaction) {
          return updateFunction(new Transaction(_this, transaction));
        });
      };
      Firestore2.prototype.batch = function() {
        var _this = this;
        ensureFirestoreConfigured(this._delegate);
        return new WriteBatch(new WriteBatch$1(this._delegate, function(mutations) {
          return executeWrite(_this._delegate, mutations);
        }));
      };
      Firestore2.prototype.loadBundle = function(bundleData) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, '"loadBundle()" does not exist, have you imported "firebase/firestore/bundle"?');
      };
      Firestore2.prototype.namedQuery = function(name) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, '"namedQuery()" does not exist, have you imported "firebase/firestore/bundle"?');
      };
      return Firestore2;
    }();
    var UserDataWriter = function(_super) {
      tslib.__extends(UserDataWriter2, _super);
      function UserDataWriter2(firestore) {
        var _this = _super.call(this) || this;
        _this.firestore = firestore;
        return _this;
      }
      UserDataWriter2.prototype.convertBytes = function(bytes) {
        return new Blob3(new Bytes(bytes));
      };
      UserDataWriter2.prototype.convertReference = function(name) {
        var key = this.convertDocumentKey(name, this.firestore._databaseId);
        return DocumentReference.forKey(key, this.firestore, null);
      };
      return UserDataWriter2;
    }(AbstractUserDataWriter);
    function setLogLevel(level) {
      setLogLevel$1(level);
    }
    var Transaction = function() {
      function Transaction2(_firestore, _delegate) {
        this._firestore = _firestore;
        this._delegate = _delegate;
        this._userDataWriter = new UserDataWriter(_firestore);
      }
      Transaction2.prototype.get = function(documentRef) {
        var _this = this;
        var ref = castReference(documentRef);
        return this._delegate.get(ref).then(function(result) {
          return new DocumentSnapshot(_this._firestore, new DocumentSnapshot$1(_this._firestore._delegate, _this._userDataWriter, result._key, result._document, result.metadata, ref.converter));
        });
      };
      Transaction2.prototype.set = function(documentRef, data, options2) {
        var ref = castReference(documentRef);
        if (options2) {
          validateSetOptions("Transaction.set", options2);
          this._delegate.set(ref, data, options2);
        } else {
          this._delegate.set(ref, data);
        }
        return this;
      };
      Transaction2.prototype.update = function(documentRef, dataOrField, value) {
        var _d;
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          moreFieldsAndValues[_i - 3] = arguments[_i];
        }
        var ref = castReference(documentRef);
        if (arguments.length === 2) {
          this._delegate.update(ref, dataOrField);
        } else {
          (_d = this._delegate).update.apply(_d, tslib.__spreadArray([ref, dataOrField, value], moreFieldsAndValues));
        }
        return this;
      };
      Transaction2.prototype.delete = function(documentRef) {
        var ref = castReference(documentRef);
        this._delegate.delete(ref);
        return this;
      };
      return Transaction2;
    }();
    var WriteBatch = function() {
      function WriteBatch2(_delegate) {
        this._delegate = _delegate;
      }
      WriteBatch2.prototype.set = function(documentRef, data, options2) {
        var ref = castReference(documentRef);
        if (options2) {
          validateSetOptions("WriteBatch.set", options2);
          this._delegate.set(ref, data, options2);
        } else {
          this._delegate.set(ref, data);
        }
        return this;
      };
      WriteBatch2.prototype.update = function(documentRef, dataOrField, value) {
        var _d;
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          moreFieldsAndValues[_i - 3] = arguments[_i];
        }
        var ref = castReference(documentRef);
        if (arguments.length === 2) {
          this._delegate.update(ref, dataOrField);
        } else {
          (_d = this._delegate).update.apply(_d, tslib.__spreadArray([ref, dataOrField, value], moreFieldsAndValues));
        }
        return this;
      };
      WriteBatch2.prototype.delete = function(documentRef) {
        var ref = castReference(documentRef);
        this._delegate.delete(ref);
        return this;
      };
      WriteBatch2.prototype.commit = function() {
        return this._delegate.commit();
      };
      return WriteBatch2;
    }();
    var FirestoreDataConverter = function() {
      function FirestoreDataConverter2(_firestore, _userDataWriter, _delegate) {
        this._firestore = _firestore;
        this._userDataWriter = _userDataWriter;
        this._delegate = _delegate;
      }
      FirestoreDataConverter2.prototype.fromFirestore = function(snapshot, options2) {
        var expSnapshot = new QueryDocumentSnapshot$1(this._firestore._delegate, this._userDataWriter, snapshot._key, snapshot._document, snapshot.metadata, null);
        return this._delegate.fromFirestore(new QueryDocumentSnapshot(this._firestore, expSnapshot), options2 !== null && options2 !== void 0 ? options2 : {});
      };
      FirestoreDataConverter2.prototype.toFirestore = function(modelObject, options2) {
        if (!options2) {
          return this._delegate.toFirestore(modelObject);
        } else {
          return this._delegate.toFirestore(modelObject, options2);
        }
      };
      FirestoreDataConverter2.getInstance = function(firestore, converter) {
        var converterMapByFirestore = FirestoreDataConverter2.INSTANCES;
        var untypedConverterByConverter = converterMapByFirestore.get(firestore);
        if (!untypedConverterByConverter) {
          untypedConverterByConverter = new WeakMap();
          converterMapByFirestore.set(firestore, untypedConverterByConverter);
        }
        var instance = untypedConverterByConverter.get(converter);
        if (!instance) {
          instance = new FirestoreDataConverter2(firestore, new UserDataWriter(firestore), converter);
          untypedConverterByConverter.set(converter, instance);
        }
        return instance;
      };
      return FirestoreDataConverter2;
    }();
    FirestoreDataConverter.INSTANCES = new WeakMap();
    var DocumentReference = function() {
      function DocumentReference2(firestore, _delegate) {
        this.firestore = firestore;
        this._delegate = _delegate;
        this._userDataWriter = new UserDataWriter(firestore);
      }
      DocumentReference2.forPath = function(path2, firestore, converter) {
        if (path2.length % 2 !== 0) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but " + (path2.canonicalString() + " has " + path2.length));
        }
        return new DocumentReference2(firestore, new DocumentReference$1(firestore._delegate, converter, new DocumentKey(path2)));
      };
      DocumentReference2.forKey = function(key, firestore, converter) {
        return new DocumentReference2(firestore, new DocumentReference$1(firestore._delegate, converter, key));
      };
      Object.defineProperty(DocumentReference2.prototype, "id", {
        get: function() {
          return this._delegate.id;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentReference2.prototype, "parent", {
        get: function() {
          return new CollectionReference(this.firestore, this._delegate.parent);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentReference2.prototype, "path", {
        get: function() {
          return this._delegate.path;
        },
        enumerable: false,
        configurable: true
      });
      DocumentReference2.prototype.collection = function(pathString) {
        try {
          return new CollectionReference(this.firestore, collection(this._delegate, pathString));
        } catch (e) {
          throw replaceFunctionName(e, "collection()", "DocumentReference.collection()");
        }
      };
      DocumentReference2.prototype.isEqual = function(other) {
        other = util.getModularInstance(other);
        if (!(other instanceof DocumentReference$1)) {
          return false;
        }
        return refEqual(this._delegate, other);
      };
      DocumentReference2.prototype.set = function(value, options2) {
        options2 = validateSetOptions("DocumentReference.set", options2);
        try {
          return setDoc(this._delegate, value, options2);
        } catch (e) {
          throw replaceFunctionName(e, "setDoc()", "DocumentReference.set()");
        }
      };
      DocumentReference2.prototype.update = function(fieldOrUpdateData, value) {
        var moreFieldsAndValues = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          moreFieldsAndValues[_i - 2] = arguments[_i];
        }
        try {
          if (arguments.length === 1) {
            return updateDoc(this._delegate, fieldOrUpdateData);
          } else {
            return updateDoc.apply(void 0, tslib.__spreadArray([this._delegate, fieldOrUpdateData, value], moreFieldsAndValues));
          }
        } catch (e) {
          throw replaceFunctionName(e, "updateDoc()", "DocumentReference.update()");
        }
      };
      DocumentReference2.prototype.delete = function() {
        return deleteDoc(this._delegate);
      };
      DocumentReference2.prototype.onSnapshot = function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var options2 = extractSnapshotOptions(args);
        var observer = wrapObserver(args, function(result) {
          return new DocumentSnapshot(_this.firestore, new DocumentSnapshot$1(_this.firestore._delegate, _this._userDataWriter, result._key, result._document, result.metadata, _this._delegate.converter));
        });
        return onSnapshot(this._delegate, options2, observer);
      };
      DocumentReference2.prototype.get = function(options2) {
        var _this = this;
        var snap;
        if ((options2 === null || options2 === void 0 ? void 0 : options2.source) === "cache") {
          snap = getDocFromCache(this._delegate);
        } else if ((options2 === null || options2 === void 0 ? void 0 : options2.source) === "server") {
          snap = getDocFromServer(this._delegate);
        } else {
          snap = getDoc(this._delegate);
        }
        return snap.then(function(result) {
          return new DocumentSnapshot(_this.firestore, new DocumentSnapshot$1(_this.firestore._delegate, _this._userDataWriter, result._key, result._document, result.metadata, _this._delegate.converter));
        });
      };
      DocumentReference2.prototype.withConverter = function(converter) {
        return new DocumentReference2(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
      };
      return DocumentReference2;
    }();
    function replaceFunctionName(e, original, updated) {
      e.message = e.message.replace(original, updated);
      return e;
    }
    function extractSnapshotOptions(args) {
      for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
        var arg = args_1[_i];
        if (typeof arg === "object" && !isPartialObserver(arg)) {
          return arg;
        }
      }
      return {};
    }
    function wrapObserver(args, wrapper) {
      var _a, _b;
      var userObserver;
      if (isPartialObserver(args[0])) {
        userObserver = args[0];
      } else if (isPartialObserver(args[1])) {
        userObserver = args[1];
      } else if (typeof args[0] === "function") {
        userObserver = {
          next: args[0],
          error: args[1],
          complete: args[2]
        };
      } else {
        userObserver = {
          next: args[1],
          error: args[2],
          complete: args[3]
        };
      }
      return {
        next: function(val) {
          if (userObserver.next) {
            userObserver.next(wrapper(val));
          }
        },
        error: (_a = userObserver.error) === null || _a === void 0 ? void 0 : _a.bind(userObserver),
        complete: (_b = userObserver.complete) === null || _b === void 0 ? void 0 : _b.bind(userObserver)
      };
    }
    var DocumentSnapshot = function() {
      function DocumentSnapshot2(_firestore, _delegate) {
        this._firestore = _firestore;
        this._delegate = _delegate;
      }
      Object.defineProperty(DocumentSnapshot2.prototype, "ref", {
        get: function() {
          return new DocumentReference(this._firestore, this._delegate.ref);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentSnapshot2.prototype, "id", {
        get: function() {
          return this._delegate.id;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentSnapshot2.prototype, "metadata", {
        get: function() {
          return this._delegate.metadata;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentSnapshot2.prototype, "exists", {
        get: function() {
          return this._delegate.exists();
        },
        enumerable: false,
        configurable: true
      });
      DocumentSnapshot2.prototype.data = function(options2) {
        return this._delegate.data(options2);
      };
      DocumentSnapshot2.prototype.get = function(fieldPath, options2) {
        return this._delegate.get(fieldPath, options2);
      };
      DocumentSnapshot2.prototype.isEqual = function(other) {
        return snapshotEqual(this._delegate, other._delegate);
      };
      return DocumentSnapshot2;
    }();
    var QueryDocumentSnapshot = function(_super) {
      tslib.__extends(QueryDocumentSnapshot2, _super);
      function QueryDocumentSnapshot2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      QueryDocumentSnapshot2.prototype.data = function(options2) {
        var data = this._delegate.data(options2);
        return data;
      };
      return QueryDocumentSnapshot2;
    }(DocumentSnapshot);
    var Query = function() {
      function Query2(firestore, _delegate) {
        this.firestore = firestore;
        this._delegate = _delegate;
        this._userDataWriter = new UserDataWriter(firestore);
      }
      Query2.prototype.where = function(fieldPath, opStr, value) {
        try {
          return new Query2(this.firestore, query(this._delegate, where(fieldPath, opStr, value)));
        } catch (e) {
          throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
        }
      };
      Query2.prototype.orderBy = function(fieldPath, directionStr) {
        try {
          return new Query2(this.firestore, query(this._delegate, orderBy(fieldPath, directionStr)));
        } catch (e) {
          throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
        }
      };
      Query2.prototype.limit = function(n) {
        try {
          return new Query2(this.firestore, query(this._delegate, limit(n)));
        } catch (e) {
          throw replaceFunctionName(e, "limit()", "Query.limit()");
        }
      };
      Query2.prototype.limitToLast = function(n) {
        try {
          return new Query2(this.firestore, query(this._delegate, limitToLast(n)));
        } catch (e) {
          throw replaceFunctionName(e, "limitToLast()", "Query.limitToLast()");
        }
      };
      Query2.prototype.startAt = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        try {
          return new Query2(this.firestore, query(this._delegate, startAt.apply(void 0, args)));
        } catch (e) {
          throw replaceFunctionName(e, "startAt()", "Query.startAt()");
        }
      };
      Query2.prototype.startAfter = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        try {
          return new Query2(this.firestore, query(this._delegate, startAfter.apply(void 0, args)));
        } catch (e) {
          throw replaceFunctionName(e, "startAfter()", "Query.startAfter()");
        }
      };
      Query2.prototype.endBefore = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        try {
          return new Query2(this.firestore, query(this._delegate, endBefore.apply(void 0, args)));
        } catch (e) {
          throw replaceFunctionName(e, "endBefore()", "Query.endBefore()");
        }
      };
      Query2.prototype.endAt = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        try {
          return new Query2(this.firestore, query(this._delegate, endAt.apply(void 0, args)));
        } catch (e) {
          throw replaceFunctionName(e, "endAt()", "Query.endAt()");
        }
      };
      Query2.prototype.isEqual = function(other) {
        return queryEqual(this._delegate, other._delegate);
      };
      Query2.prototype.get = function(options2) {
        var _this = this;
        var query2;
        if ((options2 === null || options2 === void 0 ? void 0 : options2.source) === "cache") {
          query2 = getDocsFromCache(this._delegate);
        } else if ((options2 === null || options2 === void 0 ? void 0 : options2.source) === "server") {
          query2 = getDocsFromServer(this._delegate);
        } else {
          query2 = getDocs(this._delegate);
        }
        return query2.then(function(result) {
          return new QuerySnapshot(_this.firestore, new QuerySnapshot$1(_this.firestore._delegate, _this._userDataWriter, _this._delegate, result._snapshot));
        });
      };
      Query2.prototype.onSnapshot = function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var options2 = extractSnapshotOptions(args);
        var observer = wrapObserver(args, function(snap) {
          return new QuerySnapshot(_this.firestore, new QuerySnapshot$1(_this.firestore._delegate, _this._userDataWriter, _this._delegate, snap._snapshot));
        });
        return onSnapshot(this._delegate, options2, observer);
      };
      Query2.prototype.withConverter = function(converter) {
        return new Query2(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
      };
      return Query2;
    }();
    var DocumentChange = function() {
      function DocumentChange2(_firestore, _delegate) {
        this._firestore = _firestore;
        this._delegate = _delegate;
      }
      Object.defineProperty(DocumentChange2.prototype, "type", {
        get: function() {
          return this._delegate.type;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentChange2.prototype, "doc", {
        get: function() {
          return new QueryDocumentSnapshot(this._firestore, this._delegate.doc);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentChange2.prototype, "oldIndex", {
        get: function() {
          return this._delegate.oldIndex;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentChange2.prototype, "newIndex", {
        get: function() {
          return this._delegate.newIndex;
        },
        enumerable: false,
        configurable: true
      });
      return DocumentChange2;
    }();
    var QuerySnapshot = function() {
      function QuerySnapshot2(_firestore, _delegate) {
        this._firestore = _firestore;
        this._delegate = _delegate;
      }
      Object.defineProperty(QuerySnapshot2.prototype, "query", {
        get: function() {
          return new Query(this._firestore, this._delegate.query);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QuerySnapshot2.prototype, "metadata", {
        get: function() {
          return this._delegate.metadata;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QuerySnapshot2.prototype, "size", {
        get: function() {
          return this._delegate.size;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QuerySnapshot2.prototype, "empty", {
        get: function() {
          return this._delegate.empty;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QuerySnapshot2.prototype, "docs", {
        get: function() {
          var _this = this;
          return this._delegate.docs.map(function(doc2) {
            return new QueryDocumentSnapshot(_this._firestore, doc2);
          });
        },
        enumerable: false,
        configurable: true
      });
      QuerySnapshot2.prototype.docChanges = function(options2) {
        var _this = this;
        return this._delegate.docChanges(options2).map(function(docChange) {
          return new DocumentChange(_this._firestore, docChange);
        });
      };
      QuerySnapshot2.prototype.forEach = function(callback, thisArg) {
        var _this = this;
        this._delegate.forEach(function(snapshot) {
          callback.call(thisArg, new QueryDocumentSnapshot(_this._firestore, snapshot));
        });
      };
      QuerySnapshot2.prototype.isEqual = function(other) {
        return snapshotEqual(this._delegate, other._delegate);
      };
      return QuerySnapshot2;
    }();
    var CollectionReference = function(_super) {
      tslib.__extends(CollectionReference2, _super);
      function CollectionReference2(firestore, _delegate) {
        var _this = _super.call(this, firestore, _delegate) || this;
        _this.firestore = firestore;
        _this._delegate = _delegate;
        return _this;
      }
      Object.defineProperty(CollectionReference2.prototype, "id", {
        get: function() {
          return this._delegate.id;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CollectionReference2.prototype, "path", {
        get: function() {
          return this._delegate.path;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CollectionReference2.prototype, "parent", {
        get: function() {
          var docRef = this._delegate.parent;
          return docRef ? new DocumentReference(this.firestore, docRef) : null;
        },
        enumerable: false,
        configurable: true
      });
      CollectionReference2.prototype.doc = function(documentPath) {
        try {
          if (documentPath === void 0) {
            return new DocumentReference(this.firestore, doc(this._delegate));
          } else {
            return new DocumentReference(this.firestore, doc(this._delegate, documentPath));
          }
        } catch (e) {
          throw replaceFunctionName(e, "doc()", "CollectionReference.doc()");
        }
      };
      CollectionReference2.prototype.add = function(data) {
        var _this = this;
        return addDoc(this._delegate, data).then(function(docRef) {
          return new DocumentReference(_this.firestore, docRef);
        });
      };
      CollectionReference2.prototype.isEqual = function(other) {
        return refEqual(this._delegate, other._delegate);
      };
      CollectionReference2.prototype.withConverter = function(converter) {
        return new CollectionReference2(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
      };
      return CollectionReference2;
    }(Query);
    function castReference(documentRef) {
      return cast(documentRef, DocumentReference$1);
    }
    exports2.ArrayRemoveFieldValueImpl = ArrayRemoveFieldValueImpl;
    exports2.ArrayUnionFieldValueImpl = ArrayUnionFieldValueImpl;
    exports2.Blob = Blob3;
    exports2.CACHE_SIZE_UNLIMITED = CACHE_SIZE_UNLIMITED;
    exports2.CollectionReference = CollectionReference;
    exports2.DeleteFieldValueImpl = DeleteFieldValueImpl;
    exports2.DocumentReference = DocumentReference;
    exports2.DocumentSnapshot = DocumentSnapshot;
    exports2.FieldPath = FieldPath;
    exports2.FieldPath$1 = FieldPath$1;
    exports2.Firestore = Firestore;
    exports2.Firestore$1 = Firestore$1;
    exports2.GeoPoint = GeoPoint;
    exports2.IndexedDbPersistenceProvider = IndexedDbPersistenceProvider;
    exports2.NumericIncrementFieldValueImpl = NumericIncrementFieldValueImpl;
    exports2.Query = Query;
    exports2.QueryDocumentSnapshot = QueryDocumentSnapshot;
    exports2.QuerySnapshot = QuerySnapshot;
    exports2.ServerTimestampFieldValueImpl = ServerTimestampFieldValueImpl;
    exports2.Timestamp = Timestamp;
    exports2.Transaction = Transaction;
    exports2.WriteBatch = WriteBatch;
    exports2.loadBundle = loadBundle;
    exports2.namedQuery = namedQuery;
    exports2.setLogLevel = setLogLevel;
  }
});

// node_modules/@firebase/firestore/dist/node-cjs/index.js
var require_node_cjs = __commonJS({
  "node_modules/@firebase/firestore/dist/node-cjs/index.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib = require_tslib();
    var firebase2 = require_index_node_cjs2();
    var databaseC96156d6 = require_database_c96156d6_f0f0e10d();
    var component = require_index_cjs();
    var util = require_index_node_cjs();
    require_index_cjs2();
    require("util");
    require("crypto");
    require_src();
    require_package();
    require("path");
    require_src3();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var firebase__default = /* @__PURE__ */ _interopDefaultLegacy(firebase2);
    var name = "@firebase/firestore";
    var version = "2.3.10";
    function deleteField() {
      return new databaseC96156d6.DeleteFieldValueImpl("deleteField");
    }
    function serverTimestamp() {
      return new databaseC96156d6.ServerTimestampFieldValueImpl("serverTimestamp");
    }
    function arrayUnion() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
      }
      return new databaseC96156d6.ArrayUnionFieldValueImpl("arrayUnion", elements);
    }
    function arrayRemove() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
      }
      return new databaseC96156d6.ArrayRemoveFieldValueImpl("arrayRemove", elements);
    }
    function increment(n) {
      return new databaseC96156d6.NumericIncrementFieldValueImpl("increment", n);
    }
    var FieldPath = function() {
      function FieldPath2() {
        var fieldNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fieldNames[_i] = arguments[_i];
        }
        this._delegate = new (databaseC96156d6.FieldPath.bind.apply(databaseC96156d6.FieldPath, tslib.__spreadArray([void 0], fieldNames)))();
      }
      FieldPath2.documentId = function() {
        return new FieldPath2(databaseC96156d6.FieldPath$1.keyField().canonicalString());
      };
      FieldPath2.prototype.isEqual = function(other) {
        other = util.getModularInstance(other);
        if (!(other instanceof databaseC96156d6.FieldPath)) {
          return false;
        }
        return this._delegate._internalPath.isEqual(other._internalPath);
      };
      return FieldPath2;
    }();
    var FieldValue = function() {
      function FieldValue2(_delegate) {
        this._delegate = _delegate;
      }
      FieldValue2.serverTimestamp = function() {
        var delegate = serverTimestamp();
        delegate._methodName = "FieldValue.serverTimestamp";
        return new FieldValue2(delegate);
      };
      FieldValue2.delete = function() {
        var delegate = deleteField();
        delegate._methodName = "FieldValue.delete";
        return new FieldValue2(delegate);
      };
      FieldValue2.arrayUnion = function() {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          elements[_i] = arguments[_i];
        }
        var delegate = arrayUnion.apply(void 0, elements);
        delegate._methodName = "FieldValue.arrayUnion";
        return new FieldValue2(delegate);
      };
      FieldValue2.arrayRemove = function() {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          elements[_i] = arguments[_i];
        }
        var delegate = arrayRemove.apply(void 0, elements);
        delegate._methodName = "FieldValue.arrayRemove";
        return new FieldValue2(delegate);
      };
      FieldValue2.increment = function(n) {
        var delegate = increment(n);
        delegate._methodName = "FieldValue.increment";
        return new FieldValue2(delegate);
      };
      FieldValue2.prototype.isEqual = function(other) {
        return this._delegate.isEqual(other._delegate);
      };
      return FieldValue2;
    }();
    var firestoreNamespace = {
      Firestore: databaseC96156d6.Firestore,
      GeoPoint: databaseC96156d6.GeoPoint,
      Timestamp: databaseC96156d6.Timestamp,
      Blob: databaseC96156d6.Blob,
      Transaction: databaseC96156d6.Transaction,
      WriteBatch: databaseC96156d6.WriteBatch,
      DocumentReference: databaseC96156d6.DocumentReference,
      DocumentSnapshot: databaseC96156d6.DocumentSnapshot,
      Query: databaseC96156d6.Query,
      QueryDocumentSnapshot: databaseC96156d6.QueryDocumentSnapshot,
      QuerySnapshot: databaseC96156d6.QuerySnapshot,
      CollectionReference: databaseC96156d6.CollectionReference,
      FieldPath,
      FieldValue,
      setLogLevel: databaseC96156d6.setLogLevel,
      CACHE_SIZE_UNLIMITED: databaseC96156d6.CACHE_SIZE_UNLIMITED
    };
    function configureForFirebase(firebase3, firestoreFactory) {
      firebase3.INTERNAL.registerComponent(new component.Component("firestore", function(container) {
        var app = container.getProvider("app").getImmediate();
        return firestoreFactory(app, container.getProvider("auth-internal"));
      }, "PUBLIC").setServiceProps(Object.assign({}, firestoreNamespace)));
    }
    function registerFirestore(instance) {
      configureForFirebase(instance, function(app, auth2) {
        return new databaseC96156d6.Firestore(app, new databaseC96156d6.Firestore$1(app, auth2), new databaseC96156d6.IndexedDbPersistenceProvider());
      });
      instance.registerVersion(name, version, "node");
    }
    registerFirestore(firebase__default["default"]);
    exports2.registerFirestore = registerFirestore;
  }
});

// node_modules/@firebase/firestore/dist/node-cjs/bundle.js
var require_bundle = __commonJS({
  "node_modules/@firebase/firestore/dist/node-cjs/bundle.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var databaseC96156d6 = require_database_c96156d6_f0f0e10d();
    require_tslib();
    require_index_node_cjs();
    require_index_cjs2();
    require("util");
    require("crypto");
    require_src();
    require_package();
    require("path");
    require_src3();
    function loadBundle(data) {
      return databaseC96156d6.loadBundle(this._delegate, data);
    }
    function namedQuery(queryName) {
      var _this = this;
      return databaseC96156d6.namedQuery(this._delegate, queryName).then(function(expQuery) {
        if (!expQuery) {
          return null;
        }
        return new databaseC96156d6.Query(_this, expQuery);
      });
    }
    function registerBundle(instance) {
      instance.prototype.loadBundle = loadBundle;
      instance.prototype.namedQuery = namedQuery;
    }
    registerBundle(databaseC96156d6.Firestore);
    exports2.registerBundle = registerBundle;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream2 = _interopDefault(require("stream"));
    var http2 = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var https2 = _interopDefault(require("https"));
    var zlib2 = _interopDefault(require("zlib"));
    var Readable2 = Stream2.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob3 = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options2 = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob3) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options2 && options2.type !== void 0 && String(options2.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable2();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob3([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob3.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob3.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError2(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError2.prototype = Object.create(Error.prototype);
    FetchError2.prototype.constructor = FetchError2;
    FetchError2.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS2 = Symbol("Body internals");
    var PassThrough2 = Stream2.PassThrough;
    function Body2(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob2(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream2)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS2] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream2) {
        body.on("error", function(err) {
          const error3 = err.name === "AbortError" ? err : new FetchError2(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS2].error = error3;
        });
      }
    }
    Body2.prototype = {
      get body() {
        return this[INTERNALS2].body;
      },
      get bodyUsed() {
        return this[INTERNALS2].disturbed;
      },
      arrayBuffer() {
        return consumeBody2.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody2.call(this).then(function(buf) {
          return Object.assign(new Blob3([], {
            type: ct.toLowerCase()
          }), {
            [BUFFER]: buf
          });
        });
      },
      json() {
        var _this2 = this;
        return consumeBody2.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body2.Promise.reject(new FetchError2(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      text() {
        return consumeBody2.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody2.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody2.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body2.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body2.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body2.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body2.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody2() {
      var _this4 = this;
      if (this[INTERNALS2].disturbed) {
        return Body2.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS2].disturbed = true;
      if (this[INTERNALS2].error) {
        return Body2.Promise.reject(this[INTERNALS2].error);
      }
      let body = this.body;
      if (body === null) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob2(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body2.Promise.resolve(body);
      }
      if (!(body instanceof Stream2)) {
        return Body2.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body2.Promise(function(resolve2, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError2(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError2(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError2(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve2(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError2(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob2(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone2(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream2 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough2();
        p2 = new PassThrough2();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS2].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType2(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob2(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream2) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes2(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob2(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream2(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob2(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body2.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers2 = class {
      constructor() {
        let init2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = Object.create(null);
        if (init2 instanceof Headers2) {
          const rawHeaders = init2.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init2 == null)
          ;
        else if (typeof init2 === "object") {
          const method = init2[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init2) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init2)) {
              const value = init2[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return createHeadersIterator(this, "key");
      }
      values() {
        return createHeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
    Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers2.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index2 = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index2 >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index2 + 1;
        return {
          value: values[index2],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers2();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$12 = Symbol("Response internals");
    var STATUS_CODES = http2.STATUS_CODES;
    var Response2 = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body2.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers2(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType2(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$12] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$12].url || "";
      }
      get status() {
        return this[INTERNALS$12].status;
      }
      get ok() {
        return this[INTERNALS$12].status >= 200 && this[INTERNALS$12].status < 300;
      }
      get redirected() {
        return this[INTERNALS$12].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$12].statusText;
      }
      get headers() {
        return this[INTERNALS$12].headers;
      }
      clone() {
        return new Response2(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body2.mixIn(Response2.prototype);
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$22 = Symbol("Request internals");
    var parse_url = Url.parse;
    var format_url = Url.format;
    var streamDestructionSupported = "destroy" in Stream2.Readable.prototype;
    function isRequest2(input) {
      return typeof input === "object" && typeof input[INTERNALS$22] === "object";
    }
    function isAbortSignal2(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request2 = class {
      constructor(input) {
        let init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest2(input)) {
          if (input && input.href) {
            parsedURL = parse_url(input.href);
          } else {
            parsedURL = parse_url(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parse_url(input.url);
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest2(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init2.body != null ? init2.body : isRequest2(input) && input.body !== null ? clone2(input) : null;
        Body2.call(this, inputBody, {
          timeout: init2.timeout || input.timeout || 0,
          size: init2.size || input.size || 0
        });
        const headers = new Headers2(init2.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType2(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest2(input) ? input.signal : null;
        if ("signal" in init2)
          signal = init2.signal;
        if (signal != null && !isAbortSignal2(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$22] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow !== void 0 ? init2.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init2.compress !== void 0 ? init2.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$22].method;
      }
      get url() {
        return format_url(this[INTERNALS$22].parsedURL);
      }
      get headers() {
        return this[INTERNALS$22].headers;
      }
      get redirect() {
        return this[INTERNALS$22].redirect;
      }
      get signal() {
        return this[INTERNALS$22].signal;
      }
      clone() {
        return new Request2(this);
      }
    };
    Body2.mixIn(Request2.prototype);
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions2(request) {
      const parsedURL = request[INTERNALS$22].parsedURL;
      const headers = new Headers2(request[INTERNALS$22].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream2.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes2(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError2(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError2.prototype = Object.create(Error.prototype);
    AbortError2.prototype.constructor = AbortError2;
    AbortError2.prototype.name = "AbortError";
    var PassThrough$1 = Stream2.PassThrough;
    var resolve_url = Url.resolve;
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body2.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve2, reject) {
        const request = new Request2(url, opts);
        const options2 = getNodeRequestOptions2(request);
        const send = (options2.protocol === "https:" ? https2 : http2).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error3 = new AbortError2("The user aborted a request.");
          reject(error3);
          if (request.body && request.body instanceof Stream2.Readable) {
            request.body.destroy(error3);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error3);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options2);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError2(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError2(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location2 = headers.get("Location");
            const locationURL = location2 === null ? null : resolve_url(request.url, location2);
            switch (request.redirect) {
              case "error":
                reject(new FetchError2(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError2(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers2(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (res.statusCode !== 303 && request.body && getTotalBytes2(request) === null) {
                  reject(new FetchError2("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve2(fetch2(new Request2(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          const zlibOptions = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib2.createGunzip(zlibOptions));
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib2.createInflate());
              } else {
                body = body.pipe(zlib2.createInflateRaw());
              }
              response = new Response2(body, response_options);
              resolve2(response);
            });
            return;
          }
          if (codings == "br" && typeof zlib2.createBrotliDecompress === "function") {
            body = body.pipe(zlib2.createBrotliDecompress());
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          response = new Response2(body, response_options);
          resolve2(response);
        });
        writeToStream2(req, request);
      });
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module2.exports = exports2 = fetch2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers2;
    exports2.Request = Request2;
    exports2.Response = Response2;
    exports2.FetchError = FetchError2;
  }
});

// node_modules/@firebase/functions/dist/index.node.cjs.js
var require_index_node_cjs4 = __commonJS({
  "node_modules/@firebase/functions/dist/index.node.cjs.js"() {
    init_shims();
    "use strict";
    var firebase2 = require_index_node_cjs2();
    var tslib = require_tslib();
    var component = require_index_cjs();
    var nodeFetch = require_lib2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var firebase__default = /* @__PURE__ */ _interopDefaultLegacy(firebase2);
    var nodeFetch__default = /* @__PURE__ */ _interopDefaultLegacy(nodeFetch);
    var errorCodeMap = {
      OK: "ok",
      CANCELLED: "cancelled",
      UNKNOWN: "unknown",
      INVALID_ARGUMENT: "invalid-argument",
      DEADLINE_EXCEEDED: "deadline-exceeded",
      NOT_FOUND: "not-found",
      ALREADY_EXISTS: "already-exists",
      PERMISSION_DENIED: "permission-denied",
      UNAUTHENTICATED: "unauthenticated",
      RESOURCE_EXHAUSTED: "resource-exhausted",
      FAILED_PRECONDITION: "failed-precondition",
      ABORTED: "aborted",
      OUT_OF_RANGE: "out-of-range",
      UNIMPLEMENTED: "unimplemented",
      INTERNAL: "internal",
      UNAVAILABLE: "unavailable",
      DATA_LOSS: "data-loss"
    };
    var HttpsErrorImpl = function(_super) {
      tslib.__extends(HttpsErrorImpl2, _super);
      function HttpsErrorImpl2(code, message, details) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, HttpsErrorImpl2.prototype);
        _this.code = code;
        _this.details = details;
        return _this;
      }
      return HttpsErrorImpl2;
    }(Error);
    function codeForHTTPStatus(status) {
      if (status >= 200 && status < 300) {
        return "ok";
      }
      switch (status) {
        case 0:
          return "internal";
        case 400:
          return "invalid-argument";
        case 401:
          return "unauthenticated";
        case 403:
          return "permission-denied";
        case 404:
          return "not-found";
        case 409:
          return "aborted";
        case 429:
          return "resource-exhausted";
        case 499:
          return "cancelled";
        case 500:
          return "internal";
        case 501:
          return "unimplemented";
        case 503:
          return "unavailable";
        case 504:
          return "deadline-exceeded";
      }
      return "unknown";
    }
    function _errorForResponse(status, bodyJSON, serializer) {
      var code = codeForHTTPStatus(status);
      var description = code;
      var details = void 0;
      try {
        var errorJSON = bodyJSON && bodyJSON.error;
        if (errorJSON) {
          var status_1 = errorJSON.status;
          if (typeof status_1 === "string") {
            if (!errorCodeMap[status_1]) {
              return new HttpsErrorImpl("internal", "internal");
            }
            code = errorCodeMap[status_1];
            description = status_1;
          }
          var message = errorJSON.message;
          if (typeof message === "string") {
            description = message;
          }
          details = errorJSON.details;
          if (details !== void 0) {
            details = serializer.decode(details);
          }
        }
      } catch (e) {
      }
      if (code === "ok") {
        return null;
      }
      return new HttpsErrorImpl(code, description, details);
    }
    var ContextProvider = function() {
      function ContextProvider2(authProvider, messagingProvider) {
        var _this = this;
        this.auth = null;
        this.messaging = null;
        this.auth = authProvider.getImmediate({ optional: true });
        this.messaging = messagingProvider.getImmediate({
          optional: true
        });
        if (!this.auth) {
          authProvider.get().then(function(auth2) {
            return _this.auth = auth2;
          }, function() {
          });
        }
        if (!this.messaging) {
          messagingProvider.get().then(function(messaging) {
            return _this.messaging = messaging;
          }, function() {
          });
        }
      }
      ContextProvider2.prototype.getAuthToken = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var token;
          return tslib.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.auth) {
                  return [2, void 0];
                }
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this.auth.getToken()];
              case 2:
                token = _a.sent();
                if (!token) {
                  return [2, void 0];
                }
                return [2, token.accessToken];
              case 3:
                _a.sent();
                return [2, void 0];
              case 4:
                return [2];
            }
          });
        });
      };
      ContextProvider2.prototype.getInstanceIdToken = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.messaging || !("Notification" in self) || Notification.permission !== "granted") {
                  return [2, void 0];
                }
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this.messaging.getToken()];
              case 2:
                return [2, _a.sent()];
              case 3:
                _a.sent();
                return [2, void 0];
              case 4:
                return [2];
            }
          });
        });
      };
      ContextProvider2.prototype.getContext = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var authToken, instanceIdToken;
          return tslib.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getAuthToken()];
              case 1:
                authToken = _a.sent();
                return [4, this.getInstanceIdToken()];
              case 2:
                instanceIdToken = _a.sent();
                return [2, { authToken, instanceIdToken }];
            }
          });
        });
      };
      return ContextProvider2;
    }();
    var LONG_TYPE = "type.googleapis.com/google.protobuf.Int64Value";
    var UNSIGNED_LONG_TYPE = "type.googleapis.com/google.protobuf.UInt64Value";
    function mapValues(o, f) {
      var result = {};
      for (var key in o) {
        if (o.hasOwnProperty(key)) {
          result[key] = f(o[key]);
        }
      }
      return result;
    }
    var Serializer = function() {
      function Serializer2() {
      }
      Serializer2.prototype.encode = function(data) {
        var _this = this;
        if (data == null) {
          return null;
        }
        if (data instanceof Number) {
          data = data.valueOf();
        }
        if (typeof data === "number" && isFinite(data)) {
          return data;
        }
        if (data === true || data === false) {
          return data;
        }
        if (Object.prototype.toString.call(data) === "[object String]") {
          return data;
        }
        if (data instanceof Date) {
          return data.toISOString();
        }
        if (Array.isArray(data)) {
          return data.map(function(x) {
            return _this.encode(x);
          });
        }
        if (typeof data === "function" || typeof data === "object") {
          return mapValues(data, function(x) {
            return _this.encode(x);
          });
        }
        throw new Error("Data cannot be encoded in JSON: " + data);
      };
      Serializer2.prototype.decode = function(json) {
        var _this = this;
        if (json == null) {
          return json;
        }
        if (json["@type"]) {
          switch (json["@type"]) {
            case LONG_TYPE:
            case UNSIGNED_LONG_TYPE: {
              var value = Number(json["value"]);
              if (isNaN(value)) {
                throw new Error("Data cannot be decoded from JSON: " + json);
              }
              return value;
            }
            default: {
              throw new Error("Data cannot be decoded from JSON: " + json);
            }
          }
        }
        if (Array.isArray(json)) {
          return json.map(function(x) {
            return _this.decode(x);
          });
        }
        if (typeof json === "function" || typeof json === "object") {
          return mapValues(json, function(x) {
            return _this.decode(x);
          });
        }
        return json;
      };
      return Serializer2;
    }();
    function failAfter(millis) {
      var timer;
      var promise = new Promise(function(_, reject) {
        timer = setTimeout(function() {
          reject(new HttpsErrorImpl("deadline-exceeded", "deadline-exceeded"));
        }, millis);
      });
      return {
        timer,
        promise
      };
    }
    var Service = function() {
      function Service2(app_, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain_, fetchImpl) {
        var _this = this;
        if (regionOrCustomDomain_ === void 0) {
          regionOrCustomDomain_ = "us-central1";
        }
        this.app_ = app_;
        this.appCheckProvider = appCheckProvider;
        this.fetchImpl = fetchImpl;
        this.serializer = new Serializer();
        this.emulatorOrigin = null;
        this.INTERNAL = {
          delete: function() {
            return Promise.resolve(_this.deleteService());
          }
        };
        this.contextProvider = new ContextProvider(authProvider, messagingProvider);
        this.cancelAllRequests = new Promise(function(resolve2) {
          _this.deleteService = function() {
            return resolve2();
          };
        });
        try {
          var url = new URL(regionOrCustomDomain_);
          this.customDomain = url.origin;
          this.region = "us-central1";
        } catch (e) {
          this.customDomain = null;
          this.region = regionOrCustomDomain_;
        }
      }
      Object.defineProperty(Service2.prototype, "app", {
        get: function() {
          return this.app_;
        },
        enumerable: false,
        configurable: true
      });
      Service2.prototype._url = function(name2) {
        var projectId = this.app_.options.projectId;
        if (this.emulatorOrigin !== null) {
          var origin_1 = this.emulatorOrigin;
          return origin_1 + "/" + projectId + "/" + this.region + "/" + name2;
        }
        if (this.customDomain !== null) {
          return this.customDomain + "/" + name2;
        }
        return "https://" + this.region + "-" + projectId + ".cloudfunctions.net/" + name2;
      };
      Service2.prototype.useEmulator = function(host, port) {
        this.emulatorOrigin = "http://" + host + ":" + port;
      };
      Service2.prototype.useFunctionsEmulator = function(origin) {
        this.emulatorOrigin = origin;
      };
      Service2.prototype.httpsCallable = function(name2, options2) {
        var _this = this;
        return function(data) {
          return _this.call(name2, data, options2 || {});
        };
      };
      Service2.prototype.postJSON = function(url, body, headers) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var appCheckToken, response, json;
          return tslib.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                headers["Content-Type"] = "application/json";
                return [4, this.getAppCheckToken()];
              case 1:
                appCheckToken = _a.sent();
                if (appCheckToken !== null) {
                  headers["X-Firebase-AppCheck"] = appCheckToken;
                }
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.fetchImpl(url, {
                  method: "POST",
                  body: JSON.stringify(body),
                  headers
                })];
              case 3:
                response = _a.sent();
                return [3, 5];
              case 4:
                _a.sent();
                return [2, {
                  status: 0,
                  json: null
                }];
              case 5:
                json = null;
                _a.label = 6;
              case 6:
                _a.trys.push([6, 8, , 9]);
                return [4, response.json()];
              case 7:
                json = _a.sent();
                return [3, 9];
              case 8:
                _a.sent();
                return [3, 9];
              case 9:
                return [2, {
                  status: response.status,
                  json
                }];
            }
          });
        });
      };
      Service2.prototype.getAppCheckToken = function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var appCheck, result;
          return tslib.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                appCheck = this.appCheckProvider.getImmediate({ optional: true });
                if (!appCheck)
                  return [3, 2];
                return [4, appCheck.getToken()];
              case 1:
                result = _a.sent();
                return [2, result.token];
              case 2:
                return [2, null];
            }
          });
        });
      };
      Service2.prototype.call = function(name2, data, options2) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var url, body, headers, context, timeout, _a, timer, failAfterPromise, response, error3, responseData, decodedData;
          return tslib.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                url = this._url(name2);
                data = this.serializer.encode(data);
                body = { data };
                headers = {};
                return [4, this.contextProvider.getContext()];
              case 1:
                context = _b.sent();
                if (context.authToken) {
                  headers["Authorization"] = "Bearer " + context.authToken;
                }
                if (context.instanceIdToken) {
                  headers["Firebase-Instance-ID-Token"] = context.instanceIdToken;
                }
                timeout = options2.timeout || 7e4;
                _a = failAfter(timeout), timer = _a.timer, failAfterPromise = _a.promise;
                return [4, Promise.race([
                  clearTimeoutWrapper(timer, this.postJSON(url, body, headers)),
                  failAfterPromise,
                  clearTimeoutWrapper(timer, this.cancelAllRequests)
                ])];
              case 2:
                response = _b.sent();
                if (!response) {
                  throw new HttpsErrorImpl("cancelled", "Firebase Functions instance was deleted.");
                }
                error3 = _errorForResponse(response.status, response.json, this.serializer);
                if (error3) {
                  throw error3;
                }
                if (!response.json) {
                  throw new HttpsErrorImpl("internal", "Response is not valid JSON object.");
                }
                responseData = response.json.data;
                if (typeof responseData === "undefined") {
                  responseData = response.json.result;
                }
                if (typeof responseData === "undefined") {
                  throw new HttpsErrorImpl("internal", "Response is missing data field.");
                }
                decodedData = this.serializer.decode(responseData);
                return [2, { data: decodedData }];
            }
          });
        });
      };
      return Service2;
    }();
    function clearTimeoutWrapper(timer, promise) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var result;
        return tslib.__generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, promise];
            case 1:
              result = _a.sent();
              clearTimeout(timer);
              return [2, result];
          }
        });
      });
    }
    var FUNCTIONS_TYPE = "functions";
    function registerFunctions(instance, fetchImpl) {
      var namespaceExports = {
        Functions: Service
      };
      function factory(container, _a) {
        var regionOrCustomDomain = _a.instanceIdentifier;
        var app = container.getProvider("app").getImmediate();
        var authProvider = container.getProvider("auth-internal");
        var appCheckProvider = container.getProvider("app-check-internal");
        var messagingProvider = container.getProvider("messaging");
        return new Service(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain, fetchImpl);
      }
      instance.INTERNAL.registerComponent(new component.Component(FUNCTIONS_TYPE, factory, "PUBLIC").setServiceProps(namespaceExports).setMultipleInstances(true));
    }
    var name = "@firebase/functions";
    var version = "0.6.14";
    registerFunctions(firebase__default["default"], nodeFetch__default["default"]);
    firebase__default["default"].registerVersion(name, version, "node");
  }
});

// node_modules/@firebase/storage/dist/index.node.cjs.js
var require_index_node_cjs5 = __commonJS({
  "node_modules/@firebase/storage/dist/index.node.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var firebase2 = require_index_node_cjs2();
    var util = require_index_node_cjs();
    var nodeFetch = require_lib2();
    var component = require_index_cjs();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d2 = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d2.get ? d2 : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var firebase__default = /* @__PURE__ */ _interopDefaultLegacy(firebase2);
    var nodeFetch__namespace = /* @__PURE__ */ _interopNamespace(nodeFetch);
    var DEFAULT_HOST = "firebasestorage.googleapis.com";
    var CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
    var DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
    var DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
    var FirebaseStorageError = class extends util.FirebaseError {
      constructor(code, message) {
        super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);
        this.customData = { serverResponse: null };
        this._baseMessage = this.message;
        Object.setPrototypeOf(this, FirebaseStorageError.prototype);
      }
      _codeEquals(code) {
        return prependCode(code) === this.code;
      }
      get serverResponse() {
        return this.customData.serverResponse;
      }
      set serverResponse(serverResponse) {
        this.customData.serverResponse = serverResponse;
        if (this.customData.serverResponse) {
          this.message = `${this._baseMessage}
${this.customData.serverResponse}`;
        } else {
          this.message = this._baseMessage;
        }
      }
    };
    function prependCode(code) {
      return "storage/" + code;
    }
    function unknown() {
      const message = "An unknown error occurred, please check the error payload for server response.";
      return new FirebaseStorageError("unknown", message);
    }
    function objectNotFound(path) {
      return new FirebaseStorageError("object-not-found", "Object '" + path + "' does not exist.");
    }
    function quotaExceeded(bucket) {
      return new FirebaseStorageError("quota-exceeded", "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
    }
    function unauthenticated() {
      const message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
      return new FirebaseStorageError("unauthenticated", message);
    }
    function unauthorizedApp() {
      return new FirebaseStorageError("unauthorized-app", "This app does not have permission to access Firebase Storage on this project.");
    }
    function unauthorized(path) {
      return new FirebaseStorageError("unauthorized", "User does not have permission to access '" + path + "'.");
    }
    function retryLimitExceeded() {
      return new FirebaseStorageError("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.");
    }
    function canceled() {
      return new FirebaseStorageError("canceled", "User canceled the upload/download.");
    }
    function invalidUrl(url) {
      return new FirebaseStorageError("invalid-url", "Invalid URL '" + url + "'.");
    }
    function invalidDefaultBucket(bucket) {
      return new FirebaseStorageError("invalid-default-bucket", "Invalid default bucket '" + bucket + "'.");
    }
    function noDefaultBucket() {
      return new FirebaseStorageError("no-default-bucket", "No default bucket found. Did you set the '" + CONFIG_STORAGE_BUCKET_KEY + "' property when initializing the app?");
    }
    function cannotSliceBlob() {
      return new FirebaseStorageError("cannot-slice-blob", "Cannot slice blob for upload. Please retry the upload.");
    }
    function serverFileWrongSize() {
      return new FirebaseStorageError("server-file-wrong-size", "Server recorded incorrect upload file size, please retry the upload.");
    }
    function noDownloadURL() {
      return new FirebaseStorageError("no-download-url", "The given file does not have any download URLs.");
    }
    function invalidArgument(message) {
      return new FirebaseStorageError("invalid-argument", message);
    }
    function appDeleted() {
      return new FirebaseStorageError("app-deleted", "The Firebase app was deleted.");
    }
    function invalidRootOperation(name2) {
      return new FirebaseStorageError("invalid-root-operation", "The operation '" + name2 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
    }
    function invalidFormat(format2, message) {
      return new FirebaseStorageError("invalid-format", "String does not match format '" + format2 + "': " + message);
    }
    function internalError(message) {
      throw new FirebaseStorageError("internal-error", "Internal error: " + message);
    }
    function decodeBase64(encoded) {
      if (/[^-A-Za-z0-9+/=]/.test(encoded)) {
        throw invalidFormat("base64", "Invalid character found");
      }
      return Buffer.from(encoded, "base64").toString("binary");
    }
    var StringFormat = {
      RAW: "raw",
      BASE64: "base64",
      BASE64URL: "base64url",
      DATA_URL: "data_url"
    };
    var StringData = class {
      constructor(data, contentType) {
        this.data = data;
        this.contentType = contentType || null;
      }
    };
    function dataFromString(format2, stringData) {
      switch (format2) {
        case StringFormat.RAW:
          return new StringData(utf8Bytes_(stringData));
        case StringFormat.BASE64:
        case StringFormat.BASE64URL:
          return new StringData(base64Bytes_(format2, stringData));
        case StringFormat.DATA_URL:
          return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
      }
      throw unknown();
    }
    function utf8Bytes_(value) {
      const b = [];
      for (let i = 0; i < value.length; i++) {
        let c = value.charCodeAt(i);
        if (c <= 127) {
          b.push(c);
        } else {
          if (c <= 2047) {
            b.push(192 | c >> 6, 128 | c & 63);
          } else {
            if ((c & 64512) === 55296) {
              const valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;
              if (!valid) {
                b.push(239, 191, 189);
              } else {
                const hi = c;
                const lo = value.charCodeAt(++i);
                c = 65536 | (hi & 1023) << 10 | lo & 1023;
                b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);
              }
            } else {
              if ((c & 64512) === 56320) {
                b.push(239, 191, 189);
              } else {
                b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);
              }
            }
          }
        }
      }
      return new Uint8Array(b);
    }
    function percentEncodedBytes_(value) {
      let decoded;
      try {
        decoded = decodeURIComponent(value);
      } catch (e) {
        throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
      }
      return utf8Bytes_(decoded);
    }
    function base64Bytes_(format2, value) {
      switch (format2) {
        case StringFormat.BASE64: {
          const hasMinus = value.indexOf("-") !== -1;
          const hasUnder = value.indexOf("_") !== -1;
          if (hasMinus || hasUnder) {
            const invalidChar = hasMinus ? "-" : "_";
            throw invalidFormat(format2, "Invalid character '" + invalidChar + "' found: is it base64url encoded?");
          }
          break;
        }
        case StringFormat.BASE64URL: {
          const hasPlus = value.indexOf("+") !== -1;
          const hasSlash = value.indexOf("/") !== -1;
          if (hasPlus || hasSlash) {
            const invalidChar = hasPlus ? "+" : "/";
            throw invalidFormat(format2, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
          }
          value = value.replace(/-/g, "+").replace(/_/g, "/");
          break;
        }
      }
      let bytes;
      try {
        bytes = decodeBase64(value);
      } catch (e) {
        throw invalidFormat(format2, "Invalid character found");
      }
      const array = new Uint8Array(bytes.length);
      for (let i = 0; i < bytes.length; i++) {
        array[i] = bytes.charCodeAt(i);
      }
      return array;
    }
    var DataURLParts = class {
      constructor(dataURL) {
        this.base64 = false;
        this.contentType = null;
        const matches = dataURL.match(/^data:([^,]+)?,/);
        if (matches === null) {
          throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
        }
        const middle = matches[1] || null;
        if (middle != null) {
          this.base64 = endsWith(middle, ";base64");
          this.contentType = this.base64 ? middle.substring(0, middle.length - ";base64".length) : middle;
        }
        this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
      }
    };
    function dataURLBytes_(dataUrl) {
      const parts = new DataURLParts(dataUrl);
      if (parts.base64) {
        return base64Bytes_(StringFormat.BASE64, parts.rest);
      } else {
        return percentEncodedBytes_(parts.rest);
      }
    }
    function dataURLContentType_(dataUrl) {
      const parts = new DataURLParts(dataUrl);
      return parts.contentType;
    }
    function endsWith(s2, end) {
      const longEnough = s2.length >= end.length;
      if (!longEnough) {
        return false;
      }
      return s2.substring(s2.length - end.length) === end;
    }
    var TaskEvent = {
      STATE_CHANGED: "state_changed"
    };
    var TaskState = {
      RUNNING: "running",
      PAUSED: "paused",
      SUCCESS: "success",
      CANCELED: "canceled",
      ERROR: "error"
    };
    function taskStateFromInternalTaskState(state) {
      switch (state) {
        case "running":
        case "pausing":
        case "canceling":
          return TaskState.RUNNING;
        case "paused":
          return TaskState.PAUSED;
        case "success":
          return TaskState.SUCCESS;
        case "canceled":
          return TaskState.CANCELED;
        case "error":
          return TaskState.ERROR;
        default:
          return TaskState.ERROR;
      }
    }
    var ErrorCode;
    (function(ErrorCode2) {
      ErrorCode2[ErrorCode2["NO_ERROR"] = 0] = "NO_ERROR";
      ErrorCode2[ErrorCode2["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
      ErrorCode2[ErrorCode2["ABORT"] = 2] = "ABORT";
    })(ErrorCode || (ErrorCode = {}));
    var fetch2 = nodeFetch__namespace;
    var FetchConnection = class {
      constructor() {
        this.sent_ = false;
        this.errorCode_ = ErrorCode.NO_ERROR;
      }
      send(url, method, body, headers) {
        if (this.sent_) {
          throw internalError("cannot .send() more than once");
        }
        this.sent_ = true;
        return fetch2(url, {
          method,
          headers: headers || {},
          body
        }).then((resp) => {
          this.headers_ = resp.headers;
          this.statusCode_ = resp.status;
          return resp.text();
        }).then((body2) => {
          this.body_ = body2;
        });
      }
      getErrorCode() {
        if (this.errorCode_ === void 0) {
          throw internalError("cannot .getErrorCode() before receiving response");
        }
        return this.errorCode_;
      }
      getStatus() {
        if (this.statusCode_ === void 0) {
          throw internalError("cannot .getStatus() before receiving response");
        }
        return this.statusCode_;
      }
      getResponseText() {
        if (this.body_ === void 0) {
          throw internalError("cannot .getResponseText() before receiving response");
        }
        return this.body_;
      }
      abort() {
      }
      getResponseHeader(header) {
        if (!this.headers_) {
          throw internalError("cannot .getResponseText() before receiving response");
        }
        return this.headers_.get(header);
      }
      addUploadProgressListener(listener) {
      }
      removeUploadProgressListener(listener) {
      }
    };
    function newConnection() {
      return new FetchConnection();
    }
    var ConnectionPool = class {
      createConnection() {
        return newConnection();
      }
    };
    var Location = class {
      constructor(bucket, path) {
        this.bucket = bucket;
        this.path_ = path;
      }
      get path() {
        return this.path_;
      }
      get isRoot() {
        return this.path.length === 0;
      }
      fullServerUrl() {
        const encode = encodeURIComponent;
        return "/b/" + encode(this.bucket) + "/o/" + encode(this.path);
      }
      bucketOnlyServerUrl() {
        const encode = encodeURIComponent;
        return "/b/" + encode(this.bucket) + "/o";
      }
      static makeFromBucketSpec(bucketString, host) {
        let bucketLocation;
        try {
          bucketLocation = Location.makeFromUrl(bucketString, host);
        } catch (e) {
          return new Location(bucketString, "");
        }
        if (bucketLocation.path === "") {
          return bucketLocation;
        } else {
          throw invalidDefaultBucket(bucketString);
        }
      }
      static makeFromUrl(url, host) {
        let location2 = null;
        const bucketDomain = "([A-Za-z0-9.\\-_]+)";
        function gsModify(loc) {
          if (loc.path.charAt(loc.path.length - 1) === "/") {
            loc.path_ = loc.path_.slice(0, -1);
          }
        }
        const gsPath = "(/(.*))?$";
        const gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
        const gsIndices = { bucket: 1, path: 3 };
        function httpModify(loc) {
          loc.path_ = decodeURIComponent(loc.path);
        }
        const version2 = "v[A-Za-z0-9_]+";
        const firebaseStorageHost = host.replace(/[.]/g, "\\.");
        const firebaseStoragePath = "(/([^?#]*).*)?$";
        const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version2}/b/${bucketDomain}/o${firebaseStoragePath}`, "i");
        const firebaseStorageIndices = { bucket: 1, path: 3 };
        const cloudStorageHost = host === DEFAULT_HOST ? "(?:storage.googleapis.com|storage.cloud.google.com)" : host;
        const cloudStoragePath = "([^?#]*)";
        const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, "i");
        const cloudStorageIndices = { bucket: 1, path: 2 };
        const groups = [
          { regex: gsRegex, indices: gsIndices, postModify: gsModify },
          {
            regex: firebaseStorageRegExp,
            indices: firebaseStorageIndices,
            postModify: httpModify
          },
          {
            regex: cloudStorageRegExp,
            indices: cloudStorageIndices,
            postModify: httpModify
          }
        ];
        for (let i = 0; i < groups.length; i++) {
          const group = groups[i];
          const captures = group.regex.exec(url);
          if (captures) {
            const bucketValue = captures[group.indices.bucket];
            let pathValue = captures[group.indices.path];
            if (!pathValue) {
              pathValue = "";
            }
            location2 = new Location(bucketValue, pathValue);
            group.postModify(location2);
            break;
          }
        }
        if (location2 == null) {
          throw invalidUrl(url);
        }
        return location2;
      }
    };
    var FailRequest = class {
      constructor(error3) {
        this.promise_ = Promise.reject(error3);
      }
      getPromise() {
        return this.promise_;
      }
      cancel(_appDelete = false) {
      }
    };
    function start(f, callback, timeout) {
      let waitSeconds = 1;
      let timeoutId = null;
      let hitTimeout = false;
      let cancelState = 0;
      function canceled2() {
        return cancelState === 2;
      }
      let triggeredCallback = false;
      function triggerCallback(...args) {
        if (!triggeredCallback) {
          triggeredCallback = true;
          callback.apply(null, args);
        }
      }
      function callWithDelay(millis) {
        timeoutId = setTimeout(() => {
          timeoutId = null;
          f(handler2, canceled2());
        }, millis);
      }
      function handler2(success, ...args) {
        if (triggeredCallback) {
          return;
        }
        if (success) {
          triggerCallback.call(null, success, ...args);
          return;
        }
        const mustStop = canceled2() || hitTimeout;
        if (mustStop) {
          triggerCallback.call(null, success, ...args);
          return;
        }
        if (waitSeconds < 64) {
          waitSeconds *= 2;
        }
        let waitMillis;
        if (cancelState === 1) {
          cancelState = 2;
          waitMillis = 0;
        } else {
          waitMillis = (waitSeconds + Math.random()) * 1e3;
        }
        callWithDelay(waitMillis);
      }
      let stopped = false;
      function stop2(wasTimeout) {
        if (stopped) {
          return;
        }
        stopped = true;
        if (triggeredCallback) {
          return;
        }
        if (timeoutId !== null) {
          if (!wasTimeout) {
            cancelState = 2;
          }
          clearTimeout(timeoutId);
          callWithDelay(0);
        } else {
          if (!wasTimeout) {
            cancelState = 1;
          }
        }
      }
      callWithDelay(0);
      setTimeout(() => {
        hitTimeout = true;
        stop2(true);
      }, timeout);
      return stop2;
    }
    function stop(id) {
      id(false);
    }
    function isJustDef(p) {
      return p !== void 0;
    }
    function isFunction(p) {
      return typeof p === "function";
    }
    function isNonArrayObject(p) {
      return typeof p === "object" && !Array.isArray(p);
    }
    function isString(p) {
      return typeof p === "string" || p instanceof String;
    }
    function isNativeBlob(p) {
      return isNativeBlobDefined() && p instanceof Blob;
    }
    function isNativeBlobDefined() {
      return typeof Blob !== "undefined";
    }
    function validateNumber(argument, minValue, maxValue, value) {
      if (value < minValue) {
        throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);
      }
      if (value > maxValue) {
        throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);
      }
    }
    function makeUrl(urlPart, host) {
      const protocolMatch = host.match(/^(\w+):\/\/.+/);
      const protocol = protocolMatch === null || protocolMatch === void 0 ? void 0 : protocolMatch[1];
      let origin = host;
      if (protocol == null) {
        origin = `https://${host}`;
      }
      return `${origin}/v0${urlPart}`;
    }
    function makeQueryString(params) {
      const encode = encodeURIComponent;
      let queryPart = "?";
      for (const key in params) {
        if (params.hasOwnProperty(key)) {
          const nextPart = encode(key) + "=" + encode(params[key]);
          queryPart = queryPart + nextPart + "&";
        }
      }
      queryPart = queryPart.slice(0, -1);
      return queryPart;
    }
    var NetworkRequest = class {
      constructor(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {
        this.pendingConnection_ = null;
        this.backoffId_ = null;
        this.canceled_ = false;
        this.appDelete_ = false;
        this.url_ = url;
        this.method_ = method;
        this.headers_ = headers;
        this.body_ = body;
        this.successCodes_ = successCodes.slice();
        this.additionalRetryCodes_ = additionalRetryCodes.slice();
        this.callback_ = callback;
        this.errorCallback_ = errorCallback;
        this.progressCallback_ = progressCallback;
        this.timeout_ = timeout;
        this.pool_ = pool;
        this.promise_ = new Promise((resolve2, reject) => {
          this.resolve_ = resolve2;
          this.reject_ = reject;
          this.start_();
        });
      }
      start_() {
        const self2 = this;
        function doTheRequest(backoffCallback, canceled2) {
          if (canceled2) {
            backoffCallback(false, new RequestEndStatus(false, null, true));
            return;
          }
          const connection = self2.pool_.createConnection();
          self2.pendingConnection_ = connection;
          function progressListener(progressEvent) {
            const loaded = progressEvent.loaded;
            const total = progressEvent.lengthComputable ? progressEvent.total : -1;
            if (self2.progressCallback_ !== null) {
              self2.progressCallback_(loaded, total);
            }
          }
          if (self2.progressCallback_ !== null) {
            connection.addUploadProgressListener(progressListener);
          }
          connection.send(self2.url_, self2.method_, self2.body_, self2.headers_).then(() => {
            if (self2.progressCallback_ !== null) {
              connection.removeUploadProgressListener(progressListener);
            }
            self2.pendingConnection_ = null;
            const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;
            const status = connection.getStatus();
            if (!hitServer || self2.isRetryStatusCode_(status)) {
              const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;
              backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
              return;
            }
            const successCode = self2.successCodes_.indexOf(status) !== -1;
            backoffCallback(true, new RequestEndStatus(successCode, connection));
          });
        }
        function backoffDone(requestWentThrough, status) {
          const resolve2 = self2.resolve_;
          const reject = self2.reject_;
          const connection = status.connection;
          if (status.wasSuccessCode) {
            try {
              const result = self2.callback_(connection, connection.getResponseText());
              if (isJustDef(result)) {
                resolve2(result);
              } else {
                resolve2();
              }
            } catch (e) {
              reject(e);
            }
          } else {
            if (connection !== null) {
              const err = unknown();
              err.serverResponse = connection.getResponseText();
              if (self2.errorCallback_) {
                reject(self2.errorCallback_(connection, err));
              } else {
                reject(err);
              }
            } else {
              if (status.canceled) {
                const err = self2.appDelete_ ? appDeleted() : canceled();
                reject(err);
              } else {
                const err = retryLimitExceeded();
                reject(err);
              }
            }
          }
        }
        if (this.canceled_) {
          backoffDone(false, new RequestEndStatus(false, null, true));
        } else {
          this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
        }
      }
      getPromise() {
        return this.promise_;
      }
      cancel(appDelete) {
        this.canceled_ = true;
        this.appDelete_ = appDelete || false;
        if (this.backoffId_ !== null) {
          stop(this.backoffId_);
        }
        if (this.pendingConnection_ !== null) {
          this.pendingConnection_.abort();
        }
      }
      isRetryStatusCode_(status) {
        const isFiveHundredCode = status >= 500 && status < 600;
        const extraRetryCodes = [
          408,
          429
        ];
        const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
        const isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
        return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
      }
    };
    var RequestEndStatus = class {
      constructor(wasSuccessCode, connection, canceled2) {
        this.wasSuccessCode = wasSuccessCode;
        this.connection = connection;
        this.canceled = !!canceled2;
      }
    };
    function addAuthHeader_(headers, authToken) {
      if (authToken !== null && authToken.length > 0) {
        headers["Authorization"] = "Firebase " + authToken;
      }
    }
    function addVersionHeader_(headers, firebaseVersion) {
      headers["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : "AppManager");
    }
    function addGmpidHeader_(headers, appId) {
      if (appId) {
        headers["X-Firebase-GMPID"] = appId;
      }
    }
    function addAppCheckHeader_(headers, appCheckToken) {
      if (appCheckToken !== null) {
        headers["X-Firebase-AppCheck"] = appCheckToken;
      }
    }
    function makeRequest(requestInfo, appId, authToken, appCheckToken, pool, firebaseVersion) {
      const queryPart = makeQueryString(requestInfo.urlParams);
      const url = requestInfo.url + queryPart;
      const headers = Object.assign({}, requestInfo.headers);
      addGmpidHeader_(headers, appId);
      addAuthHeader_(headers, authToken);
      addVersionHeader_(headers, firebaseVersion);
      addAppCheckHeader_(headers, appCheckToken);
      return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
    }
    function getBlobBuilder() {
      if (typeof BlobBuilder !== "undefined") {
        return BlobBuilder;
      } else if (typeof WebKitBlobBuilder !== "undefined") {
        return WebKitBlobBuilder;
      } else {
        return void 0;
      }
    }
    function getBlob(...args) {
      const BlobBuilder2 = getBlobBuilder();
      if (BlobBuilder2 !== void 0) {
        const bb = new BlobBuilder2();
        for (let i = 0; i < args.length; i++) {
          bb.append(args[i]);
        }
        return bb.getBlob();
      } else {
        if (isNativeBlobDefined()) {
          return new Blob(args);
        } else {
          throw new FirebaseStorageError("unsupported-environment", "This browser doesn't seem to support creating Blobs");
        }
      }
    }
    function sliceBlob(blob, start2, end) {
      if (blob.webkitSlice) {
        return blob.webkitSlice(start2, end);
      } else if (blob.mozSlice) {
        return blob.mozSlice(start2, end);
      } else if (blob.slice) {
        return blob.slice(start2, end);
      }
      return null;
    }
    var FbsBlob = class {
      constructor(data, elideCopy) {
        let size = 0;
        let blobType = "";
        if (isNativeBlob(data)) {
          this.data_ = data;
          size = data.size;
          blobType = data.type;
        } else if (data instanceof ArrayBuffer) {
          if (elideCopy) {
            this.data_ = new Uint8Array(data);
          } else {
            this.data_ = new Uint8Array(data.byteLength);
            this.data_.set(new Uint8Array(data));
          }
          size = this.data_.length;
        } else if (data instanceof Uint8Array) {
          if (elideCopy) {
            this.data_ = data;
          } else {
            this.data_ = new Uint8Array(data.length);
            this.data_.set(data);
          }
          size = data.length;
        }
        this.size_ = size;
        this.type_ = blobType;
      }
      size() {
        return this.size_;
      }
      type() {
        return this.type_;
      }
      slice(startByte, endByte) {
        if (isNativeBlob(this.data_)) {
          const realBlob = this.data_;
          const sliced = sliceBlob(realBlob, startByte, endByte);
          if (sliced === null) {
            return null;
          }
          return new FbsBlob(sliced);
        } else {
          const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
          return new FbsBlob(slice, true);
        }
      }
      static getBlob(...args) {
        if (isNativeBlobDefined()) {
          const blobby = args.map((val) => {
            if (val instanceof FbsBlob) {
              return val.data_;
            } else {
              return val;
            }
          });
          return new FbsBlob(getBlob.apply(null, blobby));
        } else {
          const uint8Arrays = args.map((val) => {
            if (isString(val)) {
              return dataFromString(StringFormat.RAW, val).data;
            } else {
              return val.data_;
            }
          });
          let finalLength = 0;
          uint8Arrays.forEach((array) => {
            finalLength += array.byteLength;
          });
          const merged = new Uint8Array(finalLength);
          let index2 = 0;
          uint8Arrays.forEach((array) => {
            for (let i = 0; i < array.length; i++) {
              merged[index2++] = array[i];
            }
          });
          return new FbsBlob(merged, true);
        }
      }
      uploadData() {
        return this.data_;
      }
    };
    function jsonObjectOrNull(s2) {
      let obj;
      try {
        obj = JSON.parse(s2);
      } catch (e) {
        return null;
      }
      if (isNonArrayObject(obj)) {
        return obj;
      } else {
        return null;
      }
    }
    function parent(path) {
      if (path.length === 0) {
        return null;
      }
      const index2 = path.lastIndexOf("/");
      if (index2 === -1) {
        return "";
      }
      const newPath = path.slice(0, index2);
      return newPath;
    }
    function child(path, childPath) {
      const canonicalChildPath = childPath.split("/").filter((component2) => component2.length > 0).join("/");
      if (path.length === 0) {
        return canonicalChildPath;
      } else {
        return path + "/" + canonicalChildPath;
      }
    }
    function lastComponent(path) {
      const index2 = path.lastIndexOf("/", path.length - 2);
      if (index2 === -1) {
        return path;
      } else {
        return path.slice(index2 + 1);
      }
    }
    function noXform_(metadata, value) {
      return value;
    }
    var Mapping = class {
      constructor(server, local, writable3, xform) {
        this.server = server;
        this.local = local || server;
        this.writable = !!writable3;
        this.xform = xform || noXform_;
      }
    };
    var mappings_ = null;
    function xformPath(fullPath) {
      if (!isString(fullPath) || fullPath.length < 2) {
        return fullPath;
      } else {
        return lastComponent(fullPath);
      }
    }
    function getMappings() {
      if (mappings_) {
        return mappings_;
      }
      const mappings = [];
      mappings.push(new Mapping("bucket"));
      mappings.push(new Mapping("generation"));
      mappings.push(new Mapping("metageneration"));
      mappings.push(new Mapping("name", "fullPath", true));
      function mappingsXformPath(_metadata, fullPath) {
        return xformPath(fullPath);
      }
      const nameMapping = new Mapping("name");
      nameMapping.xform = mappingsXformPath;
      mappings.push(nameMapping);
      function xformSize(_metadata, size) {
        if (size !== void 0) {
          return Number(size);
        } else {
          return size;
        }
      }
      const sizeMapping = new Mapping("size");
      sizeMapping.xform = xformSize;
      mappings.push(sizeMapping);
      mappings.push(new Mapping("timeCreated"));
      mappings.push(new Mapping("updated"));
      mappings.push(new Mapping("md5Hash", null, true));
      mappings.push(new Mapping("cacheControl", null, true));
      mappings.push(new Mapping("contentDisposition", null, true));
      mappings.push(new Mapping("contentEncoding", null, true));
      mappings.push(new Mapping("contentLanguage", null, true));
      mappings.push(new Mapping("contentType", null, true));
      mappings.push(new Mapping("metadata", "customMetadata", true));
      mappings_ = mappings;
      return mappings_;
    }
    function addRef(metadata, service) {
      function generateRef() {
        const bucket = metadata["bucket"];
        const path = metadata["fullPath"];
        const loc = new Location(bucket, path);
        return service._makeStorageReference(loc);
      }
      Object.defineProperty(metadata, "ref", { get: generateRef });
    }
    function fromResource(service, resource, mappings) {
      const metadata = {};
      metadata["type"] = "file";
      const len = mappings.length;
      for (let i = 0; i < len; i++) {
        const mapping = mappings[i];
        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
      }
      addRef(metadata, service);
      return metadata;
    }
    function fromResourceString(service, resourceString, mappings) {
      const obj = jsonObjectOrNull(resourceString);
      if (obj === null) {
        return null;
      }
      const resource = obj;
      return fromResource(service, resource, mappings);
    }
    function downloadUrlFromResourceString(metadata, resourceString, host) {
      const obj = jsonObjectOrNull(resourceString);
      if (obj === null) {
        return null;
      }
      if (!isString(obj["downloadTokens"])) {
        return null;
      }
      const tokens = obj["downloadTokens"];
      if (tokens.length === 0) {
        return null;
      }
      const encode = encodeURIComponent;
      const tokensList = tokens.split(",");
      const urls = tokensList.map((token) => {
        const bucket = metadata["bucket"];
        const path = metadata["fullPath"];
        const urlPart = "/b/" + encode(bucket) + "/o/" + encode(path);
        const base = makeUrl(urlPart, host);
        const queryString = makeQueryString({
          alt: "media",
          token
        });
        return base + queryString;
      });
      return urls[0];
    }
    function toResourceString(metadata, mappings) {
      const resource = {};
      const len = mappings.length;
      for (let i = 0; i < len; i++) {
        const mapping = mappings[i];
        if (mapping.writable) {
          resource[mapping.server] = metadata[mapping.local];
        }
      }
      return JSON.stringify(resource);
    }
    var PREFIXES_KEY = "prefixes";
    var ITEMS_KEY = "items";
    function fromBackendResponse(service, bucket, resource) {
      const listResult = {
        prefixes: [],
        items: [],
        nextPageToken: resource["nextPageToken"]
      };
      if (resource[PREFIXES_KEY]) {
        for (const path of resource[PREFIXES_KEY]) {
          const pathWithoutTrailingSlash = path.replace(/\/$/, "");
          const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));
          listResult.prefixes.push(reference);
        }
      }
      if (resource[ITEMS_KEY]) {
        for (const item of resource[ITEMS_KEY]) {
          const reference = service._makeStorageReference(new Location(bucket, item["name"]));
          listResult.items.push(reference);
        }
      }
      return listResult;
    }
    function fromResponseString(service, bucket, resourceString) {
      const obj = jsonObjectOrNull(resourceString);
      if (obj === null) {
        return null;
      }
      const resource = obj;
      return fromBackendResponse(service, bucket, resource);
    }
    var RequestInfo = class {
      constructor(url, method, handler2, timeout) {
        this.url = url;
        this.method = method;
        this.handler = handler2;
        this.timeout = timeout;
        this.urlParams = {};
        this.headers = {};
        this.body = null;
        this.errorHandler = null;
        this.progressCallback = null;
        this.successCodes = [200];
        this.additionalRetryCodes = [];
      }
    };
    function handlerCheck(cndn) {
      if (!cndn) {
        throw unknown();
      }
    }
    function metadataHandler(service, mappings) {
      function handler2(xhr, text) {
        const metadata = fromResourceString(service, text, mappings);
        handlerCheck(metadata !== null);
        return metadata;
      }
      return handler2;
    }
    function listHandler(service, bucket) {
      function handler2(xhr, text) {
        const listResult = fromResponseString(service, bucket, text);
        handlerCheck(listResult !== null);
        return listResult;
      }
      return handler2;
    }
    function downloadUrlHandler(service, mappings) {
      function handler2(xhr, text) {
        const metadata = fromResourceString(service, text, mappings);
        handlerCheck(metadata !== null);
        return downloadUrlFromResourceString(metadata, text, service.host);
      }
      return handler2;
    }
    function sharedErrorHandler(location2) {
      function errorHandler(xhr, err) {
        let newErr;
        if (xhr.getStatus() === 401) {
          if (xhr.getResponseText().includes("Firebase App Check token is invalid")) {
            newErr = unauthorizedApp();
          } else {
            newErr = unauthenticated();
          }
        } else {
          if (xhr.getStatus() === 402) {
            newErr = quotaExceeded(location2.bucket);
          } else {
            if (xhr.getStatus() === 403) {
              newErr = unauthorized(location2.path);
            } else {
              newErr = err;
            }
          }
        }
        newErr.serverResponse = err.serverResponse;
        return newErr;
      }
      return errorHandler;
    }
    function objectErrorHandler(location2) {
      const shared = sharedErrorHandler(location2);
      function errorHandler(xhr, err) {
        let newErr = shared(xhr, err);
        if (xhr.getStatus() === 404) {
          newErr = objectNotFound(location2.path);
        }
        newErr.serverResponse = err.serverResponse;
        return newErr;
      }
      return errorHandler;
    }
    function getMetadata$2(service, location2, mappings) {
      const urlPart = location2.fullServerUrl();
      const url = makeUrl(urlPart, service.host);
      const method = "GET";
      const timeout = service.maxOperationRetryTime;
      const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
      requestInfo.errorHandler = objectErrorHandler(location2);
      return requestInfo;
    }
    function list$2(service, location2, delimiter, pageToken, maxResults) {
      const urlParams = {};
      if (location2.isRoot) {
        urlParams["prefix"] = "";
      } else {
        urlParams["prefix"] = location2.path + "/";
      }
      if (delimiter && delimiter.length > 0) {
        urlParams["delimiter"] = delimiter;
      }
      if (pageToken) {
        urlParams["pageToken"] = pageToken;
      }
      if (maxResults) {
        urlParams["maxResults"] = maxResults;
      }
      const urlPart = location2.bucketOnlyServerUrl();
      const url = makeUrl(urlPart, service.host);
      const method = "GET";
      const timeout = service.maxOperationRetryTime;
      const requestInfo = new RequestInfo(url, method, listHandler(service, location2.bucket), timeout);
      requestInfo.urlParams = urlParams;
      requestInfo.errorHandler = sharedErrorHandler(location2);
      return requestInfo;
    }
    function getDownloadUrl(service, location2, mappings) {
      const urlPart = location2.fullServerUrl();
      const url = makeUrl(urlPart, service.host);
      const method = "GET";
      const timeout = service.maxOperationRetryTime;
      const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
      requestInfo.errorHandler = objectErrorHandler(location2);
      return requestInfo;
    }
    function updateMetadata$2(service, location2, metadata, mappings) {
      const urlPart = location2.fullServerUrl();
      const url = makeUrl(urlPart, service.host);
      const method = "PATCH";
      const body = toResourceString(metadata, mappings);
      const headers = { "Content-Type": "application/json; charset=utf-8" };
      const timeout = service.maxOperationRetryTime;
      const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
      requestInfo.headers = headers;
      requestInfo.body = body;
      requestInfo.errorHandler = objectErrorHandler(location2);
      return requestInfo;
    }
    function deleteObject$2(service, location2) {
      const urlPart = location2.fullServerUrl();
      const url = makeUrl(urlPart, service.host);
      const method = "DELETE";
      const timeout = service.maxOperationRetryTime;
      function handler2(_xhr, _text) {
      }
      const requestInfo = new RequestInfo(url, method, handler2, timeout);
      requestInfo.successCodes = [200, 204];
      requestInfo.errorHandler = objectErrorHandler(location2);
      return requestInfo;
    }
    function determineContentType_(metadata, blob) {
      return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
    }
    function metadataForUpload_(location2, blob, metadata) {
      const metadataClone = Object.assign({}, metadata);
      metadataClone["fullPath"] = location2.path;
      metadataClone["size"] = blob.size();
      if (!metadataClone["contentType"]) {
        metadataClone["contentType"] = determineContentType_(null, blob);
      }
      return metadataClone;
    }
    function multipartUpload(service, location2, mappings, blob, metadata) {
      const urlPart = location2.bucketOnlyServerUrl();
      const headers = {
        "X-Goog-Upload-Protocol": "multipart"
      };
      function genBoundary() {
        let str = "";
        for (let i = 0; i < 2; i++) {
          str = str + Math.random().toString().slice(2);
        }
        return str;
      }
      const boundary = genBoundary();
      headers["Content-Type"] = "multipart/related; boundary=" + boundary;
      const metadata_ = metadataForUpload_(location2, blob, metadata);
      const metadataString = toResourceString(metadata_, mappings);
      const preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata_["contentType"] + "\r\n\r\n";
      const postBlobPart = "\r\n--" + boundary + "--";
      const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
      if (body === null) {
        throw cannotSliceBlob();
      }
      const urlParams = { name: metadata_["fullPath"] };
      const url = makeUrl(urlPart, service.host);
      const method = "POST";
      const timeout = service.maxUploadRetryTime;
      const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
      requestInfo.urlParams = urlParams;
      requestInfo.headers = headers;
      requestInfo.body = body.uploadData();
      requestInfo.errorHandler = sharedErrorHandler(location2);
      return requestInfo;
    }
    var ResumableUploadStatus = class {
      constructor(current, total, finalized, metadata) {
        this.current = current;
        this.total = total;
        this.finalized = !!finalized;
        this.metadata = metadata || null;
      }
    };
    function checkResumeHeader_(xhr, allowed) {
      let status = null;
      try {
        status = xhr.getResponseHeader("X-Goog-Upload-Status");
      } catch (e) {
        handlerCheck(false);
      }
      const allowedStatus = allowed || ["active"];
      handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);
      return status;
    }
    function createResumableUpload(service, location2, mappings, blob, metadata) {
      const urlPart = location2.bucketOnlyServerUrl();
      const metadataForUpload = metadataForUpload_(location2, blob, metadata);
      const urlParams = { name: metadataForUpload["fullPath"] };
      const url = makeUrl(urlPart, service.host);
      const method = "POST";
      const headers = {
        "X-Goog-Upload-Protocol": "resumable",
        "X-Goog-Upload-Command": "start",
        "X-Goog-Upload-Header-Content-Length": `${blob.size()}`,
        "X-Goog-Upload-Header-Content-Type": metadataForUpload["contentType"],
        "Content-Type": "application/json; charset=utf-8"
      };
      const body = toResourceString(metadataForUpload, mappings);
      const timeout = service.maxUploadRetryTime;
      function handler2(xhr) {
        checkResumeHeader_(xhr);
        let url2;
        try {
          url2 = xhr.getResponseHeader("X-Goog-Upload-URL");
        } catch (e) {
          handlerCheck(false);
        }
        handlerCheck(isString(url2));
        return url2;
      }
      const requestInfo = new RequestInfo(url, method, handler2, timeout);
      requestInfo.urlParams = urlParams;
      requestInfo.headers = headers;
      requestInfo.body = body;
      requestInfo.errorHandler = sharedErrorHandler(location2);
      return requestInfo;
    }
    function getResumableUploadStatus(service, location2, url, blob) {
      const headers = { "X-Goog-Upload-Command": "query" };
      function handler2(xhr) {
        const status = checkResumeHeader_(xhr, ["active", "final"]);
        let sizeString = null;
        try {
          sizeString = xhr.getResponseHeader("X-Goog-Upload-Size-Received");
        } catch (e) {
          handlerCheck(false);
        }
        if (!sizeString) {
          handlerCheck(false);
        }
        const size = Number(sizeString);
        handlerCheck(!isNaN(size));
        return new ResumableUploadStatus(size, blob.size(), status === "final");
      }
      const method = "POST";
      const timeout = service.maxUploadRetryTime;
      const requestInfo = new RequestInfo(url, method, handler2, timeout);
      requestInfo.headers = headers;
      requestInfo.errorHandler = sharedErrorHandler(location2);
      return requestInfo;
    }
    var RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;
    function continueResumableUpload(location2, service, url, blob, chunkSize, mappings, status, progressCallback) {
      const status_ = new ResumableUploadStatus(0, 0);
      if (status) {
        status_.current = status.current;
        status_.total = status.total;
      } else {
        status_.current = 0;
        status_.total = blob.size();
      }
      if (blob.size() !== status_.total) {
        throw serverFileWrongSize();
      }
      const bytesLeft = status_.total - status_.current;
      let bytesToUpload = bytesLeft;
      if (chunkSize > 0) {
        bytesToUpload = Math.min(bytesToUpload, chunkSize);
      }
      const startByte = status_.current;
      const endByte = startByte + bytesToUpload;
      const uploadCommand = bytesToUpload === bytesLeft ? "upload, finalize" : "upload";
      const headers = {
        "X-Goog-Upload-Command": uploadCommand,
        "X-Goog-Upload-Offset": `${status_.current}`
      };
      const body = blob.slice(startByte, endByte);
      if (body === null) {
        throw cannotSliceBlob();
      }
      function handler2(xhr, text) {
        const uploadStatus = checkResumeHeader_(xhr, ["active", "final"]);
        const newCurrent = status_.current + bytesToUpload;
        const size = blob.size();
        let metadata;
        if (uploadStatus === "final") {
          metadata = metadataHandler(service, mappings)(xhr, text);
        } else {
          metadata = null;
        }
        return new ResumableUploadStatus(newCurrent, size, uploadStatus === "final", metadata);
      }
      const method = "POST";
      const timeout = service.maxUploadRetryTime;
      const requestInfo = new RequestInfo(url, method, handler2, timeout);
      requestInfo.headers = headers;
      requestInfo.body = body.uploadData();
      requestInfo.progressCallback = progressCallback || null;
      requestInfo.errorHandler = sharedErrorHandler(location2);
      return requestInfo;
    }
    var Observer = class {
      constructor(nextOrObserver, error3, complete) {
        const asFunctions = isFunction(nextOrObserver) || error3 != null || complete != null;
        if (asFunctions) {
          this.next = nextOrObserver;
          this.error = error3;
          this.complete = complete;
        } else {
          const observer = nextOrObserver;
          this.next = observer.next;
          this.error = observer.error;
          this.complete = observer.complete;
        }
      }
    };
    function async(f) {
      return (...argsToForward) => {
        Promise.resolve().then(() => f(...argsToForward));
      };
    }
    var UploadTask = class {
      constructor(ref2, blob, metadata = null) {
        this._transferred = 0;
        this._needToFetchStatus = false;
        this._needToFetchMetadata = false;
        this._observers = [];
        this._error = void 0;
        this._uploadUrl = void 0;
        this._request = void 0;
        this._chunkMultiplier = 1;
        this._resolve = void 0;
        this._reject = void 0;
        this._ref = ref2;
        this._blob = blob;
        this._metadata = metadata;
        this._mappings = getMappings();
        this._resumable = this._shouldDoResumable(this._blob);
        this._state = "running";
        this._errorHandler = (error3) => {
          this._request = void 0;
          this._chunkMultiplier = 1;
          if (error3._codeEquals("canceled")) {
            this._needToFetchStatus = true;
            this.completeTransitions_();
          } else {
            this._error = error3;
            this._transition("error");
          }
        };
        this._metadataErrorHandler = (error3) => {
          this._request = void 0;
          if (error3._codeEquals("canceled")) {
            this.completeTransitions_();
          } else {
            this._error = error3;
            this._transition("error");
          }
        };
        this._promise = new Promise((resolve2, reject) => {
          this._resolve = resolve2;
          this._reject = reject;
          this._start();
        });
        this._promise.then(null, () => {
        });
      }
      _makeProgressCallback() {
        const sizeBefore = this._transferred;
        return (loaded) => this._updateProgress(sizeBefore + loaded);
      }
      _shouldDoResumable(blob) {
        return blob.size() > 256 * 1024;
      }
      _start() {
        if (this._state !== "running") {
          return;
        }
        if (this._request !== void 0) {
          return;
        }
        if (this._resumable) {
          if (this._uploadUrl === void 0) {
            this._createResumable();
          } else {
            if (this._needToFetchStatus) {
              this._fetchStatus();
            } else {
              if (this._needToFetchMetadata) {
                this._fetchMetadata();
              } else {
                this._continueUpload();
              }
            }
          }
        } else {
          this._oneShotUpload();
        }
      }
      _resolveToken(callback) {
        Promise.all([
          this._ref.storage._getAuthToken(),
          this._ref.storage._getAppCheckToken()
        ]).then(([authToken, appCheckToken]) => {
          switch (this._state) {
            case "running":
              callback(authToken, appCheckToken);
              break;
            case "canceling":
              this._transition("canceled");
              break;
            case "pausing":
              this._transition("paused");
              break;
          }
        });
      }
      _createResumable() {
        this._resolveToken((authToken, appCheckToken) => {
          const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
          const createRequest = this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
          this._request = createRequest;
          createRequest.getPromise().then((url) => {
            this._request = void 0;
            this._uploadUrl = url;
            this._needToFetchStatus = false;
            this.completeTransitions_();
          }, this._errorHandler);
        });
      }
      _fetchStatus() {
        const url = this._uploadUrl;
        this._resolveToken((authToken, appCheckToken) => {
          const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);
          const statusRequest = this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
          this._request = statusRequest;
          statusRequest.getPromise().then((status) => {
            status = status;
            this._request = void 0;
            this._updateProgress(status.current);
            this._needToFetchStatus = false;
            if (status.finalized) {
              this._needToFetchMetadata = true;
            }
            this.completeTransitions_();
          }, this._errorHandler);
        });
      }
      _continueUpload() {
        const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
        const status = new ResumableUploadStatus(this._transferred, this._blob.size());
        const url = this._uploadUrl;
        this._resolveToken((authToken, appCheckToken) => {
          let requestInfo;
          try {
            requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());
          } catch (e) {
            this._error = e;
            this._transition("error");
            return;
          }
          const uploadRequest = this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
          this._request = uploadRequest;
          uploadRequest.getPromise().then((newStatus) => {
            this._increaseMultiplier();
            this._request = void 0;
            this._updateProgress(newStatus.current);
            if (newStatus.finalized) {
              this._metadata = newStatus.metadata;
              this._transition("success");
            } else {
              this.completeTransitions_();
            }
          }, this._errorHandler);
        });
      }
      _increaseMultiplier() {
        const currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
        if (currentSize < 32 * 1024 * 1024) {
          this._chunkMultiplier *= 2;
        }
      }
      _fetchMetadata() {
        this._resolveToken((authToken, appCheckToken) => {
          const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);
          const metadataRequest = this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
          this._request = metadataRequest;
          metadataRequest.getPromise().then((metadata) => {
            this._request = void 0;
            this._metadata = metadata;
            this._transition("success");
          }, this._metadataErrorHandler);
        });
      }
      _oneShotUpload() {
        this._resolveToken((authToken, appCheckToken) => {
          const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
          const multipartRequest = this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
          this._request = multipartRequest;
          multipartRequest.getPromise().then((metadata) => {
            this._request = void 0;
            this._metadata = metadata;
            this._updateProgress(this._blob.size());
            this._transition("success");
          }, this._errorHandler);
        });
      }
      _updateProgress(transferred) {
        const old = this._transferred;
        this._transferred = transferred;
        if (this._transferred !== old) {
          this._notifyObservers();
        }
      }
      _transition(state) {
        if (this._state === state) {
          return;
        }
        switch (state) {
          case "canceling":
            this._state = state;
            if (this._request !== void 0) {
              this._request.cancel();
            }
            break;
          case "pausing":
            this._state = state;
            if (this._request !== void 0) {
              this._request.cancel();
            }
            break;
          case "running":
            const wasPaused = this._state === "paused";
            this._state = state;
            if (wasPaused) {
              this._notifyObservers();
              this._start();
            }
            break;
          case "paused":
            this._state = state;
            this._notifyObservers();
            break;
          case "canceled":
            this._error = canceled();
            this._state = state;
            this._notifyObservers();
            break;
          case "error":
            this._state = state;
            this._notifyObservers();
            break;
          case "success":
            this._state = state;
            this._notifyObservers();
            break;
        }
      }
      completeTransitions_() {
        switch (this._state) {
          case "pausing":
            this._transition("paused");
            break;
          case "canceling":
            this._transition("canceled");
            break;
          case "running":
            this._start();
            break;
        }
      }
      get snapshot() {
        const externalState = taskStateFromInternalTaskState(this._state);
        return {
          bytesTransferred: this._transferred,
          totalBytes: this._blob.size(),
          state: externalState,
          metadata: this._metadata,
          task: this,
          ref: this._ref
        };
      }
      on(type, nextOrObserver, error3, completed) {
        const observer = new Observer(nextOrObserver, error3, completed);
        this._addObserver(observer);
        return () => {
          this._removeObserver(observer);
        };
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.then(null, onRejected);
      }
      _addObserver(observer) {
        this._observers.push(observer);
        this._notifyObserver(observer);
      }
      _removeObserver(observer) {
        const i = this._observers.indexOf(observer);
        if (i !== -1) {
          this._observers.splice(i, 1);
        }
      }
      _notifyObservers() {
        this._finishPromise();
        const observers = this._observers.slice();
        observers.forEach((observer) => {
          this._notifyObserver(observer);
        });
      }
      _finishPromise() {
        if (this._resolve !== void 0) {
          let triggered = true;
          switch (taskStateFromInternalTaskState(this._state)) {
            case TaskState.SUCCESS:
              async(this._resolve.bind(null, this.snapshot))();
              break;
            case TaskState.CANCELED:
            case TaskState.ERROR:
              const toCall = this._reject;
              async(toCall.bind(null, this._error))();
              break;
            default:
              triggered = false;
              break;
          }
          if (triggered) {
            this._resolve = void 0;
            this._reject = void 0;
          }
        }
      }
      _notifyObserver(observer) {
        const externalState = taskStateFromInternalTaskState(this._state);
        switch (externalState) {
          case TaskState.RUNNING:
          case TaskState.PAUSED:
            if (observer.next) {
              async(observer.next.bind(observer, this.snapshot))();
            }
            break;
          case TaskState.SUCCESS:
            if (observer.complete) {
              async(observer.complete.bind(observer))();
            }
            break;
          case TaskState.CANCELED:
          case TaskState.ERROR:
            if (observer.error) {
              async(observer.error.bind(observer, this._error))();
            }
            break;
          default:
            if (observer.error) {
              async(observer.error.bind(observer, this._error))();
            }
        }
      }
      resume() {
        const valid = this._state === "paused" || this._state === "pausing";
        if (valid) {
          this._transition("running");
        }
        return valid;
      }
      pause() {
        const valid = this._state === "running";
        if (valid) {
          this._transition("pausing");
        }
        return valid;
      }
      cancel() {
        const valid = this._state === "running" || this._state === "pausing";
        if (valid) {
          this._transition("canceling");
        }
        return valid;
      }
    };
    var Reference = class {
      constructor(_service, location2) {
        this._service = _service;
        if (location2 instanceof Location) {
          this._location = location2;
        } else {
          this._location = Location.makeFromUrl(location2, _service.host);
        }
      }
      toString() {
        return "gs://" + this._location.bucket + "/" + this._location.path;
      }
      _newRef(service, location2) {
        return new Reference(service, location2);
      }
      get root() {
        const location2 = new Location(this._location.bucket, "");
        return this._newRef(this._service, location2);
      }
      get bucket() {
        return this._location.bucket;
      }
      get fullPath() {
        return this._location.path;
      }
      get name() {
        return lastComponent(this._location.path);
      }
      get storage() {
        return this._service;
      }
      get parent() {
        const newPath = parent(this._location.path);
        if (newPath === null) {
          return null;
        }
        const location2 = new Location(this._location.bucket, newPath);
        return new Reference(this._service, location2);
      }
      _throwIfRoot(name2) {
        if (this._location.path === "") {
          throw invalidRootOperation(name2);
        }
      }
    };
    function uploadBytesResumable$1(ref2, data, metadata) {
      ref2._throwIfRoot("uploadBytesResumable");
      return new UploadTask(ref2, new FbsBlob(data), metadata);
    }
    function listAll$1(ref2) {
      const accumulator = {
        prefixes: [],
        items: []
      };
      return listAllHelper(ref2, accumulator).then(() => accumulator);
    }
    async function listAllHelper(ref2, accumulator, pageToken) {
      const opt = {
        pageToken
      };
      const nextPage = await list$1(ref2, opt);
      accumulator.prefixes.push(...nextPage.prefixes);
      accumulator.items.push(...nextPage.items);
      if (nextPage.nextPageToken != null) {
        await listAllHelper(ref2, accumulator, nextPage.nextPageToken);
      }
    }
    async function list$1(ref2, options2) {
      if (options2 != null) {
        if (typeof options2.maxResults === "number") {
          validateNumber("options.maxResults", 1, 1e3, options2.maxResults);
        }
      }
      const op = options2 || {};
      const requestInfo = list$2(ref2.storage, ref2._location, "/", op.pageToken, op.maxResults);
      return (await ref2.storage.makeRequestWithTokens(requestInfo)).getPromise();
    }
    async function getMetadata$1(ref2) {
      ref2._throwIfRoot("getMetadata");
      const requestInfo = getMetadata$2(ref2.storage, ref2._location, getMappings());
      return (await ref2.storage.makeRequestWithTokens(requestInfo)).getPromise();
    }
    async function updateMetadata$1(ref2, metadata) {
      ref2._throwIfRoot("updateMetadata");
      const requestInfo = updateMetadata$2(ref2.storage, ref2._location, metadata, getMappings());
      return (await ref2.storage.makeRequestWithTokens(requestInfo)).getPromise();
    }
    async function getDownloadURL$1(ref2) {
      ref2._throwIfRoot("getDownloadURL");
      const requestInfo = getDownloadUrl(ref2.storage, ref2._location, getMappings());
      return (await ref2.storage.makeRequestWithTokens(requestInfo)).getPromise().then((url) => {
        if (url === null) {
          throw noDownloadURL();
        }
        return url;
      });
    }
    async function deleteObject$1(ref2) {
      ref2._throwIfRoot("deleteObject");
      const requestInfo = deleteObject$2(ref2.storage, ref2._location);
      return (await ref2.storage.makeRequestWithTokens(requestInfo)).getPromise();
    }
    function _getChild$1(ref2, childPath) {
      const newPath = child(ref2._location.path, childPath);
      const location2 = new Location(ref2._location.bucket, newPath);
      return new Reference(ref2.storage, location2);
    }
    function isUrl(path) {
      return /^[A-Za-z]+:\/\//.test(path);
    }
    function refFromURL(service, url) {
      return new Reference(service, url);
    }
    function refFromPath(ref2, path) {
      if (ref2 instanceof FirebaseStorageImpl) {
        const service = ref2;
        if (service._bucket == null) {
          throw noDefaultBucket();
        }
        const reference = new Reference(service, service._bucket);
        if (path != null) {
          return refFromPath(reference, path);
        } else {
          return reference;
        }
      } else {
        if (path !== void 0) {
          if (path.includes("..")) {
            throw invalidArgument('`path` param cannot contain ".."');
          }
          return _getChild$1(ref2, path);
        } else {
          return ref2;
        }
      }
    }
    function ref$1(serviceOrRef, pathOrUrl) {
      if (pathOrUrl && isUrl(pathOrUrl)) {
        if (serviceOrRef instanceof FirebaseStorageImpl) {
          return refFromURL(serviceOrRef, pathOrUrl);
        } else {
          throw invalidArgument("To use ref(service, url), the first argument must be a Storage instance.");
        }
      } else {
        return refFromPath(serviceOrRef, pathOrUrl);
      }
    }
    function extractBucket(host, config) {
      const bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];
      if (bucketString == null) {
        return null;
      }
      return Location.makeFromBucketSpec(bucketString, host);
    }
    function connectStorageEmulator$1(storage, host, port) {
      storage.host = `http://${host}:${port}`;
    }
    var FirebaseStorageImpl = class {
      constructor(app, _authProvider, _appCheckProvider, _pool, _url, _firebaseVersion) {
        this.app = app;
        this._authProvider = _authProvider;
        this._appCheckProvider = _appCheckProvider;
        this._pool = _pool;
        this._url = _url;
        this._firebaseVersion = _firebaseVersion;
        this._bucket = null;
        this._host = DEFAULT_HOST;
        this._appId = null;
        this._deleted = false;
        this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
        this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
        this._requests = new Set();
        if (_url != null) {
          this._bucket = Location.makeFromBucketSpec(_url, this._host);
        } else {
          this._bucket = extractBucket(this._host, this.app.options);
        }
      }
      get host() {
        return this._host;
      }
      set host(host) {
        this._host = host;
        if (this._url != null) {
          this._bucket = Location.makeFromBucketSpec(this._url, host);
        } else {
          this._bucket = extractBucket(host, this.app.options);
        }
      }
      get maxUploadRetryTime() {
        return this._maxUploadRetryTime;
      }
      set maxUploadRetryTime(time) {
        validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
        this._maxUploadRetryTime = time;
      }
      get maxOperationRetryTime() {
        return this._maxOperationRetryTime;
      }
      set maxOperationRetryTime(time) {
        validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
        this._maxOperationRetryTime = time;
      }
      async _getAuthToken() {
        const auth2 = this._authProvider.getImmediate({ optional: true });
        if (auth2) {
          const tokenData = await auth2.getToken();
          if (tokenData !== null) {
            return tokenData.accessToken;
          }
        }
        return null;
      }
      async _getAppCheckToken() {
        const appCheck = this._appCheckProvider.getImmediate({ optional: true });
        if (appCheck) {
          const result = await appCheck.getToken();
          return result.token;
        }
        return null;
      }
      _delete() {
        if (!this._deleted) {
          this._deleted = true;
          this._requests.forEach((request) => request.cancel());
          this._requests.clear();
        }
        return Promise.resolve();
      }
      _makeStorageReference(loc) {
        return new Reference(this, loc);
      }
      _makeRequest(requestInfo, authToken, appCheckToken) {
        if (!this._deleted) {
          const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, this._pool, this._firebaseVersion);
          this._requests.add(request);
          request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));
          return request;
        } else {
          return new FailRequest(appDeleted());
        }
      }
      async makeRequestWithTokens(requestInfo) {
        const [authToken, appCheckToken] = await Promise.all([
          this._getAuthToken(),
          this._getAppCheckToken()
        ]);
        return this._makeRequest(requestInfo, authToken, appCheckToken);
      }
    };
    function uploadBytesResumable(ref2, data, metadata) {
      ref2 = util.getModularInstance(ref2);
      return uploadBytesResumable$1(ref2, data, metadata);
    }
    function getMetadata(ref2) {
      ref2 = util.getModularInstance(ref2);
      return getMetadata$1(ref2);
    }
    function updateMetadata(ref2, metadata) {
      ref2 = util.getModularInstance(ref2);
      return updateMetadata$1(ref2, metadata);
    }
    function list(ref2, options2) {
      ref2 = util.getModularInstance(ref2);
      return list$1(ref2, options2);
    }
    function listAll(ref2) {
      ref2 = util.getModularInstance(ref2);
      return listAll$1(ref2);
    }
    function getDownloadURL(ref2) {
      ref2 = util.getModularInstance(ref2);
      return getDownloadURL$1(ref2);
    }
    function deleteObject(ref2) {
      ref2 = util.getModularInstance(ref2);
      return deleteObject$1(ref2);
    }
    function ref(serviceOrRef, pathOrUrl) {
      serviceOrRef = util.getModularInstance(serviceOrRef);
      return ref$1(serviceOrRef, pathOrUrl);
    }
    function _getChild(ref2, childPath) {
      return _getChild$1(ref2, childPath);
    }
    function connectStorageEmulator(storage, host, port) {
      connectStorageEmulator$1(storage, host, port);
    }
    var UploadTaskSnapshotCompat = class {
      constructor(_delegate, task, ref2) {
        this._delegate = _delegate;
        this.task = task;
        this.ref = ref2;
      }
      get bytesTransferred() {
        return this._delegate.bytesTransferred;
      }
      get metadata() {
        return this._delegate.metadata;
      }
      get state() {
        return this._delegate.state;
      }
      get totalBytes() {
        return this._delegate.totalBytes;
      }
    };
    var UploadTaskCompat = class {
      constructor(_delegate, _ref) {
        this._delegate = _delegate;
        this._ref = _ref;
        this.cancel = this._delegate.cancel.bind(this._delegate);
        this.catch = this._delegate.catch.bind(this._delegate);
        this.pause = this._delegate.pause.bind(this._delegate);
        this.resume = this._delegate.resume.bind(this._delegate);
      }
      get snapshot() {
        return new UploadTaskSnapshotCompat(this._delegate.snapshot, this, this._ref);
      }
      then(onFulfilled, onRejected) {
        return this._delegate.then((snapshot) => {
          if (onFulfilled) {
            return onFulfilled(new UploadTaskSnapshotCompat(snapshot, this, this._ref));
          }
        }, onRejected);
      }
      on(type, nextOrObserver, error3, completed) {
        let wrappedNextOrObserver = void 0;
        if (!!nextOrObserver) {
          if (typeof nextOrObserver === "function") {
            wrappedNextOrObserver = (taskSnapshot) => nextOrObserver(new UploadTaskSnapshotCompat(taskSnapshot, this, this._ref));
          } else {
            wrappedNextOrObserver = {
              next: !!nextOrObserver.next ? (taskSnapshot) => nextOrObserver.next(new UploadTaskSnapshotCompat(taskSnapshot, this, this._ref)) : void 0,
              complete: nextOrObserver.complete || void 0,
              error: nextOrObserver.error || void 0
            };
          }
        }
        return this._delegate.on(type, wrappedNextOrObserver, error3 || void 0, completed || void 0);
      }
    };
    var ListResultCompat = class {
      constructor(_delegate, _service) {
        this._delegate = _delegate;
        this._service = _service;
      }
      get prefixes() {
        return this._delegate.prefixes.map((ref2) => new ReferenceCompat(ref2, this._service));
      }
      get items() {
        return this._delegate.items.map((ref2) => new ReferenceCompat(ref2, this._service));
      }
      get nextPageToken() {
        return this._delegate.nextPageToken || null;
      }
    };
    var ReferenceCompat = class {
      constructor(_delegate, storage) {
        this._delegate = _delegate;
        this.storage = storage;
      }
      get name() {
        return this._delegate.name;
      }
      get bucket() {
        return this._delegate.bucket;
      }
      get fullPath() {
        return this._delegate.fullPath;
      }
      toString() {
        return this._delegate.toString();
      }
      child(childPath) {
        const reference = _getChild(this._delegate, childPath);
        return new ReferenceCompat(reference, this.storage);
      }
      get root() {
        return new ReferenceCompat(this._delegate.root, this.storage);
      }
      get parent() {
        const reference = this._delegate.parent;
        if (reference == null) {
          return null;
        }
        return new ReferenceCompat(reference, this.storage);
      }
      put(data, metadata) {
        this._throwIfRoot("put");
        return new UploadTaskCompat(uploadBytesResumable(this._delegate, data, metadata), this);
      }
      putString(value, format2 = StringFormat.RAW, metadata) {
        this._throwIfRoot("putString");
        const data = dataFromString(format2, value);
        const metadataClone = Object.assign({}, metadata);
        if (metadataClone["contentType"] == null && data.contentType != null) {
          metadataClone["contentType"] = data.contentType;
        }
        return new UploadTaskCompat(new UploadTask(this._delegate, new FbsBlob(data.data, true), metadataClone), this);
      }
      listAll() {
        return listAll(this._delegate).then((r) => new ListResultCompat(r, this.storage));
      }
      list(options2) {
        return list(this._delegate, options2 || void 0).then((r) => new ListResultCompat(r, this.storage));
      }
      getMetadata() {
        return getMetadata(this._delegate);
      }
      updateMetadata(metadata) {
        return updateMetadata(this._delegate, metadata);
      }
      getDownloadURL() {
        return getDownloadURL(this._delegate);
      }
      delete() {
        this._throwIfRoot("delete");
        return deleteObject(this._delegate);
      }
      _throwIfRoot(name2) {
        if (this._delegate._location.path === "") {
          throw invalidRootOperation(name2);
        }
      }
    };
    var StorageServiceCompat = class {
      constructor(app, _delegate) {
        this.app = app;
        this._delegate = _delegate;
      }
      get maxOperationRetryTime() {
        return this._delegate.maxOperationRetryTime;
      }
      get maxUploadRetryTime() {
        return this._delegate.maxUploadRetryTime;
      }
      ref(path) {
        if (isUrl(path)) {
          throw invalidArgument("ref() expected a child path but got a URL, use refFromURL instead.");
        }
        return new ReferenceCompat(ref(this._delegate, path), this);
      }
      refFromURL(url) {
        if (!isUrl(url)) {
          throw invalidArgument("refFromURL() expected a full URL but got a child path, use ref() instead.");
        }
        try {
          Location.makeFromUrl(url, this._delegate.host);
        } catch (e) {
          throw invalidArgument("refFromUrl() expected a valid full URL but got an invalid one.");
        }
        return new ReferenceCompat(ref(this._delegate, url), this);
      }
      setMaxUploadRetryTime(time) {
        this._delegate.maxUploadRetryTime = time;
      }
      setMaxOperationRetryTime(time) {
        this._delegate.maxOperationRetryTime = time;
      }
      useEmulator(host, port) {
        connectStorageEmulator(this._delegate, host, port);
      }
    };
    var name = "@firebase/storage";
    var version = "0.6.2";
    var STORAGE_TYPE = "storage";
    function factory(container, { instanceIdentifier: url }) {
      const app = container.getProvider("app").getImmediate();
      const authProvider = container.getProvider("auth-internal");
      const appCheckProvider = container.getProvider("app-check-internal");
      const storageServiceCompat = new StorageServiceCompat(app, new FirebaseStorageImpl(app, authProvider, appCheckProvider, new ConnectionPool(), url, firebase__default["default"].SDK_VERSION));
      return storageServiceCompat;
    }
    function registerStorage(instance) {
      const namespaceExports = {
        TaskState,
        TaskEvent,
        StringFormat,
        Storage: FirebaseStorageImpl,
        Reference: ReferenceCompat
      };
      instance.INTERNAL.registerComponent(new component.Component(STORAGE_TYPE, factory, "PUBLIC").setServiceProps(namespaceExports).setMultipleInstances(true));
      instance.registerVersion(name, version);
    }
    registerStorage(firebase__default["default"]);
    exports2.registerStorage = registerStorage;
  }
});

// node_modules/firebase/dist/index.node.cjs.js
var require_index_node_cjs6 = __commonJS({
  "node_modules/firebase/dist/index.node.cjs.js"(exports2, module2) {
    init_shims();
    "use strict";
    var firebase2 = require_index_node_cjs2();
    require_auth();
    require_index_node_cjs3();
    require_node_cjs();
    require_bundle();
    require_index_node_cjs4();
    require_index_node_cjs5();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var firebase__default = /* @__PURE__ */ _interopDefaultLegacy(firebase2);
    var name$1 = "firebase";
    var version$1 = "8.9.0";
    firebase__default["default"].registerVersion(name$1, version$1, "app");
    firebase__default["default"].SDK_VERSION = version$1;
    var name = "firebase";
    var version = "8.9.0";
    firebase__default["default"].registerVersion(name, version, "node");
    module2.exports = firebase__default["default"];
  }
});

// .svelte-kit/netlify/entry.js
__export(exports, {
  handler: () => handler
});
init_shims();

// .svelte-kit/output/server/app.js
init_shims();

// node_modules/@sveltejs/kit/dist/ssr.js
init_shims();

// node_modules/@sveltejs/kit/dist/adapter-utils.js
init_shims();
function isContentTypeTextual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}

// node_modules/@sveltejs/kit/dist/ssr.js
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s2) {
  return typeof s2 === "string" || s2 instanceof String;
}
async function render_endpoint(request, route) {
  const mod = await route.load();
  const handler2 = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler2) {
    return;
  }
  const match = route.pattern.exec(request.path);
  if (!match) {
    return error("could not parse parameters from request path");
  }
  const params = route.params(match);
  const response = await handler2({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = headers["content-type"];
  const is_type_textual = isContentTypeTextual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = { ...headers, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  options: options2,
  $session,
  page_config,
  status,
  error: error3,
  branch,
  page
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error3) {
    error3.stack = options2.get_stack(error3);
  }
  if (branch) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error4) => {
      throw new Error(`Failed to serialize session data: ${error4.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error3)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page && page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page && page.path)},
						query: new URLSearchParams(${page ? s$1(page.query.toString()) : ""}),
						params: ${page && s$1(page.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url="${url}"`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n			")}
		`.replace(/^\t{2}/gm, "");
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error3) {
  if (!error3)
    return null;
  let serialized = try_serialize(error3);
  if (!serialized) {
    const { name, message, stack } = error3;
    serialized = try_serialize({ ...error3, name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error3 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error3 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error3}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error3 };
    }
    return { status, error: error3 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
var absolute = /^([a-z]+:)?\/?\//;
function resolve(base, path) {
  const base_match = absolute.exec(base);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base}"`);
  }
  const baseparts = path_match ? [] : base.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  context,
  is_leaf,
  is_error,
  status,
  error: error3
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let loaded;
  if (module2.load) {
    const load_input = {
      page,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const filename = resolved.replace(options2.paths.assets, "").slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d2) => d2.file === filename || d2.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? {
              "content-type": asset.type
            } : {}
          }) : await fetch(`http://${page.host}/${asset.file}`, opts);
        } else if (resolved.startsWith(options2.paths.base || "/") && !resolved.startsWith("//")) {
          const relative = resolved.replace(options2.paths.base, "");
          const headers = { ...opts.headers };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body,
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.serverFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 !== "etag" && key2 !== "set-cookie")
                    headers[key2] = value;
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      context: { ...context }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error3;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    uses_credentials
  };
}
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function coalesce_to_error(err) {
  return err instanceof Error ? err : new Error(JSON.stringify(err));
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error3 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    context: {},
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      context: loaded ? loaded.context : {},
      is_leaf: false,
      is_error: true,
      status,
      error: error3
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error3,
      branch,
      page
    });
  } catch (err) {
    const error4 = coalesce_to_error(err);
    options2.handle_error(error4);
    return {
      status: 500,
      headers: {},
      body: error4.stack
    };
  }
}
async function respond$1({ request, options: options2, state, $session, route }) {
  const match = route.pattern.exec(request.path);
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id ? options2.load_component(id) : void 0));
  } catch (err) {
    const error4 = coalesce_to_error(err);
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  const page_config = {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: ""
    };
  }
  let branch;
  let status = 200;
  let error3;
  ssr:
    if (page_config.ssr) {
      let context = {};
      branch = [];
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              request,
              options: options2,
              state,
              route,
              page,
              node,
              $session,
              context,
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            if (loaded.loaded.redirect) {
              return {
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              };
            }
            if (loaded.loaded.error) {
              ({ status, error: error3 } = loaded.loaded);
            } else {
              branch.push(loaded);
            }
          } catch (err) {
            const e = coalesce_to_error(err);
            options2.handle_error(e);
            status = 500;
            error3 = e;
          }
          if (error3) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                let error_loaded;
                try {
                  error_loaded = await load_node({
                    request,
                    options: options2,
                    state,
                    route,
                    page,
                    node: error_node,
                    $session,
                    context: node_loaded.context,
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error3
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e = coalesce_to_error(err);
                  options2.handle_error(e);
                  continue;
                }
              }
            }
            return await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error3
            });
          }
        }
        if (loaded && loaded.loaded.context) {
          context = {
            ...context,
            ...loaded.loaded.context
          };
        }
      }
    }
  try {
    return await render_response({
      options: options2,
      $session,
      page_config,
      status,
      error: error3,
      branch: branch && branch.filter(Boolean),
      page
    });
  } catch (err) {
    const error4 = coalesce_to_error(err);
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
}
async function render_page(request, route, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        (map.get(key) || []).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  #map;
  constructor(map) {
    this.#map = map;
  }
  get(key) {
    const value = this.#map.get(key);
    return value && value[0];
  }
  getAll(key) {
    return this.#map.get(key);
  }
  has(key) {
    return this.#map.has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key] of this.#map)
      yield key;
  }
  *values() {
    for (const [, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield value[i];
      }
    }
  }
};
function parse_body(raw, headers) {
  if (!raw || typeof raw !== "string")
    return raw;
  const [type, ...directives] = headers["content-type"].split(/;\s*/);
  switch (type) {
    case "text/plain":
      return raw;
    case "application/json":
      return JSON.parse(raw);
    case "application/x-www-form-urlencoded":
      return get_urlencoded(raw);
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(raw, boundary.slice("boundary=".length));
    }
    default:
      throw new Error(`Invalid Content-Type ${type}`);
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: encodeURI(path + (q ? `?${q}` : ""))
        }
      };
    }
  }
  try {
    const headers = lowercase_keys(incoming.headers);
    return await options2.hooks.handle({
      request: {
        ...incoming,
        headers,
        body: parse_body(incoming.rawBody, headers),
        params: {},
        locals: {}
      },
      resolve: async (request) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        for (const route of options2.manifest.routes) {
          if (!route.pattern.test(request.path))
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request, route) : await render_page(request, route, options2, state);
          if (response) {
            if (response.status === 200) {
              if (!/(no-store|immutable)/.test(response.headers["cache-control"])) {
                const etag = `"${hash(response.body || "")}"`;
                if (request.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: ""
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request);
        return await respond_with_error({
          request,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request.path}`)
        });
      }
    });
  } catch (err) {
    const e = coalesce_to_error(err);
    options2.handle_error(e);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}

// .svelte-kit/output/server/app.js
var import_firebase = __toModule(require_index_node_cjs6());
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal2(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
Promise.resolve();
var escaped2 = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape2(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : context || []),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
}
function afterUpdate() {
}
var css$c = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$c);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="es">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="/favicon.png" />\n		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous">\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
var options = null;
var default_settings = { paths: { "base": "", "assets": "/." } };
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-647a34da.js",
      css: ["/./_app/assets/start-a8cd1609.css"],
      js: ["/./_app/start-647a34da.js", "/./_app/chunks/vendor-1554e238.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error22) => String(error22),
    handle_error: (error22) => {
      if (error22.frame) {
        console.error(error22.frame);
      }
      console.error(error22.stack);
      error22.stack = options.get_stack(error22);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var d = decodeURIComponent;
var empty = () => ({});
var manifest = {
  assets: [{ "file": "favicon.png", "size": 12848, "type": "image/png" }, { "file": "img/banner.jpg", "size": 243049, "type": "image/jpeg" }, { "file": "img/bg_1.jpg", "size": 157630, "type": "image/jpeg" }, { "file": "img/bg_2.jpg", "size": 169300, "type": "image/jpeg" }, { "file": "img/bg_3.jpg", "size": 118928, "type": "image/jpeg" }, { "file": "img/logo_1.png", "size": 27947, "type": "image/png" }, { "file": "img/logo_2.png", "size": 41259, "type": "image/png" }, { "file": "img/preview.jpg", "size": 283963, "type": "image/jpeg" }],
  layout: "src/routes/__layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/aggreceta\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/aggreceta.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/register\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/register.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/profile\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/profile.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/recipes\/([^/]+?)\/?$/,
      params: (m) => ({ id: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/recipes/[id].svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/admin\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/admin.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/login\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/login.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
  serverFetch: hooks.serverFetch || fetch
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error2;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/aggreceta.svelte": () => Promise.resolve().then(function() {
    return aggreceta;
  }),
  "src/routes/register.svelte": () => Promise.resolve().then(function() {
    return register;
  }),
  "src/routes/profile.svelte": () => Promise.resolve().then(function() {
    return profile;
  }),
  "src/routes/recipes/[id].svelte": () => Promise.resolve().then(function() {
    return _id_;
  }),
  "src/routes/admin.svelte": () => Promise.resolve().then(function() {
    return admin;
  }),
  "src/routes/login.svelte": () => Promise.resolve().then(function() {
    return login;
  })
};
var metadata_lookup = { "src/routes/__layout.svelte": { "entry": "/./_app/pages/__layout.svelte-ab8d9d3e.js", "css": ["/./_app/assets/pages/__layout.svelte-5a3fe004.css"], "js": ["/./_app/pages/__layout.svelte-ab8d9d3e.js", "/./_app/chunks/vendor-1554e238.js", "/./_app/chunks/store-5d8306f7.js", "/./_app/chunks/firebase-ceae66eb.js"], "styles": [] }, ".svelte-kit/build/components/error.svelte": { "entry": "/./_app/error.svelte-03fe4b80.js", "css": [], "js": ["/./_app/error.svelte-03fe4b80.js", "/./_app/chunks/vendor-1554e238.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "/./_app/pages/index.svelte-f0e2cd88.js", "css": ["/./_app/assets/pages/index.svelte-0bea6511.css", "/./_app/assets/recipeCard-1cfc7f69.css"], "js": ["/./_app/pages/index.svelte-f0e2cd88.js", "/./_app/chunks/vendor-1554e238.js", "/./_app/chunks/recipeCard-d5c28719.js", "/./_app/chunks/store-5d8306f7.js"], "styles": [] }, "src/routes/aggreceta.svelte": { "entry": "/./_app/pages/aggreceta.svelte-b83f9793.js", "css": ["/./_app/assets/pages/aggreceta.svelte-b7616d81.css"], "js": ["/./_app/pages/aggreceta.svelte-b83f9793.js", "/./_app/chunks/vendor-1554e238.js", "/./_app/chunks/firebase-ceae66eb.js", "/./_app/chunks/store-5d8306f7.js"], "styles": [] }, "src/routes/register.svelte": { "entry": "/./_app/pages/register.svelte-c164c084.js", "css": ["/./_app/assets/pages/register.svelte-42a86734.css"], "js": ["/./_app/pages/register.svelte-c164c084.js", "/./_app/chunks/vendor-1554e238.js", "/./_app/chunks/firebase-ceae66eb.js"], "styles": [] }, "src/routes/profile.svelte": { "entry": "/./_app/pages/profile.svelte-aebe0330.js", "css": ["/./_app/assets/pages/profile.svelte-20d059e5.css", "/./_app/assets/recipeCard-1cfc7f69.css"], "js": ["/./_app/pages/profile.svelte-aebe0330.js", "/./_app/chunks/vendor-1554e238.js", "/./_app/chunks/recipeCard-d5c28719.js", "/./_app/chunks/firebase-ceae66eb.js", "/./_app/chunks/store-5d8306f7.js"], "styles": [] }, "src/routes/recipes/[id].svelte": { "entry": "/./_app/pages/recipes/[id].svelte-80f22ec9.js", "css": ["/./_app/assets/pages/recipes/[id].svelte-62e7bdce.css"], "js": ["/./_app/pages/recipes/[id].svelte-80f22ec9.js", "/./_app/chunks/vendor-1554e238.js", "/./_app/chunks/store-5d8306f7.js", "/./_app/chunks/firebase-ceae66eb.js"], "styles": [] }, "src/routes/admin.svelte": { "entry": "/./_app/pages/admin.svelte-bed470a4.js", "css": ["/./_app/assets/pages/admin.svelte-ac7dbccf.css"], "js": ["/./_app/pages/admin.svelte-bed470a4.js", "/./_app/chunks/vendor-1554e238.js", "/./_app/chunks/firebase-ceae66eb.js", "/./_app/chunks/store-5d8306f7.js"], "styles": [] }, "src/routes/login.svelte": { "entry": "/./_app/pages/login.svelte-b7daa7df.js", "css": ["/./_app/assets/pages/login.svelte-81f0f799.css"], "js": ["/./_app/pages/login.svelte-b7daa7df.js", "/./_app/chunks/vendor-1554e238.js", "/./_app/chunks/store-5d8306f7.js", "/./_app/chunks/firebase-ceae66eb.js"], "styles": [] } };
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
var css$b = {
  code: "nav.svelte-leenum.svelte-leenum.svelte-leenum{background:#f05a28;display:flex;justify-content:flex-end;align-items:center;height:65px;position:sticky;top:0;z-index:5}nav.svelte-leenum .logoContainer.svelte-leenum.svelte-leenum{display:flex;justify-content:center;align-items:center;position:absolute;left:15px;text-decoration:none}nav.svelte-leenum .logoContainer img.svelte-leenum.svelte-leenum{width:50px;margin-right:8px}nav.svelte-leenum .logoContainer span.svelte-leenum.svelte-leenum{color:white;font-family:'Bad Script', cursive;font-size:1.5em}#nav-container.svelte-leenum.svelte-leenum.svelte-leenum{position:fixed;height:100vh;width:100%;pointer-events:none;z-index:20}#nav-container.svelte-leenum:focus-within .button.svelte-leenum.svelte-leenum{pointer-events:none}#nav-container.svelte-leenum:focus-within .icon-bar.svelte-leenum.svelte-leenum:nth-of-type(1){transform:translate3d(0, 8px, 0) rotate(45deg)}#nav-container.svelte-leenum:focus-within .icon-bar.svelte-leenum.svelte-leenum:nth-of-type(2){opacity:0}#nav-container.svelte-leenum:focus-within .icon-bar.svelte-leenum.svelte-leenum:nth-of-type(3){transform:translate3d(0, -8px, 0) rotate(-45deg)}#nav-container.svelte-leenum:focus-within #nav-content.svelte-leenum.svelte-leenum{transform:none}.button.svelte-leenum.svelte-leenum.svelte-leenum{position:absolute;top:-65px;right:20px;display:flex;flex-direction:column;justify-content:center;z-index:1;-webkit-appearance:none;border:0;background:transparent;border-radius:0;height:65px;width:30px;cursor:pointer;pointer-events:auto;touch-action:manipulation;-webkit-tap-highlight-color:rgba(0, 0, 0, 0)}.button.svelte-leenum .icon-bar.svelte-leenum.svelte-leenum{display:block;width:100%;height:3px;background:white;transition:0.3s}.button.svelte-leenum .icon-bar.svelte-leenum+.icon-bar.svelte-leenum{margin-top:5px}#nav-content.svelte-leenum.svelte-leenum.svelte-leenum{width:90%;max-width:300px;position:absolute;top:0;right:0;height:100%;background:#f05a28;pointer-events:auto;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);transform:translateX(100%);transition:transform 0.3s;will-change:transform;contain:paint;z-index:30}#nav-content.svelte-leenum ul.svelte-leenum.svelte-leenum{height:100%;display:flex;flex-direction:column}#nav-content.svelte-leenum li.svelte-leenum.svelte-leenum{padding:10px 20px}#nav-content.svelte-leenum li.svelte-leenum.svelte-leenum:hover{background-color:white;transition:all 0.2s}#nav-content.svelte-leenum li:hover a.svelte-leenum.svelte-leenum{color:#f05a28;transition:color 0.2s}#nav-content.svelte-leenum li a.svelte-leenum.svelte-leenum{padding:10px 5px;display:block;text-transform:uppercase}a.svelte-leenum.svelte-leenum.svelte-leenum,a.svelte-leenum.svelte-leenum.svelte-leenum:visited,a.svelte-leenum.svelte-leenum.svelte-leenum:focus,a.svelte-leenum.svelte-leenum.svelte-leenum:active,a.svelte-leenum.svelte-leenum.svelte-leenum:link{text-decoration:none;outline:0}a.svelte-leenum.svelte-leenum.svelte-leenum{color:white;transition:0.2s ease-in-out}ul.svelte-leenum.svelte-leenum.svelte-leenum{padding:0;list-style:none}",
  map: `{"version":3,"file":"inactiveNav.svelte","sources":["inactiveNav.svelte"],"sourcesContent":["<nav>\\n\\t<a href=\\"/\\" class=\\"logoContainer\\">\\n\\t\\t<img src=\\"./img/logo_1.png\\" alt=\\"RecipeTime Logo\\" />\\n\\t\\t<span>RecipeTime</span>\\n\\t</a>\\n</nav>\\n<div id=\\"nav-container\\">\\n\\t<div class=\\"button\\" tabindex=\\"0\\">\\n\\t\\t<span class=\\"icon-bar\\" />\\n\\t\\t<span class=\\"icon-bar\\" />\\n\\t\\t<span class=\\"icon-bar\\" />\\n\\t</div>\\n\\t<div id=\\"nav-content\\" tabindex=\\"0\\">\\n\\t\\t<ul>\\n\\t\\t\\t<li><a href=\\"/\\">Inicio</a></li>\\n\\t\\t\\t<li><a href=\\"/login\\">Iniciar Sesion</a></li>\\n\\t\\t\\t<li><a href=\\"/register\\">Registrarse</a></li>\\n\\t\\t</ul>\\n\\t</div>\\n</div>\\n\\n\\n\\n\\n<style lang=\\"scss\\">nav {\\n  background: #f05a28;\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: center;\\n  height: 65px;\\n  position: sticky;\\n  top: 0;\\n  z-index: 5; }\\n  nav .logoContainer {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    position: absolute;\\n    left: 15px;\\n    text-decoration: none; }\\n    nav .logoContainer img {\\n      width: 50px;\\n      margin-right: 8px; }\\n    nav .logoContainer span {\\n      color: white;\\n      font-family: 'Bad Script', cursive;\\n      font-size: 1.5em; }\\n\\n#nav-container {\\n  position: fixed;\\n  height: 100vh;\\n  width: 100%;\\n  pointer-events: none;\\n  z-index: 20; }\\n  #nav-container:focus-within .button {\\n    pointer-events: none; }\\n  #nav-container:focus-within .icon-bar:nth-of-type(1) {\\n    transform: translate3d(0, 8px, 0) rotate(45deg); }\\n  #nav-container:focus-within .icon-bar:nth-of-type(2) {\\n    opacity: 0; }\\n  #nav-container:focus-within .icon-bar:nth-of-type(3) {\\n    transform: translate3d(0, -8px, 0) rotate(-45deg); }\\n  #nav-container:focus-within #nav-content {\\n    transform: none; }\\n\\n.button {\\n  position: absolute;\\n  top: -65px;\\n  right: 20px;\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  z-index: 1;\\n  -webkit-appearance: none;\\n  border: 0;\\n  background: transparent;\\n  border-radius: 0;\\n  height: 65px;\\n  width: 30px;\\n  cursor: pointer;\\n  pointer-events: auto;\\n  touch-action: manipulation;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\\n  .button .icon-bar {\\n    display: block;\\n    width: 100%;\\n    height: 3px;\\n    background: white;\\n    transition: 0.3s; }\\n  .button .icon-bar + .icon-bar {\\n    margin-top: 5px; }\\n\\n#nav-content {\\n  width: 90%;\\n  max-width: 300px;\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  height: 100%;\\n  background: #f05a28;\\n  pointer-events: auto;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n  transform: translateX(100%);\\n  transition: transform 0.3s;\\n  will-change: transform;\\n  contain: paint;\\n  z-index: 30; }\\n  #nav-content ul {\\n    height: 100%;\\n    display: flex;\\n    flex-direction: column; }\\n  #nav-content li {\\n    padding: 10px 20px; }\\n    #nav-content li:hover {\\n      background-color: white;\\n      transition: all 0.2s; }\\n      #nav-content li:hover a {\\n        color: #f05a28;\\n        transition: color 0.2s; }\\n    #nav-content li a {\\n      padding: 10px 5px;\\n      display: block;\\n      text-transform: uppercase; }\\n\\na,\\na:visited,\\na:focus,\\na:active,\\na:link {\\n  text-decoration: none;\\n  outline: 0; }\\n\\na {\\n  color: white;\\n  transition: 0.2s ease-in-out; }\\n\\nul {\\n  padding: 0;\\n  list-style: none; }\\n</style>\\n"],"names":[],"mappings":"AAwBmB,GAAG,0CAAC,CAAC,AACtB,UAAU,CAAE,OAAO,CACnB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,QAAQ,CACzB,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,MAAM,CAChB,GAAG,CAAE,CAAC,CACN,OAAO,CAAE,CAAC,AAAE,CAAC,AACb,iBAAG,CAAC,cAAc,4BAAC,CAAC,AAClB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,CACnB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,IAAI,CACV,eAAe,CAAE,IAAI,AAAE,CAAC,AACxB,iBAAG,CAAC,cAAc,CAAC,GAAG,4BAAC,CAAC,AACtB,KAAK,CAAE,IAAI,CACX,YAAY,CAAE,GAAG,AAAE,CAAC,AACtB,iBAAG,CAAC,cAAc,CAAC,IAAI,4BAAC,CAAC,AACvB,KAAK,CAAE,KAAK,CACZ,WAAW,CAAE,YAAY,CAAC,CAAC,OAAO,CAClC,SAAS,CAAE,KAAK,AAAE,CAAC,AAEzB,cAAc,0CAAC,CAAC,AACd,QAAQ,CAAE,KAAK,CACf,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,IAAI,CACX,cAAc,CAAE,IAAI,CACpB,OAAO,CAAE,EAAE,AAAE,CAAC,AACd,4BAAc,aAAa,CAAC,OAAO,4BAAC,CAAC,AACnC,cAAc,CAAE,IAAI,AAAE,CAAC,AACzB,4BAAc,aAAa,CAAC,qCAAS,aAAa,CAAC,CAAC,AAAC,CAAC,AACpD,SAAS,CAAE,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,KAAK,CAAC,AAAE,CAAC,AACpD,4BAAc,aAAa,CAAC,qCAAS,aAAa,CAAC,CAAC,AAAC,CAAC,AACpD,OAAO,CAAE,CAAC,AAAE,CAAC,AACf,4BAAc,aAAa,CAAC,qCAAS,aAAa,CAAC,CAAC,AAAC,CAAC,AACpD,SAAS,CAAE,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,MAAM,CAAC,AAAE,CAAC,AACtD,4BAAc,aAAa,CAAC,YAAY,4BAAC,CAAC,AACxC,SAAS,CAAE,IAAI,AAAE,CAAC,AAEtB,OAAO,0CAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,KAAK,CACV,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,CACvB,OAAO,CAAE,CAAC,CACV,kBAAkB,CAAE,IAAI,CACxB,MAAM,CAAE,CAAC,CACT,IAAI,MAAM,CAAE,WAAW,CACvB,aAAa,CAAE,CAAC,CAChB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,OAAO,CACf,cAAc,CAAE,GAAG,CAAC,CACpB,YAAY,CAAE,YAAY,CAC1B,2BAA2B,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,AAAE,CAAC,AAChD,qBAAO,CAAC,SAAS,4BAAC,CAAC,AACjB,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,CACX,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,IAAI,AAAE,CAAC,AACrB,qBAAO,CAAC,uBAAS,CAAG,SAAS,cAAC,CAAC,AAC7B,UAAU,CAAE,GAAG,AAAE,CAAC,AAEtB,YAAY,0CAAC,CAAC,AACZ,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,OAAO,CACnB,cAAc,CAAE,IAAI,CACpB,2BAA2B,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC7C,SAAS,CAAE,WAAW,IAAI,CAAC,CAC3B,UAAU,CAAE,SAAS,CAAC,IAAI,CAC1B,WAAW,CAAE,SAAS,CACtB,OAAO,CAAE,KAAK,CACd,OAAO,CAAE,EAAE,AAAE,CAAC,AACd,0BAAY,CAAC,EAAE,4BAAC,CAAC,AACf,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AAAE,CAAC,AAC3B,0BAAY,CAAC,EAAE,4BAAC,CAAC,AACf,OAAO,CAAE,IAAI,CAAC,IAAI,AAAE,CAAC,AACrB,0BAAY,CAAC,8BAAE,MAAM,AAAC,CAAC,AACrB,gBAAgB,CAAE,KAAK,CACvB,UAAU,CAAE,GAAG,CAAC,IAAI,AAAE,CAAC,AACvB,0BAAY,CAAC,EAAE,MAAM,CAAC,CAAC,4BAAC,CAAC,AACvB,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,KAAK,CAAC,IAAI,AAAE,CAAC,AAC7B,0BAAY,CAAC,EAAE,CAAC,CAAC,4BAAC,CAAC,AACjB,OAAO,CAAE,IAAI,CAAC,GAAG,CACjB,OAAO,CAAE,KAAK,CACd,cAAc,CAAE,SAAS,AAAE,CAAC,AAElC,2CAAC,CACD,2CAAC,QAAQ,CACT,2CAAC,MAAM,CACP,2CAAC,OAAO,CACR,2CAAC,KAAK,AAAC,CAAC,AACN,eAAe,CAAE,IAAI,CACrB,OAAO,CAAE,CAAC,AAAE,CAAC,AAEf,CAAC,0CAAC,CAAC,AACD,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,IAAI,CAAC,WAAW,AAAE,CAAC,AAEjC,EAAE,0CAAC,CAAC,AACF,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,IAAI,AAAE,CAAC"}`
};
var InactiveNav = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$b);
  return `<nav class="${"svelte-leenum"}"><a href="${"/"}" class="${"logoContainer svelte-leenum"}"><img src="${"./img/logo_1.png"}" alt="${"RecipeTime Logo"}" class="${"svelte-leenum"}">
		<span class="${"svelte-leenum"}">RecipeTime</span></a></nav>
<div id="${"nav-container"}" class="${"svelte-leenum"}"><div class="${"button svelte-leenum"}" tabindex="${"0"}"><span class="${"icon-bar svelte-leenum"}"></span>
		<span class="${"icon-bar svelte-leenum"}"></span>
		<span class="${"icon-bar svelte-leenum"}"></span></div>
	<div id="${"nav-content"}" tabindex="${"0"}" class="${"svelte-leenum"}"><ul class="${"svelte-leenum"}"><li class="${"svelte-leenum"}"><a href="${"/"}" class="${"svelte-leenum"}">Inicio</a></li>
			<li class="${"svelte-leenum"}"><a href="${"/login"}" class="${"svelte-leenum"}">Iniciar Sesion</a></li>
			<li class="${"svelte-leenum"}"><a href="${"/register"}" class="${"svelte-leenum"}">Registrarse</a></li></ul></div>
</div>`;
});
var subscriber_queue2 = [];
function writable2(value, start = noop2) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue2.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue2.length; i += 2) {
            subscriber_queue2[i][0](subscriber_queue2[i + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
var activeSesion = writable2(0);
var nombreUsuario = writable2("");
var correoUsuario = writable2("");
var creacionUsuario = writable2("");
var photoURL = writable2("");
var recetasUser = writable2([]);
var recetasTotal = writable2([]);
var usuarios = writable2([]);
var firebaseConfig = {
  apiKey: "AIzaSyB6tHwlxvP0awd_drZzYZEVnM-dg8r7FAk",
  authDomain: "recetario-607a0.firebaseapp.com",
  projectId: "recetario-607a0",
  messagingSenderId: "26779463143",
  appId: "1:26779463143:web:a1b22a79962d822c77e142",
  databaseURL: "https://recetario-607a0-default-rtdb.firebaseio.com/",
  storageBucket: "gs://recetario-607a0.appspot.com/"
};
import_firebase.default.initializeApp(firebaseConfig);
var db = import_firebase.default.firestore();
var auth = import_firebase.default.auth();
import_firebase.default.storage();
var css$a = {
  code: "nav.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5{background:#f05a28;display:flex;justify-content:flex-end;align-items:center;height:65px;position:sticky;top:0;z-index:5}nav.svelte-ixmpo5 .logoContainer.svelte-ixmpo5.svelte-ixmpo5{display:flex;justify-content:center;align-items:center;position:absolute;left:15px;text-decoration:none}nav.svelte-ixmpo5 .logoContainer img.svelte-ixmpo5.svelte-ixmpo5{width:50px;margin-right:8px}nav.svelte-ixmpo5 .logoContainer span.svelte-ixmpo5.svelte-ixmpo5{color:white;font-family:'Bad Script', cursive;font-size:1.5em}#nav-container.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5{position:fixed;height:100vh;width:100%;pointer-events:none;z-index:20}#nav-container.svelte-ixmpo5:focus-within .button.svelte-ixmpo5.svelte-ixmpo5{pointer-events:none}#nav-container.svelte-ixmpo5:focus-within .icon-bar.svelte-ixmpo5.svelte-ixmpo5:nth-of-type(1){transform:translate3d(0, 8px, 0) rotate(45deg)}#nav-container.svelte-ixmpo5:focus-within .icon-bar.svelte-ixmpo5.svelte-ixmpo5:nth-of-type(2){opacity:0}#nav-container.svelte-ixmpo5:focus-within .icon-bar.svelte-ixmpo5.svelte-ixmpo5:nth-of-type(3){transform:translate3d(0, -8px, 0) rotate(-45deg)}#nav-container.svelte-ixmpo5:focus-within #nav-content.svelte-ixmpo5.svelte-ixmpo5{transform:none}.button.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5{position:absolute;top:-65px;right:20px;display:flex;flex-direction:column;justify-content:center;z-index:1;-webkit-appearance:none;border:0;background:transparent;border-radius:0;height:65px;width:30px;cursor:pointer;pointer-events:auto;touch-action:manipulation;-webkit-tap-highlight-color:rgba(0, 0, 0, 0)}.button.svelte-ixmpo5 .icon-bar.svelte-ixmpo5.svelte-ixmpo5{display:block;width:100%;height:3px;background:white;transition:0.3s}.button.svelte-ixmpo5 .icon-bar.svelte-ixmpo5+.icon-bar.svelte-ixmpo5{margin-top:5px}#nav-content.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5{width:90%;max-width:300px;position:absolute;top:0;right:0;height:100%;background:#f05a28;pointer-events:auto;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);transform:translateX(100%);transition:transform 0.3s;will-change:transform;contain:paint;z-index:30}#nav-content.svelte-ixmpo5 ul.svelte-ixmpo5.svelte-ixmpo5{height:100%;display:flex;flex-direction:column;position:relative}#nav-content.svelte-ixmpo5 ul #delete.svelte-ixmpo5.svelte-ixmpo5{position:absolute;bottom:65px;width:100%;text-align:center;border-top:solid 2px;border-color:rgba(0, 0, 0, 0.6)}#nav-content.svelte-ixmpo5 ul #delete a.svelte-ixmpo5.svelte-ixmpo5{color:rgba(0, 0, 0, 0.8)}#nav-content.svelte-ixmpo5 ul #delete.svelte-ixmpo5.svelte-ixmpo5:hover{background-color:black}#nav-content.svelte-ixmpo5 ul #delete:hover a.svelte-ixmpo5.svelte-ixmpo5{color:white}#nav-content.svelte-ixmpo5 li.svelte-ixmpo5.svelte-ixmpo5{padding:10px 20px}#nav-content.svelte-ixmpo5 li.svelte-ixmpo5.svelte-ixmpo5:nth-of-type(4){background-color:white}#nav-content.svelte-ixmpo5 li:nth-of-type(4) a.svelte-ixmpo5.svelte-ixmpo5{color:#f05a28}#nav-content.svelte-ixmpo5 li:nth-of-type(4) a.svelte-ixmpo5.svelte-ixmpo5:hover{color:black}#nav-content.svelte-ixmpo5 li.svelte-ixmpo5.svelte-ixmpo5:hover{background-color:white;transition:all 0.2s}#nav-content.svelte-ixmpo5 li:hover a.svelte-ixmpo5.svelte-ixmpo5{color:#f05a28;transition:color 0.2s}#nav-content.svelte-ixmpo5 li a.svelte-ixmpo5.svelte-ixmpo5{padding:10px 5px;display:block;text-transform:uppercase}a.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5,a.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5:visited,a.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5:focus,a.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5:active,a.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5:link{text-decoration:none;outline:0}a.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5{color:white;transition:0.2s ease-in-out}ul.svelte-ixmpo5.svelte-ixmpo5.svelte-ixmpo5{padding:0;list-style:none}",
  map: `{"version":3,"file":"activeNav.svelte","sources":["activeNav.svelte"],"sourcesContent":["<script>\\n\\timport{activeSesion} from \\"../store\\";\\n\\timport {auth} from \\"../firebase\\";\\n\\timport { correoUsuario } from \\"../store\\"\\n\\tconst logout = async () => {\\n\\t\\ttry{\\n\\t\\t\\tif($activeSesion){\\n\\t\\t\\t\\tauth.signOut();\\n\\t\\t\\t\\tconsole.log(\\"Salida exitosa\\")\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tconsole.log(\\"No hay usuario activo\\")\\n\\t\\t\\t}\\n\\t\\t}catch(error){\\n\\t\\t\\tconsole.log(error.message)\\n\\t\\t}\\n\\t}\\n\\n\\tconst borrar = async () =>{\\n\\t\\tlet user = auth.currentUser\\n\\t\\tactiveSesion.set(0)\\n\\t\\tawait user.delete().then(() => {\\n\\t\\t\\tconsole.log(\\"usuario eliminado...\\")\\n\\t\\t}).catch((error) => {\\n\\t\\t\\tconsole.log(error.message)\\n\\t\\t});\\n\\n\\t\\t//redireccionamiento\\n\\t\\twindow.history.pushState('', '', '/');\\n        location.reload();\\n                \\n\\t}\\n\\n<\/script>\\n\\n\\n<nav>\\n\\t<a href=\\"/\\" class=\\"logoContainer\\">\\n\\t\\t<img src=\\"./img/logo_1.png\\" alt=\\"RecipeTime Logo\\" />\\n\\t\\t<span>RecipeTime</span>\\n\\t</a>\\n</nav>\\n<div id=\\"nav-container\\">\\n\\t<div class=\\"button\\" tabindex=\\"0\\">\\n\\t\\t<span class=\\"icon-bar\\" />\\n\\t\\t<span class=\\"icon-bar\\" />\\n\\t\\t<span class=\\"icon-bar\\" />\\n\\t</div>\\n\\t<div id=\\"nav-content\\" tabindex=\\"0\\">\\n\\t\\t<ul>\\n\\t\\t\\t<li><a href=\\"/\\">Inicio</a></li>\\n\\t\\t\\t{#if $correoUsuario === \\"admin@admin.com\\"}\\n\\t\\t\\t\\t <!-- content here -->\\n\\t\\t\\t\\t <li><a href=\\"/admin\\">Perfil admin</a></li>\\n\\t\\t\\t{:else}\\n\\t\\t\\t<!-- else content here -->\\n\\t\\t\\t\\t<li><a href=\\"/profile\\">Perfil usuario</a></li>\\n\\t\\t\\t{/if}\\n\\t\\t\\t<li><a href=\\"/aggreceta\\">Subir Receta</a></li>\\n\\t\\t\\t<li on:click={logout}><a href=\\"/\\">Cerrar Sesion Activa</a></li>\\n\\t\\t\\t<li id=\\"delete\\" on:click={borrar}><a href=\\"/\\"><span class=\\"fas fa-trash\\"></span> Dar de baja</a></li>\\n\\t\\t</ul>\\n\\t</div>\\n</div>\\n\\n\\n\\n\\n<style lang=\\"scss\\">nav {\\n  background: #f05a28;\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: center;\\n  height: 65px;\\n  position: sticky;\\n  top: 0;\\n  z-index: 5; }\\n  nav .logoContainer {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    position: absolute;\\n    left: 15px;\\n    text-decoration: none; }\\n    nav .logoContainer img {\\n      width: 50px;\\n      margin-right: 8px; }\\n    nav .logoContainer span {\\n      color: white;\\n      font-family: 'Bad Script', cursive;\\n      font-size: 1.5em; }\\n\\n#nav-container {\\n  position: fixed;\\n  height: 100vh;\\n  width: 100%;\\n  pointer-events: none;\\n  z-index: 20; }\\n  #nav-container:focus-within .button {\\n    pointer-events: none; }\\n  #nav-container:focus-within .icon-bar:nth-of-type(1) {\\n    transform: translate3d(0, 8px, 0) rotate(45deg); }\\n  #nav-container:focus-within .icon-bar:nth-of-type(2) {\\n    opacity: 0; }\\n  #nav-container:focus-within .icon-bar:nth-of-type(3) {\\n    transform: translate3d(0, -8px, 0) rotate(-45deg); }\\n  #nav-container:focus-within #nav-content {\\n    transform: none; }\\n\\n.button {\\n  position: absolute;\\n  top: -65px;\\n  right: 20px;\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  z-index: 1;\\n  -webkit-appearance: none;\\n  border: 0;\\n  background: transparent;\\n  border-radius: 0;\\n  height: 65px;\\n  width: 30px;\\n  cursor: pointer;\\n  pointer-events: auto;\\n  touch-action: manipulation;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\\n  .button .icon-bar {\\n    display: block;\\n    width: 100%;\\n    height: 3px;\\n    background: white;\\n    transition: 0.3s; }\\n  .button .icon-bar + .icon-bar {\\n    margin-top: 5px; }\\n\\n#nav-content {\\n  width: 90%;\\n  max-width: 300px;\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  height: 100%;\\n  background: #f05a28;\\n  pointer-events: auto;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n  transform: translateX(100%);\\n  transition: transform 0.3s;\\n  will-change: transform;\\n  contain: paint;\\n  z-index: 30; }\\n  #nav-content ul {\\n    height: 100%;\\n    display: flex;\\n    flex-direction: column;\\n    position: relative; }\\n    #nav-content ul #delete {\\n      position: absolute;\\n      bottom: 65px;\\n      width: 100%;\\n      text-align: center;\\n      border-top: solid 2px;\\n      border-color: rgba(0, 0, 0, 0.6); }\\n      #nav-content ul #delete a {\\n        color: rgba(0, 0, 0, 0.8); }\\n      #nav-content ul #delete:hover {\\n        background-color: black; }\\n        #nav-content ul #delete:hover a {\\n          color: white; }\\n  #nav-content li {\\n    padding: 10px 20px; }\\n    #nav-content li:nth-of-type(4) {\\n      background-color: white; }\\n      #nav-content li:nth-of-type(4) a {\\n        color: #f05a28; }\\n        #nav-content li:nth-of-type(4) a:hover {\\n          color: black; }\\n    #nav-content li:hover {\\n      background-color: white;\\n      transition: all 0.2s; }\\n      #nav-content li:hover a {\\n        color: #f05a28;\\n        transition: color 0.2s; }\\n    #nav-content li a {\\n      padding: 10px 5px;\\n      display: block;\\n      text-transform: uppercase; }\\n\\na,\\na:visited,\\na:focus,\\na:active,\\na:link {\\n  text-decoration: none;\\n  outline: 0; }\\n\\na {\\n  color: white;\\n  transition: 0.2s ease-in-out; }\\n\\nul {\\n  padding: 0;\\n  list-style: none; }\\n</style>\\n"],"names":[],"mappings":"AAmEmB,GAAG,0CAAC,CAAC,AACtB,UAAU,CAAE,OAAO,CACnB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,QAAQ,CACzB,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,MAAM,CAChB,GAAG,CAAE,CAAC,CACN,OAAO,CAAE,CAAC,AAAE,CAAC,AACb,iBAAG,CAAC,cAAc,4BAAC,CAAC,AAClB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,CACnB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,IAAI,CACV,eAAe,CAAE,IAAI,AAAE,CAAC,AACxB,iBAAG,CAAC,cAAc,CAAC,GAAG,4BAAC,CAAC,AACtB,KAAK,CAAE,IAAI,CACX,YAAY,CAAE,GAAG,AAAE,CAAC,AACtB,iBAAG,CAAC,cAAc,CAAC,IAAI,4BAAC,CAAC,AACvB,KAAK,CAAE,KAAK,CACZ,WAAW,CAAE,YAAY,CAAC,CAAC,OAAO,CAClC,SAAS,CAAE,KAAK,AAAE,CAAC,AAEzB,cAAc,0CAAC,CAAC,AACd,QAAQ,CAAE,KAAK,CACf,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,IAAI,CACX,cAAc,CAAE,IAAI,CACpB,OAAO,CAAE,EAAE,AAAE,CAAC,AACd,4BAAc,aAAa,CAAC,OAAO,4BAAC,CAAC,AACnC,cAAc,CAAE,IAAI,AAAE,CAAC,AACzB,4BAAc,aAAa,CAAC,qCAAS,aAAa,CAAC,CAAC,AAAC,CAAC,AACpD,SAAS,CAAE,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,KAAK,CAAC,AAAE,CAAC,AACpD,4BAAc,aAAa,CAAC,qCAAS,aAAa,CAAC,CAAC,AAAC,CAAC,AACpD,OAAO,CAAE,CAAC,AAAE,CAAC,AACf,4BAAc,aAAa,CAAC,qCAAS,aAAa,CAAC,CAAC,AAAC,CAAC,AACpD,SAAS,CAAE,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,MAAM,CAAC,AAAE,CAAC,AACtD,4BAAc,aAAa,CAAC,YAAY,4BAAC,CAAC,AACxC,SAAS,CAAE,IAAI,AAAE,CAAC,AAEtB,OAAO,0CAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,KAAK,CACV,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,CACvB,OAAO,CAAE,CAAC,CACV,kBAAkB,CAAE,IAAI,CACxB,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,WAAW,CACvB,aAAa,CAAE,CAAC,CAChB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,OAAO,CACf,cAAc,CAAE,IAAI,CACpB,YAAY,CAAE,YAAY,CAC1B,2BAA2B,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,AAAE,CAAC,AAChD,qBAAO,CAAC,SAAS,4BAAC,CAAC,AACjB,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,CACX,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,IAAI,AAAE,CAAC,AACrB,qBAAO,CAAC,uBAAS,CAAG,SAAS,cAAC,CAAC,AAC7B,UAAU,CAAE,GAAG,AAAE,CAAC,AAEtB,YAAY,0CAAC,CAAC,AACZ,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,OAAO,CACnB,cAAc,CAAE,IAAI,CACpB,2BAA2B,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC7C,SAAS,CAAE,WAAW,IAAI,CAAC,CAC3B,UAAU,CAAE,SAAS,CAAC,IAAI,CAC1B,WAAW,CAAE,SAAS,CACtB,OAAO,CAAE,KAAK,CACd,OAAO,CAAE,EAAE,AAAE,CAAC,AACd,0BAAY,CAAC,EAAE,4BAAC,CAAC,AACf,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACrB,0BAAY,CAAC,EAAE,CAAC,OAAO,4BAAC,CAAC,AACvB,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,KAAK,CAAC,GAAG,CACrB,YAAY,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AAAE,CAAC,AACnC,0BAAY,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,4BAAC,CAAC,AACzB,KAAK,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AAAE,CAAC,AAC9B,0BAAY,CAAC,EAAE,CAAC,mCAAO,MAAM,AAAC,CAAC,AAC7B,gBAAgB,CAAE,KAAK,AAAE,CAAC,AAC1B,0BAAY,CAAC,EAAE,CAAC,OAAO,MAAM,CAAC,CAAC,4BAAC,CAAC,AAC/B,KAAK,CAAE,KAAK,AAAE,CAAC,AACvB,GAAG,uBAAS,CAAC,EAAE,4BAAC,CAAC,AACf,OAAO,CAAE,IAAI,CAAC,IAAI,AAAE,CAAC,AACrB,0BAAY,CAAC,8BAAE,aAAa,CAAC,CAAC,AAAC,CAAC,AAC9B,gBAAgB,CAAE,KAAK,AAAE,CAAC,AAC1B,0BAAY,CAAC,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC,4BAAC,CAAC,AAChC,KAAK,CAAE,OAAO,AAAE,CAAC,AACjB,0BAAY,CAAC,EAAE,aAAa,CAAC,CAAC,CAAC,6BAAC,MAAM,AAAC,CAAC,AACtC,KAAK,CAAE,KAAK,AAAE,CAAC,AACrB,0BAAY,CAAC,8BAAE,MAAM,AAAC,CAAC,AACrB,gBAAgB,CAAE,KAAK,CACvB,UAAU,CAAE,GAAG,CAAC,IAAI,AAAE,CAAC,AACvB,0BAAY,CAAC,EAAE,MAAM,CAAC,CAAC,4BAAC,CAAC,AACvB,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,KAAK,CAAC,IAAI,AAAE,CAAC,AAC7B,0BAAY,CAAC,EAAE,CAAC,CAAC,4BAAC,CAAC,AACjB,OAAO,CAAE,IAAI,CAAC,GAAG,CACjB,OAAO,CAAE,KAAK,CACd,cAAc,CAAE,SAAS,AAAE,CAAC,AAElC,2CAAC,CACD,2CAAC,QAAQ,CACT,2CAAC,MAAM,CACP,2CAAC,OAAO,CACR,2CAAC,KAAK,AAAC,CAAC,AACN,eAAe,CAAE,IAAI,CACrB,OAAO,CAAE,CAAC,AAAE,CAAC,AAEf,CAAC,0CAAC,CAAC,AACD,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,IAAI,CAAC,WAAW,AAAE,CAAC,AAEjC,EAAE,0CAAC,CAAC,AACF,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,IAAI,AAAE,CAAC"}`
};
var ActiveNav = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_activeSesion;
  let $correoUsuario, $$unsubscribe_correoUsuario;
  $$unsubscribe_activeSesion = subscribe(activeSesion, (value) => value);
  $$unsubscribe_correoUsuario = subscribe(correoUsuario, (value) => $correoUsuario = value);
  $$result.css.add(css$a);
  $$unsubscribe_activeSesion();
  $$unsubscribe_correoUsuario();
  return `<nav class="${"svelte-ixmpo5"}"><a href="${"/"}" class="${"logoContainer svelte-ixmpo5"}"><img src="${"./img/logo_1.png"}" alt="${"RecipeTime Logo"}" class="${"svelte-ixmpo5"}">
		<span class="${"svelte-ixmpo5"}">RecipeTime</span></a></nav>
<div id="${"nav-container"}" class="${"svelte-ixmpo5"}"><div class="${"button svelte-ixmpo5"}" tabindex="${"0"}"><span class="${"icon-bar svelte-ixmpo5"}"></span>
		<span class="${"icon-bar svelte-ixmpo5"}"></span>
		<span class="${"icon-bar svelte-ixmpo5"}"></span></div>
	<div id="${"nav-content"}" tabindex="${"0"}" class="${"svelte-ixmpo5"}"><ul class="${"svelte-ixmpo5"}"><li class="${"svelte-ixmpo5"}"><a href="${"/"}" class="${"svelte-ixmpo5"}">Inicio</a></li>
			${$correoUsuario === "admin@admin.com" ? `
				 <li class="${"svelte-ixmpo5"}"><a href="${"/admin"}" class="${"svelte-ixmpo5"}">Perfil admin</a></li>` : `
				<li class="${"svelte-ixmpo5"}"><a href="${"/profile"}" class="${"svelte-ixmpo5"}">Perfil usuario</a></li>`}
			<li class="${"svelte-ixmpo5"}"><a href="${"/aggreceta"}" class="${"svelte-ixmpo5"}">Subir Receta</a></li>
			<li class="${"svelte-ixmpo5"}"><a href="${"/"}" class="${"svelte-ixmpo5"}">Cerrar Sesion Activa</a></li>
			<li id="${"delete"}" class="${"svelte-ixmpo5"}"><a href="${"/"}" class="${"svelte-ixmpo5"}"><span class="${"fas fa-trash"}"></span> Dar de baja</a></li></ul></div>
</div>`;
});
var css$9 = {
  code: `@import url("https://fonts.googleapis.com/css2?family=Bad+Script&family=Work+Sans&display=swap");*{box-sizing:border-box;margin:0;padding:0}body{font-family:'Work Sans', sans-serif;font-size:16px;background-color:#F7931E}`,
  map: `{"version":3,"file":"__layout.svelte","sources":["__layout.svelte"],"sourcesContent":["<script>\\n    import inactiveNav from '$lib/inactiveNav.svelte';\\n    import activeNav from '$lib/activeNav.svelte';\\n    import {auth, db} from '../firebase'; \\n    import {activeSesion} from '../store';\\n    import { nombreUsuario , correoUsuario, creacionUsuario, photoURL} from '../store';\\n    import { recetasUser, recetasTotal, usuarios } from '../store';\\n\\n   \\n\\n\\n    const navs = [\\n\\t\\t{ sesion: 'inactive', component: inactiveNav },\\n\\t\\t{ sesion: 'active',   component: activeNav   }\\n\\t];\\n    let sesion = navs[0];\\n    auth.onAuthStateChanged((user) => {\\n        if (user) {\\n            nombreUsuario.set(user.displayName);\\n            correoUsuario.set(user.email);\\n            creacionUsuario.set(user.metadata.creationTime);\\n            photoURL.set(user.photoURL);\\n            activeSesion.set(1);\\n            sesion = navs[1];\\n\\n            db.collection('recetas').onSnapshot(querySnapshot => {\\n                let docs =[];\\n                querySnapshot.forEach(doc => {\\n                    docs.push({...doc.data(), id: doc.id})\\n                })\\n                recetasTotal.set([...docs])\\n\\n                recetasUser.set([])\\n                $recetasTotal.forEach( item =>{\\n                    if (item.autor == user.email){\\n                        recetasUser.set([...$recetasUser,item])\\n                    }\\n                })\\n            });\\n\\n            db.collection('usuarios').onSnapshot(querySnapshot => {\\n                let docs = [];\\n                querySnapshot.forEach(doc =>{\\n                    docs.push({...doc.data(), idDoc: doc.id})\\n                })\\n                usuarios.set([...docs])\\n            })\\n\\n        }else{\\n            nombreUsuario.set(\\"No disponible\\");\\n            correoUsuario.set(\\"No disponible\\");\\n            creacionUsuario.set(\\"No disponible\\")\\n            activeSesion.set(0)\\n            sesion = navs[0];\\n        }\\n        });\\n\\n    \\n<\/script>\\n\\n<div class=\\"content\\">\\n    <svelte:component this={sesion.component} />\\n    <slot></slot>\\n</div>\\n\\n<style lang=\\"scss\\">@import url(\\"https://fonts.googleapis.com/css2?family=Bad+Script&family=Work+Sans&display=swap\\");\\n:global(*) {\\n  box-sizing: border-box;\\n  margin: 0;\\n  padding: 0; }\\n\\n:global(body) {\\n  font-family: 'Work Sans', sans-serif;\\n  font-size: 16px;\\n  background-color: #F7931E; }\\n</style>"],"names":[],"mappings":"AAiEmB,QAAQ,IAAI,mFAAmF,CAAC,CAAC,AAC5G,CAAC,AAAE,CAAC,AACV,UAAU,CAAE,UAAU,CACtB,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,AAAE,CAAC,AAEP,IAAI,AAAE,CAAC,AACb,WAAW,CAAE,WAAW,CAAC,CAAC,UAAU,CACpC,SAAS,CAAE,IAAI,CACf,gBAAgB,CAAE,OAAO,AAAE,CAAC"}`
};
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $recetasUser, $$unsubscribe_recetasUser;
  let $recetasTotal, $$unsubscribe_recetasTotal;
  $$unsubscribe_recetasUser = subscribe(recetasUser, (value) => $recetasUser = value);
  $$unsubscribe_recetasTotal = subscribe(recetasTotal, (value) => $recetasTotal = value);
  const navs = [
    {
      sesion: "inactive",
      component: InactiveNav
    },
    { sesion: "active", component: ActiveNav }
  ];
  let sesion = navs[0];
  auth.onAuthStateChanged((user) => {
    if (user) {
      nombreUsuario.set(user.displayName);
      correoUsuario.set(user.email);
      creacionUsuario.set(user.metadata.creationTime);
      photoURL.set(user.photoURL);
      activeSesion.set(1);
      sesion = navs[1];
      db.collection("recetas").onSnapshot((querySnapshot) => {
        let docs = [];
        querySnapshot.forEach((doc) => {
          docs.push({ ...doc.data(), id: doc.id });
        });
        recetasTotal.set([...docs]);
        recetasUser.set([]);
        $recetasTotal.forEach((item) => {
          if (item.autor == user.email) {
            recetasUser.set([...$recetasUser, item]);
          }
        });
      });
      db.collection("usuarios").onSnapshot((querySnapshot) => {
        let docs = [];
        querySnapshot.forEach((doc) => {
          docs.push({ ...doc.data(), idDoc: doc.id });
        });
        usuarios.set([...docs]);
      });
    } else {
      nombreUsuario.set("No disponible");
      correoUsuario.set("No disponible");
      creacionUsuario.set("No disponible");
      activeSesion.set(0);
      sesion = navs[0];
    }
  });
  $$result.css.add(css$9);
  $$unsubscribe_recetasUser();
  $$unsubscribe_recetasTotal();
  return `<div class="${"content"}">${validate_component(sesion.component || missing_component, "svelte:component").$$render($$result, {}, {}, {})}
    ${slots.default ? slots.default({}) : ``}
</div>`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
function load$1({ error: error22, status }) {
  return { props: { error: error22, status } };
}
var Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { status } = $$props;
  let { error: error22 } = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error22 !== void 0)
    $$bindings.error(error22);
  return `<h1>${escape2(status)}</h1>

<pre>${escape2(error22.message)}</pre>



${error22.frame ? `<pre>${escape2(error22.frame)}</pre>` : ``}
${error22.stack ? `<pre>${escape2(error22.stack)}</pre>` : ``}`;
});
var error2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load: load$1
});
var css$8 = {
  code: ".card.svelte-j4x9a4.svelte-j4x9a4{width:300px;height:400px;background:white;box-shadow:4px 4px 12px rgba(0, 0, 0, 0.5);margin-bottom:30px;overflow:hidden;position:relative}.card.svelte-j4x9a4 a.svelte-j4x9a4{width:100%;height:100%;color:black;text-decoration:none}.card.svelte-j4x9a4 .img.svelte-j4x9a4{height:200px;overflow:hidden;border-bottom:solid 4px #f05a28;position:relative}.card.svelte-j4x9a4 .img p.svelte-j4x9a4{position:absolute;color:white;font-weight:bold;padding:4px 8px;font-size:1.5em;bottom:0;z-index:1}.card.svelte-j4x9a4 .img img.svelte-j4x9a4{object-fit:cover;width:100%;height:100%;position:absolute}.card.svelte-j4x9a4 .img.svelte-j4x9a4::after{content:'';position:absolute;width:100%;height:100%;background:rgba(0, 0, 0, 0.3)}.card.svelte-j4x9a4 .descripcion.svelte-j4x9a4{padding:8px 20px}.card.svelte-j4x9a4 .stars.svelte-j4x9a4{position:absolute;color:#f05a28;font-weight:bold;font-size:1.2em;bottom:20px;right:20px}.card.svelte-j4x9a4.svelte-j4x9a4:hover{transition:0.2s;transform:scale(1.02)}",
  map: `{"version":3,"file":"recipeCard.svelte","sources":["recipeCard.svelte"],"sourcesContent":["<script>\\n    export let imgURL = \\"https://placekitten.com/200/300\\";\\n    export let title = \\"undefined\\"\\n    //TODO: ponle a la descripcion un maximo de caracteres a mostrar => Luego, (CAMBIO A FUTURO)\\n    export let description = \\"undefined\\";\\n    export let stars = 0;\\n    export let id = 0;\\n\\n<\/script>\\n\\n<div class=\\"card\\">\\n    <a href={'recipes/' + id}>\\n        <div class=\\"img\\">\\n            <p>{title}</p>\\n            <img src={imgURL} alt=\\"\\">\\n        </div>\\n        <p class=\\"descripcion\\">{description}</p>\\n        <p class=\\"stars\\">{stars}/5</p>\\n    </a>\\n</div>\\n\\n<style lang=\\"scss\\">.card {\\n  width: 300px;\\n  height: 400px;\\n  background: white;\\n  box-shadow: 4px 4px 12px rgba(0, 0, 0, 0.5);\\n  margin-bottom: 30px;\\n  overflow: hidden;\\n  position: relative; }\\n  .card a {\\n    width: 100%;\\n    height: 100%;\\n    color: black;\\n    text-decoration: none; }\\n  .card .img {\\n    height: 200px;\\n    overflow: hidden;\\n    border-bottom: solid 4px #f05a28;\\n    position: relative; }\\n    .card .img p {\\n      position: absolute;\\n      color: white;\\n      font-weight: bold;\\n      padding: 4px 8px;\\n      font-size: 1.5em;\\n      bottom: 0;\\n      z-index: 1; }\\n    .card .img img {\\n      object-fit: cover;\\n      width: 100%;\\n      height: 100%;\\n      position: absolute; }\\n    .card .img::after {\\n      content: '';\\n      position: absolute;\\n      width: 100%;\\n      height: 100%;\\n      background: rgba(0, 0, 0, 0.3); }\\n  .card .descripcion {\\n    padding: 8px 20px; }\\n  .card .stars {\\n    position: absolute;\\n    color: #f05a28;\\n    font-weight: bold;\\n    font-size: 1.2em;\\n    bottom: 20px;\\n    right: 20px; }\\n  .card:hover {\\n    transition: 0.2s;\\n    transform: scale(1.02); }\\n</style>"],"names":[],"mappings":"AAqBmB,KAAK,4BAAC,CAAC,AACxB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAC3C,aAAa,CAAE,IAAI,CACnB,QAAQ,CAAE,MAAM,CAChB,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACrB,mBAAK,CAAC,CAAC,cAAC,CAAC,AACP,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,KAAK,CACZ,eAAe,CAAE,IAAI,AAAE,CAAC,AAC1B,mBAAK,CAAC,IAAI,cAAC,CAAC,AACV,MAAM,CAAE,KAAK,CACb,QAAQ,CAAE,MAAM,CAChB,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CAChC,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACrB,mBAAK,CAAC,IAAI,CAAC,CAAC,cAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,CACZ,WAAW,CAAE,IAAI,CACjB,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,AAAE,CAAC,AACf,mBAAK,CAAC,IAAI,CAAC,GAAG,cAAC,CAAC,AACd,UAAU,CAAE,KAAK,CACjB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACvB,mBAAK,CAAC,kBAAI,OAAO,AAAC,CAAC,AACjB,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AAAE,CAAC,AACrC,mBAAK,CAAC,YAAY,cAAC,CAAC,AAClB,OAAO,CAAE,GAAG,CAAC,IAAI,AAAE,CAAC,AACtB,mBAAK,CAAC,MAAM,cAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,OAAO,CACd,WAAW,CAAE,IAAI,CACjB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,AAAE,CAAC,AAChB,iCAAK,MAAM,AAAC,CAAC,AACX,UAAU,CAAE,IAAI,CAChB,SAAS,CAAE,MAAM,IAAI,CAAC,AAAE,CAAC"}`
};
var RecipeCard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { imgURL = "https://placekitten.com/200/300" } = $$props;
  let { title = "undefined" } = $$props;
  let { description = "undefined" } = $$props;
  let { stars = 0 } = $$props;
  let { id = 0 } = $$props;
  if ($$props.imgURL === void 0 && $$bindings.imgURL && imgURL !== void 0)
    $$bindings.imgURL(imgURL);
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.description === void 0 && $$bindings.description && description !== void 0)
    $$bindings.description(description);
  if ($$props.stars === void 0 && $$bindings.stars && stars !== void 0)
    $$bindings.stars(stars);
  if ($$props.id === void 0 && $$bindings.id && id !== void 0)
    $$bindings.id(id);
  $$result.css.add(css$8);
  return `<div class="${"card svelte-j4x9a4"}"><a${add_attribute("href", "recipes/" + id, 0)} class="${"svelte-j4x9a4"}"><div class="${"img svelte-j4x9a4"}"><p class="${"svelte-j4x9a4"}">${escape2(title)}</p>
            <img${add_attribute("src", imgURL, 0)} alt="${""}" class="${"svelte-j4x9a4"}"></div>
        <p class="${"descripcion svelte-j4x9a4"}">${escape2(description)}</p>
        <p class="${"stars svelte-j4x9a4"}">${escape2(stars)}/5</p></a>
</div>`;
});
var css$7 = {
  code: ".banner.svelte-1d437l.svelte-1d437l{height:calc(100vh - 65px);position:relative}.banner.svelte-1d437l>.svelte-1d437l{position:absolute}.banner.svelte-1d437l .bg.svelte-1d437l{object-fit:cover;width:100%;height:100%}.banner.svelte-1d437l.svelte-1d437l::after{content:'';position:absolute;width:100%;height:100%;background:rgba(0, 0, 0, 0.2)}.banner.svelte-1d437l h1.svelte-1d437l{z-index:1;font-size:3em;color:white;font-weight:400;font-family:'Bad Script', cursive;bottom:25px;left:150px}.banner.svelte-1d437l #logo.svelte-1d437l{z-index:1;width:120px;animation:svelte-1d437l-spin 40s linear infinite;bottom:20px;left:20px;filter:drop-shadow(4px 4px 4px black)}.banner.svelte-1d437l p.svelte-1d437l{color:white;font-size:2em;z-index:1;padding:20px;width:50%}.container.svelte-1d437l.svelte-1d437l{display:flex;flex-wrap:wrap;padding:25px;background:white}.container.svelte-1d437l .title-container.svelte-1d437l{display:flex;align-items:center;margin:0px 0 20px 0;width:100%}.container.svelte-1d437l .title-container h4.svelte-1d437l{color:#f05a28;font-size:1.5em;margin-right:4px}.container.svelte-1d437l .title-container .linea.svelte-1d437l{width:100%;border-top:dashed 3px #f05a28}.container.svelte-1d437l .recipes.svelte-1d437l{max-width:1300px;padding:20px;display:flex;justify-content:space-around;flex-wrap:wrap;gap:5px 10px}@keyframes svelte-1d437l-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n    import RecipeCard from './../lib/recipeCard.svelte';\\n    import { recetasTotal } from '../store';\\n\\n<\/script>\\n\\n<header class=\\"banner\\">\\n    <img src=\\"/img/banner.jpg\\" class=\\"bg\\" alt=\\"\\">\\n    <img src=\\"/img/logo_1.png\\" id=\\"logo\\" alt=\\"logo RacipeTime\\">\\n    <h1>RecipeTime</h1>\\n    <p>\xBFQu&eacute; esperas para saciar tu antojo?</p>\\n</header>\\n<div class=\\"container\\">\\n    <div class=\\"title-container\\">\\n        <h4>Recetas</h4>\\n        <div class='linea'></div>\\n    </div>\\n    <div class=\\"recipes\\">\\n        {#each $recetasTotal as item}\\n            <!-- content here -->\\n            <RecipeCard \\n                imgURL={item.imgURL} \\n                title={item.titulo} \\n                description={item.descripcion}\\n                stars = {item.puntuado}\\n                id = {item.id}\\n            />\\n        {/each}\\n    </div>\\n</div>\\n\\n<style lang=\\"scss\\">.banner {\\n  height: calc(100vh - 65px);\\n  position: relative; }\\n  .banner > * {\\n    position: absolute; }\\n  .banner .bg {\\n    object-fit: cover;\\n    width: 100%;\\n    height: 100%; }\\n  .banner::after {\\n    content: '';\\n    position: absolute;\\n    width: 100%;\\n    height: 100%;\\n    background: rgba(0, 0, 0, 0.2); }\\n  .banner h1 {\\n    z-index: 1;\\n    font-size: 3em;\\n    color: white;\\n    font-weight: 400;\\n    font-family: 'Bad Script', cursive;\\n    bottom: 25px;\\n    left: 150px; }\\n  .banner #logo {\\n    z-index: 1;\\n    width: 120px;\\n    animation: spin 40s linear infinite;\\n    bottom: 20px;\\n    left: 20px;\\n    filter: drop-shadow(4px 4px 4px black); }\\n  .banner p {\\n    color: white;\\n    font-size: 2em;\\n    z-index: 1;\\n    padding: 20px;\\n    width: 50%; }\\n\\n.container {\\n  display: flex;\\n  flex-wrap: wrap;\\n  padding: 25px;\\n  background: white; }\\n  .container .title-container {\\n    display: flex;\\n    align-items: center;\\n    margin: 0px 0 20px 0;\\n    width: 100%; }\\n    .container .title-container h4 {\\n      color: #f05a28;\\n      font-size: 1.5em;\\n      margin-right: 4px; }\\n    .container .title-container .linea {\\n      width: 100%;\\n      border-top: dashed 3px #f05a28; }\\n  .container .recipes {\\n    max-width: 1300px;\\n    padding: 20px;\\n    display: flex;\\n    justify-content: space-around;\\n    flex-wrap: wrap;\\n    gap: 5px 10px; }\\n\\n@keyframes spin {\\n  0% {\\n    transform: rotate(0deg); }\\n  100% {\\n    transform: rotate(360deg); } }\\n</style>"],"names":[],"mappings":"AA+BmB,OAAO,4BAAC,CAAC,AAC1B,MAAM,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAC1B,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACrB,qBAAO,CAAG,cAAE,CAAC,AACX,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACvB,qBAAO,CAAC,GAAG,cAAC,CAAC,AACX,UAAU,CAAE,KAAK,CACjB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AAAE,CAAC,AACjB,mCAAO,OAAO,AAAC,CAAC,AACd,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AAAE,CAAC,AACnC,qBAAO,CAAC,EAAE,cAAC,CAAC,AACV,OAAO,CAAE,CAAC,CACV,SAAS,CAAE,GAAG,CACd,KAAK,CAAE,KAAK,CACZ,WAAW,CAAE,GAAG,CAChB,WAAW,CAAE,YAAY,CAAC,CAAC,OAAO,CAClC,MAAM,CAAE,IAAI,CACZ,IAAI,CAAE,KAAK,AAAE,CAAC,AAChB,qBAAO,CAAC,KAAK,cAAC,CAAC,AACb,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,kBAAI,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,CACnC,MAAM,CAAE,IAAI,CACZ,IAAI,CAAE,IAAI,CACV,MAAM,CAAE,YAAY,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,AAAE,CAAC,AAC3C,qBAAO,CAAC,CAAC,cAAC,CAAC,AACT,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,GAAG,CACd,OAAO,CAAE,CAAC,CACV,OAAO,CAAE,IAAI,CACb,KAAK,CAAE,GAAG,AAAE,CAAC,AAEjB,UAAU,4BAAC,CAAC,AACV,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,CACf,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,KAAK,AAAE,CAAC,AACpB,wBAAU,CAAC,gBAAgB,cAAC,CAAC,AAC3B,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CACpB,KAAK,CAAE,IAAI,AAAE,CAAC,AACd,wBAAU,CAAC,gBAAgB,CAAC,EAAE,cAAC,CAAC,AAC9B,KAAK,CAAE,OAAO,CACd,SAAS,CAAE,KAAK,CAChB,YAAY,CAAE,GAAG,AAAE,CAAC,AACtB,wBAAU,CAAC,gBAAgB,CAAC,MAAM,cAAC,CAAC,AAClC,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACrC,wBAAU,CAAC,QAAQ,cAAC,CAAC,AACnB,SAAS,CAAE,MAAM,CACjB,OAAO,CAAE,IAAI,CACb,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,CAC7B,SAAS,CAAE,IAAI,CACf,GAAG,CAAE,GAAG,CAAC,IAAI,AAAE,CAAC,AAEpB,WAAW,kBAAK,CAAC,AACf,EAAE,AAAC,CAAC,AACF,SAAS,CAAE,OAAO,IAAI,CAAC,AAAE,CAAC,AAC5B,IAAI,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,MAAM,CAAC,AAAE,CAAC,AAAC,CAAC"}`
};
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $recetasTotal, $$unsubscribe_recetasTotal;
  $$unsubscribe_recetasTotal = subscribe(recetasTotal, (value) => $recetasTotal = value);
  $$result.css.add(css$7);
  $$unsubscribe_recetasTotal();
  return `<header class="${"banner svelte-1d437l"}"><img src="${"/img/banner.jpg"}" class="${"bg svelte-1d437l"}" alt="${""}">
    <img src="${"/img/logo_1.png"}" id="${"logo"}" alt="${"logo RacipeTime"}" class="${"svelte-1d437l"}">
    <h1 class="${"svelte-1d437l"}">RecipeTime</h1>
    <p class="${"svelte-1d437l"}">\xBFQu\xE9 esperas para saciar tu antojo?</p></header>
<div class="${"container svelte-1d437l"}"><div class="${"title-container svelte-1d437l"}"><h4 class="${"svelte-1d437l"}">Recetas</h4>
        <div class="${"linea svelte-1d437l"}"></div></div>
    <div class="${"recipes svelte-1d437l"}">${each($recetasTotal, (item) => `
            ${validate_component(RecipeCard, "RecipeCard").$$render($$result, {
    imgURL: item.imgURL,
    title: item.titulo,
    description: item.descripcion,
    stars: item.puntuado,
    id: item.id
  }, {}, {})}`)}</div>
</div>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes
});
var css$6 = {
  code: ".container.svelte-19q68vd.svelte-19q68vd{display:flex;flex-direction:column}.container.svelte-19q68vd .paper.svelte-19q68vd{position:relative;background:white;border-bottom:solid 4px #f05a28}.container.svelte-19q68vd .paper.svelte-19q68vd::before{content:'';width:2px;height:100%;position:absolute;top:0;left:40px;background-color:#f05a28}.container.svelte-19q68vd .paper #pattern.svelte-19q68vd{height:100%;background-image:repeating-linear-gradient(white 0px, white 24px, teal 25px)}.container.svelte-19q68vd .paper .form-container.svelte-19q68vd{display:flex;flex-direction:column;padding:23px 20px 20px 56px;line-height:25px;letter-spacing:1px;word-spacing:5px}.container.svelte-19q68vd .paper .form-container header.svelte-19q68vd{color:#f05a28;font-family:'Bad Script', cursive;font-size:2.5em;margin-bottom:30px}.container.svelte-19q68vd .paper .form-container label.svelte-19q68vd{font-weight:bold;font-family:'Bad Script', cursive;color:#f05a28;font-size:1.4em;margin-bottom:5px}.container.svelte-19q68vd .paper .form-container label.svelte-19q68vd:nth-of-type(2){margin-bottom:2px}.container.svelte-19q68vd .paper .form-container label.svelte-19q68vd:nth-of-type(3){margin-bottom:4px}.container.svelte-19q68vd .paper .form-container .no-spin.svelte-19q68vd::-webkit-inner-spin-button,.container.svelte-19q68vd .paper .form-container .no-spin.svelte-19q68vd::-webkit-outer-spin-button{-webkit-appearance:none !important;margin:0 !important}.container.svelte-19q68vd .paper .form-container .no-spin.svelte-19q68vd{-moz-appearance:textfield !important}.container.svelte-19q68vd .paper .form-container input.svelte-19q68vd:nth-of-type(1),.container.svelte-19q68vd .paper .form-container input.svelte-19q68vd:nth-of-type(2){margin-bottom:27px}.container.svelte-19q68vd .paper .form-container input.svelte-19q68vd,.container.svelte-19q68vd .paper .form-container #descripcion.svelte-19q68vd{background:transparent;box-sizing:content-box;border:none;outline:none;margin-bottom:24px}.container.svelte-19q68vd .paper .form-container #descripcion.svelte-19q68vd{resize:none;line-height:24px}.container.svelte-19q68vd .paper .form-container .form-lista.svelte-19q68vd{display:flex;margin-top:-8px;margin-bottom:26px}.container.svelte-19q68vd .paper .form-container .form-lista input.svelte-19q68vd{margin-bottom:0;margin-top:8px;width:100%}.container.svelte-19q68vd .paper .form-container .form-lista button.svelte-19q68vd{border:none;background:transparent;cursor:pointer;color:#f05a28;font-weight:bold;display:flex;align-items:center;transition:all .3s;background:transparent;border-radius:10px;padding:0px 10px;height:24px}.container.svelte-19q68vd .paper .form-container .form-lista button span.svelte-19q68vd{margin-left:5px}.container.svelte-19q68vd .paper .form-container .form-lista button.svelte-19q68vd:hover{background:#f05a28;color:white}.container.svelte-19q68vd .paper .form-container select.svelte-19q68vd{margin-top:0px;margin-bottom:26px;background:transparent;border:none}.container.svelte-19q68vd .paper .form-container .button-container.svelte-19q68vd{margin-top:-8px;display:flex;height:24px;margin-bottom:26px;position:relative}.container.svelte-19q68vd .paper .form-container .button-container .button-file.svelte-19q68vd{background-color:white;font-size:1em;font-family:'Work Sans', sans-serif;border-radius:10px;color:#f05a28;transition:all 0.3s;cursor:pointer;height:24px;display:flex;align-items:center;justify-content:center;width:220px;padding:0 10px;position:absolute;z-index:1}.container.svelte-19q68vd .paper .form-container .button-container .button-file.svelte-19q68vd:hover{background-color:#f05a28;color:white}.container.svelte-19q68vd .paper .form-container .button-container .button-file span.svelte-19q68vd{margin-left:10px}.container.svelte-19q68vd .paper .form-container .button-container input.svelte-19q68vd{position:absolute;left:152px;top:1px;font-size:12px}.container.svelte-19q68vd .preview.svelte-19q68vd{display:flex;flex-direction:column;align-items:center;background:white}.container.svelte-19q68vd .preview .title-space.svelte-19q68vd{width:100%;height:400px;position:relative;font-weight:bold;color:white;font-size:2em;border-bottom:solid 4px #f05a28}.container.svelte-19q68vd .preview .title-space img.svelte-19q68vd{width:100%;height:100%;object-fit:cover;position:absolute}.container.svelte-19q68vd .preview .title-space header.svelte-19q68vd{position:absolute;top:20px;left:20px;z-index:1;text-transform:uppercase;font-weight:bold}.container.svelte-19q68vd .preview .title-space span.svelte-19q68vd{position:absolute;bottom:20px;right:20px;z-index:1}.container.svelte-19q68vd .preview .title-space.svelte-19q68vd::after{content:'';position:absolute;width:100%;height:100%;background:rgba(0, 0, 0, 0.3)}.container.svelte-19q68vd .preview .recipe-container.svelte-19q68vd{min-width:100%;padding:30px}.container.svelte-19q68vd .preview .recipe-container .meta-container.svelte-19q68vd{margin-bottom:10px;display:flex;justify-content:space-around;flex-wrap:wrap;font-size:14px}.container.svelte-19q68vd .preview .recipe-container .meta-container span.svelte-19q68vd{font-weight:bold}.container.svelte-19q68vd .preview .recipe-container .title-container.svelte-19q68vd{display:flex;align-items:center;margin:20px 0}.container.svelte-19q68vd .preview .recipe-container .title-container h4.svelte-19q68vd{font-size:1.5em;margin-right:4px}.container.svelte-19q68vd .preview .recipe-container .title-container .linea.svelte-19q68vd{width:100%;border-top:dashed 3px #f05a28}.container.svelte-19q68vd #subir.svelte-19q68vd{background:#f05a28;border-radius:50px;border:solid 2px #f05a28;height:49px;color:white;font-weight:bold;text-transform:uppercase;font-size:1.4em;cursor:pointer;transition:all .2s}.container.svelte-19q68vd #subir.svelte-19q68vd:hover{color:#f05a28;background-color:white}@media(min-width: 768px){.container.svelte-19q68vd.svelte-19q68vd{flex-direction:row;min-height:calc(100vh - 65px)}.container.svelte-19q68vd .paper.svelte-19q68vd{min-width:450px;border-bottom:none;border-right:solid 4px #f05a28;overflow-y:scroll}.container.svelte-19q68vd .preview.svelte-19q68vd{width:100%}}",
  map: `{"version":3,"file":"aggreceta.svelte","sources":["aggreceta.svelte"],"sourcesContent":["<script>\\n\\n    import { db } from \\"../firebase\\";\\n    import { auth } from \\"../firebase\\";\\n    import { storage } from \\"../firebase\\";\\n    import { correoUsuario } from \\"../store\\";\\n\\n    //Inicializacion de variables genereales\\n    let titulo = '';\\n    let duracion = 0;\\n    let descripcion = '';\\n    let dificultad = 'Facil';\\n    let imagen;\\n    let  avatar, fileinput;\\n\\n\\n    //Apartado de seleccion de imagen\\n    const onFileSelected =(e)=>{\\n        imagen = e.target.files[0];\\n        let reader = new FileReader();\\n        reader.readAsDataURL(imagen);\\n        reader.onload = e => {\\n            avatar = e.target.result\\n        };\\n    }\\n\\n    //Apartado de ingredientes\\n    let nIngredientes = 1;\\n    let ingrediente = '';\\n    let ingredientes = [];\\n\\n    const aggIngrediente = () =>{\\n        ingredientes = [...ingredientes,ingrediente]\\n        nIngredientes ++;\\n        ingrediente = '';\\n        console.log(ingredientes)\\n    }\\n\\n    //Apartado de Pasos\\n    let nPasos = 1;\\n    let paso = '';\\n    let pasos = [];\\n\\n    const aggPaso = () =>{\\n        pasos = [... pasos,paso]\\n        nPasos ++;\\n        paso = '';\\n        console.log(pasos)\\n    }\\n\\n\\n    //Subir recetas\\n    const subirReceta = async ()  =>{\\n        let user = auth.currentUser\\n\\n        ///////////////////////////////////////SUBIENDO IMAGEN\\n        //variables de uso\\n\\n        let storageRef = storage.ref('/recetas/' + $correoUsuario + imagen.name);\\n        \\n        let uploadTask = storageRef.put(imagen);\\n\\n        const funcion = async () =>{\\n             uploadTask.on('state_changed', function(){\\n                },function(error) {\\n                        console.log(error.message)\\n                },function() {\\n                    uploadTask.snapshot.ref.getDownloadURL().then(function(downloadURL) {\\n                        let receta = {\\n                            autor: user.email,\\n                            titulo: titulo,\\n                            descripcion: descripcion,\\n                            duracion: duracion,\\n                            dificultad: dificultad,\\n                            ingredientes:ingredientes,\\n                            pasos:pasos,\\n                            puntuado:0.0,\\n                            imgURL: downloadURL\\n                        }\\n\\n                        db.collection('recetas/').doc().set(receta);\\n                        console.log(\\"SUBIDA EXITOSA BRINDEMOOOS\\")\\n                        ////////////////////////////////////////////////////////RESETEO\\n                        //reinicio de ingredientes\\n                        nIngredientes = 1;\\n                        ingredientes = [];\\n                        ingrediente = '';\\n\\n                        //reinicio de pasos\\n                        nPasos = 1;\\n                        paso = '';\\n                        pasos = [];\\n\\n                        //Reinicio general\\n                        titulo = '';\\n                        duracion = 0;\\n                        descripcion = '';\\n                        imagen = '';\\n\\n                    });\\n            });\\n        }\\n\\n        funcion()\\n        \\n    }\\n<\/script>\\n\\n<div class=\\"container\\">\\n    <form class=\\"paper\\">\\n        <div id=\\"pattern\\">\\n            <form on:submit|preventDefault={subirReceta} class=\\"form-container\\">\\n                <header>Agregar receta</header>\\n                \\n                <label for=\\"title\\">Titulo de la receta</label>\\n                <input type=\\"text\\" name=\\"title\\" bind:value={titulo} placeholder=\\"Titulo Receta\\">\\n                \\n                <label for=\\"\\">Descripcion de la receta</label>\\n                <textarea name=\\"\\" id=\\"descripcion\\" bind:value={descripcion} cols=\\"30\\" rows=\\"2\\" placeholder=\\"Descripcion de la receta\\"></textarea>\\n                \\n                <label for=\\"\\">Duracion en minutos</label>\\n                <input class='no-spin' type=\\"number\\" bind:value={duracion} placeholder=\\"Duracion de la receta\\" min=\\"1\\">\\n                \\n                <label for=\\"\\">Lista de ingredientes</label>\\n                <form on:submit|preventDefault={aggIngrediente} class=\\"form-lista\\">\\n                    <input type=\\"text\\" bind:value={ingrediente} placeholder=\\"Ingrediente {nIngredientes}\\">\\n                    <button>Agregar <span class=\\"fas fa-check\\"></span></button>\\n                </form>\\n\\n                <label for=\\"\\">Pasos a seguir</label>\\n                <form on:submit|preventDefault={aggPaso} class=\\"form-lista\\">\\n                    <input type=\\"text\\" bind:value={paso} placeholder=\\"Pasos a seguir {[nPasos]}\\">\\n                    <button>Agregar <span class=\\"fas fa-check\\"></span></button>\\n                </form>               \\n                <label for=\\"\\">Dificultad</label>\\n                <select name=\\"dificultad\\" id=\\"dificultad\\" bind:value={dificultad}>\\n                    <option value=\\"Facil\\">Facil</option>\\n                    <option value=\\"Intermedio\\">Intermedio</option>\\n                    <option value=\\"Dificil\\">Dificil</option>\\n                </select>\\n                <label for=\\"\\">Foto</label>\\n                <div class=\\"button-container\\">\\n                    <label class=\\"button-file\\" for=\\"foto\\">Seleccionar foto <span class=\\"fas fa-file-image\\"></span></label>\\n                    <input type=\\"file\\" id=\\"foto\\" on:change={(e)=>onFileSelected(e)} bind:this={fileinput} >\\n                </div>\\n                \\n                <button id=\\"subir\\">Subir</button> \\n            </form>\\n        </div>\\n    </form>\\n    <section class=\\"preview\\">\\n        <div class=\\"title-space\\">\\n            {#if avatar}\\n                <img src=\\"{avatar}\\" alt=\\"d\\" />\\n            {:else}\\n                <img src=\\"/img/preview.jpg\\" alt=\\"\\" /> \\n            {/if}\\n            <header>{titulo}</header>\\n            <span>?/5</span>\\n        </div>\\n        <div class=\\"recipe-container\\">\\n            <div class=\\"meta-container\\">\\n                <p><span>Dificultad: </span>{dificultad}</p>\\n                <p><span>Duraci&oacute;n:</span> {(duracion === 0) ? duracion = \\"\\" : duracion} min </p>\\n            </div>\\n            <p id=\\"descripcion-preview\\">{descripcion}</p>\\n            <div class=\\"title-container\\">\\n                <h4>Ingredientes</h4>\\n                <div class='linea'></div>\\n            </div>\\n\\n            {#each ingredientes as item, i}\\n                 <!-- content here -->\\n                <p>{i + 1}. {item}</p>\\n            {/each}\\n    \\n            <div class=\\"title-container\\">\\n                <h4>Instrucciones</h4>\\n                <div class='linea'></div>\\n            </div>\\n    \\n            {#each pasos as item, i}\\n                 <!-- content here -->\\n                <p>{i + 1}. {item}</p>\\n            {/each}\\n\\n    </section>\\n</div>\\n\\n<style lang=\\"scss\\">.container {\\n  display: flex;\\n  flex-direction: column; }\\n  .container .paper {\\n    position: relative;\\n    background: white;\\n    border-bottom: solid 4px #f05a28; }\\n    .container .paper::before {\\n      content: '';\\n      width: 2px;\\n      height: 100%;\\n      position: absolute;\\n      top: 0;\\n      left: 40px;\\n      background-color: #f05a28; }\\n    .container .paper #pattern {\\n      height: 100%;\\n      background-image: repeating-linear-gradient(white 0px, white 24px, teal 25px); }\\n    .container .paper .form-container {\\n      display: flex;\\n      flex-direction: column;\\n      padding: 23px 20px 20px 56px;\\n      line-height: 25px;\\n      letter-spacing: 1px;\\n      word-spacing: 5px; }\\n      .container .paper .form-container header {\\n        color: #f05a28;\\n        font-family: 'Bad Script', cursive;\\n        font-size: 2.5em;\\n        margin-bottom: 30px; }\\n      .container .paper .form-container label {\\n        font-weight: bold;\\n        font-family: 'Bad Script', cursive;\\n        color: #f05a28;\\n        font-size: 1.4em;\\n        margin-bottom: 5px; }\\n        .container .paper .form-container label:nth-of-type(2) {\\n          margin-bottom: 2px; }\\n        .container .paper .form-container label:nth-of-type(3) {\\n          margin-bottom: 4px; }\\n      .container .paper .form-container .no-spin::-webkit-inner-spin-button, .container .paper .form-container .no-spin::-webkit-outer-spin-button {\\n        -webkit-appearance: none !important;\\n        margin: 0 !important; }\\n      .container .paper .form-container .no-spin {\\n        -moz-appearance: textfield !important; }\\n      .container .paper .form-container input:nth-of-type(1), .container .paper .form-container input:nth-of-type(2) {\\n        margin-bottom: 27px; }\\n      .container .paper .form-container input,\\n      .container .paper .form-container #descripcion {\\n        background: transparent;\\n        box-sizing: content-box;\\n        border: none;\\n        outline: none;\\n        margin-bottom: 24px; }\\n      .container .paper .form-container #descripcion {\\n        resize: none;\\n        line-height: 24px; }\\n      .container .paper .form-container .form-lista {\\n        display: flex;\\n        margin-top: -8px;\\n        margin-bottom: 26px; }\\n        .container .paper .form-container .form-lista input {\\n          margin-bottom: 0;\\n          margin-top: 8px;\\n          width: 100%; }\\n        .container .paper .form-container .form-lista button {\\n          border: none;\\n          background: transparent;\\n          cursor: pointer;\\n          color: #f05a28;\\n          font-weight: bold;\\n          display: flex;\\n          align-items: center;\\n          transition: all .3s;\\n          background: transparent;\\n          border-radius: 10px;\\n          padding: 0px 10px;\\n          height: 24px; }\\n          .container .paper .form-container .form-lista button span {\\n            margin-left: 5px; }\\n          .container .paper .form-container .form-lista button:hover {\\n            background: #f05a28;\\n            color: white; }\\n      .container .paper .form-container select {\\n        margin-top: 0px;\\n        margin-bottom: 26px;\\n        background: transparent;\\n        border: none; }\\n      .container .paper .form-container .button-container {\\n        margin-top: -8px;\\n        display: flex;\\n        height: 24px;\\n        margin-bottom: 26px;\\n        position: relative; }\\n        .container .paper .form-container .button-container .button-file {\\n          background-color: white;\\n          font-size: 1em;\\n          font-family: 'Work Sans', sans-serif;\\n          border-radius: 10px;\\n          color: #f05a28;\\n          transition: all 0.3s;\\n          cursor: pointer;\\n          height: 24px;\\n          display: flex;\\n          align-items: center;\\n          justify-content: center;\\n          width: 220px;\\n          padding: 0 10px;\\n          position: absolute;\\n          z-index: 1; }\\n          .container .paper .form-container .button-container .button-file:hover {\\n            background-color: #f05a28;\\n            color: white; }\\n          .container .paper .form-container .button-container .button-file span {\\n            margin-left: 10px; }\\n        .container .paper .form-container .button-container input {\\n          position: absolute;\\n          left: 152px;\\n          top: 1px;\\n          font-size: 12px; }\\n  .container .preview {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    background: white; }\\n    .container .preview .title-space {\\n      width: 100%;\\n      height: 400px;\\n      position: relative;\\n      font-weight: bold;\\n      color: white;\\n      font-size: 2em;\\n      border-bottom: solid 4px #f05a28; }\\n      .container .preview .title-space img {\\n        width: 100%;\\n        height: 100%;\\n        object-fit: cover;\\n        position: absolute; }\\n      .container .preview .title-space header {\\n        position: absolute;\\n        top: 20px;\\n        left: 20px;\\n        z-index: 1;\\n        text-transform: uppercase;\\n        font-weight: bold; }\\n      .container .preview .title-space span {\\n        position: absolute;\\n        bottom: 20px;\\n        right: 20px;\\n        z-index: 1; }\\n      .container .preview .title-space::after {\\n        content: '';\\n        position: absolute;\\n        width: 100%;\\n        height: 100%;\\n        background: rgba(0, 0, 0, 0.3); }\\n    .container .preview .recipe-container {\\n      min-width: 100%;\\n      padding: 30px; }\\n      .container .preview .recipe-container .meta-container {\\n        margin-bottom: 10px;\\n        display: flex;\\n        justify-content: space-around;\\n        flex-wrap: wrap;\\n        font-size: 14px; }\\n        .container .preview .recipe-container .meta-container span {\\n          font-weight: bold; }\\n      .container .preview .recipe-container .title-container {\\n        display: flex;\\n        align-items: center;\\n        margin: 20px 0; }\\n        .container .preview .recipe-container .title-container h4 {\\n          font-size: 1.5em;\\n          margin-right: 4px; }\\n        .container .preview .recipe-container .title-container .linea {\\n          width: 100%;\\n          border-top: dashed 3px #f05a28; }\\n  .container #subir {\\n    background: #f05a28;\\n    border-radius: 50px;\\n    border: solid 2px #f05a28;\\n    height: 49px;\\n    color: white;\\n    font-weight: bold;\\n    text-transform: uppercase;\\n    font-size: 1.4em;\\n    cursor: pointer;\\n    transition: all .2s; }\\n    .container #subir:hover {\\n      color: #f05a28;\\n      background-color: white; }\\n  @media (min-width: 768px) {\\n    .container {\\n      flex-direction: row;\\n      min-height: calc(100vh - 65px); }\\n      .container .paper {\\n        min-width: 450px;\\n        border-bottom: none;\\n        border-right: solid 4px #f05a28;\\n        overflow-y: scroll; }\\n      .container .preview {\\n        width: 100%; } }\\n</style>\\n"],"names":[],"mappings":"AA6LmB,UAAU,8BAAC,CAAC,AAC7B,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AAAE,CAAC,AACzB,yBAAU,CAAC,MAAM,eAAC,CAAC,AACjB,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,KAAK,CACjB,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACnC,yBAAU,CAAC,qBAAM,QAAQ,AAAC,CAAC,AACzB,OAAO,CAAE,EAAE,CACX,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,IAAI,CACV,gBAAgB,CAAE,OAAO,AAAE,CAAC,AAC9B,yBAAU,CAAC,MAAM,CAAC,QAAQ,eAAC,CAAC,AAC1B,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,0BAA0B,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,AAAE,CAAC,AAClF,yBAAU,CAAC,MAAM,CAAC,eAAe,eAAC,CAAC,AACjC,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,OAAO,CAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAC5B,WAAW,CAAE,IAAI,CACjB,cAAc,CAAE,GAAG,CACnB,YAAY,CAAE,GAAG,AAAE,CAAC,AACpB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,MAAM,eAAC,CAAC,AACxC,KAAK,CAAE,OAAO,CACd,WAAW,CAAE,YAAY,CAAC,CAAC,OAAO,CAClC,SAAS,CAAE,KAAK,CAChB,aAAa,CAAE,IAAI,AAAE,CAAC,AACxB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,eAAC,CAAC,AACvC,WAAW,CAAE,IAAI,CACjB,WAAW,CAAE,YAAY,CAAC,CAAC,OAAO,CAClC,KAAK,CAAE,OAAO,CACd,SAAS,CAAE,KAAK,CAChB,aAAa,CAAE,GAAG,AAAE,CAAC,AACrB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,oBAAK,aAAa,CAAC,CAAC,AAAC,CAAC,AACtD,aAAa,CAAE,GAAG,AAAE,CAAC,AACvB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,oBAAK,aAAa,CAAC,CAAC,AAAC,CAAC,AACtD,aAAa,CAAE,GAAG,AAAE,CAAC,AACzB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,uBAAQ,2BAA2B,CAAE,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,uBAAQ,2BAA2B,AAAC,CAAC,AAC5I,kBAAkB,CAAE,IAAI,CAAC,UAAU,CACnC,MAAM,CAAE,CAAC,CAAC,UAAU,AAAE,CAAC,AACzB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,QAAQ,eAAC,CAAC,AAC1C,eAAe,CAAE,SAAS,CAAC,UAAU,AAAE,CAAC,AAC1C,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,oBAAK,aAAa,CAAC,CAAC,CAAE,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,oBAAK,aAAa,CAAC,CAAC,AAAC,CAAC,AAC9G,aAAa,CAAE,IAAI,AAAE,CAAC,AACxB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,oBAAK,CACvC,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,YAAY,eAAC,CAAC,AAC9C,UAAU,CAAE,WAAW,CACvB,UAAU,CAAE,WAAW,CACvB,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,IAAI,CACb,aAAa,CAAE,IAAI,AAAE,CAAC,AACxB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,YAAY,eAAC,CAAC,AAC9C,MAAM,CAAE,IAAI,CACZ,WAAW,CAAE,IAAI,AAAE,CAAC,AACtB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,eAAC,CAAC,AAC7C,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,IAAI,CAChB,aAAa,CAAE,IAAI,AAAE,CAAC,AACtB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,KAAK,eAAC,CAAC,AACnD,aAAa,CAAE,CAAC,CAChB,UAAU,CAAE,GAAG,CACf,KAAK,CAAE,IAAI,AAAE,CAAC,AAChB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,MAAM,eAAC,CAAC,AACpD,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,WAAW,CACvB,MAAM,CAAE,OAAO,CACf,KAAK,CAAE,OAAO,CACd,WAAW,CAAE,IAAI,CACjB,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,UAAU,CAAE,GAAG,CAAC,GAAG,CACnB,UAAU,CAAE,WAAW,CACvB,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,GAAG,CAAC,IAAI,CACjB,MAAM,CAAE,IAAI,AAAE,CAAC,AACf,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,eAAC,CAAC,AACzD,WAAW,CAAE,GAAG,AAAE,CAAC,AACrB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,qBAAM,MAAM,AAAC,CAAC,AAC1D,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,KAAK,AAAE,CAAC,AACrB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,MAAM,eAAC,CAAC,AACxC,UAAU,CAAE,GAAG,CACf,aAAa,CAAE,IAAI,CACnB,UAAU,CAAE,WAAW,CACvB,MAAM,CAAE,IAAI,AAAE,CAAC,AACjB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,iBAAiB,eAAC,CAAC,AACnD,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,IAAI,CACnB,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACrB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,iBAAiB,CAAC,YAAY,eAAC,CAAC,AAChE,gBAAgB,CAAE,KAAK,CACvB,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,WAAW,CAAC,CAAC,UAAU,CACpC,aAAa,CAAE,IAAI,CACnB,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,GAAG,CAAC,IAAI,CACpB,MAAM,CAAE,OAAO,CACf,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,CAAC,CAAC,IAAI,CACf,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AAAE,CAAC,AACb,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,iBAAiB,CAAC,2BAAY,MAAM,AAAC,CAAC,AACtE,gBAAgB,CAAE,OAAO,CACzB,KAAK,CAAE,KAAK,AAAE,CAAC,AACjB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,iBAAiB,CAAC,YAAY,CAAC,IAAI,eAAC,CAAC,AACrE,WAAW,CAAE,IAAI,AAAE,CAAC,AACxB,yBAAU,CAAC,MAAM,CAAC,eAAe,CAAC,iBAAiB,CAAC,KAAK,eAAC,CAAC,AACzD,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,KAAK,CACX,GAAG,CAAE,GAAG,CACR,SAAS,CAAE,IAAI,AAAE,CAAC,AAC1B,yBAAU,CAAC,QAAQ,eAAC,CAAC,AACnB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,UAAU,CAAE,KAAK,AAAE,CAAC,AACpB,yBAAU,CAAC,QAAQ,CAAC,YAAY,eAAC,CAAC,AAChC,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,CACb,QAAQ,CAAE,QAAQ,CAClB,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,GAAG,CACd,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACnC,yBAAU,CAAC,QAAQ,CAAC,YAAY,CAAC,GAAG,eAAC,CAAC,AACpC,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CACjB,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACvB,yBAAU,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,eAAC,CAAC,AACvC,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,OAAO,CAAE,CAAC,CACV,cAAc,CAAE,SAAS,CACzB,WAAW,CAAE,IAAI,AAAE,CAAC,AACtB,yBAAU,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,eAAC,CAAC,AACrC,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,CAAC,AAAE,CAAC,AACf,yBAAU,CAAC,QAAQ,CAAC,2BAAY,OAAO,AAAC,CAAC,AACvC,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AAAE,CAAC,AACrC,yBAAU,CAAC,QAAQ,CAAC,iBAAiB,eAAC,CAAC,AACrC,SAAS,CAAE,IAAI,CACf,OAAO,CAAE,IAAI,AAAE,CAAC,AAChB,yBAAU,CAAC,QAAQ,CAAC,iBAAiB,CAAC,eAAe,eAAC,CAAC,AACrD,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,CAC7B,SAAS,CAAE,IAAI,CACf,SAAS,CAAE,IAAI,AAAE,CAAC,AAClB,yBAAU,CAAC,QAAQ,CAAC,iBAAiB,CAAC,eAAe,CAAC,IAAI,eAAC,CAAC,AAC1D,WAAW,CAAE,IAAI,AAAE,CAAC,AACxB,yBAAU,CAAC,QAAQ,CAAC,iBAAiB,CAAC,gBAAgB,eAAC,CAAC,AACtD,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,IAAI,CAAC,CAAC,AAAE,CAAC,AACjB,yBAAU,CAAC,QAAQ,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,EAAE,eAAC,CAAC,AACzD,SAAS,CAAE,KAAK,CAChB,YAAY,CAAE,GAAG,AAAE,CAAC,AACtB,yBAAU,CAAC,QAAQ,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,MAAM,eAAC,CAAC,AAC7D,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACzC,yBAAU,CAAC,MAAM,eAAC,CAAC,AACjB,UAAU,CAAE,OAAO,CACnB,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CACzB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,KAAK,CACZ,WAAW,CAAE,IAAI,CACjB,cAAc,CAAE,SAAS,CACzB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,GAAG,CAAC,GAAG,AAAE,CAAC,AACtB,yBAAU,CAAC,qBAAM,MAAM,AAAC,CAAC,AACvB,KAAK,CAAE,OAAO,CACd,gBAAgB,CAAE,KAAK,AAAE,CAAC,AAC9B,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,UAAU,8BAAC,CAAC,AACV,cAAc,CAAE,GAAG,CACnB,UAAU,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,AAAE,CAAC,AACjC,yBAAU,CAAC,MAAM,eAAC,CAAC,AACjB,SAAS,CAAE,KAAK,CAChB,aAAa,CAAE,IAAI,CACnB,YAAY,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CAC/B,UAAU,CAAE,MAAM,AAAE,CAAC,AACvB,yBAAU,CAAC,QAAQ,eAAC,CAAC,AACnB,KAAK,CAAE,IAAI,AAAE,CAAC,AAAC,CAAC"}`
};
var Aggreceta = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_correoUsuario;
  $$unsubscribe_correoUsuario = subscribe(correoUsuario, (value) => value);
  let titulo = "";
  let duracion = 0;
  let descripcion = "";
  let dificultad = "Facil";
  let nIngredientes = 1;
  let ingrediente = "";
  let ingredientes = [];
  let nPasos = 1;
  let paso = "";
  let pasos = [];
  $$result.css.add(css$6);
  $$unsubscribe_correoUsuario();
  return `<div class="${"container svelte-19q68vd"}"><form class="${"paper svelte-19q68vd"}"><div id="${"pattern"}" class="${"svelte-19q68vd"}"><form class="${"form-container svelte-19q68vd"}"><header class="${"svelte-19q68vd"}">Agregar receta</header>
                
                <label for="${"title"}" class="${"svelte-19q68vd"}">Titulo de la receta</label>
                <input type="${"text"}" name="${"title"}" placeholder="${"Titulo Receta"}" class="${"svelte-19q68vd"}"${add_attribute("value", titulo, 0)}>
                
                <label for="${""}" class="${"svelte-19q68vd"}">Descripcion de la receta</label>
                <textarea name="${""}" id="${"descripcion"}" cols="${"30"}" rows="${"2"}" placeholder="${"Descripcion de la receta"}" class="${"svelte-19q68vd"}">${""}</textarea>
                
                <label for="${""}" class="${"svelte-19q68vd"}">Duracion en minutos</label>
                <input class="${"no-spin svelte-19q68vd"}" type="${"number"}" placeholder="${"Duracion de la receta"}" min="${"1"}"${add_attribute("value", duracion, 0)}>
                
                <label for="${""}" class="${"svelte-19q68vd"}">Lista de ingredientes</label>
                <form class="${"form-lista svelte-19q68vd"}"><input type="${"text"}" placeholder="${"Ingrediente " + escape2(nIngredientes)}" class="${"svelte-19q68vd"}"${add_attribute("value", ingrediente, 0)}>
                    <button class="${"svelte-19q68vd"}">Agregar <span class="${"fas fa-check svelte-19q68vd"}"></span></button></form>

                <label for="${""}" class="${"svelte-19q68vd"}">Pasos a seguir</label>
                <form class="${"form-lista svelte-19q68vd"}"><input type="${"text"}" placeholder="${"Pasos a seguir " + escape2([nPasos])}" class="${"svelte-19q68vd"}"${add_attribute("value", paso, 0)}>
                    <button class="${"svelte-19q68vd"}">Agregar <span class="${"fas fa-check svelte-19q68vd"}"></span></button></form>               
                <label for="${""}" class="${"svelte-19q68vd"}">Dificultad</label>
                <select name="${"dificultad"}" id="${"dificultad"}" class="${"svelte-19q68vd"}"><option value="${"Facil"}">Facil</option><option value="${"Intermedio"}">Intermedio</option><option value="${"Dificil"}">Dificil</option></select>
                <label for="${""}" class="${"svelte-19q68vd"}">Foto</label>
                <div class="${"button-container svelte-19q68vd"}"><label class="${"button-file svelte-19q68vd"}" for="${"foto"}">Seleccionar foto <span class="${"fas fa-file-image svelte-19q68vd"}"></span></label>
                    <input type="${"file"}" id="${"foto"}" class="${"svelte-19q68vd"}"></div>
                
                <button id="${"subir"}" class="${"svelte-19q68vd"}">Subir</button></form></div></form>
    <section class="${"preview svelte-19q68vd"}"><div class="${"title-space svelte-19q68vd"}">${`<img src="${"/img/preview.jpg"}" alt="${""}" class="${"svelte-19q68vd"}">`}
            <header class="${"svelte-19q68vd"}">${escape2(titulo)}</header>
            <span class="${"svelte-19q68vd"}">?/5</span></div>
        <div class="${"recipe-container svelte-19q68vd"}"><div class="${"meta-container svelte-19q68vd"}"><p><span class="${"svelte-19q68vd"}">Dificultad: </span>${escape2(dificultad)}</p>
                <p><span class="${"svelte-19q68vd"}">Duraci\xF3n:</span> ${escape2(duracion === 0 ? duracion = "" : duracion)} min </p></div>
            <p id="${"descripcion-preview"}">${escape2(descripcion)}</p>
            <div class="${"title-container svelte-19q68vd"}"><h4 class="${"svelte-19q68vd"}">Ingredientes</h4>
                <div class="${"linea svelte-19q68vd"}"></div></div>

            ${each(ingredientes, (item, i) => `
                <p>${escape2(i + 1)}. ${escape2(item)}</p>`)}
    
            <div class="${"title-container svelte-19q68vd"}"><h4 class="${"svelte-19q68vd"}">Instrucciones</h4>
                <div class="${"linea svelte-19q68vd"}"></div></div>
    
            ${each(pasos, (item, i) => `
                <p>${escape2(i + 1)}. ${escape2(item)}</p>`)}</div></section>
</div>`;
});
var aggreceta = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Aggreceta
});
var css$5 = {
  code: ".container.svelte-x5agaf.svelte-x5agaf{display:flex;flex-direction:column;height:calc(100vh - 65px)}.container.svelte-x5agaf img.svelte-x5agaf{width:100%;height:100%;min-height:250px;overflow:hidden;object-fit:cover;object-position:center;border-bottom:solid 2px #f05a28}.container.svelte-x5agaf form.svelte-x5agaf{background:white;display:flex;justify-content:center;align-items:center}.container.svelte-x5agaf form p.svelte-x5agaf{font-size:12px}.container.svelte-x5agaf form p.svelte-x5agaf:first-of-type{margin-bottom:5px}.container.svelte-x5agaf form a.svelte-x5agaf{color:#f05a28}.container.svelte-x5agaf form div.svelte-x5agaf{display:flex;flex-direction:column;max-width:320px;padding:20px}.container.svelte-x5agaf form div h4.svelte-x5agaf{color:#f05a28;font-size:2em;margin-bottom:10px}.container.svelte-x5agaf form div label.svelte-x5agaf{font-weight:bold;color:#f05a28;display:block;position:relative;z-index:1;margin-left:10px}.container.svelte-x5agaf form div label span.svelte-x5agaf{background:white;padding:2px 10px}.container.svelte-x5agaf form div label #terms.svelte-x5agaf{display:inline;color:black}.container.svelte-x5agaf form div .terms-box.svelte-x5agaf{padding:10px 0;flex-direction:row;flex-wrap:nowrap;font-size:12px}.container.svelte-x5agaf form div button.svelte-x5agaf{background-color:#f05a28;border:solid 2px #f05a28;border-radius:20px;padding:10px;text-transform:uppercase;font-weight:bold;color:white;cursor:pointer;transition:all .2s}.container.svelte-x5agaf form div button.svelte-x5agaf:hover{background-color:white;color:#f05a28}.container.svelte-x5agaf form input.svelte-x5agaf{border:dashed 2px #f05a28;border-radius:20px 20px 0 0;padding:15px 10px 10px;outline:none;position:relative;margin-top:-10px;margin-bottom:5px}@media(min-width: 768px){.container.svelte-x5agaf.svelte-x5agaf{flex-direction:row}.container.svelte-x5agaf img.svelte-x5agaf{border-bottom:none;border-right:solid 2px #f05a28}.container.svelte-x5agaf form.svelte-x5agaf{width:100%}}",
  map: `{"version":3,"file":"register.svelte","sources":["register.svelte"],"sourcesContent":["<script>\\n    //Importamos la funcion de registro de usuario AUTH\\n   import {auth} from \\"../firebase\\";\\n   import { db } from \\"../firebase\\"\\n\\n    let email = ''//Email del usuario\\n    let password = ''//Password del usuario\\n    let confirm = ''//Confirmar password\\n    let username = ''//nombre del usuario\\n    const register = async () =>{//Funcion de registro de usuario\\n        try{\\n            if(password == confirm){\\n                await auth.createUserWithEmailAndPassword(email,password)\\n                \\n                let user = auth.currentUser\\n\\n                await user.updateProfile({\\n                    displayName:username\\n                }).then(() =>{\\n                    console.log(\\"Nombre de usuario registrado correctamente\\")\\n                }).catch((error) =>{\\n                    console.log(error)\\n                })\\n\\n                let usuario ={\\n                    correo: user.email,\\n                    id: user.uid,\\n                }\\n                await db.collection('usuarios/').doc().set(usuario);\\n\\n                //Mensaje de validacion\\n                console.log(\\"Usuario creado\\")\\n                \\n\\n                ///REDIRECCIONAMIENTO A PERFIL\\n                window.history.pushState('', '', '/profile');\\n                location.reload();\\n            }else{\\n                console.log(\\"CONTRASENIAS DIFERENTES\\")\\n            }\\n        } catch(error){\\n            //En caso de error al registrarse...\\n            console.log(error.code);\\n            console.log(error.message);\\n        }\\n    }\\n<\/script>\\n\\n<!--Formulario de registro-->\\n<div class=\\"container\\">\\n    <img src=\\"/img/bg_1.jpg\\" alt=\\"\\">\\n    <form on:submit|preventDefault={register}>\\n        <div>\\n            <h4>Registro</h4>\\n            <p><a href=\\"/login\\">Entra</a> o reg&iacute;strate para poder crear, clasificar, comentar o guardar recetas</p>\\n            <label for=\\"mail\\"> <span> Correo Electr&oacute;nico:</span></label>\\n            <input type=\\"text\\" name=\\"mail\\" bind:value={email}>\\n            <label for=\\"password\\"> <span> Contrase&ntilde;a:</span></label>\\n            <input type=\\"password\\" name=\\"password\\" bind:value={password}>\\n            <label for=\\"confirm\\"> <span> Confirmar contrase&ntilde;a:</span></label>\\n            <input type=\\"password\\" name=\\"confirm\\" bind:value={confirm}>\\n            <label for=\\"mail\\"> <span> Nombre de usuario:</span></label>\\n            <input type=\\"text\\" bind:value={username}>\\n            <p>www.recipetime.netlify.app/usuario/</p>\\n            <p>Se usa la direcci&oacute;n para tu p&aacute;gina de usuario, pi&eacute;nsalo bien porque no podr&aacute;s cambiarlo.</p>\\n            <div class=\\"terms-box\\">\\n                <input type=\\"checkbox\\" name=\\"terms\\" >\\n                <label for=\\"terms\\" id=\\"terms\\">He le&iacute;do y acepto la <a href=\\"/\\">pol&iacute;tica de privacidad y participaci&oacute;n.</a></label>\\n            </div>\\n            <br>\\n            <button>Registrar</button>\\n        </div>\\n    </form>\\n</div>\\n\\n<style lang=\\"scss\\">.container {\\n  display: flex;\\n  flex-direction: column;\\n  height: calc(100vh - 65px); }\\n  .container img {\\n    width: 100%;\\n    height: 100%;\\n    min-height: 250px;\\n    overflow: hidden;\\n    object-fit: cover;\\n    object-position: center;\\n    border-bottom: solid 2px #f05a28; }\\n  .container form {\\n    background: white;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center; }\\n    .container form p {\\n      font-size: 12px; }\\n      .container form p:first-of-type {\\n        margin-bottom: 5px; }\\n    .container form a {\\n      color: #f05a28; }\\n    .container form div {\\n      display: flex;\\n      flex-direction: column;\\n      max-width: 320px;\\n      padding: 20px; }\\n      .container form div h4 {\\n        color: #f05a28;\\n        font-size: 2em;\\n        margin-bottom: 10px; }\\n      .container form div label {\\n        font-weight: bold;\\n        color: #f05a28;\\n        display: block;\\n        position: relative;\\n        z-index: 1;\\n        margin-left: 10px; }\\n        .container form div label span {\\n          background: white;\\n          padding: 2px 10px; }\\n        .container form div label #terms {\\n          display: inline;\\n          color: black; }\\n      .container form div .terms-box {\\n        padding: 10px 0;\\n        flex-direction: row;\\n        flex-wrap: nowrap;\\n        font-size: 12px; }\\n      .container form div button {\\n        background-color: #f05a28;\\n        border: solid 2px #f05a28;\\n        border-radius: 20px;\\n        padding: 10px;\\n        text-transform: uppercase;\\n        font-weight: bold;\\n        color: white;\\n        cursor: pointer;\\n        transition: all .2s; }\\n        .container form div button:hover {\\n          background-color: white;\\n          color: #f05a28; }\\n    .container form input {\\n      border: dashed 2px #f05a28;\\n      border-radius: 20px 20px 0 0;\\n      padding: 15px 10px 10px;\\n      outline: none;\\n      position: relative;\\n      margin-top: -10px;\\n      margin-bottom: 5px; }\\n  @media (min-width: 768px) {\\n    .container {\\n      flex-direction: row; }\\n      .container img {\\n        border-bottom: none;\\n        border-right: solid 2px #f05a28; }\\n      .container form {\\n        width: 100%; } }\\n</style>\\n"],"names":[],"mappings":"AA2EmB,UAAU,4BAAC,CAAC,AAC7B,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,MAAM,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,AAAE,CAAC,AAC7B,wBAAU,CAAC,GAAG,cAAC,CAAC,AACd,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CACjB,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,KAAK,CACjB,eAAe,CAAE,MAAM,CACvB,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACrC,wBAAU,CAAC,IAAI,cAAC,CAAC,AACf,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,AAAE,CAAC,AACtB,wBAAU,CAAC,IAAI,CAAC,CAAC,cAAC,CAAC,AACjB,SAAS,CAAE,IAAI,AAAE,CAAC,AAClB,wBAAU,CAAC,IAAI,CAAC,eAAC,cAAc,AAAC,CAAC,AAC/B,aAAa,CAAE,GAAG,AAAE,CAAC,AACzB,wBAAU,CAAC,IAAI,CAAC,CAAC,cAAC,CAAC,AACjB,KAAK,CAAE,OAAO,AAAE,CAAC,AACnB,wBAAU,CAAC,IAAI,CAAC,GAAG,cAAC,CAAC,AACnB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,IAAI,AAAE,CAAC,AAChB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,cAAC,CAAC,AACtB,KAAK,CAAE,OAAO,CACd,SAAS,CAAE,GAAG,CACd,aAAa,CAAE,IAAI,AAAE,CAAC,AACxB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,cAAC,CAAC,AACzB,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,OAAO,CACd,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,WAAW,CAAE,IAAI,AAAE,CAAC,AACpB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,cAAC,CAAC,AAC9B,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,GAAG,CAAC,IAAI,AAAE,CAAC,AACtB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,cAAC,CAAC,AAChC,OAAO,CAAE,MAAM,CACf,KAAK,CAAE,KAAK,AAAE,CAAC,AACnB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,cAAC,CAAC,AAC9B,OAAO,CAAE,IAAI,CAAC,CAAC,CACf,cAAc,CAAE,GAAG,CACnB,SAAS,CAAE,MAAM,CACjB,SAAS,CAAE,IAAI,AAAE,CAAC,AACpB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,cAAC,CAAC,AAC1B,gBAAgB,CAAE,OAAO,CACzB,MAAM,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CACzB,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,SAAS,CACzB,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,GAAG,CAAC,GAAG,AAAE,CAAC,AACtB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,oBAAM,MAAM,AAAC,CAAC,AAChC,gBAAgB,CAAE,KAAK,CACvB,KAAK,CAAE,OAAO,AAAE,CAAC,AACvB,wBAAU,CAAC,IAAI,CAAC,KAAK,cAAC,CAAC,AACrB,MAAM,CAAE,MAAM,CAAC,GAAG,CAAC,OAAO,CAC1B,aAAa,CAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAC5B,OAAO,CAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CACvB,OAAO,CAAE,IAAI,CACb,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,KAAK,CACjB,aAAa,CAAE,GAAG,AAAE,CAAC,AACzB,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,UAAU,4BAAC,CAAC,AACV,cAAc,CAAE,GAAG,AAAE,CAAC,AACtB,wBAAU,CAAC,GAAG,cAAC,CAAC,AACd,aAAa,CAAE,IAAI,CACnB,YAAY,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACpC,wBAAU,CAAC,IAAI,cAAC,CAAC,AACf,KAAK,CAAE,IAAI,AAAE,CAAC,AAAC,CAAC"}`
};
var Register = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let email = "";
  let password = "";
  let confirm = "";
  let username = "";
  $$result.css.add(css$5);
  return `
<div class="${"container svelte-x5agaf"}"><img src="${"/img/bg_1.jpg"}" alt="${""}" class="${"svelte-x5agaf"}">
    <form class="${"svelte-x5agaf"}"><div class="${"svelte-x5agaf"}"><h4 class="${"svelte-x5agaf"}">Registro</h4>
            <p class="${"svelte-x5agaf"}"><a href="${"/login"}" class="${"svelte-x5agaf"}">Entra</a> o reg\xEDstrate para poder crear, clasificar, comentar o guardar recetas</p>
            <label for="${"mail"}" class="${"svelte-x5agaf"}"><span class="${"svelte-x5agaf"}">Correo Electr\xF3nico:</span></label>
            <input type="${"text"}" name="${"mail"}" class="${"svelte-x5agaf"}"${add_attribute("value", email, 0)}>
            <label for="${"password"}" class="${"svelte-x5agaf"}"><span class="${"svelte-x5agaf"}">Contrase\xF1a:</span></label>
            <input type="${"password"}" name="${"password"}" class="${"svelte-x5agaf"}"${add_attribute("value", password, 0)}>
            <label for="${"confirm"}" class="${"svelte-x5agaf"}"><span class="${"svelte-x5agaf"}">Confirmar contrase\xF1a:</span></label>
            <input type="${"password"}" name="${"confirm"}" class="${"svelte-x5agaf"}"${add_attribute("value", confirm, 0)}>
            <label for="${"mail"}" class="${"svelte-x5agaf"}"><span class="${"svelte-x5agaf"}">Nombre de usuario:</span></label>
            <input type="${"text"}" class="${"svelte-x5agaf"}"${add_attribute("value", username, 0)}>
            <p class="${"svelte-x5agaf"}">www.recipetime.netlify.app/usuario/</p>
            <p class="${"svelte-x5agaf"}">Se usa la direcci\xF3n para tu p\xE1gina de usuario, pi\xE9nsalo bien porque no podr\xE1s cambiarlo.</p>
            <div class="${"terms-box svelte-x5agaf"}"><input type="${"checkbox"}" name="${"terms"}" class="${"svelte-x5agaf"}">
                <label for="${"terms"}" id="${"terms"}" class="${"svelte-x5agaf"}">He le\xEDdo y acepto la <a href="${"/"}" class="${"svelte-x5agaf"}">pol\xEDtica de privacidad y participaci\xF3n.</a></label></div>
            <br>
            <button class="${"svelte-x5agaf"}">Registrar</button></div></form>
</div>`;
});
var register = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Register
});
var css$4 = {
  code: ".container.svelte-114dlfg.svelte-114dlfg{display:flex;flex-direction:column;height:calc(100vh - 65px)}.container.svelte-114dlfg .img-bg.svelte-114dlfg{width:100%;height:100%;min-height:320px;max-height:450px;overflow:hidden;background-image:url(/img/bg_2.jpg);background-size:cover;background-position:center;background-repeat:no-repeat;border-bottom:solid 2px #f05a28;display:flex;flex-direction:column;align-items:center;justify-content:center}.container.svelte-114dlfg .img-bg .profile-img.svelte-114dlfg{overflow:hidden;width:200px;height:200px;border-radius:50%;display:flex;position:relative;cursor:pointer}.container.svelte-114dlfg .img-bg .profile-img img.svelte-114dlfg{width:100%;object-fit:cover}.container.svelte-114dlfg .img-bg .profile-img #edit.svelte-114dlfg{position:absolute;width:100%;height:100%;background-color:rgba(0, 0, 0, 0.4);display:flex;align-items:center;justify-content:center;visibility:hidden}.container.svelte-114dlfg .img-bg .profile-img #edit span.svelte-114dlfg{color:white;font-size:1.5em}.container.svelte-114dlfg .img-bg h3.svelte-114dlfg{padding:10px 0;font-size:2em}@media(min-width: 768px){.container.svelte-114dlfg .img-bg.svelte-114dlfg{max-height:100%}}.container.svelte-114dlfg section.svelte-114dlfg{background:white;padding:25px}.container.svelte-114dlfg section .title-container.svelte-114dlfg{display:flex;align-items:center;margin-bottom:10px}.container.svelte-114dlfg section .title-container h4.svelte-114dlfg{font-size:1.5em;margin-right:4px}.container.svelte-114dlfg section .title-container .linea.svelte-114dlfg{width:100%;border-top:dashed 3px #f05a28}.container.svelte-114dlfg section .recipes.svelte-114dlfg{display:flex;flex-wrap:wrap;gap:10px;justify-content:center}@media(min-width: 768px){.container.svelte-114dlfg section .recipes.svelte-114dlfg{justify-content:space-between}}@media(min-width: 768px){.container.svelte-114dlfg section.svelte-114dlfg{overflow-y:scroll}}@media(min-width: 768px){.container.svelte-114dlfg.svelte-114dlfg{flex-direction:row}.container.svelte-114dlfg .img-bg.svelte-114dlfg{border-bottom:none;border-right:solid 2px #f05a28}.container.svelte-114dlfg section.svelte-114dlfg{width:100%}}",
  map: `{"version":3,"file":"profile.svelte","sources":["profile.svelte"],"sourcesContent":["<script>\\n\\timport RecipeCard from './../lib/recipeCard.svelte';\\n    import { auth, storage } from '../firebase'\\n    import { nombreUsuario, creacionUsuario, photoURL, correoUsuario} from '../store'\\n    import {recetasUser} from '../store';\\n\\n    const show = () => {\\n        document.getElementById(\\"edit\\").style.visibility = 'visible';\\n    }\\n    const hide = () => {\\n        document.getElementById(\\"edit\\").style.visibility = 'hidden';\\n    }\\n\\n    //Apartado de seleccion de imagen\\n    const onFileSelected = (e)=>{\\n        let user = auth.currentUser\\n\\n        let imagen = e.target.files[0];\\n       \\n        let storageRef = storage.ref('/usuarios/' + $correoUsuario + \\"/\\" + imagen.name);\\n        \\n        let uploadTask = storageRef.put(imagen);\\n\\n        uploadTask.on('state_changed', function(){\\n            },function(error) {\\n                    console.log(error.message)\\n            },function() {\\n                uploadTask.snapshot.ref.getDownloadURL().then(function(downloadURL) {\\n                    user.updateProfile({\\n                        photoURL:downloadURL\\n                    }).then(() =>{\\n                        console.log(\\"SUBIDA EXITOSA\\")\\n                    }).catch((error) =>{\\n                        console.log(error)\\n                    })                    \\n                    photoURL.set(downloadURL);\\n                });\\n        });\\n    }\\n\\n\\n<\/script>\\n\\n<!--Formulario de registro-->\\n<div class=\\"container\\">\\n    <div class=\\"img-bg\\">\\n        <div on:mouseenter={show} on:mouseleave={hide} class=\\"profile-img\\">\\n            <img src={$photoURL} alt=\\"\\">\\n            <div id=\\"edit\\">\\n                <input type=\\"file\\" on:change={(e)=>onFileSelected(e)} style=\\"opacity: 0; position:absolute; width: 100%; height:100%\\">\\n                <span class=\\"fas fa-edit\\"></span>\\n                \\n            </div>\\n        </div>\\n        <h3>{$nombreUsuario}</h3>\\n        <p>Fecha creacion: {$creacionUsuario}h</p>\\n    </div>\\n    <section>\\n        <div class=\\"title-container\\">\\n            <h4>Recetas</h4>\\n            <div class='linea'></div>\\n        </div>\\n        <div class=\\"recipes\\">\\n\\n            {#each $recetasUser as item}\\n                <!-- content here -->\\n                <RecipeCard \\n                    imgURL={item.imgURL} \\n                    title={item.titulo} \\n                    description={item.descripcion}\\n                    stars = {item.puntuado}\\n                    id = {item.id}\\n                />\\n            \\n            {/each}\\n        </div>\\n    </section>\\n</div>\\n\\n<style lang=\\"scss\\">.container {\\n  display: flex;\\n  flex-direction: column;\\n  height: calc(100vh - 65px); }\\n  .container .img-bg {\\n    width: 100%;\\n    height: 100%;\\n    min-height: 320px;\\n    max-height: 450px;\\n    overflow: hidden;\\n    background-image: url(/img/bg_2.jpg);\\n    background-size: cover;\\n    background-position: center;\\n    background-repeat: no-repeat;\\n    border-bottom: solid 2px #f05a28;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center; }\\n    .container .img-bg .profile-img {\\n      overflow: hidden;\\n      width: 200px;\\n      height: 200px;\\n      border-radius: 50%;\\n      display: flex;\\n      position: relative;\\n      cursor: pointer; }\\n      .container .img-bg .profile-img img {\\n        width: 100%;\\n        object-fit: cover; }\\n      .container .img-bg .profile-img #edit {\\n        position: absolute;\\n        width: 100%;\\n        height: 100%;\\n        background-color: rgba(0, 0, 0, 0.4);\\n        display: flex;\\n        align-items: center;\\n        justify-content: center;\\n        visibility: hidden; }\\n        .container .img-bg .profile-img #edit span {\\n          color: white;\\n          font-size: 1.5em; }\\n    .container .img-bg h3 {\\n      padding: 10px 0;\\n      font-size: 2em; }\\n    @media (min-width: 768px) {\\n      .container .img-bg {\\n        max-height: 100%; } }\\n  .container section {\\n    background: white;\\n    padding: 25px; }\\n    .container section .title-container {\\n      display: flex;\\n      align-items: center;\\n      margin-bottom: 10px; }\\n      .container section .title-container h4 {\\n        font-size: 1.5em;\\n        margin-right: 4px; }\\n      .container section .title-container .linea {\\n        width: 100%;\\n        border-top: dashed 3px #f05a28; }\\n    .container section .recipes {\\n      display: flex;\\n      flex-wrap: wrap;\\n      gap: 10px;\\n      justify-content: center; }\\n      @media (min-width: 768px) {\\n        .container section .recipes {\\n          justify-content: space-between; } }\\n    @media (min-width: 768px) {\\n      .container section {\\n        overflow-y: scroll; } }\\n  @media (min-width: 768px) {\\n    .container {\\n      flex-direction: row; }\\n      .container .img-bg {\\n        border-bottom: none;\\n        border-right: solid 2px #f05a28; }\\n      .container section {\\n        width: 100%; } }\\n</style>\\n"],"names":[],"mappings":"AA+EmB,UAAU,8BAAC,CAAC,AAC7B,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,MAAM,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,AAAE,CAAC,AAC7B,yBAAU,CAAC,OAAO,eAAC,CAAC,AAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,KAAK,CACjB,QAAQ,CAAE,MAAM,CAChB,gBAAgB,CAAE,IAAI,aAAa,CAAC,CACpC,eAAe,CAAE,KAAK,CACtB,mBAAmB,CAAE,MAAM,CAC3B,iBAAiB,CAAE,SAAS,CAC5B,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CAChC,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,AAAE,CAAC,AAC1B,yBAAU,CAAC,OAAO,CAAC,YAAY,eAAC,CAAC,AAC/B,QAAQ,CAAE,MAAM,CAChB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,IAAI,CACb,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,OAAO,AAAE,CAAC,AAClB,yBAAU,CAAC,OAAO,CAAC,YAAY,CAAC,GAAG,eAAC,CAAC,AACnC,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,KAAK,AAAE,CAAC,AACtB,yBAAU,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,eAAC,CAAC,AACrC,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CACpC,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,UAAU,CAAE,MAAM,AAAE,CAAC,AACrB,yBAAU,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,eAAC,CAAC,AAC1C,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,KAAK,AAAE,CAAC,AACzB,yBAAU,CAAC,OAAO,CAAC,EAAE,eAAC,CAAC,AACrB,OAAO,CAAE,IAAI,CAAC,CAAC,CACf,SAAS,CAAE,GAAG,AAAE,CAAC,AACnB,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,yBAAU,CAAC,OAAO,eAAC,CAAC,AAClB,UAAU,CAAE,IAAI,AAAE,CAAC,AAAC,CAAC,AAC3B,yBAAU,CAAC,OAAO,eAAC,CAAC,AAClB,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,IAAI,AAAE,CAAC,AAChB,yBAAU,CAAC,OAAO,CAAC,gBAAgB,eAAC,CAAC,AACnC,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,aAAa,CAAE,IAAI,AAAE,CAAC,AACtB,yBAAU,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE,eAAC,CAAC,AACtC,SAAS,CAAE,KAAK,CAChB,YAAY,CAAE,GAAG,AAAE,CAAC,AACtB,yBAAU,CAAC,OAAO,CAAC,gBAAgB,CAAC,MAAM,eAAC,CAAC,AAC1C,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACrC,yBAAU,CAAC,OAAO,CAAC,QAAQ,eAAC,CAAC,AAC3B,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,CACf,GAAG,CAAE,IAAI,CACT,eAAe,CAAE,MAAM,AAAE,CAAC,AAC1B,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,yBAAU,CAAC,OAAO,CAAC,QAAQ,eAAC,CAAC,AAC3B,eAAe,CAAE,aAAa,AAAE,CAAC,AAAC,CAAC,AACzC,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,yBAAU,CAAC,OAAO,eAAC,CAAC,AAClB,UAAU,CAAE,MAAM,AAAE,CAAC,AAAC,CAAC,AAC7B,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,UAAU,8BAAC,CAAC,AACV,cAAc,CAAE,GAAG,AAAE,CAAC,AACtB,yBAAU,CAAC,OAAO,eAAC,CAAC,AAClB,aAAa,CAAE,IAAI,CACnB,YAAY,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACpC,yBAAU,CAAC,OAAO,eAAC,CAAC,AAClB,KAAK,CAAE,IAAI,AAAE,CAAC,AAAC,CAAC"}`
};
var Profile = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_correoUsuario;
  let $photoURL, $$unsubscribe_photoURL;
  let $nombreUsuario, $$unsubscribe_nombreUsuario;
  let $creacionUsuario, $$unsubscribe_creacionUsuario;
  let $recetasUser, $$unsubscribe_recetasUser;
  $$unsubscribe_correoUsuario = subscribe(correoUsuario, (value) => value);
  $$unsubscribe_photoURL = subscribe(photoURL, (value) => $photoURL = value);
  $$unsubscribe_nombreUsuario = subscribe(nombreUsuario, (value) => $nombreUsuario = value);
  $$unsubscribe_creacionUsuario = subscribe(creacionUsuario, (value) => $creacionUsuario = value);
  $$unsubscribe_recetasUser = subscribe(recetasUser, (value) => $recetasUser = value);
  $$result.css.add(css$4);
  $$unsubscribe_correoUsuario();
  $$unsubscribe_photoURL();
  $$unsubscribe_nombreUsuario();
  $$unsubscribe_creacionUsuario();
  $$unsubscribe_recetasUser();
  return `
<div class="${"container svelte-114dlfg"}"><div class="${"img-bg svelte-114dlfg"}"><div class="${"profile-img svelte-114dlfg"}"><img${add_attribute("src", $photoURL, 0)} alt="${""}" class="${"svelte-114dlfg"}">
            <div id="${"edit"}" class="${"svelte-114dlfg"}"><input type="${"file"}" style="${"opacity: 0; position:absolute; width: 100%; height:100%"}">
                <span class="${"fas fa-edit svelte-114dlfg"}"></span></div></div>
        <h3 class="${"svelte-114dlfg"}">${escape2($nombreUsuario)}</h3>
        <p>Fecha creacion: ${escape2($creacionUsuario)}h</p></div>
    <section class="${"svelte-114dlfg"}"><div class="${"title-container svelte-114dlfg"}"><h4 class="${"svelte-114dlfg"}">Recetas</h4>
            <div class="${"linea svelte-114dlfg"}"></div></div>
        <div class="${"recipes svelte-114dlfg"}">${each($recetasUser, (item) => `
                ${validate_component(RecipeCard, "RecipeCard").$$render($$result, {
    imgURL: item.imgURL,
    title: item.titulo,
    description: item.descripcion,
    stars: item.puntuado,
    id: item.id
  }, {}, {})}`)}</div></section>
</div>`;
});
var profile = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Profile
});
var css$3 = {
  code: ".container.svelte-le1ww5.svelte-le1ww5{width:100vw;display:flex;flex-direction:column;align-items:center;background:white}.container.svelte-le1ww5 .title-space.svelte-le1ww5{width:100%;height:400px;position:relative;font-weight:bold;color:white;font-size:2em;border-bottom:solid 4px #f05a28}.container.svelte-le1ww5 .title-space img.svelte-le1ww5{width:100%;height:100%;object-fit:cover;position:absolute}.container.svelte-le1ww5 .title-space header.svelte-le1ww5{position:absolute;top:20px;left:20px;z-index:1;text-transform:uppercase;font-weight:bold}.container.svelte-le1ww5 .title-space span.svelte-le1ww5{position:absolute;bottom:20px;right:20px;z-index:1}.container.svelte-le1ww5 .title-space.svelte-le1ww5::after{content:'';position:absolute;width:100%;height:100%;background:rgba(0, 0, 0, 0.3)}.container.svelte-le1ww5 .recipe-container.svelte-le1ww5{width:100%;max-width:1000px;padding:30px}.container.svelte-le1ww5 .recipe-container .meta-container.svelte-le1ww5{margin-bottom:10px;display:flex;justify-content:space-around;flex-wrap:wrap;font-size:14px}.container.svelte-le1ww5 .recipe-container .meta-container span.svelte-le1ww5{font-weight:bold}.container.svelte-le1ww5 .recipe-container .title-container.svelte-le1ww5{display:flex;align-items:center;margin:20px 0}.container.svelte-le1ww5 .recipe-container .title-container h4.svelte-le1ww5{font-size:1.5em;margin-right:4px}.container.svelte-le1ww5 .recipe-container .title-container .linea.svelte-le1ww5{width:100%;border-top:dashed 3px #f05a28}.container.svelte-le1ww5 .rating-container.svelte-le1ww5{border-top:dashed 3px #f05a28;padding:20px;margin-top:20px;text-align:center}.container.svelte-le1ww5 .rating-container h4.svelte-le1ww5{font-size:1.5em;margin-bottom:10px}.container.svelte-le1ww5 .rating-container span.svelte-le1ww5{color:gray;cursor:pointer}.container.svelte-le1ww5 .rating-container span.svelte-le1ww5:last-of-type{cursor:initial;color:black}",
  map: `{"version":3,"file":"[id].svelte","sources":["[id].svelte"],"sourcesContent":["<script context=\\"module\\">\\n    export async function load({page}) {\\n            const id = page.params.id\\n            return{props: {id}}\\n        }\\n<\/script>\\n\\n<script>\\n    export let id;\\n    import { recetasTotal } from '../../store';\\n    import { db } from '../../firebase';\\n    \\n    let title = 'titulo';\\n    let img = '/img/bg_1.jpg';\\n    let description = \\"Lorem ipsum dolor sit amet consectetur adipisicing elit. Rem, deserunt quam id quibusdam dolorum fuga numquam nihil et, nisi illum quos debitis ducimus temporibus quas aliquam accusantium reprehenderit sapiente quod.\\";\\n    let duration = 0;\\n    let dificulty = 'As easy as ur sister';\\n    let ingredients = ['atun','mas atun','aun mas atun'];\\n    let steps = ['sazonar elatun','cocinar el atun','comer el atun'];\\n    let puntos = 0;\\n    let stars = 0;\\n    let lectura = 0;\\n    \\n    $recetasTotal.forEach(item =>{\\n        if(item.id == id){\\n            title = item.titulo;\\n            img = item.imgURL;\\n            description = item.descripcion;\\n            duration = item.duracion;\\n            dificulty = item.dificultad;\\n            ingredients = item.ingredientes;\\n            steps = item.pasos;\\n            puntos = item.puntuado;\\n        }\\n    })\\n\\n    const clickStar = async (n) => {\\n        stars = n;\\n        let starItems = document.getElementsByClassName(\\"fa-star\\");\\n        for (let item of starItems) {\\n            item.style.color = \\"gray\\"; \\n        }\\n        for (let i = 0; i < stars; i++) {\\n            starItems[i].style.color = \\"orange\\";   \\n        }\\n\\n        await db.collection('recetas/').doc(id).update({\\n            puntuado: stars\\n        })\\n\\n        puntos = stars   \\n    }\\n\\n    function leer(){\\n       \\n        if (!'speechSynthesis' in window){\\n             alert(\\"Lo siento, tu navegador no soporta esta tecnolog\xEDa\\")\\n            }\\n        else{\\n            if(lectura == steps.length){\\n                lectura = 0;\\n            }else{\\n                try{\\n                    speechSynthesis.speak(new SpeechSynthesisUtterance(steps[lectura]));\\n                    lectura++;\\n                }catch(error){\\n                    alert(\\"Lo siento, tu navegador no soporta esta tecnolog\xEDa\\")\\n                }\\n            }\\n        }\\n    \\n     \\n    }\\n\\n<\/script>\\n\\n<div class=\\"container\\">\\n    <div class=\\"title-space\\">\\n        <img src={img} alt=\\"\\">\\n        <header>{title}</header>\\n        <span>{puntos}/5</span>\\n    </div>\\n    <div class=\\"recipe-container\\">\\n        <div class=\\"meta-container\\">\\n            <p><span>Dificultad: </span>{dificulty}</p>\\n            <p><span>Duraci&oacute;n:</span> {duration} min </p>\\n        </div>\\n        <p>{description}</p>\\n        <div class=\\"title-container\\">\\n            <h4>Ingredientes</h4>\\n            <div class='linea'></div>\\n        </div>\\n        \\n        {#each ingredients as item, i}\\n             <!-- content here -->\\n            <p>{i + 1}. {item}</p>\\n        {/each}\\n\\n        <div class=\\"title-container\\">\\n            <h4>Instrucciones</h4>\\n            <div class='linea'></div>\\n        </div>\\n\\n        {#each steps as item, i}\\n             <!-- content here -->\\n            <p>{i + 1}. {item}</p>\\n        {/each}\\n\\n            <button on:click={leer}>Leer paso {lectura + 1}</button>\\n        <div class=\\"rating-container\\">\\n            <h4>Valora esta receta</h4>\\n            <span class=\\"fa fa-star\\" on:click={() => clickStar(1)}></span>\\n            <span class=\\"fa fa-star\\" on:click={() => clickStar(2)}></span>\\n            <span class=\\"fa fa-star\\" on:click={() => clickStar(3)}></span>\\n            <span class=\\"fa fa-star\\" on:click={() => clickStar(4)}></span>\\n            <span class=\\"fa fa-star\\" on:click={() => clickStar(5)}></span>\\n            <span>{stars}</span>\\n        </div>\\n    </div>\\n</div>\\n\\n<style lang=\\"scss\\">.container {\\n  width: 100vw;\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  background: white; }\\n  .container .title-space {\\n    width: 100%;\\n    height: 400px;\\n    position: relative;\\n    font-weight: bold;\\n    color: white;\\n    font-size: 2em;\\n    border-bottom: solid 4px #f05a28; }\\n    .container .title-space img {\\n      width: 100%;\\n      height: 100%;\\n      object-fit: cover;\\n      position: absolute; }\\n    .container .title-space header {\\n      position: absolute;\\n      top: 20px;\\n      left: 20px;\\n      z-index: 1;\\n      text-transform: uppercase;\\n      font-weight: bold; }\\n    .container .title-space span {\\n      position: absolute;\\n      bottom: 20px;\\n      right: 20px;\\n      z-index: 1; }\\n    .container .title-space::after {\\n      content: '';\\n      position: absolute;\\n      width: 100%;\\n      height: 100%;\\n      background: rgba(0, 0, 0, 0.3); }\\n  .container .recipe-container {\\n    width: 100%;\\n    max-width: 1000px;\\n    padding: 30px; }\\n    .container .recipe-container .meta-container {\\n      margin-bottom: 10px;\\n      display: flex;\\n      justify-content: space-around;\\n      flex-wrap: wrap;\\n      font-size: 14px; }\\n      .container .recipe-container .meta-container span {\\n        font-weight: bold; }\\n    .container .recipe-container .title-container {\\n      display: flex;\\n      align-items: center;\\n      margin: 20px 0; }\\n      .container .recipe-container .title-container h4 {\\n        font-size: 1.5em;\\n        margin-right: 4px; }\\n      .container .recipe-container .title-container .linea {\\n        width: 100%;\\n        border-top: dashed 3px #f05a28; }\\n  .container .rating-container {\\n    border-top: dashed 3px #f05a28;\\n    padding: 20px;\\n    margin-top: 20px;\\n    text-align: center; }\\n    .container .rating-container h4 {\\n      font-size: 1.5em;\\n      margin-bottom: 10px; }\\n    .container .rating-container span {\\n      color: gray;\\n      cursor: pointer; }\\n      .container .rating-container span:last-of-type {\\n        cursor: initial;\\n        color: black; }\\n</style>"],"names":[],"mappings":"AAyHmB,UAAU,4BAAC,CAAC,AAC7B,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,UAAU,CAAE,KAAK,AAAE,CAAC,AACpB,wBAAU,CAAC,YAAY,cAAC,CAAC,AACvB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,CACb,QAAQ,CAAE,QAAQ,CAClB,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,GAAG,CACd,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACnC,wBAAU,CAAC,YAAY,CAAC,GAAG,cAAC,CAAC,AAC3B,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CACjB,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACvB,wBAAU,CAAC,YAAY,CAAC,MAAM,cAAC,CAAC,AAC9B,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,OAAO,CAAE,CAAC,CACV,cAAc,CAAE,SAAS,CACzB,WAAW,CAAE,IAAI,AAAE,CAAC,AACtB,wBAAU,CAAC,YAAY,CAAC,IAAI,cAAC,CAAC,AAC5B,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,CAAC,AAAE,CAAC,AACf,wBAAU,CAAC,0BAAY,OAAO,AAAC,CAAC,AAC9B,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AAAE,CAAC,AACrC,wBAAU,CAAC,iBAAiB,cAAC,CAAC,AAC5B,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,MAAM,CACjB,OAAO,CAAE,IAAI,AAAE,CAAC,AAChB,wBAAU,CAAC,iBAAiB,CAAC,eAAe,cAAC,CAAC,AAC5C,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,CAC7B,SAAS,CAAE,IAAI,CACf,SAAS,CAAE,IAAI,AAAE,CAAC,AAClB,wBAAU,CAAC,iBAAiB,CAAC,eAAe,CAAC,IAAI,cAAC,CAAC,AACjD,WAAW,CAAE,IAAI,AAAE,CAAC,AACxB,wBAAU,CAAC,iBAAiB,CAAC,gBAAgB,cAAC,CAAC,AAC7C,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,IAAI,CAAC,CAAC,AAAE,CAAC,AACjB,wBAAU,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,EAAE,cAAC,CAAC,AAChD,SAAS,CAAE,KAAK,CAChB,YAAY,CAAE,GAAG,AAAE,CAAC,AACtB,wBAAU,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,MAAM,cAAC,CAAC,AACpD,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACvC,wBAAU,CAAC,iBAAiB,cAAC,CAAC,AAC5B,UAAU,CAAE,MAAM,CAAC,GAAG,CAAC,OAAO,CAC9B,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,IAAI,CAChB,UAAU,CAAE,MAAM,AAAE,CAAC,AACrB,wBAAU,CAAC,iBAAiB,CAAC,EAAE,cAAC,CAAC,AAC/B,SAAS,CAAE,KAAK,CAChB,aAAa,CAAE,IAAI,AAAE,CAAC,AACxB,wBAAU,CAAC,iBAAiB,CAAC,IAAI,cAAC,CAAC,AACjC,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,OAAO,AAAE,CAAC,AAClB,wBAAU,CAAC,iBAAiB,CAAC,kBAAI,aAAa,AAAC,CAAC,AAC9C,MAAM,CAAE,OAAO,CACf,KAAK,CAAE,KAAK,AAAE,CAAC"}`
};
async function load({ page }) {
  const id = page.params.id;
  return { props: { id } };
}
var U5Bidu5D = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $recetasTotal, $$unsubscribe_recetasTotal;
  $$unsubscribe_recetasTotal = subscribe(recetasTotal, (value) => $recetasTotal = value);
  let { id } = $$props;
  let title = "titulo";
  let img = "/img/bg_1.jpg";
  let description = "Lorem ipsum dolor sit amet consectetur adipisicing elit. Rem, deserunt quam id quibusdam dolorum fuga numquam nihil et, nisi illum quos debitis ducimus temporibus quas aliquam accusantium reprehenderit sapiente quod.";
  let duration = 0;
  let dificulty = "As easy as ur sister";
  let ingredients = ["atun", "mas atun", "aun mas atun"];
  let steps = ["sazonar elatun", "cocinar el atun", "comer el atun"];
  let puntos = 0;
  let stars = 0;
  let lectura = 0;
  $recetasTotal.forEach((item) => {
    if (item.id == id) {
      title = item.titulo;
      img = item.imgURL;
      description = item.descripcion;
      duration = item.duracion;
      dificulty = item.dificultad;
      ingredients = item.ingredientes;
      steps = item.pasos;
      puntos = item.puntuado;
    }
  });
  if ($$props.id === void 0 && $$bindings.id && id !== void 0)
    $$bindings.id(id);
  $$result.css.add(css$3);
  $$unsubscribe_recetasTotal();
  return `<div class="${"container svelte-le1ww5"}"><div class="${"title-space svelte-le1ww5"}"><img${add_attribute("src", img, 0)} alt="${""}" class="${"svelte-le1ww5"}">
        <header class="${"svelte-le1ww5"}">${escape2(title)}</header>
        <span class="${"svelte-le1ww5"}">${escape2(puntos)}/5</span></div>
    <div class="${"recipe-container svelte-le1ww5"}"><div class="${"meta-container svelte-le1ww5"}"><p><span class="${"svelte-le1ww5"}">Dificultad: </span>${escape2(dificulty)}</p>
            <p><span class="${"svelte-le1ww5"}">Duraci\xF3n:</span> ${escape2(duration)} min </p></div>
        <p>${escape2(description)}</p>
        <div class="${"title-container svelte-le1ww5"}"><h4 class="${"svelte-le1ww5"}">Ingredientes</h4>
            <div class="${"linea svelte-le1ww5"}"></div></div>
        
        ${each(ingredients, (item, i) => `
            <p>${escape2(i + 1)}. ${escape2(item)}</p>`)}

        <div class="${"title-container svelte-le1ww5"}"><h4 class="${"svelte-le1ww5"}">Instrucciones</h4>
            <div class="${"linea svelte-le1ww5"}"></div></div>

        ${each(steps, (item, i) => `
            <p>${escape2(i + 1)}. ${escape2(item)}</p>`)}

            <button>Leer paso ${escape2(lectura + 1)}</button>
        <div class="${"rating-container svelte-le1ww5"}"><h4 class="${"svelte-le1ww5"}">Valora esta receta</h4>
            <span class="${"fa fa-star svelte-le1ww5"}"></span>
            <span class="${"fa fa-star svelte-le1ww5"}"></span>
            <span class="${"fa fa-star svelte-le1ww5"}"></span>
            <span class="${"fa fa-star svelte-le1ww5"}"></span>
            <span class="${"fa fa-star svelte-le1ww5"}"></span>
            <span class="${"svelte-le1ww5"}">${escape2(stars)}</span></div></div>
</div>`;
});
var _id_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": U5Bidu5D,
  load
});
var css$2 = {
  code: ".card.svelte-1bnhty0.svelte-1bnhty0{width:300px;height:400px;background:white;box-shadow:4px 4px 12px rgba(0, 0, 0, 0.5);margin-bottom:30px;overflow:hidden;position:relative}.card.svelte-1bnhty0 .a.svelte-1bnhty0{width:100%;height:100%;color:black;text-decoration:none}.card.svelte-1bnhty0 .img.svelte-1bnhty0{height:200px;overflow:hidden;border-bottom:solid 4px #f05a28;position:relative}.card.svelte-1bnhty0 .img p.svelte-1bnhty0{position:absolute;color:white;font-weight:bold;padding:4px 8px;font-size:1.5em;bottom:0;z-index:1}.card.svelte-1bnhty0 .img img.svelte-1bnhty0{object-fit:cover;width:100%;height:100%;position:absolute}.card.svelte-1bnhty0 .img span.svelte-1bnhty0{position:absolute;color:white;z-index:1;right:20px;top:20px;transition:.2s}.card.svelte-1bnhty0 .img span.svelte-1bnhty0:hover{color:red}.card.svelte-1bnhty0 .img.svelte-1bnhty0::after{content:'';position:absolute;width:100%;height:100%;background:rgba(0, 0, 0, 0.3)}.card.svelte-1bnhty0 .descripcion.svelte-1bnhty0{padding:8px 20px}.card.svelte-1bnhty0 .stars.svelte-1bnhty0{position:absolute;color:#f05a28;font-weight:bold;font-size:1.2em;bottom:20px;right:20px}.card.svelte-1bnhty0.svelte-1bnhty0:hover{transition:0.2s;transform:scale(1.02)}",
  map: `{"version":3,"file":"recipeCardAdmin.svelte","sources":["recipeCardAdmin.svelte"],"sourcesContent":["<script>\\n    export let imgURL = \\"https://placekitten.com/200/300\\";\\n    export let title = \\"undefined\\"\\n    //TODO: ponle a la descripcion un maximo de caracteres a mostrar => Luego, (CAMBIO A FUTURO)\\n    export let description = \\"undefined\\";\\n    export let stars = 0;\\n    export let id = 0;\\n\\n    import { db } from '../firebase';\\n\\n    let borrar = async () =>{\\n        db.collection('recetas').doc(id).delete();\\n    }\\n<\/script>\\n\\n<div class=\\"card\\">\\n    <div class=\\"a\\">\\n        <div class=\\"img\\">\\n            <p>{title}</p>\\n            <img src={imgURL} alt=\\"\\">\\n            <span class=\\"fas fa-trash\\" on:click={borrar} style=\\"cursor:pointer\\"></span>\\n        </div>\\n        <p class=\\"descripcion\\">{description}</p>\\n        <p class=\\"stars\\">{stars}/5</p>\\n    </div>\\n</div>\\n\\n<style lang=\\"scss\\">.card {\\n  width: 300px;\\n  height: 400px;\\n  background: white;\\n  box-shadow: 4px 4px 12px rgba(0, 0, 0, 0.5);\\n  margin-bottom: 30px;\\n  overflow: hidden;\\n  position: relative; }\\n  .card .a {\\n    width: 100%;\\n    height: 100%;\\n    color: black;\\n    text-decoration: none; }\\n  .card .img {\\n    height: 200px;\\n    overflow: hidden;\\n    border-bottom: solid 4px #f05a28;\\n    position: relative; }\\n    .card .img p {\\n      position: absolute;\\n      color: white;\\n      font-weight: bold;\\n      padding: 4px 8px;\\n      font-size: 1.5em;\\n      bottom: 0;\\n      z-index: 1; }\\n    .card .img img {\\n      object-fit: cover;\\n      width: 100%;\\n      height: 100%;\\n      position: absolute; }\\n    .card .img span {\\n      position: absolute;\\n      color: white;\\n      z-index: 1;\\n      right: 20px;\\n      top: 20px;\\n      transition: .2s; }\\n      .card .img span:hover {\\n        color: red; }\\n    .card .img::after {\\n      content: '';\\n      position: absolute;\\n      width: 100%;\\n      height: 100%;\\n      background: rgba(0, 0, 0, 0.3); }\\n  .card .descripcion {\\n    padding: 8px 20px; }\\n  .card .stars {\\n    position: absolute;\\n    color: #f05a28;\\n    font-weight: bold;\\n    font-size: 1.2em;\\n    bottom: 20px;\\n    right: 20px; }\\n  .card:hover {\\n    transition: 0.2s;\\n    transform: scale(1.02); }\\n</style>"],"names":[],"mappings":"AA2BmB,KAAK,8BAAC,CAAC,AACxB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAC3C,aAAa,CAAE,IAAI,CACnB,QAAQ,CAAE,MAAM,CAChB,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACrB,oBAAK,CAAC,EAAE,eAAC,CAAC,AACR,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,KAAK,CACZ,eAAe,CAAE,IAAI,AAAE,CAAC,AAC1B,oBAAK,CAAC,IAAI,eAAC,CAAC,AACV,MAAM,CAAE,KAAK,CACb,QAAQ,CAAE,MAAM,CAChB,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CAChC,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACrB,oBAAK,CAAC,IAAI,CAAC,CAAC,eAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,CACZ,WAAW,CAAE,IAAI,CACjB,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,AAAE,CAAC,AACf,oBAAK,CAAC,IAAI,CAAC,GAAG,eAAC,CAAC,AACd,UAAU,CAAE,KAAK,CACjB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,AAAE,CAAC,AACvB,oBAAK,CAAC,IAAI,CAAC,IAAI,eAAC,CAAC,AACf,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,IAAI,CACX,GAAG,CAAE,IAAI,CACT,UAAU,CAAE,GAAG,AAAE,CAAC,AAClB,oBAAK,CAAC,IAAI,CAAC,mBAAI,MAAM,AAAC,CAAC,AACrB,KAAK,CAAE,GAAG,AAAE,CAAC,AACjB,oBAAK,CAAC,mBAAI,OAAO,AAAC,CAAC,AACjB,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AAAE,CAAC,AACrC,oBAAK,CAAC,YAAY,eAAC,CAAC,AAClB,OAAO,CAAE,GAAG,CAAC,IAAI,AAAE,CAAC,AACtB,oBAAK,CAAC,MAAM,eAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,OAAO,CACd,WAAW,CAAE,IAAI,CACjB,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,AAAE,CAAC,AAChB,mCAAK,MAAM,AAAC,CAAC,AACX,UAAU,CAAE,IAAI,CAChB,SAAS,CAAE,MAAM,IAAI,CAAC,AAAE,CAAC"}`
};
var RecipeCardAdmin = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { imgURL = "https://placekitten.com/200/300" } = $$props;
  let { title = "undefined" } = $$props;
  let { description = "undefined" } = $$props;
  let { stars = 0 } = $$props;
  let { id = 0 } = $$props;
  if ($$props.imgURL === void 0 && $$bindings.imgURL && imgURL !== void 0)
    $$bindings.imgURL(imgURL);
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.description === void 0 && $$bindings.description && description !== void 0)
    $$bindings.description(description);
  if ($$props.stars === void 0 && $$bindings.stars && stars !== void 0)
    $$bindings.stars(stars);
  if ($$props.id === void 0 && $$bindings.id && id !== void 0)
    $$bindings.id(id);
  $$result.css.add(css$2);
  return `<div class="${"card svelte-1bnhty0"}"><div class="${"a svelte-1bnhty0"}"><div class="${"img svelte-1bnhty0"}"><p class="${"svelte-1bnhty0"}">${escape2(title)}</p>
            <img${add_attribute("src", imgURL, 0)} alt="${""}" class="${"svelte-1bnhty0"}">
            <span class="${"fas fa-trash svelte-1bnhty0"}" style="${"cursor:pointer"}"></span></div>
        <p class="${"descripcion svelte-1bnhty0"}">${escape2(description)}</p>
        <p class="${"stars svelte-1bnhty0"}">${escape2(stars)}/5</p></div>
</div>`;
});
var css$1 = {
  code: ".container.svelte-si8p78.svelte-si8p78{display:flex;flex-direction:column;height:calc(100vh - 65px)}.container.svelte-si8p78 .img-bg.svelte-si8p78{width:100%;height:100%;min-height:320px;max-height:450px;overflow:hidden;background-image:url(/img/bg_2.jpg);background-size:cover;background-position:center;background-repeat:no-repeat;border-bottom:solid 2px #f05a28;display:flex;flex-direction:column;align-items:center;justify-content:center}.container.svelte-si8p78 .img-bg .profile-img.svelte-si8p78{overflow:hidden;width:200px;height:200px;border-radius:50%;display:flex;position:relative;cursor:pointer}.container.svelte-si8p78 .img-bg .profile-img img.svelte-si8p78{width:100%;object-fit:cover}.container.svelte-si8p78 .img-bg .profile-img #edit.svelte-si8p78{position:absolute;width:100%;height:100%;background-color:rgba(0, 0, 0, 0.4);display:flex;align-items:center;justify-content:center;visibility:hidden}.container.svelte-si8p78 .img-bg .profile-img #edit span.svelte-si8p78{color:white;font-size:1.5em}.container.svelte-si8p78 .img-bg h3.svelte-si8p78{padding:10px 0;font-size:2em}@media(min-width: 768px){.container.svelte-si8p78 .img-bg.svelte-si8p78{max-height:100%}}.container.svelte-si8p78 section.svelte-si8p78{background:white;padding:25px}.container.svelte-si8p78 section .title-container.svelte-si8p78{display:flex;align-items:center;margin-bottom:10px}.container.svelte-si8p78 section .title-container h4.svelte-si8p78{font-size:1.5em;margin-right:4px;min-width:max-content}.container.svelte-si8p78 section .title-container .linea.svelte-si8p78{width:100%;border-top:dashed 3px #f05a28}.container.svelte-si8p78 section form.svelte-si8p78{display:flex}.container.svelte-si8p78 section form input.svelte-si8p78{padding:10px;width:100%;border:none;border-bottom:solid 2px #f05a28;outline:none}.container.svelte-si8p78 section form button.svelte-si8p78{border:solid 2px #f05a28;color:white;background-color:#f05a28;padding:10px 20px;text-transform:uppercase;margin-left:10px;font-weight:bold;cursor:pointer;transition:all .2s}.container.svelte-si8p78 section form button.svelte-si8p78:hover{background-color:white;color:#f05a28}.container.svelte-si8p78 section .recipes.svelte-si8p78{display:flex;flex-wrap:wrap;gap:10px;justify-content:center}@media(min-width: 768px){.container.svelte-si8p78 section .recipes.svelte-si8p78{justify-content:space-between}}@media(min-width: 768px){.container.svelte-si8p78 section.svelte-si8p78{overflow-y:scroll}}@media(min-width: 768px){.container.svelte-si8p78.svelte-si8p78{flex-direction:row}.container.svelte-si8p78 .img-bg.svelte-si8p78{border-bottom:none;border-right:solid 2px #f05a28}.container.svelte-si8p78 section.svelte-si8p78{width:100%}}",
  map: `{"version":3,"file":"admin.svelte","sources":["admin.svelte"],"sourcesContent":["<script>\\n\\timport RecipeCardAdmin from './../lib/recipeCardAdmin.svelte';\\n    import { auth, storage } from '../firebase'\\n    import { nombreUsuario, creacionUsuario, photoURL, correoUsuario} from '../store'\\n    import { recetasTotal } from '../store';\\n    import { usuarios } from '../store';\\n\\n    const show = () => {\\n        document.getElementById(\\"edit\\").style.visibility = 'visible';\\n    }\\n    const hide = () => {\\n        document.getElementById(\\"edit\\").style.visibility = 'hidden';\\n    }\\n\\n    //Apartado de seleccion de imagen\\n    const onFileSelected = (e)=>{\\n        let user = auth.currentUser\\n\\n        let imagen = e.target.files[0];\\n       \\n        let storageRef = storage.ref('/usuarios/' + $correoUsuario + \\"/\\" + imagen.name);\\n        \\n        let uploadTask = storageRef.put(imagen);\\n\\n        uploadTask.on('state_changed', function(){\\n            },function(error) {\\n                    console.log(error.message)\\n            },function() {\\n                uploadTask.snapshot.ref.getDownloadURL().then(function(downloadURL) {\\n                    user.updateProfile({\\n                        photoURL:downloadURL\\n                    }).then(() =>{\\n                        console.log(\\"SUBIDA EXITOSA\\")\\n                    }).catch((error) =>{\\n                        console.log(error)\\n                    })                    \\n                    photoURL.set(downloadURL);\\n                });\\n        });\\n    }\\n\\n    const mostrar = async () => {\\n        alert(\\"CTRL+SHIFT+I PARA ABRIR LA CONSOLA\\")\\n        $usuarios.forEach(item =>{\\n            console.log(item.correo)\\n        })\\n    }\\n<\/script>\\n\\n<div class=\\"container\\">\\n    <div class=\\"img-bg\\">\\n        <div on:mouseenter={show} on:mouseleave={hide} class=\\"profile-img\\">\\n            <img src={$photoURL} alt=\\"\\">\\n            <div id=\\"edit\\">\\n                <input type=\\"file\\" on:change={(e)=>onFileSelected(e)} style=\\"opacity: 0; position:absolute; width: 100%; height:100%\\">\\n                <span class=\\"fas fa-edit\\"></span>\\n            </div>\\n        </div>\\n        <h3>{$nombreUsuario}</h3>\\n        <p>Fecha creacion: {$creacionUsuario}h</p>\\n    </div>\\n    <section>\\n        <div class=\\"title-container\\">\\n            <h4>Ver usuarios</h4>\\n            <div class='linea'></div>\\n        </div>\\n        <form on:submit|preventDefault={mostrar}>\\n            <button>MOSTRAR USUARIOS EN CONSOLA</button>\\n        </form>\\n        \\n        <div class=\\"title-container\\">\\n            <h4>Recetas</h4>\\n            <div class='linea'></div>\\n        </div>\\n        <div class=\\"recipes\\">\\n\\n            {#each $recetasTotal as item}\\n                <!-- content here -->\\n                <RecipeCardAdmin \\n                    imgURL={item.imgURL} \\n                    title={item.titulo} \\n                    description={item.descripcion}\\n                    stars = {item.puntuado}\\n                    id = {item.id}\\n                />\\n            {/each}\\n        </div>\\n    </section>\\n</div>\\n\\n<style lang=\\"scss\\">.container {\\n  display: flex;\\n  flex-direction: column;\\n  height: calc(100vh - 65px); }\\n  .container .img-bg {\\n    width: 100%;\\n    height: 100%;\\n    min-height: 320px;\\n    max-height: 450px;\\n    overflow: hidden;\\n    background-image: url(/img/bg_2.jpg);\\n    background-size: cover;\\n    background-position: center;\\n    background-repeat: no-repeat;\\n    border-bottom: solid 2px #f05a28;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center; }\\n    .container .img-bg .profile-img {\\n      overflow: hidden;\\n      width: 200px;\\n      height: 200px;\\n      border-radius: 50%;\\n      display: flex;\\n      position: relative;\\n      cursor: pointer; }\\n      .container .img-bg .profile-img img {\\n        width: 100%;\\n        object-fit: cover; }\\n      .container .img-bg .profile-img #edit {\\n        position: absolute;\\n        width: 100%;\\n        height: 100%;\\n        background-color: rgba(0, 0, 0, 0.4);\\n        display: flex;\\n        align-items: center;\\n        justify-content: center;\\n        visibility: hidden; }\\n        .container .img-bg .profile-img #edit span {\\n          color: white;\\n          font-size: 1.5em; }\\n    .container .img-bg h3 {\\n      padding: 10px 0;\\n      font-size: 2em; }\\n    @media (min-width: 768px) {\\n      .container .img-bg {\\n        max-height: 100%; } }\\n  .container section {\\n    background: white;\\n    padding: 25px; }\\n    .container section .title-container {\\n      display: flex;\\n      align-items: center;\\n      margin-bottom: 10px; }\\n      .container section .title-container h4 {\\n        font-size: 1.5em;\\n        margin-right: 4px;\\n        min-width: max-content; }\\n      .container section .title-container .linea {\\n        width: 100%;\\n        border-top: dashed 3px #f05a28; }\\n    .container section form {\\n      display: flex; }\\n      .container section form input {\\n        padding: 10px;\\n        width: 100%;\\n        border: none;\\n        border-bottom: solid 2px #f05a28;\\n        outline: none; }\\n      .container section form button {\\n        border: solid 2px #f05a28;\\n        color: white;\\n        background-color: #f05a28;\\n        padding: 10px 20px;\\n        text-transform: uppercase;\\n        margin-left: 10px;\\n        font-weight: bold;\\n        cursor: pointer;\\n        transition: all .2s; }\\n        .container section form button:hover {\\n          background-color: white;\\n          color: #f05a28; }\\n    .container section .recipes {\\n      display: flex;\\n      flex-wrap: wrap;\\n      gap: 10px;\\n      justify-content: center; }\\n      @media (min-width: 768px) {\\n        .container section .recipes {\\n          justify-content: space-between; } }\\n    @media (min-width: 768px) {\\n      .container section {\\n        overflow-y: scroll; } }\\n  @media (min-width: 768px) {\\n    .container {\\n      flex-direction: row; }\\n      .container .img-bg {\\n        border-bottom: none;\\n        border-right: solid 2px #f05a28; }\\n      .container section {\\n        width: 100%; } }\\n</style>\\n"],"names":[],"mappings":"AA0FmB,UAAU,4BAAC,CAAC,AAC7B,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,MAAM,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,AAAE,CAAC,AAC7B,wBAAU,CAAC,OAAO,cAAC,CAAC,AAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,KAAK,CACjB,QAAQ,CAAE,MAAM,CAChB,gBAAgB,CAAE,IAAI,aAAa,CAAC,CACpC,eAAe,CAAE,KAAK,CACtB,mBAAmB,CAAE,MAAM,CAC3B,iBAAiB,CAAE,SAAS,CAC5B,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CAChC,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,AAAE,CAAC,AAC1B,wBAAU,CAAC,OAAO,CAAC,YAAY,cAAC,CAAC,AAC/B,QAAQ,CAAE,MAAM,CAChB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,IAAI,CACb,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,OAAO,AAAE,CAAC,AAClB,wBAAU,CAAC,OAAO,CAAC,YAAY,CAAC,GAAG,cAAC,CAAC,AACnC,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,KAAK,AAAE,CAAC,AACtB,wBAAU,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,cAAC,CAAC,AACrC,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CACpC,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,UAAU,CAAE,MAAM,AAAE,CAAC,AACrB,wBAAU,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,cAAC,CAAC,AAC1C,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,KAAK,AAAE,CAAC,AACzB,wBAAU,CAAC,OAAO,CAAC,EAAE,cAAC,CAAC,AACrB,OAAO,CAAE,IAAI,CAAC,CAAC,CACf,SAAS,CAAE,GAAG,AAAE,CAAC,AACnB,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,wBAAU,CAAC,OAAO,cAAC,CAAC,AAClB,UAAU,CAAE,IAAI,AAAE,CAAC,AAAC,CAAC,AAC3B,wBAAU,CAAC,OAAO,cAAC,CAAC,AAClB,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,IAAI,AAAE,CAAC,AAChB,wBAAU,CAAC,OAAO,CAAC,gBAAgB,cAAC,CAAC,AACnC,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,aAAa,CAAE,IAAI,AAAE,CAAC,AACtB,wBAAU,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE,cAAC,CAAC,AACtC,SAAS,CAAE,KAAK,CAChB,YAAY,CAAE,GAAG,CACjB,SAAS,CAAE,WAAW,AAAE,CAAC,AAC3B,wBAAU,CAAC,OAAO,CAAC,gBAAgB,CAAC,MAAM,cAAC,CAAC,AAC1C,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,MAAM,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACrC,wBAAU,CAAC,OAAO,CAAC,IAAI,cAAC,CAAC,AACvB,OAAO,CAAE,IAAI,AAAE,CAAC,AAChB,wBAAU,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,cAAC,CAAC,AAC7B,OAAO,CAAE,IAAI,CACb,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CAChC,OAAO,CAAE,IAAI,AAAE,CAAC,AAClB,wBAAU,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,cAAC,CAAC,AAC9B,MAAM,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CACzB,KAAK,CAAE,KAAK,CACZ,gBAAgB,CAAE,OAAO,CACzB,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,cAAc,CAAE,SAAS,CACzB,WAAW,CAAE,IAAI,CACjB,WAAW,CAAE,IAAI,CACjB,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,GAAG,CAAC,GAAG,AAAE,CAAC,AACtB,wBAAU,CAAC,OAAO,CAAC,IAAI,CAAC,oBAAM,MAAM,AAAC,CAAC,AACpC,gBAAgB,CAAE,KAAK,CACvB,KAAK,CAAE,OAAO,AAAE,CAAC,AACvB,wBAAU,CAAC,OAAO,CAAC,QAAQ,cAAC,CAAC,AAC3B,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,CACf,GAAG,CAAE,IAAI,CACT,eAAe,CAAE,MAAM,AAAE,CAAC,AAC1B,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,wBAAU,CAAC,OAAO,CAAC,QAAQ,cAAC,CAAC,AAC3B,eAAe,CAAE,aAAa,AAAE,CAAC,AAAC,CAAC,AACzC,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,wBAAU,CAAC,OAAO,cAAC,CAAC,AAClB,UAAU,CAAE,MAAM,AAAE,CAAC,AAAC,CAAC,AAC7B,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,UAAU,4BAAC,CAAC,AACV,cAAc,CAAE,GAAG,AAAE,CAAC,AACtB,wBAAU,CAAC,OAAO,cAAC,CAAC,AAClB,aAAa,CAAE,IAAI,CACnB,YAAY,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACpC,wBAAU,CAAC,OAAO,cAAC,CAAC,AAClB,KAAK,CAAE,IAAI,AAAE,CAAC,AAAC,CAAC"}`
};
var Admin = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_usuarios;
  let $$unsubscribe_correoUsuario;
  let $photoURL, $$unsubscribe_photoURL;
  let $nombreUsuario, $$unsubscribe_nombreUsuario;
  let $creacionUsuario, $$unsubscribe_creacionUsuario;
  let $recetasTotal, $$unsubscribe_recetasTotal;
  $$unsubscribe_usuarios = subscribe(usuarios, (value) => value);
  $$unsubscribe_correoUsuario = subscribe(correoUsuario, (value) => value);
  $$unsubscribe_photoURL = subscribe(photoURL, (value) => $photoURL = value);
  $$unsubscribe_nombreUsuario = subscribe(nombreUsuario, (value) => $nombreUsuario = value);
  $$unsubscribe_creacionUsuario = subscribe(creacionUsuario, (value) => $creacionUsuario = value);
  $$unsubscribe_recetasTotal = subscribe(recetasTotal, (value) => $recetasTotal = value);
  $$result.css.add(css$1);
  $$unsubscribe_usuarios();
  $$unsubscribe_correoUsuario();
  $$unsubscribe_photoURL();
  $$unsubscribe_nombreUsuario();
  $$unsubscribe_creacionUsuario();
  $$unsubscribe_recetasTotal();
  return `<div class="${"container svelte-si8p78"}"><div class="${"img-bg svelte-si8p78"}"><div class="${"profile-img svelte-si8p78"}"><img${add_attribute("src", $photoURL, 0)} alt="${""}" class="${"svelte-si8p78"}">
            <div id="${"edit"}" class="${"svelte-si8p78"}"><input type="${"file"}" style="${"opacity: 0; position:absolute; width: 100%; height:100%"}" class="${"svelte-si8p78"}">
                <span class="${"fas fa-edit svelte-si8p78"}"></span></div></div>
        <h3 class="${"svelte-si8p78"}">${escape2($nombreUsuario)}</h3>
        <p>Fecha creacion: ${escape2($creacionUsuario)}h</p></div>
    <section class="${"svelte-si8p78"}"><div class="${"title-container svelte-si8p78"}"><h4 class="${"svelte-si8p78"}">Ver usuarios</h4>
            <div class="${"linea svelte-si8p78"}"></div></div>
        <form class="${"svelte-si8p78"}"><button class="${"svelte-si8p78"}">MOSTRAR USUARIOS EN CONSOLA</button></form>
        
        <div class="${"title-container svelte-si8p78"}"><h4 class="${"svelte-si8p78"}">Recetas</h4>
            <div class="${"linea svelte-si8p78"}"></div></div>
        <div class="${"recipes svelte-si8p78"}">${each($recetasTotal, (item) => `
                ${validate_component(RecipeCardAdmin, "RecipeCardAdmin").$$render($$result, {
    imgURL: item.imgURL,
    title: item.titulo,
    description: item.descripcion,
    stars: item.puntuado,
    id: item.id
  }, {}, {})}`)}</div></section>
</div>`;
});
var admin = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Admin
});
var css = {
  code: ".container.svelte-2vjwnz.svelte-2vjwnz{display:flex;flex-direction:column;height:calc(100vh - 65px)}.container.svelte-2vjwnz img.svelte-2vjwnz{width:100%;height:100%;min-height:250px;overflow:hidden;object-fit:cover;object-position:center;border-bottom:solid 2px #f05a28}.container.svelte-2vjwnz form.svelte-2vjwnz{background:white;display:flex;justify-content:center;align-items:center}.container.svelte-2vjwnz form p.svelte-2vjwnz{font-size:12px}.container.svelte-2vjwnz form p.svelte-2vjwnz:first-of-type{margin-bottom:5px}.container.svelte-2vjwnz form a.svelte-2vjwnz{color:#f05a28}.container.svelte-2vjwnz form div.svelte-2vjwnz{display:flex;flex-direction:column;max-width:320px;padding:20px}.container.svelte-2vjwnz form div h4.svelte-2vjwnz{color:#f05a28;font-size:2em;margin-bottom:10px}.container.svelte-2vjwnz form div label.svelte-2vjwnz{font-weight:bold;color:#f05a28;display:block;position:relative;z-index:1;margin-left:10px}.container.svelte-2vjwnz form div label span.svelte-2vjwnz{background:white;padding:2px 10px}.container.svelte-2vjwnz form div button.svelte-2vjwnz{background-color:#f05a28;border:solid 2px #f05a28;border-radius:20px;padding:10px;text-transform:uppercase;font-weight:bold;color:white;cursor:pointer;transition:all .2s;margin-top:10px}.container.svelte-2vjwnz form div button.svelte-2vjwnz:hover{background-color:white;color:#f05a28}.container.svelte-2vjwnz form input.svelte-2vjwnz{border:dashed 2px #f05a28;border-radius:20px 20px 0 0;padding:15px 10px 10px;outline:none;position:relative;margin-top:-10px;margin-bottom:5px}@media(min-width: 768px){.container.svelte-2vjwnz.svelte-2vjwnz{flex-direction:row}.container.svelte-2vjwnz img.svelte-2vjwnz{border-bottom:none;border-right:solid 2px #f05a28}.container.svelte-2vjwnz form.svelte-2vjwnz{width:100%}}",
  map: `{"version":3,"file":"login.svelte","sources":["login.svelte"],"sourcesContent":["<script>\\n    //Importamos la funcion para hacer el inicio de sesion\\n    import {activeSesion} from '../store';\\n    import {auth} from '../firebase'\\n    \\n\\n    let email ='';//Email del usuario\\n    let password = '';//Password del usuario\\n\\n    const login = async () =>{//Funcion de registro de usuario\\n\\n        try{\\n            if(!$activeSesion){\\n                await auth.signInWithEmailAndPassword(email,password)\\n                \\n                ///REDIRECCIONAMIENTO A PERFIL\\n                window.history.pushState('', '', '/profile');\\n                location.reload();\\n                \\n                //Mensaje de validacion\\n            }else{\\n                console.log(\\"Ya hay una sesion activa\\")\\n            }\\n        } catch(error){\\n            //En caso de error al registrarse...\\n            console.log(error.code);\\n            console.log(error.message);\\n        }\\n    }\\n\\n\\n<\/script>\\n\\n<div class=\\"container\\">\\n    <img src=\\"/img/bg_3.jpg\\" alt=\\"\\">\\n    <form on:submit|preventDefault={login}>\\n        <div>\\n            <h4>Iniciar Sesi&oacute;n</h4>\\n            <p>Entra o <a href=\\"/register\\">reg&iacute;strate</a> para poder crear, clasificar, comentar o guardar recetas</p>\\n            <label for=\\"mail\\"> <span> Correo Electr&oacute;nico:</span></label>\\n            <input type=\\"text\\" name=\\"mail\\" bind:value={email}>\\n            <label for=\\"password\\"> <span> Contrase&ntilde;a:</span></label>\\n            <input type=\\"password\\" name=\\"password\\" bind:value={password}>\\n            <button>Iniciar sesion</button>\\n        </div>\\n    </form>\\n</div>\\n\\n<style lang=\\"scss\\">.container {\\n  display: flex;\\n  flex-direction: column;\\n  height: calc(100vh - 65px); }\\n  .container img {\\n    width: 100%;\\n    height: 100%;\\n    min-height: 250px;\\n    overflow: hidden;\\n    object-fit: cover;\\n    object-position: center;\\n    border-bottom: solid 2px #f05a28; }\\n  .container form {\\n    background: white;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center; }\\n    .container form p {\\n      font-size: 12px; }\\n      .container form p:first-of-type {\\n        margin-bottom: 5px; }\\n    .container form a {\\n      color: #f05a28; }\\n    .container form div {\\n      display: flex;\\n      flex-direction: column;\\n      max-width: 320px;\\n      padding: 20px; }\\n      .container form div h4 {\\n        color: #f05a28;\\n        font-size: 2em;\\n        margin-bottom: 10px; }\\n      .container form div label {\\n        font-weight: bold;\\n        color: #f05a28;\\n        display: block;\\n        position: relative;\\n        z-index: 1;\\n        margin-left: 10px; }\\n        .container form div label span {\\n          background: white;\\n          padding: 2px 10px; }\\n      .container form div button {\\n        background-color: #f05a28;\\n        border: solid 2px #f05a28;\\n        border-radius: 20px;\\n        padding: 10px;\\n        text-transform: uppercase;\\n        font-weight: bold;\\n        color: white;\\n        cursor: pointer;\\n        transition: all .2s;\\n        margin-top: 10px; }\\n        .container form div button:hover {\\n          background-color: white;\\n          color: #f05a28; }\\n    .container form input {\\n      border: dashed 2px #f05a28;\\n      border-radius: 20px 20px 0 0;\\n      padding: 15px 10px 10px;\\n      outline: none;\\n      position: relative;\\n      margin-top: -10px;\\n      margin-bottom: 5px; }\\n  @media (min-width: 768px) {\\n    .container {\\n      flex-direction: row; }\\n      .container img {\\n        border-bottom: none;\\n        border-right: solid 2px #f05a28; }\\n      .container form {\\n        width: 100%; } }\\n</style>\\n"],"names":[],"mappings":"AAgDmB,UAAU,4BAAC,CAAC,AAC7B,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,MAAM,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,AAAE,CAAC,AAC7B,wBAAU,CAAC,GAAG,cAAC,CAAC,AACd,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CACjB,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,KAAK,CACjB,eAAe,CAAE,MAAM,CACvB,aAAa,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACrC,wBAAU,CAAC,IAAI,cAAC,CAAC,AACf,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,AAAE,CAAC,AACtB,wBAAU,CAAC,IAAI,CAAC,CAAC,cAAC,CAAC,AACjB,SAAS,CAAE,IAAI,AAAE,CAAC,AAClB,wBAAU,CAAC,IAAI,CAAC,eAAC,cAAc,AAAC,CAAC,AAC/B,aAAa,CAAE,GAAG,AAAE,CAAC,AACzB,wBAAU,CAAC,IAAI,CAAC,CAAC,cAAC,CAAC,AACjB,KAAK,CAAE,OAAO,AAAE,CAAC,AACnB,wBAAU,CAAC,IAAI,CAAC,GAAG,cAAC,CAAC,AACnB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,IAAI,AAAE,CAAC,AAChB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,cAAC,CAAC,AACtB,KAAK,CAAE,OAAO,CACd,SAAS,CAAE,GAAG,CACd,aAAa,CAAE,IAAI,AAAE,CAAC,AACxB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,cAAC,CAAC,AACzB,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,OAAO,CACd,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,CACV,WAAW,CAAE,IAAI,AAAE,CAAC,AACpB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,cAAC,CAAC,AAC9B,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,GAAG,CAAC,IAAI,AAAE,CAAC,AACxB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,cAAC,CAAC,AAC1B,gBAAgB,CAAE,OAAO,CACzB,MAAM,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,CACzB,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,SAAS,CACzB,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,GAAG,CAAC,GAAG,CACnB,UAAU,CAAE,IAAI,AAAE,CAAC,AACnB,wBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,oBAAM,MAAM,AAAC,CAAC,AAChC,gBAAgB,CAAE,KAAK,CACvB,KAAK,CAAE,OAAO,AAAE,CAAC,AACvB,wBAAU,CAAC,IAAI,CAAC,KAAK,cAAC,CAAC,AACrB,MAAM,CAAE,MAAM,CAAC,GAAG,CAAC,OAAO,CAC1B,aAAa,CAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAC5B,OAAO,CAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CACvB,OAAO,CAAE,IAAI,CACb,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,KAAK,CACjB,aAAa,CAAE,GAAG,AAAE,CAAC,AACzB,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,UAAU,4BAAC,CAAC,AACV,cAAc,CAAE,GAAG,AAAE,CAAC,AACtB,wBAAU,CAAC,GAAG,cAAC,CAAC,AACd,aAAa,CAAE,IAAI,CACnB,YAAY,CAAE,KAAK,CAAC,GAAG,CAAC,OAAO,AAAE,CAAC,AACpC,wBAAU,CAAC,IAAI,cAAC,CAAC,AACf,KAAK,CAAE,IAAI,AAAE,CAAC,AAAC,CAAC"}`
};
var Login = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_activeSesion;
  $$unsubscribe_activeSesion = subscribe(activeSesion, (value) => value);
  let email = "";
  let password = "";
  $$result.css.add(css);
  $$unsubscribe_activeSesion();
  return `<div class="${"container svelte-2vjwnz"}"><img src="${"/img/bg_3.jpg"}" alt="${""}" class="${"svelte-2vjwnz"}">
    <form class="${"svelte-2vjwnz"}"><div class="${"svelte-2vjwnz"}"><h4 class="${"svelte-2vjwnz"}">Iniciar Sesi\xF3n</h4>
            <p class="${"svelte-2vjwnz"}">Entra o <a href="${"/register"}" class="${"svelte-2vjwnz"}">reg\xEDstrate</a> para poder crear, clasificar, comentar o guardar recetas</p>
            <label for="${"mail"}" class="${"svelte-2vjwnz"}"><span class="${"svelte-2vjwnz"}">Correo Electr\xF3nico:</span></label>
            <input type="${"text"}" name="${"mail"}" class="${"svelte-2vjwnz"}"${add_attribute("value", email, 0)}>
            <label for="${"password"}" class="${"svelte-2vjwnz"}"><span class="${"svelte-2vjwnz"}">Contrase\xF1a:</span></label>
            <input type="${"password"}" name="${"password"}" class="${"svelte-2vjwnz"}"${add_attribute("value", password, 0)}>
            <button class="${"svelte-2vjwnz"}">Iniciar sesion</button></div></form>
</div>`;
});
var login = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Login
});

// .svelte-kit/netlify/entry.js
init();
async function handler(event) {
  const { path, httpMethod, headers, rawQuery, body, isBase64Encoded } = event;
  const query = new URLSearchParams(rawQuery);
  const type = headers["content-type"];
  const rawBody = type && isContentTypeTextual(type) ? isBase64Encoded ? Buffer.from(body, "base64").toString() : body : new TextEncoder("base64").encode(body);
  const rendered = await render({
    method: httpMethod,
    headers,
    path,
    query,
    rawBody
  });
  if (rendered) {
    return {
      isBase64Encoded: false,
      statusCode: rendered.status,
      ...splitHeaders(rendered.headers),
      body: rendered.body
    };
  }
  return {
    statusCode: 404,
    body: "Not found"
  };
}
function splitHeaders(headers) {
  const h = {};
  const m = {};
  for (const key in headers) {
    const value = headers[key];
    const target = Array.isArray(value) ? m : h;
    target[key] = value;
  }
  return {
    headers: h,
    multiValueHeaders: m
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */
